// GameUI.cpp

#include "GameUI.hpp"
#include "MainMenu.hpp"
#include "Frame.hpp"
#include "Image.hpp"
#include "Field.hpp"
#include "Button.hpp"
#include "Text.hpp"
#include "Slider.hpp"
#include "Widget.hpp"

#include "../main.hpp"
#include "../game.hpp"
#include "../menu.hpp"
#include "../interface/interface.hpp"
#include "../interface/consolecommand.hpp"
#include "../stat.hpp"
#include "../player.hpp"
#include "../draw.hpp"
#include "../items.hpp"
#include "../mod_tools.hpp"
#include "../input.hpp"
#include "../collision.hpp"
#include "../monster.hpp"
#include "../classdescriptions.hpp"
#include "../shops.hpp"
#include "../colors.hpp"
#include "../book.hpp"

#include <assert.h>

const Uint32 playerColor(int index, bool colorblind, bool ally)
{
    Uint32 result;
    if (colorblind) {
        switch (index) {
        default: result = uint32ColorPlayerX_colorblind; break;
        case 0: result = uint32ColorPlayer1_colorblind; break;
        case 1: result = uint32ColorPlayer2_colorblind; break;
        case 2: result = uint32ColorPlayer3_colorblind; break;
        case 3: result = uint32ColorPlayer4_colorblind; break;
        case 4: result = uint32ColorPlayer5_colorblind; break;
        case 5: result = uint32ColorPlayer6_colorblind; break;
        case 6: result = uint32ColorPlayer7_colorblind; break;
        case 7: result = uint32ColorPlayer8_colorblind; break;
        }
    }
    else {
        switch (index) {
        default: result = uint32ColorPlayerX; break;
        case 0: result = uint32ColorPlayer1; break;
        case 1: result = uint32ColorPlayer2; break;
        case 2: result = uint32ColorPlayer3; break;
        case 3: result = uint32ColorPlayer4; break;
        case 4: result = uint32ColorPlayer5; break;
        case 5: result = uint32ColorPlayer6; break;
        case 6: result = uint32ColorPlayer7; break;
        case 7: result = uint32ColorPlayer8; break;
        }
    }
    if (ally) {
        uint8_t r, g, b, a;
        getColor(result, &r, &g, &b, &a);
        r /= 2; g /= 2; b /= 2;
        return makeColor(r, g, b, a);
    } else {
        return result;
    }
}

static const char* bigfont_outline = "fonts/pixelmix.ttf#16#2";
static const char* bigfont_no_outline = "fonts/pixelmix.ttf#16#0";
static const char* smallfont_outline = "fonts/pixel_maz_multiline.ttf#16#2";
static const char* smallfont_no_outline = "fonts/pixel_maz_multiline.ttf#16#0";

static ConsoleVariable<Vector4> mapBgColor("/map_background_color", Vector4{22.f, 24.f, 29.f, 223.f});
static ConsoleVariable<Vector4> logBgColor("/log_background_color", Vector4{22.f, 24.f, 29.f, 223.f});
static ConsoleVariable<bool> cvar_hotbar_compact_disable("/hotbar_compact_disable", false); // dont use compact at all
static ConsoleVariable<bool> cvar_hotbar_compact_use_fullsize("/hotbar_compact_fullsize", true); // dont use extra compact view, just normal compact

Frame* gameUIFrame[MAXPLAYERS] = { nullptr };
bool newui = true;
int selectedCursorOpacity = 255;
int oldSelectedCursorOpacity = 255;
int hotbarSlotOpacity = 255;
int hotbarSelectedSlotOpacity = 255;
int hotbarCompactOffsetX = 0;
real_t hotbarCompactSlotOverlapPercent = 0.0; // % of a slot to overlap facemenu buttons in compact view
int hotbarCompactInactiveSlotMovementX = 0; // inactive facemenu groups move over by this much out of the way in compact view
int hotbarCompactExpandedOffsetX = 0; // navigating the hotbar in inventory mode will expand the centers of groups out by this much
int hotbarOffsetY = 0;
int hotbarCompactOffsetY = 0;

int xpbarOffsetWidth = 0;
int xpbarOffsetY = 0;
int xpbarCompactOffsetWidth = 0;
int xpbarCompactOffsetY = 0;

int hpmpbarOffsetWidth = 0;
int hpmpbarOffsetX = 0;
int hpmpbarOffsetY = 0;
int hpmpbarCompactOffsetWidth = 0;
int hpmpbarCompactOffsetX = 0;
int hpmpbarCompactOffsetY = 0;

int hpmpbarMaxWidthAmount = 160; // hp / mp value that makes the bar 100% size
int hpmpbarIntervalToIncreaseWidth = 5; // hp / mp grows every x max hp/mp value
int hpmpbarIntervalStartValue = 20; // hp / mp of this value is the smallest interval
int hpmpbarBasePercentSize = 30; // smallest width at low hp/mp value
real_t hpmpbarWidthIncreasePercentOnInterval = 2.5; // % to grow bar per interval
int hpmpbarCompactMaxWidthAmount = 160; // hp / mp value that makes the bar 100% size
int hpmpbarCompactIntervalToIncreaseWidth = 5; // hp / mp grows every x max hp/mp value
int hpmpbarCompactIntervalStartValue = 20; // hp / mp of this value is the smallest interval
int hpmpbarCompactBasePercentSize = 44; // smallest width at low hp/mp value
real_t hpmpbarCompactWidthIncreasePercentOnInterval = 2.0; // % to grow bar per interval

struct AllyStatusBarSettings_t
{
	struct HPBar_t
	{
		int barPixelWidth = 120; // pixel width of bar
		int barCompactPixelWidth = 120; // pixel width of bar
		int barSplitscreenPixelWidthOffset = 0; // amount to shrink bars in compact width mode
		int barMaxWidthAmount = 160; // hp / mp value that makes the bar 100% size
		int barIntervalToIncreaseWidth = 5; // hp / mp grows every x max hp/mp value
		int barIntervalStartValue = 20; // hp / mp of this value is the smallest interval
		int barBasePercentSize = 30; // smallest width at low hp/mp value
		real_t barWidthIncreasePercentOnInterval = 2.5; // % to grow bar per interval
		int barCompactMaxWidthAmount = 160; // hp / mp value that makes the bar 100% size
		int barCompactIntervalToIncreaseWidth = 5; // hp / mp grows every x max hp/mp value
		int barCompactIntervalStartValue = 20; // hp / mp of this value is the smallest interval
		int barCompactBasePercentSize = 44; // smallest width at low hp/mp value
		real_t barCompactWidthIncreasePercentOnInterval = 2.0; // % to grow bar per interval
	};
	struct MPBar_t
	{
		int barPixelWidth = 120; // pixel width of bar
		int barCompactPixelWidth = 120; // pixel width of bar
		int barMaxWidthAmount = 160; // hp / mp value that makes the bar 100% size
		int barIntervalToIncreaseWidth = 5; // hp / mp grows every x max hp/mp value
		int barIntervalStartValue = 20; // hp / mp of this value is the smallest interval
		int barBasePercentSize = 30; // smallest width at low hp/mp value
		real_t barWidthIncreasePercentOnInterval = 2.5; // % to grow bar per interval
		int barCompactMaxWidthAmount = 160; // hp / mp value that makes the bar 100% size
		int barCompactIntervalToIncreaseWidth = 5; // hp / mp grows every x max hp/mp value
		int barCompactIntervalStartValue = 20; // hp / mp of this value is the smallest interval
		int barCompactBasePercentSize = 44; // smallest width at low hp/mp value
		real_t barCompactWidthIncreasePercentOnInterval = 2.0; // % to grow bar per interval
	};
	struct EntrySettings_t
	{
		int entryHeight = 40;
		int entryCompactHeight = 40;
		int maxNameLengthFullsize = 10;
		int maxNameLengthCompact = 10;
		int maxNameLengthSplitscreenFullsize = 10;
		int maxNameLengthSplitscreenCompact = 10;
		int baseY = 20;
		int baseYSplitscreen = 20;
	};
	struct FollowerBars_t
	{
		static EntrySettings_t entrySettings;
		static HPBar_t hpBar;
		static MPBar_t mpBar;
	};
	struct PlayerBars_t
	{
		static EntrySettings_t entrySettings;
		static HPBar_t hpBar;
		static MPBar_t mpBar;
	};
};
AllyStatusBarSettings_t::EntrySettings_t AllyStatusBarSettings_t::FollowerBars_t::entrySettings;
AllyStatusBarSettings_t::EntrySettings_t AllyStatusBarSettings_t::PlayerBars_t::entrySettings;
AllyStatusBarSettings_t::HPBar_t AllyStatusBarSettings_t::FollowerBars_t::hpBar;
AllyStatusBarSettings_t::MPBar_t AllyStatusBarSettings_t::FollowerBars_t::mpBar;
AllyStatusBarSettings_t::HPBar_t AllyStatusBarSettings_t::PlayerBars_t::hpBar;
AllyStatusBarSettings_t::MPBar_t AllyStatusBarSettings_t::PlayerBars_t::mpBar;

struct MessageZoneSettings_t
{
	enum HotbarTypes_t : int {
		HOTBAR_CLASSIC,
		HOTBAR_MODERN_GAMEPAD,
		HOTBAR_MODERN_KEYBOARD
	};
	struct MessageSettings_t
	{
		HotbarTypes_t hotbarType = HOTBAR_CLASSIC;
		Player::MessageZone_t::ChatAlignment_t alignment = Player::MessageZone_t::ALIGN_LEFT_BOTTOM;
		enum LayoutType_t : int {
			LAYOUT_DEFAULT,
			LAYOUT_COMPACT
		};
		struct Layout_t
		{
			LayoutType_t layoutType = LAYOUT_DEFAULT;
			int offsetY = 0;
			int maxMessages = 10;
		};
		std::map<LayoutType_t, Layout_t> layouts;
	};
	std::map<HotbarTypes_t, std::map<Player::MessageZone_t::ChatAlignment_t, MessageSettings_t>> settings;
	MessageSettings_t& addSetting(const HotbarTypes_t _hotbarType, const Player::MessageZone_t::ChatAlignment_t _alignment)
	{
		settings[_hotbarType][_alignment] = MessageSettings_t();
		auto& setting = settings[_hotbarType][_alignment];
		setting.hotbarType = _hotbarType;
		setting.alignment = _alignment;
		return setting;
	}
	MessageSettings_t::Layout_t& getLayout(const int player, const Player::MessageZone_t::ChatAlignment_t _alignment)
	{
		bool compact = players[player]->bUseCompactGUIHeight();
		auto layout = compact ? MessageSettings_t::LayoutType_t::LAYOUT_COMPACT : MessageSettings_t::LayoutType_t::LAYOUT_DEFAULT;
		if ( players[player]->hotbar.useHotbarFaceMenu )
		{
			if ( inputs.hasController(player) )
			{
				return settings[HOTBAR_MODERN_GAMEPAD][_alignment].layouts[layout];
			}
			else
			{
				return settings[HOTBAR_MODERN_KEYBOARD][_alignment].layouts[layout];
			}
		}
		else
		{
			return settings[HOTBAR_CLASSIC][_alignment].layouts[layout];
		}
	}
};
MessageZoneSettings_t messageZoneSettings;

struct DamageIndicatorSettings_t
{
	enum LayoutType_t : int {
		LAYOUT_DEFAULT,
		LAYOUT_2P_WIDE,
		LAYOUT_2P_TALL,
		LAYOUT_4P
	};
	struct Layout_t
	{
		int image_size = 3;
		int radius_x = 200;
		int radius_y = 200;
	};
	std::map<LayoutType_t, Layout_t> settings;
	real_t fadeSpeed = 1.0;
	Uint32 fadeAfterTicks = HITRATE;
	Uint32 deleteAfterTicks = 45;
	std::string indicatorDamageFramePaths[4] = {
		"images/ui/HUD/indicators/damageB",
		"images/ui/HUD/indicators/damage",
		"images/ui/HUD/indicators/damage",
		"images/ui/HUD/indicators/damage"
	};
	std::string indicatorBlockedFramePaths[4] = {
		"images/ui/HUD/indicators/damage_blocked",
		"images/ui/HUD/indicators/damage_blocked",
		"images/ui/HUD/indicators/damage_blocked",
		"images/ui/HUD/indicators/damage_blocked"
	};
};
DamageIndicatorSettings_t damageIndicatorSettings;

std::vector<int> LevelUpAnimBreakpoints;
LevelUpAnimation_t levelUpAnimation[MAXPLAYERS];

std::map<Player::WorldUI_t::WorldTooltipDialogue_t::DialogueType_t, 
	Player::WorldUI_t::WorldTooltipDialogue_t::WorldDialogueSettings_t::Setting_t> Player::WorldUI_t::WorldTooltipDialogue_t::WorldDialogueSettings_t::settings;
real_t Player::WorldUI_t::WorldTooltipItem_t::WorldItemSettings_t::scaleMod = 0.0;
real_t Player::WorldUI_t::WorldTooltipItem_t::WorldItemSettings_t::opacity = 0.0;

bool bUsePreciseFieldTextReflow = true;
bool bUseSelectedSlotCycleAnimation = false; // probably not gonna use, but can enable
CustomColors_t hudColors;
EnemyBarSettings_t enemyBarSettings;
#ifdef BARONY_SUPER_MULTIPLAYER
StatusEffectQueue_t StatusEffectQueue[MAXPLAYERS] = { {0}, {1}, {2}, {3}, {4}, {5}, {6}, {7} };
#else
StatusEffectQueue_t StatusEffectQueue[MAXPLAYERS] = { {0}, {1}, {2}, {3} };
#endif
std::unordered_map<int, StatusEffectQueue_t::EffectDefinitionEntry_t> StatusEffectQueue_t::StatusEffectDefinitions_t::allEffects;
std::unordered_map<int, StatusEffectQueue_t::EffectDefinitionEntry_t> StatusEffectQueue_t::StatusEffectDefinitions_t::allSustainedSpells;
Uint32 StatusEffectQueue_t::StatusEffectDefinitions_t::tooltipDescColor = 0xFFFFFFFF;
Uint32 StatusEffectQueue_t::StatusEffectDefinitions_t::tooltipHeadingColor = 0xFFFFFFFF;
Uint32 StatusEffectQueue_t::StatusEffectDefinitions_t::notificationTextColor = 0xFFFFFFFF;
std::string StatusEffectQueue_t::StatusEffectDefinitions_t::notificationFont = "fonts/pixelmix.ttf#16#2";

std::string formatSkillSheetEffects(int playernum, int proficiency, std::string& tag, std::string& rawValue);

int GAMEUI_FRAMEDATA_ANIMATING_ITEM = 1;
int GAMEUI_FRAMEDATA_ALCHEMY_ITEM = 2;
int GAMEUI_FRAMEDATA_ALCHEMY_RECIPE_SLOT = 3;
int GAMEUI_FRAMEDATA_ALCHEMY_RECIPE_ENTRY = 4;
int GAMEUI_FRAMEDATA_WORLDTOOLTIP_ITEM = 5;
int GAMEUI_FRAMEDATA_SHOP_ITEM = 6;

MinotaurWarning_t minotaurWarning[MAXPLAYERS];

void updateLevelUpFrame(const int player);
void updateSkillUpFrame(const int player);
void drawClockwiseSquareMesh(const char* texture, float lerp, SDL_Rect rect, Uint32 color);

void capitalizeString(std::string& str)
{
	if ( str.size() < 1 ) { return; }
	char letter = str[0];
	if ( letter >= 'a' && letter <= 'z' )
	{
		str[0] = toupper(letter);
	}
}

void uppercaseString(std::string& str)
{
	if ( str.size() < 1 ) { return; }
	for ( auto& letter : str )
	{
		if ( letter >= 'a' && letter <= 'z' )
		{
			letter = toupper(letter);
		}
	}
}

void camelCaseString(std::string& str)
{
	if ( str.size() < 1 ) { return; }
	char prevLetter = ' ';
	for ( auto& letter : str )
	{
		if ( letter >= 'a' && letter <= 'z' && prevLetter == ' ' )
		{
			letter = toupper(letter);
		}
		prevLetter = letter;
	}
}

bool stringStartsWithVowel(std::string& str)
{
	if ( str.size() < 1 ) { return false; }
	switch ( str[0] )
	{
		case 'a':
		case 'e':
		case 'i':
		case 'o':
		case 'u':
		case 'A':
		case 'E':
		case 'I':
		case 'O':
		case 'U':
			return true;
		default:
			break;
	}
	return false;
}

std::string EnemyBarSettings_t::getEnemyBarSpriteName(Entity* entity)
{
	if ( !entity ) { return "default"; }

	if ( entity->behavior == &actPlayer || entity->behavior == &actMonster )
	{
		int type = entity->getMonsterTypeFromSprite();
		if ( type < NUMMONSTERS && type >= 0 )
		{
			if ( type == MIMIC )
			{
				if ( entity->isInertMimic() )
				{
					return "chest_mimic";
				}
			}
			return monstertypename[type];
		}
	}
	else if ( entity->behavior == &actDoor )
	{
		return "door";
	}
	else if ( entity->behavior == &actChest )
	{
		return "chest";
	}
	else if ( entity->isDamageableCollider() )
	{
		auto& colliderData = EditorEntityData_t::colliderData[entity->colliderDamageTypes];
		return colliderData.hpbarLookupName;
	}
	else if ( entity->behavior == &actFurniture )
	{
		switch ( entity->furnitureType )
		{
			case FURNITURE_TABLE:
			case FURNITURE_PODIUM:
				return "table";
				break;
			default:
				return "chair";
				break;
		}
	}
	return "default";
}

enum ImageIndexes9x9 : int
{
	TOP_LEFT,
	TOP_RIGHT,
	TOP,
	MIDDLE_LEFT,
	MIDDLE_RIGHT,
	MIDDLE,
	BOTTOM_LEFT,
	BOTTOM_RIGHT,
	BOTTOM
};

const std::vector<std::string> skillsheetEffectBackgroundImages = 
{
	"9x9 bg top left",
	"9x9 bg top right",
	"9x9 bg top middle",
	"9x9 bg left",
	"9x9 bg right",
	"9x9 bg middle",
	"9x9 bg bottom left",
	"9x9 bg bottom right",
	"9x9 bg bottom middle"
};

void imageSetWidthHeight9x9(Frame* container, const std::vector<std::string>& imgNames)
{
	for ( auto& img : imgNames )
	{
		if ( auto i = container->findImage(img.c_str()) )
		{
			if ( auto imgGet = Image::get(i->path.c_str()) )
			{
				i->pos.w = (int)imgGet->getWidth();
				i->pos.h = (int)imgGet->getHeight();
			}
		}
	}
}

// for 9x9 images stretched to fit a container
void imageResizeToContainer9x9(Frame* container, SDL_Rect dimensionsToFill, const std::vector<std::string>& imgNames)
{
	assert(imgNames.size() == 9);
	// adjust inner background image elements
	auto tl = container->findImage(imgNames[TOP_LEFT].c_str());
	tl->pos.x = dimensionsToFill.x;
	tl->pos.y = dimensionsToFill.y;
	auto tr = container->findImage(imgNames[TOP_RIGHT].c_str());
	tr->pos.x = dimensionsToFill.w - tr->pos.w;
	tr->pos.y = dimensionsToFill.y;
	auto tm = container->findImage(imgNames[TOP].c_str());
	tm->pos.x = tl->pos.x + tl->pos.w;
	tm->pos.y = dimensionsToFill.y;
	tm->pos.w = dimensionsToFill.w - tr->pos.w - tl->pos.w;
	auto bl = container->findImage(imgNames[BOTTOM_LEFT].c_str());
	bl->pos.x = dimensionsToFill.x;
	bl->pos.y = dimensionsToFill.h - bl->pos.h;
	auto br = container->findImage(imgNames[BOTTOM_RIGHT].c_str());
	br->pos.x = dimensionsToFill.w - br->pos.w;
	br->pos.y = bl->pos.y;
	auto bm = container->findImage(imgNames[BOTTOM].c_str());
	bm->pos.x = bl->pos.x + bl->pos.w;
	bm->pos.w = dimensionsToFill.w - bl->pos.w - br->pos.w;
	bm->pos.y = bl->pos.y;
	auto ml = container->findImage(imgNames[MIDDLE_LEFT].c_str());
	ml->pos.x = dimensionsToFill.x;
	ml->pos.y = tl->pos.y + tl->pos.h;
	ml->pos.h = dimensionsToFill.h - dimensionsToFill.y - bl->pos.h - tl->pos.h;
	auto mr = container->findImage(imgNames[MIDDLE_RIGHT].c_str());
	mr->pos.x = dimensionsToFill.w - mr->pos.w;
	mr->pos.y = ml->pos.y;
	mr->pos.h = ml->pos.h;
	auto mm = container->findImage(imgNames[MIDDLE].c_str());
	mm->pos.x = ml->pos.x + ml->pos.w;
	mm->pos.y = ml->pos.y;
	mm->pos.w = dimensionsToFill.w - ml->pos.w - mr->pos.w;
	mm->pos.h = ml->pos.h;
}

static ConsoleVariable<bool> cvar_mp_flash_whole_bar("/mp_flash_whole_bar", true);
struct MPBarPaths_t
{
	static const std::map<std::string, std::string> normalMPBars;
	static const std::map<std::string, std::string> automatonHTBars;
	static const std::map<std::string, std::string> automatonSTBars;
	static const std::map<std::string, std::string> insectoidENBars;
	static const std::map<std::string, std::string> warningMPBars;
	static const std::map<std::string, std::string>& getMPBar(const int player)
	{
		/*if ( keystatus[SDLK_h] )
		{
			return automatonHTBars;
		}*/
		if ( stats[player]->type == AUTOMATON )
		{
			/*if ( keystatus[SDLK_g] )
			{
				return automatonHTBars;
			}*/
			return automatonSTBars;
		}
		else if ( stats[player]->playerRace == RACE_INSECTOID && stats[player]->appearance == 0 )
		{
			return insectoidENBars;
		}
		return normalMPBars;
	}
	static const std::string& get(const int player, const std::string key)
	{
		if ( (players[player]->magic.noManaProcessedOnTick != 0
				&& players[player]->magic.noManaFeedbackTicks % 20 < 10) )
		{
			if ( *cvar_mp_flash_whole_bar )
			{
				if ( key.find("fade") == std::string::npos )
				{
					return warningMPBars.at(key);
				}
			}
			else
			{
				if ( key == "mp img value" )
				{
					return warningMPBars.at(key);
				}
			}
		}
		return getMPBar(player).at(key);
	}
};

const std::map<std::string, std::string> MPBarPaths_t::normalMPBars = {
	{ "mp img progress bot", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPBot_00.png" },
	{ "mp img progress bot 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPBot_01.png" },
	{ "mp img progress bot 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPBot_02.png" },
	{ "mp img progress bot 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPBot_03.png" },

	{ "mp img progress endcap","*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_00.png" },
	{ "mp img progress endcap 1","*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_01.png" },

	{ "mp img progress endcap flash", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_F00.png" },
	{ "mp img progress endcap flash 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_F01.png" },
	{ "mp img progress endcap flash 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_F02.png" },
	{ "mp img progress endcap flash 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_F03.png" },
	{ "mp img progress endcap flash 4", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_F04.png" },
	{ "mp img progress endcap flash b", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_F00b.png" },
	{ "mp img progress endcap flash c", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_F00c.png" },
	{ "mp img progress endcap flash d", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_F00d.png" },

	{ "mp img fade endcap", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPEndFade_00.png" },

	{ "mp img progress", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPMid_00.png" },
	{ "mp img progress 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPMid_01.png" },
	{ "mp img progress 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPMid_02.png" },
	{ "mp img progress 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPMid_03.png" },

	{ "mp img fade bot",	"*#images/ui/HUD/hpmpbars/HUD_Bars_MPMidFade_00.png" },
	{ "mp img fade", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPMidFade_00.png" },

	{ "mp img value", "*#images/ui/HUD/hpmpbars/HUD_Bars_MPNumBase_00.png" }
};

const std::map<std::string, std::string> MPBarPaths_t::automatonHTBars = {
	{ "mp img progress bot", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTBot_00.png" },
	{ "mp img progress bot 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTBot_01.png" },
	{ "mp img progress bot 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTBot_02.png" },
	{ "mp img progress bot 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTBot_03.png" },

	{ "mp img progress endcap","*#images/ui/HUD/hpmpbars/HUD_Bars_HTEnd_00.png" },
	{ "mp img progress endcap 1","*#images/ui/HUD/hpmpbars/HUD_Bars_HTEnd_01.png" },

	{ "mp img progress endcap flash", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTEnd_F00.png" },
	{ "mp img progress endcap flash 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTEnd_F01.png" },
	{ "mp img progress endcap flash 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTEnd_F02.png" },
	{ "mp img progress endcap flash 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTEnd_F03.png" },
	{ "mp img progress endcap flash 4", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTEnd_F04.png" },
	{ "mp img progress endcap flash b", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTEnd_F00b.png" },
	{ "mp img progress endcap flash c", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTEnd_F00c.png" },
	{ "mp img progress endcap flash d", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTEnd_F00d.png" },

	{ "mp img fade endcap", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTEndFade_00.png" },

	{ "mp img progress", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTMid_00.png" },
	{ "mp img progress 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTMid_01.png" },
	{ "mp img progress 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTMid_02.png" },
	{ "mp img progress 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTMid_03.png" },

	{ "mp img fade bot",	"*#images/ui/HUD/hpmpbars/HUD_Bars_HTMidFade_00.png" },
	{ "mp img fade", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTMidFade_00.png" },

	{ "mp img value", "*#images/ui/HUD/hpmpbars/HUD_Bars_HTNumBase_00.png" }
};

const std::map<std::string, std::string> MPBarPaths_t::automatonSTBars = {
	{ "mp img progress bot", "*#images/ui/HUD/hpmpbars/HUD_Bars_STBot_00.png" },
	{ "mp img progress bot 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_STBot_01.png" },
	{ "mp img progress bot 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_STBot_02.png" },
	{ "mp img progress bot 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_STBot_03.png" },

	{ "mp img progress endcap","*#images/ui/HUD/hpmpbars/HUD_Bars_STEnd_00.png" },
	{ "mp img progress endcap 1","*#images/ui/HUD/hpmpbars/HUD_Bars_STEnd_01.png" },

	{ "mp img progress endcap flash", "*#images/ui/HUD/hpmpbars/HUD_Bars_STEnd_F00.png" },
	{ "mp img progress endcap flash 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_STEnd_F01.png" },
	{ "mp img progress endcap flash 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_STEnd_F02.png" },
	{ "mp img progress endcap flash 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_STEnd_F03.png" },
	{ "mp img progress endcap flash 4", "*#images/ui/HUD/hpmpbars/HUD_Bars_STEnd_F04.png" },
	{ "mp img progress endcap flash b", "*#images/ui/HUD/hpmpbars/HUD_Bars_STEnd_F00b.png" },
	{ "mp img progress endcap flash c", "*#images/ui/HUD/hpmpbars/HUD_Bars_STEnd_F00c.png" },
	{ "mp img progress endcap flash d", "*#images/ui/HUD/hpmpbars/HUD_Bars_STEnd_F00d.png" },

	{ "mp img fade endcap", "*#images/ui/HUD/hpmpbars/HUD_Bars_STEndFade_00.png" },

	{ "mp img progress", "*#images/ui/HUD/hpmpbars/HUD_Bars_STMid_00.png" },
	{ "mp img progress 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_STMid_01.png" },
	{ "mp img progress 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_STMid_02.png" },
	{ "mp img progress 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_STMid_03.png" },

	{ "mp img fade bot",	"*#images/ui/HUD/hpmpbars/HUD_Bars_STMidFade_00.png" },
	{ "mp img fade", "*#images/ui/HUD/hpmpbars/HUD_Bars_STMidFade_00.png" },

	{ "mp img value", "*#images/ui/HUD/hpmpbars/HUD_Bars_STNumBase_00.png" }
};

const std::map<std::string, std::string> MPBarPaths_t::insectoidENBars = {
	{ "mp img progress bot", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENBot_00.png" },
	{ "mp img progress bot 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENBot_01.png" },
	{ "mp img progress bot 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENBot_02.png" },
	{ "mp img progress bot 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENBot_03.png" },

	{ "mp img progress endcap","*#images/ui/HUD/hpmpbars/HUD_Bars_ENEnd_00.png" },
	{ "mp img progress endcap 1","*#images/ui/HUD/hpmpbars/HUD_Bars_ENEnd_01.png" },

	{ "mp img progress endcap flash", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENEnd_F00.png" },
	{ "mp img progress endcap flash 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENEnd_F01.png" },
	{ "mp img progress endcap flash 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENEnd_F02.png" },
	{ "mp img progress endcap flash 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENEnd_F03.png" },
	{ "mp img progress endcap flash 4", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENEnd_F04.png" },
	{ "mp img progress endcap flash b", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENEnd_F00b.png" },
	{ "mp img progress endcap flash c", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENEnd_F00c.png" },
	{ "mp img progress endcap flash d", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENEnd_F00d.png" },

	{ "mp img fade endcap", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENEndFade_00.png" },

	{ "mp img progress", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENMid_00.png" },
	{ "mp img progress 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENMid_01.png" },
	{ "mp img progress 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENMid_02.png" },
	{ "mp img progress 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENMid_03.png" },

	{ "mp img fade bot",	"*#images/ui/HUD/hpmpbars/HUD_Bars_ENMidFade_00.png" },
	{ "mp img fade", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENMidFade_00.png" },

	{ "mp img value", "*#images/ui/HUD/hpmpbars/HUD_Bars_ENNumBase_00.png" }
};

const std::map<std::string, std::string> MPBarPaths_t::warningMPBars = {
	{ "mp img progress bot", "*#images/ui/HUD/hpmpbars/HUD_Bars_NABot_00.png" },
	{ "mp img progress bot 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_NABot_01.png" },
	{ "mp img progress bot 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_NABot_02.png" },
	{ "mp img progress bot 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_NABot_03.png" },

	{ "mp img progress endcap","*#images/ui/HUD/hpmpbars/HUD_Bars_NAEnd_00.png" },
	{ "mp img progress endcap 1","*#images/ui/HUD/hpmpbars/HUD_Bars_NAEnd_01.png" },

	{ "mp img progress endcap flash", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAEnd_F00.png" },
	{ "mp img progress endcap flash 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAEnd_F01.png" },
	{ "mp img progress endcap flash 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAEnd_F02.png" },
	{ "mp img progress endcap flash 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAEnd_F03.png" },
	{ "mp img progress endcap flash 4", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAEnd_F04.png" },
	{ "mp img progress endcap flash b", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAEnd_F00b.png" },
	{ "mp img progress endcap flash c", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAEnd_F00c.png" },
	{ "mp img progress endcap flash d", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAEnd_F00d.png" },

	{ "mp img fade endcap", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAEndFade_00.png" },

	{ "mp img progress", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAMid_00.png" },
	{ "mp img progress 1", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAMid_01.png" },
	{ "mp img progress 2", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAMid_02.png" },
	{ "mp img progress 3", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAMid_03.png" },

	{ "mp img fade bot",	"*#images/ui/HUD/hpmpbars/HUD_Bars_NAMidFade_00.png" },
	{ "mp img fade", "*#images/ui/HUD/hpmpbars/HUD_Bars_NAMidFade_00.png" },

	{ "mp img value", "*#images/ui/HUD/hpmpbars/HUD_Bars_NANumBase_00.png" }
};

void createHPMPBars(const int player)
{
	auto& hud_t = players[player]->hud;
	const int barTotalHeight = hud_t.HPMP_FRAME_HEIGHT;
	const int hpBarStartY = (hud_t.hudFrame->getSize().h - hud_t.HPMP_FRAME_START_Y);
	const int mpBarStartY = hpBarStartY + barTotalHeight;
	const int barWidth = hud_t.HPMP_FRAME_WIDTH;
	const int barStartX = hud_t.HPMP_FRAME_START_X;
	{
		hud_t.hpFrame = hud_t.hudFrame->addFrame("hp bar");
		hud_t.hpFrame->setHollow(true);

		SDL_Rect pos{ barStartX, hpBarStartY, barWidth, barTotalHeight };
		hud_t.hpFrame->setSize(pos);

		auto fadeFrame = hud_t.hpFrame->addFrame("hp fade frame");
		fadeFrame->setSize(SDL_Rect{0, 0, barWidth, barTotalHeight});
		fadeFrame->setInheritParentFrameOpacity(false);

		auto foregroundFrame = hud_t.hpFrame->addFrame("hp foreground frame");
		foregroundFrame->setSize(SDL_Rect{ 0, 0, barWidth, barTotalHeight });


		auto base = hud_t.hpFrame->addImage(SDL_Rect{ 54, 4, barWidth - 54, 26 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_Base_00.png", "hp img base");

		const int progressBarHeight = 22;
		auto fadeProgressBase = fadeFrame->addImage(SDL_Rect{ 54, 6, 6, progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_HPMidFade_00.png", "hp img fade bot");
		auto fadeProgress = fadeFrame->addImage(SDL_Rect{ 60, 6, barWidth - 60 - 8,  progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_HPMidFade_00.png", "hp img fade");
		auto fadeProgressEndCap = fadeFrame->addImage(SDL_Rect{
			fadeProgress->pos.x + fadeProgress->pos.w, 6, 8, progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_HPEndFade_00.png", "hp img fade endcap");

		auto numbase = foregroundFrame->addImage(SDL_Rect{ 0, 4, 48, 26 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_HPNumBase_00.png", "hp img value");
		auto div = foregroundFrame->addImage(SDL_Rect{ 46, 0, 8, 34 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_Separator_00.png", "hp img div");

		auto currentProgressBase = foregroundFrame->addImage(SDL_Rect{ 54, 6, 6, progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_HPBot_00.png", "hp img progress bot");
		auto currentProgress = foregroundFrame->addImage(SDL_Rect{ 60, 6, barWidth - 60 - 8,  progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_HPMid_00.png", "hp img progress");
		auto currentProgressEndCap = foregroundFrame->addImage(SDL_Rect{
			currentProgress->pos.x + currentProgress->pos.w, 6, 8, progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_HPEnd_00.png", "hp img progress endcap");
		auto currentProgressEndCapFlash = foregroundFrame->addImage(SDL_Rect{
			currentProgress->pos.x + currentProgress->pos.w - 14, 6, 22, progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_HPEnd_F00.png", "hp img progress endcap flash");
		currentProgressEndCapFlash->disabled = true;

		const int endCapWidth = 16;
		auto endCap = foregroundFrame->addImage(SDL_Rect{ pos.w - endCapWidth, 0, endCapWidth, barTotalHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_EndCap_00.png", "hp img endcap");

		auto div25Percent = foregroundFrame->addImage(SDL_Rect{ 0, 8, 2, 18 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_Divider_01.png", "hp img div 25pc");
		div25Percent->disabled = true;
		auto div50Percent = foregroundFrame->addImage(SDL_Rect{ 0, 8, 2, 18 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_Divider_01.png", "hp img div 50pc");
		div50Percent->disabled = true;
		auto div75Percent = foregroundFrame->addImage(SDL_Rect{ 0, 8, 2, 18 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_Divider_01.png", "hp img div 75pc");
		div75Percent->disabled = true;

		auto font = "fonts/pixel_maz.ttf#32#2";
		auto hptext = foregroundFrame->addField("hp text", 16);
		hptext->setText("0");
		hptext->setSize(numbase->pos);
		hptext->setFont(font);
		hptext->setVJustify(Field::justify_t::CENTER);
		hptext->setHJustify(Field::justify_t::CENTER);
		hptext->setColor(makeColor( 255, 255, 255, 255));
	}

	// MP bar below
	{
		hud_t.mpFrame = hud_t.hudFrame->addFrame("mp bar");
		hud_t.mpFrame->setHollow(true);

		SDL_Rect pos{ barStartX, mpBarStartY, barWidth, barTotalHeight };
		hud_t.mpFrame->setSize(pos);

		auto fadeFrame = hud_t.mpFrame->addFrame("mp fade frame");
		fadeFrame->setSize(SDL_Rect{ 0, 0, barWidth, barTotalHeight });
		fadeFrame->setInheritParentFrameOpacity(false);

		auto foregroundFrame = hud_t.mpFrame->addFrame("mp foreground frame");
		foregroundFrame->setSize(SDL_Rect{ 0, 0, barWidth, barTotalHeight });


		auto base = hud_t.mpFrame->addImage(SDL_Rect{ 54, 4, barWidth - 54, 26 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_Base_00.png", "mp img base");

		const int progressBarHeight = 22;
		auto fadeProgressBase = fadeFrame->addImage(SDL_Rect{ 54, 6, 6, progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_MPMidFade_00.png", "mp img fade bot");
		auto fadeProgress = fadeFrame->addImage(SDL_Rect{ 60, 6, barWidth - 60 - 8,  progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_MPMidFade_00.png", "mp img fade");
		auto fadeProgressEndCap = fadeFrame->addImage(SDL_Rect{
			fadeProgress->pos.x + fadeProgress->pos.w, 6, 8, progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_MPEndFade_00.png", "mp img fade endcap");

		auto numbase = foregroundFrame->addImage(SDL_Rect{ 0, 4, 48, 26 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_MPNumBase_00.png", "mp img value");
		auto div = foregroundFrame->addImage(SDL_Rect{ 46, 0, 8, 34 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_Separator_00.png", "mp img div");

		auto currentProgressBase = foregroundFrame->addImage(SDL_Rect{ 54, 6, 6, progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_MPBot_00.png", "mp img progress bot");
		auto currentProgress = foregroundFrame->addImage(SDL_Rect{ 60, 6, barWidth - 60 - 8,  progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_MPMid_00.png", "mp img progress");
		auto currentProgressEndCap = foregroundFrame->addImage(SDL_Rect{
			currentProgress->pos.x + currentProgress->pos.w, 6, 8, progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_00.png", "mp img progress endcap");
		auto currentProgressEndCapFlash = foregroundFrame->addImage(SDL_Rect{
			currentProgress->pos.x + currentProgress->pos.w - 14, 6, 22, progressBarHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_F00.png", "mp img progress endcap flash");
		currentProgressEndCapFlash->disabled = true;

		const int endCapWidth = 16;
		auto endCap = foregroundFrame->addImage(SDL_Rect{ pos.w - endCapWidth, 0, endCapWidth, barTotalHeight }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_EndCap_00.png", "mp img endcap");

		auto div25Percent = foregroundFrame->addImage(SDL_Rect{ 0, 8, 2, 18 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_Divider_01.png", "mp img div 25pc");
		div25Percent->disabled = true;
		auto div50Percent = foregroundFrame->addImage(SDL_Rect{ 0, 8, 2, 18 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_Divider_01.png", "mp img div 50pc");
		div50Percent->disabled = true;
		auto div75Percent = foregroundFrame->addImage(SDL_Rect{ 0, 8, 2, 18 }, 0xFFFFFFFF,
			"*#images/ui/HUD/hpmpbars/HUD_Bars_Divider_01.png", "mp img div 75pc");
		div75Percent->disabled = true;

		auto font = "fonts/pixel_maz.ttf#32#2";
		auto mptext = foregroundFrame->addField("mp text", 16);
		mptext->setText("0");
		mptext->setSize(numbase->pos);
		mptext->setFont(font);
		mptext->setVJustify(Field::justify_t::CENTER);
		mptext->setHJustify(Field::justify_t::CENTER);
		mptext->setColor(makeColor( 255, 255, 255, 255));
	}
}

void createAllyFollowerFrame(const int player)
{
	auto& hud_t = players[player]->hud;

	auto frame = hud_t.hudFrame->addFrame("follower status");
	hud_t.allyFollowerFrame = frame;
	frame->setHollow(true);
	frame->setSize(SDL_Rect{ 0, 0, 300, 0 });
	frame->setDisabled(true);
	frame->setScrollBarsEnabled(false);
	frame->setAllowScrollBinds(false);

	auto selector = frame->addImage(SDL_Rect{ 0, 0, 8, 8 }, 0xFFFFFFFF, "*#images/ui/HUD/allies/HUD_Ally_Arrow_00.png", "selector");
	selector->disabled = true;
	selector->ontop = true;

	auto glyphFrame = hud_t.hudFrame->addFrame("follower glyphs");
	hud_t.allyFollowerGlyphFrame = glyphFrame;
	glyphFrame->setHollow(true);
	glyphFrame->setSize(SDL_Rect{ 0, 0, 300, 0 });
	glyphFrame->setDisabled(true);
	{
		std::string font = "fonts/pixel_maz.ttf#32#2";
		/*auto commandText = glyphFrame->addField("command prompt txt", 32);
		commandText->setFont(font.c_str());
		commandText->setHJustify(Field::justify_t::LEFT);
		commandText->setVJustify(Field::justify_t::TOP);
		commandText->setSize(SDL_Rect{ 0, 0, glyphFrame->getSize().w, 24 });
		commandText->setText(Language::get(4202));
		commandText->setColor(hudColors.characterSheetLightNeutral);
		commandText->setOntop(true);
		commandText->setDisabled(true);*/

		auto glyphCommand = glyphFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "glyph command");
		glyphCommand->disabled = true;
		glyphCommand->ontop = true;

		auto imgCommand = glyphFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_Ally_Circle_00.png", "img command");
		imgCommand->disabled = true;
		imgCommand->ontop = true;

		/*auto repeatText = glyphFrame->addField("repeat prompt txt", 32);
		repeatText->setFont(font.c_str());
		repeatText->setHJustify(Field::justify_t::LEFT);
		repeatText->setVJustify(Field::justify_t::TOP);
		repeatText->setSize(SDL_Rect{ 0, 0, frame->getSize().w, 24 });
		repeatText->setText(Language::get(4203));
		repeatText->setColor(hudColors.characterSheetLightNeutral);
		repeatText->setOntop(true);
		repeatText->setDisabled(true);*/

		auto glyphRepeat = glyphFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "glyph repeat");
		glyphRepeat->disabled = true;
		glyphRepeat->ontop = true;

		auto imgRepeat = glyphFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_Ally_Repeat_00.png", "img repeat");
		imgRepeat->disabled = true;
		imgRepeat->ontop = true;
	}
}

void createCalloutPromptFrame(const int player)
{
	auto& hud_t = players[player]->hud;

	auto frame = hud_t.hudFrame->addFrame("callout prompts");
	hud_t.calloutPromptFrame = frame;
	frame->setHollow(true);
	frame->setSize(SDL_Rect{ 0, 0, 300, 0 });
	frame->setDisabled(true);
	frame->setScrollBarsEnabled(false);
	frame->setAllowScrollBinds(false);

	auto glyph = frame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "glyph");
	glyph->disabled = true;
	auto icon = frame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "icon");
	icon->disabled = true;

	auto text = frame->addField("prompt", 64);
	text->setFont(smallfont_outline);
	text->setHJustify(Field::justify_t::LEFT);
	text->setVJustify(Field::justify_t::TOP);
	text->setSize(SDL_Rect{ 0, 0, frame->getSize().w, 24 });
	text->setText(Language::get(6049));
	text->setColor(0xFFFFFFFF);
	text->setOntop(true);
	text->setDisabled(true);
}

const int kPlayerBarsEntryFrameWidth = 214;

void updateCalloutPromptFrame(const int player)
{
	auto& hud_t = players[player]->hud;
	auto frame = hud_t.calloutPromptFrame;
	if ( !frame )
	{
		return;
	}

	if ( !CalloutRadialMenu::calloutMenuEnabledForGamemode() )
	{
		frame->setDisabled(true);
		return;
	}
	if ( !Player::getPlayerInteractEntity(player) )
	{
		frame->setDisabled(true);
		return;
	}
	if ( splitscreen && player == 3 )
	{
		frame->setDisabled(true); // we overlap the minimap, so don't draw this one
		return;
	}
	else if ( !players[player]->shootmode && !FollowerMenu[player].followerMenuIsOpen()
		&& !CalloutMenu[player].calloutMenuIsOpen() )
	{
		frame->setDisabled(true);
		return;
	}

	int alignX = 8;
	int alignY = 0;
	static ConsoleVariable<bool> cvar_callout_prompt_horizontal("/callout_prompt_horizontal", false);
	if ( hud_t.allyPlayerFrame && !hud_t.allyPlayerFrame->isDisabled()
		&& hud_t.allyPlayerFrame->getOpacity() > 0.0 )
	{
		if ( hud_t.playerBars.size() > 0 )
		{
			if ( *cvar_callout_prompt_horizontal )
			{
				alignX += kPlayerBarsEntryFrameWidth;
			}
			else
			{
				alignY += hud_t.playerBars.size() * 36;
			}
		}
	}

	frame->setDisabled(false);
	SDL_Rect framePos;
	framePos.x = alignX;
	framePos.y = players[player]->bUseCompactGUIWidth() ? AllyStatusBarSettings_t::FollowerBars_t::entrySettings.baseYSplitscreen : AllyStatusBarSettings_t::FollowerBars_t::entrySettings.baseY;
	framePos.y -= 4;
	framePos.y += alignY;
	framePos.w = 300;
	framePos.h = 50;
	frame->setSize(framePos);

	auto glyph = frame->findImage("glyph");
	auto glyphPathUnpressed = Input::inputs[player].getGlyphPathForBinding("Call Out", false);
	auto glyphPathPressed = Input::inputs[player].getGlyphPathForBinding("Call Out", true);
	glyph->disabled = true;

	const int nominalGlyphHeight = 26;
	int unpressedHeight = 0;
	int unpressedY = 0;
	if ( ticks % 50 < 25 && (CalloutMenu[player].calloutMenuIsOpen() && CalloutMenu[player].selectMoveTo) )
	{
		glyph->path = glyphPathPressed;
		if ( auto imgGet = Image::get(glyph->path.c_str()) )
		{
			glyph->disabled = false;
			SDL_Rect glyphPos{ 0, 8, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
			glyph->pos = glyphPos;
			if ( auto imgGetUnpressed = Image::get(glyphPathUnpressed.c_str()) )
			{
				unpressedHeight = imgGetUnpressed->getHeight();
				unpressedY = glyph->pos.y;
				if ( unpressedHeight != glyph->pos.h )
				{
					glyph->pos.y -= (glyph->pos.h - unpressedHeight);
				}

				if ( unpressedHeight != nominalGlyphHeight )
				{
					unpressedY -= (unpressedHeight - nominalGlyphHeight) / 2;
					glyph->pos.y -= (unpressedHeight - nominalGlyphHeight) / 2;
				}
			}
		}
	}
	else
	{
		glyph->path = glyphPathUnpressed;
		if ( auto imgGet = Image::get(glyph->path.c_str()) )
		{
			glyph->disabled = false;
			SDL_Rect glyphPos{ 0, 8, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
			glyph->pos = glyphPos;
			unpressedHeight = glyph->pos.h;
			unpressedY = glyph->pos.y;
			if ( glyph->pos.h != nominalGlyphHeight )
			{
				unpressedY -= (glyph->pos.h - nominalGlyphHeight) / 2;
				glyph->pos.y -= (glyph->pos.h - nominalGlyphHeight) / 2;
			}
		}
	}
	
	int glyphAlignY = unpressedY + (unpressedHeight - nominalGlyphHeight) / 2;

	auto icon = frame->findImage("icon");
	icon->disabled = true;
	static ConsoleVariable<bool> cvar_callout_prompt_wheel("/callout_prompt_wheel", false);
	if ( !glyph->disabled )
	{
		if ( *cvar_callout_prompt_wheel &&
			CalloutMenu[player].calloutMenuIsOpen() && CalloutMenu[player].selectMoveTo )
		{
			icon->path = "*images/ui/HUD/HUD_Ally_Callout_Wheel_00.png";
		}
		else
		{
			icon->path = "*images/ui/HUD/HUD_Ally_Callout_00.png";
		}
		if ( auto imgGet = Image::get(icon->path.c_str()) )
		{
			icon->disabled = false;
			icon->pos.w = imgGet->getWidth();
			icon->pos.h = imgGet->getHeight();
			icon->pos.x = glyph->pos.x + glyph->pos.w + 4;
			icon->pos.y = unpressedY + (unpressedHeight) / 2 - icon->pos.h / 2;
			if ( icon->pos.y % 2 == 1 )
			{
				++icon->pos.y;
			}
		}
	}

	auto text = frame->findField("prompt");
	text->setDisabled(true);
	static ConsoleVariable<bool> cvar_callout_prompt_text("/callout_prompt_text", false);
	if ( !icon->disabled && *cvar_callout_prompt_text )
	{
		if ( CalloutMenu[player].calloutMenuIsOpen() && CalloutMenu[player].selectMoveTo )
		{
			text->setDisabled(false);
			text->setText(Language::get(6049));
			SDL_Rect pos = text->getSize();
			pos.x = icon->pos.x + icon->pos.w + 4;
			pos.y = glyphAlignY - 10;
			text->setSize(pos);
		}
	}
}

void createAllyFollowerTitleFrame(const int player)
{
	auto& hud_t = players[player]->hud;

	auto frame = hud_t.hudFrame->addFrame("follower title status");
	hud_t.allyFollowerTitleFrame = frame;
	frame->setHollow(true);
	frame->setSize(SDL_Rect{ 0, 0, 300, 0 });
	frame->setDisabled(true);

	auto selector = frame->addImage(SDL_Rect{ 0, 0, 8, 8 }, 0xFFFFFFFF, "*#images/ui/HUD/allies/HUD_Ally_Arrow_00.png", "selector");
	selector->disabled = true;
	selector->ontop = true;

	auto glyphSelector = frame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "glyph selector");
	glyphSelector->disabled = true;
	glyphSelector->ontop = true;
}

void createAllyPlayerFrame(const int player)
{
	auto& hud_t = players[player]->hud;

	auto frame = hud_t.hudFrame->addFrame("player status");
	hud_t.allyPlayerFrame = frame;
	frame->setHollow(true);
	frame->setSize(SDL_Rect{ 0, 0, 300, 0 });
	frame->setDisabled(true);
	frame->setScrollBarsEnabled(false);
	frame->setAllowScrollBinds(false);
}

Frame* createAllyPlayerEntry(const int player)
{
	auto& hud_t = players[player]->hud;
	Frame* baseFrame = hud_t.allyPlayerFrame;

	auto entry = baseFrame->addFrame("entry");
	const int allyPlayerEntryHeight = 40;
	entry->setSize(SDL_Rect{ 0, 0, kPlayerBarsEntryFrameWidth, allyPlayerEntryHeight });
	entry->setHollow(true);
	entry->setInheritParentFrameOpacity(false);

	Frame* portrait = nullptr;
	{
		portrait = entry->addFrame("portrait");
		portrait->setSize(SDL_Rect{ 0, 0, 36, 36 });
		portrait->addImage(SDL_Rect{ 0, 0, 32, 32 }, 0xFFFFFFFF, "*#images/ui/HUD/allies/HUD_HPBar_HeadDefaultM_00.png", "portrait img");
	}

	std::string font = "fonts/pixel_maz.ttf#32#2";
	{
		Field* name = entry->addField("name", 128);
		name->setFont(font.c_str());
		name->setHJustify(Field::justify_t::LEFT);
		name->setVJustify(Field::justify_t::TOP);
		name->setSize(SDL_Rect{ portrait->getSize().x + portrait->getSize().w - 4, 0, entry->getSize().w, 24 });
		name->setText("");
		name->setColor(hudColors.characterSheetLightNeutral);
		name->setOntop(true);
	}
	{
		Field* level = entry->addField("level", 32);
		level->setFont("fonts/pixel_maz.ttf#32#2");
		level->setHJustify(Field::justify_t::RIGHT);
		level->setVJustify(Field::justify_t::TOP);
		level->setSize(SDL_Rect{ 0, 14, entry->getSize().w - 16, 24 });
		level->setText("");
		level->setColor(hudColors.characterSheetLightNeutral);
		level->setOntop(true);
	}
	{
		Field* hp = entry->addField("hp", 32);
		hp->setFont(font.c_str());
		hp->setHJustify(Field::justify_t::RIGHT);
		hp->setVJustify(Field::justify_t::TOP);
		hp->setSize(SDL_Rect{ 0, 0, entry->getSize().w - 16, 24 });
		hp->setText("");
		hp->setColor(makeColor(255, 255, 255, 255));
		hp->setOntop(true);
	}

	const int hpHeight = 16;
	{
		Frame* hpFrame = entry->addFrame("hp");
		hpFrame->setSize(SDL_Rect{ portrait->getSize().x + portrait->getSize().w - 4, 16, entry->getSize().w - (portrait->getSize().x + portrait->getSize().w - 4), hpHeight });
		SDL_Rect hpFramePos = hpFrame->getSize();
		hpFrame->setHollow(true);

		auto mid = hpFrame->addImage(SDL_Rect{ 6, 2, 40, 12 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Mid_00.png", "hp img mid");
		auto endCap = hpFrame->addImage(SDL_Rect{ mid->pos.x + mid->pos.w, 0, 6, 16 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_End_00.png", "hp img endcap");

		auto progressBase = hpFrame->addImage(SDL_Rect{ 6, 4, 4, 8 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Fill_Base_00.png", "hp img progress base");
		auto progressMid = hpFrame->addImage(SDL_Rect{ 6, 4, 2, 8 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Fill_Mid_00.png", "hp img progress");
		auto progressEndCap = hpFrame->addImage(SDL_Rect{ 0, 4, 4, 8 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Fill_End_00.png", "hp img progress endcap");

		auto progressEndcapDamaged = hpFrame->addImage(SDL_Rect{ 6, 4, 18, 8 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Fill_End_Damaged.png", "hp img progress damaged");
		progressEndcapDamaged->disabled = true;

		auto progressEndCapFlash = hpFrame->addImage(SDL_Rect{
			0, 4, 18, 8 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Fill_End_00.png", "hp img progress endcap flash");
		progressEndCapFlash->disabled = true;

		auto base = hpFrame->addImage(SDL_Rect{ 0, 0, 6, 16 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Base_00.png", "hp img base");

	}

	const int mpHeight = 6;
	{
		Frame* mpFrame = entry->addFrame("mp");
		mpFrame->setSize(SDL_Rect{ portrait->getSize().x + portrait->getSize().w, 30, entry->getSize().w - (portrait->getSize().x + portrait->getSize().w - 4), mpHeight });
		SDL_Rect mpFramePos = mpFrame->getSize();
		mpFrame->setHollow(true);

		auto mid = mpFrame->addImage(SDL_Rect{ 2, 0, 40, 6 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Mid_00.png", "mp img mid");
		auto endCap = mpFrame->addImage(SDL_Rect{ mid->pos.x + mid->pos.w, 0, 4, 6 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_End_00.png", "mp img endcap");

		auto progressBase = mpFrame->addImage(SDL_Rect{ 2, 0, 4, 4 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Fill_Base_00.png", "mp img progress base");
		auto progressMid = mpFrame->addImage(SDL_Rect{ 2, 0, 4, 4 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_00.png", "mp img progress");
		auto progressEndCap = mpFrame->addImage(SDL_Rect{ 0, 0, 4, 4 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Fill_End_00.png", "mp img progress endcap");

		auto progressEndcapDamaged = mpFrame->addImage(SDL_Rect{ 0, 0, 8, 4 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Fill_End_Damaged.png", "mp img progress damaged");
		progressEndcapDamaged->disabled = true;

		auto progressEndCapFlash = mpFrame->addImage(SDL_Rect{
			0, 0, 8, 4 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Fill_End_00.png", "mp img progress endcap flash");
		progressEndCapFlash->disabled = true;

		auto base = mpFrame->addImage(SDL_Rect{ 0, 0, 4, 6 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Base_00.png", "mp img base");
	}

	entry->setDrawCallback([](const Widget& widget, SDL_Rect rect) {
		if ( widget.getUserData() && PingNetworkStatus_t::bEnabled )
		{
			int player = reinterpret_cast<intptr_t>(widget.getUserData()) - 1;
			if ( player < 0 || player >= MAXPLAYERS ) {
				return;
			}

			auto value = PingNetworkStatus[player].displayMillisImmediate;
			const int divideInterval = 25;
			Image* img = nullptr;
			Image* warningImg = nullptr;
			if ( value > 0 )
			{
				char buf[32];
				if ( value < PingNetworkStatus_t::pingLimitGreen )
				{
					if ( PingNetworkStatus[player].hudDisplayOKTicks == 0 )
					{
						PingNetworkStatus[player].hudDisplayOKTicks = ticks;
					}
					if ( PingNetworkStatus_t::pingHUDDisplayGreen || 
						(PingNetworkStatus_t::pingHUDShowOKBriefly
							&& ((ticks - PingNetworkStatus[player].hudDisplayOKTicks) < 5 * TICKS_PER_SECOND)) )
					{
						img = Image::get("#*images/ui/HUD/Ping_Green.png");
					}
				}
				else if ( value < PingNetworkStatus_t::pingLimitYellow )
				{
					if ( PingNetworkStatus[player].hudDisplayOKTicks == 0 )
					{
						PingNetworkStatus[player].hudDisplayOKTicks = ticks;
					}
					if ( PingNetworkStatus_t::pingHUDDisplayYellow ||
						(PingNetworkStatus_t::pingHUDShowOKBriefly
							&& ((ticks - PingNetworkStatus[player].hudDisplayOKTicks) < 5 * TICKS_PER_SECOND)) )
					{
						img = Image::get("#*images/ui/HUD/Ping_Yellow.png");
					}
				}
				else if ( value < PingNetworkStatus_t::pingLimitOrange )
				{
					PingNetworkStatus[player].hudDisplayOKTicks = 0;
					if ( PingNetworkStatus_t::pingHUDDisplayOrange )
					{
						img = Image::get("#*images/ui/HUD/Ping_Orange.png");
						warningImg = Image::get("#*images/ui/HUD/warning_glyph.png");
					}
				}
				else
				{
					PingNetworkStatus[player].hudDisplayOKTicks = 0;
					if ( PingNetworkStatus_t::pingHUDDisplayRed )
					{
						img = Image::get("#*images/ui/HUD/Ping_Red.png");
						warningImg = Image::get("#*images/ui/HUD/danger_glyph.png");
					}
				}
			}
			else
			{
				img = nullptr;
				PingNetworkStatus[player].hudDisplayOKTicks = 0;
			}
			if ( img )
			{
				const auto frame = static_cast<const Frame*>(&widget);
				SDL_Rect pos = frame->getSize();
				pos.x = pos.x + pos.w - 4;
				pos.y = pos.y + 8;
				pos.w = img->getWidth();
				pos.h = img->getHeight();
				img->drawColor(nullptr, pos, SDL_Rect{ 0, 0, Frame::virtualScreenX, Frame::virtualScreenY }, 
					makeColor(255, 255, 255, 255 * (frame->getOpacity() / 100.0)));

				if ( warningImg )
				{
					pos.y += 14;
					warningImg->drawColor(nullptr, pos, SDL_Rect{ 0, 0, Frame::virtualScreenX, Frame::virtualScreenY },
						makeColor(255, 255, 255, 255 * (frame->getOpacity() / 100.0)));
				}

				if ( PingNetworkStatus_t::pingHUDShowNumericValue )
				{
					pos.x += 20;
					pos.y = frame->getSize().y + 9;
					char buf[32];
					snprintf(buf, sizeof(buf), "%dMS", PingNetworkStatus[player].displayMillis);
					if ( auto textGet = Text::get(buf, smallfont_outline, 
						makeColor(134, 159, 165, 255), makeColor(0, 0, 0, 255)) )
					{
						textGet->drawColor(SDL_Rect{ 0,0,0,0 }, SDL_Rect{ pos.x, pos.y, 0, 0 },
							SDL_Rect{ 0, 0, Frame::virtualScreenX, Frame::virtualScreenY }, 
							makeColor(255, 255, 255, 255 * (frame->getOpacity() / 100.0)));
					}
				}
			}
		}
	});
	return entry;
}

Frame* createAllyFollowerEntry(const int player, Frame* baseFrame)
{
	auto& hud_t = players[player]->hud;

	auto entry = baseFrame->addFrame("entry");
	const int allyFollowerEntryHeight = 40;
	entry->setSize(SDL_Rect{ 0, 0, 300, allyFollowerEntryHeight });
	entry->setHollow(true);
	entry->setInheritParentFrameOpacity(false);

	if ( baseFrame == players[player]->hud.allyFollowerTitleFrame )
	{
		auto bgImg = entry->addImage(SDL_Rect{ 0, 0, 0, 0 }, makeColor(255, 255, 255, 255), "*images/ui/HUD/allies/HUD_Ally_TitleBG_Left_00.png", "bg img left");
		bgImg->disabled = true;
		if ( auto imgGet = Image::get(bgImg->path.c_str()) )
		{
			bgImg->pos.w = imgGet->getWidth();
			bgImg->pos.h = imgGet->getHeight();
		}

		bgImg = entry->addImage(SDL_Rect{ 0, 0, 0, 0 }, makeColor(255, 255, 255, 255), "*images/ui/HUD/allies/HUD_Ally_TitleBG_Mid_00.png", "bg img mid");
		bgImg->disabled = true;
		if ( auto imgGet = Image::get(bgImg->path.c_str()) )
		{
			bgImg->pos.w = imgGet->getWidth();
			bgImg->pos.h = imgGet->getHeight();
		}

		bgImg = entry->addImage(SDL_Rect{ 0, 0, 0, 0 }, makeColor(255, 255, 255, 255), "*images/ui/HUD/allies/HUD_Ally_TitleBG_Right_00.png", "bg img right");
		bgImg->disabled = true;
		if ( auto imgGet = Image::get(bgImg->path.c_str()) )
		{
			bgImg->pos.w = imgGet->getWidth();
			bgImg->pos.h = imgGet->getHeight();
		}
	}
	
	Frame* portrait = nullptr;
	{
		portrait = entry->addFrame("portrait");
		portrait->setSize(SDL_Rect{ 0, 0, 36, 36 });
		portrait->addImage(SDL_Rect{ 0, 0, 32, 32 }, 0xFFFFFFFF, "*#images/ui/HUD/allies/HUD_HPBar_HeadDefaultM_00.png", "portrait img");
	}

	std::string font = "fonts/pixel_maz.ttf#32#2";
	{
		Field* name = entry->addField("name", 128);
		name->setFont(font.c_str());
		name->setHJustify(Field::justify_t::LEFT);
		name->setVJustify(Field::justify_t::TOP);
		name->setSize(SDL_Rect{ portrait->getSize().x + portrait->getSize().w - 4, 0, entry->getSize().w, 24 });
		name->setText("");
		name->setColor(hudColors.characterSheetLightNeutral);
		name->setOntop(true);
	}
	{
		Field* level = entry->addField("level", 32);
		level->setFont("fonts/pixel_maz.ttf#32#2");
		level->setHJustify(Field::justify_t::RIGHT);
		level->setVJustify(Field::justify_t::TOP);
		level->setSize(SDL_Rect{ 0, 14, entry->getSize().w - 16, 24 });
		level->setText("");
		level->setColor(hudColors.characterSheetLightNeutral);
		level->setOntop(true);
	}
	{
		Field* hp = entry->addField("hp", 32);
		hp->setFont(font.c_str());
		hp->setHJustify(Field::justify_t::RIGHT);
		hp->setVJustify(Field::justify_t::TOP);
		hp->setSize(SDL_Rect{ 0, 0, entry->getSize().w - 16, 24 });
		hp->setText("");
		hp->setColor(makeColor(255, 255, 255, 255));
		hp->setOntop(true);
	}

	const int hpHeight = 16;
	{
		Frame* hpFrame = entry->addFrame("hp");
		hpFrame->setSize(SDL_Rect{ portrait->getSize().x + portrait->getSize().w - 4, 16, entry->getSize().w - (portrait->getSize().x + portrait->getSize().w - 4), hpHeight });
		SDL_Rect hpFramePos = hpFrame->getSize();
		hpFrame->setHollow(true);

		auto mid = hpFrame->addImage(SDL_Rect{ 6, 2, 40, 12 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Mid_00.png", "hp img mid");
		auto endCap = hpFrame->addImage(SDL_Rect{ mid->pos.x + mid->pos.w, 0, 6, 16 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_End_00.png", "hp img endcap");

		auto progressBase = hpFrame->addImage(SDL_Rect{ 6, 4, 4, 8 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Fill_Base_00.png", "hp img progress base");
		auto progressMid = hpFrame->addImage(SDL_Rect{ 6, 4, 2, 8 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Fill_Mid_00.png", "hp img progress");
		auto progressEndCap = hpFrame->addImage(SDL_Rect{ 0, 4, 4, 8 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Fill_End_00.png", "hp img progress endcap");

		auto progressEndcapDamaged = hpFrame->addImage(SDL_Rect{ 6, 4, 18, 8 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Fill_End_Damaged.png", "hp img progress damaged");
		progressEndcapDamaged->disabled = true;

		auto progressEndCapFlash = hpFrame->addImage(SDL_Rect{
			0, 4, 18, 8 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_HPBar_Fill_End_00.png", "hp img progress endcap flash");
		progressEndCapFlash->disabled = true;

		auto base = hpFrame->addImage(SDL_Rect{ 0, 0, 6, 16 }, 0xFFFFFFFF, 
			"*#images/ui/HUD/allies/HUD_HPBar_Base_00.png", "hp img base");

	}

	const int mpHeight = 6;
	if ( false )
	{
		Frame* mpFrame = entry->addFrame("mp");
		mpFrame->setSize(SDL_Rect{ portrait->getSize().x + portrait->getSize().w, 30, entry->getSize().w - (portrait->getSize().x + portrait->getSize().w - 4), mpHeight });
		SDL_Rect mpFramePos = mpFrame->getSize();
		mpFrame->setHollow(true);

		auto mid = mpFrame->addImage(SDL_Rect{ 2, 0, 40, 6 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Mid_00.png", "mp img mid");
		auto endCap = mpFrame->addImage(SDL_Rect{ mid->pos.x + mid->pos.w, 0, 4, 6 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_End_00.png", "mp img endcap");

		auto progressBase = mpFrame->addImage(SDL_Rect{ 2, 0, 4, 4 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Fill_Base_00.png", "mp img progress base");
		auto progressMid = mpFrame->addImage(SDL_Rect{ 2, 0, 4, 4 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_00.png", "mp img progress");
		auto progressEndCap = mpFrame->addImage(SDL_Rect{ 0, 0, 4, 4 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Fill_End_00.png", "mp img progress endcap");

		auto progressEndcapDamaged = mpFrame->addImage(SDL_Rect{ 0, 0, 8, 4 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Fill_End_Damaged.png", "mp img progress damaged");
		progressEndcapDamaged->disabled = true;

		auto progressEndCapFlash = mpFrame->addImage(SDL_Rect{
			0, 0, 8, 4 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Fill_End_00.png", "mp img progress endcap flash");
		progressEndCapFlash->disabled = true;

		auto base = mpFrame->addImage(SDL_Rect{ 0, 0, 4, 6 }, 0xFFFFFFFF,
			"*#images/ui/HUD/allies/HUD_MPBar_Base_00.png", "mp img base");
	}
	return entry;
}

bool Player::HUD_t::FollowerDisplay_t::infiniteScrolling = true;
int Player::HUD_t::FollowerDisplay_t::numFiniteBars = 8;;
int Player::HUD_t::FollowerDisplay_t::numInfiniteFullsizeBars = 8;
int Player::HUD_t::FollowerDisplay_t::numInfiniteCompactBars = 16;
int Player::HUD_t::FollowerDisplay_t::numInfiniteSplitscreenFullsizeBars = 4;
int Player::HUD_t::FollowerDisplay_t::numInfiniteSplitscreenCompactBars = 8;
int Player::HUD_t::FollowerDisplay_t::getNumEntriesToShow(const int playernum)
{
	auto& hud_t = players[playernum]->hud;
	if ( !infiniteScrolling )
	{
		return numFiniteBars;
	}
	if ( !splitscreen || !players[playernum]->bUseCompactGUIHeight() )
	{
		if ( list_Size(&stats[playernum]->FOLLOWERS) < numInfiniteFullsizeBars )
		{
			return numInfiniteFullsizeBars;
		}
		else
		{
			return numInfiniteCompactBars;
		}
	}
	else
	{
		if ( list_Size(&stats[playernum]->FOLLOWERS) < numInfiniteSplitscreenFullsizeBars )
		{
			return numInfiniteSplitscreenFullsizeBars;
		}
		else
		{
			return numInfiniteSplitscreenCompactBars;
		}
	}
}

bool Player::HUD_t::FollowerDisplay_t::getCompactMode(const int playernum)
{
	auto& hud_t = players[playernum]->hud;
	if ( !infiniteScrolling )
	{
		return false;
	}
	if ( !splitscreen || !players[playernum]->bUseCompactGUIHeight() )
	{
		if ( list_Size(&stats[playernum]->FOLLOWERS) < numInfiniteFullsizeBars )
		{
			return false;
		}
		else
		{
			return true;
		}
	}
	else
	{
		if ( list_Size(&stats[playernum]->FOLLOWERS) < numInfiniteSplitscreenFullsizeBars )
		{
			return false;
		}
		else
		{
			return true;
		}
	}
}

Frame* getAllyBarTitleFrameEntry(const int player)
{
	auto& hud_t = players[player]->hud;
	Frame* entry = hud_t.allyFollowerTitleFrame->findFrame("entry");
	if ( !entry )
	{
		entry = createAllyFollowerEntry(player, hud_t.allyFollowerTitleFrame);
	}
	return entry;
}

void updateAllyBarFrame(const int player, Frame* baseFrame, int activeBars, int realActiveBars, const bool bPlayerBars)
{
	Frame::image_t* selector = baseFrame->findImage("selector");
	if ( selector )
	{
		selector->disabled = true;
	}
	Frame::image_t* titleSelector = !bPlayerBars ? players[player]->hud.allyFollowerTitleFrame->findImage("selector") : nullptr;
	if ( titleSelector )
	{
		titleSelector->disabled = true;
	}
	Frame::image_t* titleSelectorGlyph = !bPlayerBars ? players[player]->hud.allyFollowerTitleFrame->findImage("glyph selector") : nullptr;
	if ( titleSelectorGlyph )
	{
		titleSelectorGlyph->disabled = true;
	}

	std::vector<Frame*> allyFrames;
	int barIndex = -1;
	for ( auto f : baseFrame->getFrames() )
	{
		if ( strcmp(f->getName(), "entry") || f->isToBeDeleted() )
		{
			continue;
		}
		++barIndex;

		if ( barIndex >= activeBars )
		{
			f->removeSelf();
			continue;
		}
		allyFrames.push_back(f);
	}

	while ( allyFrames.size() < activeBars )
	{
		allyFrames.push_back(bPlayerBars ? createAllyPlayerEntry(player) : createAllyFollowerEntry(player, baseFrame));
	}

	auto& hud_t = players[player]->hud;

	Uint32 recentFollowerUID = 0;
	if ( FollowerMenu[player].recentEntity )
	{
		recentFollowerUID = FollowerMenu[player].recentEntity->getUID();
	}

	auto& infiniteScrolling = Player::HUD_t::FollowerDisplay_t::infiniteScrolling;
	/*if ( enableDebugKeys && keystatus[SDLK_F] )
	{
		keystatus[SDLK_F] = 0;
		infiniteScrolling = !infiniteScrolling;
	}*/

	auto& followerDisplay = hud_t.followerDisplay;

	Frame* titleFrame = nullptr;
	if ( infiniteScrolling && !bPlayerBars )
	{
		titleFrame = getAllyBarTitleFrameEntry(player);
		titleFrame->setDisabled(true);
	}

	const int kNumEntriesToShow = Player::HUD_t::FollowerDisplay_t::getNumEntriesToShow(player);

	int currentY = 0;
	int entryHeightForGlyphs = 0;
	int baseFrameHeight = 0;
	int selectorX = 0;
	bool madeSelection = false;
	bool updateTitleFrame = false;
	bool doneTitleFrame = false;
	barIndex = -1;
	bool halfWidthBars = (splitscreen && players[player]->bUseCompactGUIWidth()) 
		/*|| (enableDebugKeys && keystatus[SDLK_G])*/;

	std::set<Uint32> followerUids;
	for ( node_t* node = stats[player]->FOLLOWERS.first; node != nullptr; node = node->next )
	{
		if ( (Uint32*)node->element )
		{
			followerUids.emplace(*((Uint32*)node->element));
		}
	}

	for ( auto it = (bPlayerBars ? hud_t.playerBars.begin() : hud_t.followerBars.begin()); 
		it != (bPlayerBars ? hud_t.playerBars.end() : hud_t.followerBars.end()); )
	{
		++barIndex;
		auto& followerBar = (*it).second;
		Frame* entryFrame = allyFrames[barIndex];

		bool doAnimation = true;
		bool shortBars = players[player]->hud.followerDisplay.bCompact && infiniteScrolling && !bPlayerBars;
		if ( followerBar.dummy )
		{
			doAnimation = true;
		}
		else if ( followerBar.selected )
		{
			if ( updateTitleFrame )
			{
				shortBars = false;
				entryFrame = titleFrame;
				titleFrame->setDisabled(false);
				doneTitleFrame = true;
				doAnimation = false;
			}
		}

		auto& HPBar = followerBar.hpBar;
		auto& MPBar = followerBar.mpBar;

		if ( doAnimation )
		{
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			/*if ( !players[player]->shootmode && !FollowerMenu[player].followerMenuIsOpen() )
			{
				real_t setpointDiffX = fpsScale * std::max(.01, (followerBar.animx)) / 2.0;
				followerBar.animx -= setpointDiffX;
				followerBar.animx = std::max(0.0, followerBar.animx);
			}
			else*/
			{
				real_t setpointDiffX = fpsScale * std::max(.01, (1.0 - followerBar.animx)) / 2.0;
				followerBar.animx += setpointDiffX;
				followerBar.animx = std::min(1.0, followerBar.animx);
			}
		}

		SDL_Rect pos = entryFrame->getSize();
		pos.x = pos.w - followerBar.animx * pos.w;
		if ( halfWidthBars && !bPlayerBars )
		{
			pos.x += 8;
		}
		if ( updateTitleFrame )
		{
			pos.y = hud_t.allyFollowerTitleFrame->getSize().h - AllyStatusBarSettings_t::FollowerBars_t::entrySettings.entryHeight * 2;
		}
		else
		{
			pos.y = currentY;
		}
		if ( bPlayerBars )
		{
			if ( shortBars )
			{
				pos.h = AllyStatusBarSettings_t::PlayerBars_t::entrySettings.entryCompactHeight;
			}
			else
			{
				pos.h = AllyStatusBarSettings_t::PlayerBars_t::entrySettings.entryHeight;
			}
		}
		else
		{
			if ( shortBars )
			{
				pos.h = AllyStatusBarSettings_t::FollowerBars_t::entrySettings.entryCompactHeight;
			}
			else
			{
				pos.h = AllyStatusBarSettings_t::FollowerBars_t::entrySettings.entryHeight;
			}
			entryHeightForGlyphs = pos.h;
		}
		if ( bPlayerBars )
		{
			baseFrameHeight += pos.h;
		}
		else
		{
			if ( !infiniteScrolling )
			{
				if ( barIndex < kNumEntriesToShow )
				{
					baseFrameHeight += pos.h;
				}
			}
			else
			{
				if ( !shortBars && !updateTitleFrame )
				{
					baseFrameHeight = (((kNumEntriesToShow - 1))
						* AllyStatusBarSettings_t::FollowerBars_t::entrySettings.entryHeight);
				}
				else
				{
					baseFrameHeight = (((kNumEntriesToShow - 1))
							* AllyStatusBarSettings_t::FollowerBars_t::entrySettings.entryCompactHeight);
				}
			}
		}
		entryFrame->setOpacity(baseFrame->getOpacity());


		if ( followerBar.expired && ((ticks - followerBar.expiredTicks) > TICKS_PER_SECOND / 2) )
		{
			if ( doAnimation )
			{
				const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
				real_t setpointDiffFade = fpsScale * std::max(.01, (1.0 - followerBar.animFade)) / 5.0;
				followerBar.animFade += setpointDiffFade;
				followerBar.animFade = std::min(1.0, followerBar.animFade);
			}
			entryFrame->setOpacity(entryFrame->getOpacity() * (1.0 - followerBar.animFade));

			if ( doAnimation && followerBar.animFade >= 0.9999 )
			{
				const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
				real_t setpointDiffY = fpsScale * std::max(.01, (1.0 - followerBar.animy)) / 2.0;
				followerBar.animy += setpointDiffY;
				followerBar.animy = std::min(1.0, followerBar.animy);
			}
			pos.h *= (1.0 - followerBar.animy);
		}

		Uint32 uid = (*it).first;
		Entity* follower = bPlayerBars ? players[uid]->entity : uidToEntity(uid);
		if ( (!bPlayerBars && (!follower || followerUids.find(uid) == followerUids.end())) || (bPlayerBars && client_disconnected[uid]) )
		{
			if ( !followerBar.expired )
			{
				followerBar.expiredTicks = ticks;
				followerBar.animFadeScroll = 0.0;
				followerBar.animFadeScrollDummy = 1.0;
			}
			followerBar.expired = true;
			followerBar.selected = false;
		}

		if ( bPlayerBars )
		{
			entryFrame->setUserData(followerBar.expired ? nullptr : (void*)(intptr_t)(uid + 1)); // 0 is nullptr, so +1
		}

		if ( !bPlayerBars )
		{
			if ( doAnimation )
			{
				if ( hud_t.followerBars.size() > kNumEntriesToShow && !infiniteScrolling )
				{
					if ( barIndex >= followerDisplay.scrollSetpoint
						&& barIndex < (followerDisplay.scrollSetpoint + kNumEntriesToShow) )
					{
						// visible in list
						const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
						real_t setpointDiffFade = fpsScale * std::max(.01, followerBar.animFadeScroll) / 1.0;
						followerBar.animFadeScroll -= setpointDiffFade;
						followerBar.animFadeScroll = std::max(0.0, followerBar.animFadeScroll);
					}
					else
					{
						// not visible
						const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
						real_t setpointDiffFade = fpsScale * std::max(.01, (1.0 - followerBar.animFadeScroll)) / 1.0;
						followerBar.animFadeScroll += setpointDiffFade;
						followerBar.animFadeScroll = std::min(1.0, followerBar.animFadeScroll);
					}
				}
				else
				{
					if ( infiniteScrolling 
						&& (barIndex < followerDisplay.scrollSetpoint
							// below statement fades real bars if the list is truncated because of JSON config.
							// if list not truncated, then no real bar should show up until scroll resets to 0
							|| barIndex >= followerDisplay.scrollSetpoint + kNumEntriesToShow - 1) )
					{
						//followerBar.animFadeScroll = 1.0;
						// not visible
						const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
						if ( !followerBar.dummy )
						{
							real_t setpointDiffFade = fpsScale * std::max(.01, (1.0 - followerBar.animFadeScroll)) / 10.0;
							followerBar.animFadeScroll += setpointDiffFade;
							followerBar.animFadeScroll = std::min(1.0, followerBar.animFadeScroll);
						}

					}
					else
					{
						const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
						if ( !followerBar.dummy )
						{
							real_t setpointDiffFade = fpsScale * std::max(.01, followerBar.animFadeScroll) / 10.0;
							followerBar.animFadeScroll -= setpointDiffFade;
							followerBar.animFadeScroll = std::max(0.0, followerBar.animFadeScroll);
						}

					}

					if ( infiniteScrolling 
						&& (barIndex < followerDisplay.scrollSetpoint - 1
							// below statement stops dummy bars fading in if the list is truncated because of JSON config.
							// otherwise fade in as the real bar is less than the current scroll
							&& !(barIndex + realActiveBars >= followerDisplay.scrollSetpoint + kNumEntriesToShow - 1)) )
					{
						const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
						if ( !followerBar.dummy )
						{
							real_t setpointDiffFade = fpsScale * std::max(.01, followerBar.animFadeScrollDummy) / 10.0;
							followerBar.animFadeScrollDummy -= setpointDiffFade;
							followerBar.animFadeScrollDummy = std::max(0.0, followerBar.animFadeScrollDummy);
						}
					}
					else
					{
						const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
						if ( !followerBar.dummy )
						{
							real_t setpointDiffFade = fpsScale * std::max(.01, (1.0 - followerBar.animFadeScrollDummy)) / 10.0;
							followerBar.animFadeScrollDummy += setpointDiffFade;
							followerBar.animFadeScrollDummy = std::min(1.0, followerBar.animFadeScrollDummy);
						}
					}
				}
			}

			if ( !updateTitleFrame )
			{
				bool fadeWhenMenuOpen = FollowerMenu[player].followerMenuIsOpen() && halfWidthBars;
				real_t dim = .5;
				if ( followerBar.dummy )
				{
					entryFrame->setOpacity(entryFrame->getOpacity() * (1.0 - followerBar.animFadeScrollDummy) * (fadeWhenMenuOpen ? dim : 1.0));
				}
				else
				{
					entryFrame->setOpacity(entryFrame->getOpacity() * (1.0 - followerBar.animFadeScroll) * (fadeWhenMenuOpen ? dim : 1.0));
				}
			}
		}

		if ( !updateTitleFrame )
		{
			currentY += pos.h;
		}
		entryFrame->setSize(pos);

		auto hpFrame = entryFrame->findFrame("hp");
		auto hpMid = hpFrame->findImage("hp img mid");
		auto hpEndcap = hpFrame->findImage("hp img endcap");
		auto hpProgressBase = hpFrame->findImage("hp img progress base");
		auto hpProgress = hpFrame->findImage("hp img progress");
		auto hpProgressEndcap = hpFrame->findImage("hp img progress endcap");

		auto& hpBarSettings = bPlayerBars ? AllyStatusBarSettings_t::PlayerBars_t::hpBar : AllyStatusBarSettings_t::FollowerBars_t::hpBar;
		auto& mpBarSettings = bPlayerBars ? AllyStatusBarSettings_t::PlayerBars_t::mpBar : AllyStatusBarSettings_t::FollowerBars_t::mpBar;
		const int hpCompactMaxWidthAmount = hpBarSettings.barCompactMaxWidthAmount;
		const int hpMaxWidthAmount = hpBarSettings.barMaxWidthAmount;
		const real_t hpCompactWidthIncreasePercentOnInterval = hpBarSettings.barCompactWidthIncreasePercentOnInterval;
		const real_t hpWidthIncreasePercentOnInterval = hpBarSettings.barWidthIncreasePercentOnInterval;
		const int hpCompactIntervalToIncreaseWidth = hpBarSettings.barCompactIntervalToIncreaseWidth;
		const int hpIntervalToIncreaseWidth = hpBarSettings.barIntervalToIncreaseWidth;
		const int hpCompactBasePercentSize = hpBarSettings.barCompactBasePercentSize;
		const int hpBasePercentSize = hpBarSettings.barBasePercentSize;

		const real_t hpCompactIntervalStartValue = hpBarSettings.barCompactIntervalStartValue;
		const real_t hpIntervalStartValue = hpBarSettings.barIntervalStartValue;

		const int mpCompactMaxWidthAmount = mpBarSettings.barCompactMaxWidthAmount;
		const int mpMaxWidthAmount = mpBarSettings.barMaxWidthAmount;
		const real_t mpCompactWidthIncreasePercentOnInterval = mpBarSettings.barCompactWidthIncreasePercentOnInterval;
		const real_t mpWidthIncreasePercentOnInterval = mpBarSettings.barWidthIncreasePercentOnInterval;
		const int mpCompactIntervalToIncreaseWidth = mpBarSettings.barCompactIntervalToIncreaseWidth;
		const int mpIntervalToIncreaseWidth = mpBarSettings.barIntervalToIncreaseWidth;
		const int mpCompactBasePercentSize = mpBarSettings.barCompactBasePercentSize;
		const int mpBasePercentSize = mpBarSettings.barBasePercentSize;

		const real_t mpCompactIntervalStartValue = mpBarSettings.barCompactIntervalStartValue;
		const real_t mpIntervalStartValue = mpBarSettings.barIntervalStartValue;

		Stat* followerStats = nullptr;
		if ( bPlayerBars )
		{
			followerStats = stats[uid];
		}
		else
		{
			followerStats = follower ? follower->getStats() : nullptr;
		}

		int MAXHP = HPBar.maxValue;
		int HP = HPBar.animateSetpoint;
		int MAXMP = MPBar.maxValue;
		int MP = MPBar.animateSetpoint;
		Field* nameField = entryFrame->findField("name");
		bool updateName = false;
		if ( followerBar.name == "" || followerDisplay.bHalfWidthBars != halfWidthBars || updateTitleFrame )
		{
			updateName = true;
		}

		if ( followerStats && ((!bPlayerBars && follower) || bPlayerBars) )
		{
			followerBar.level = followerStats->LVL;
			if ( follower )
			{
				followerBar.monsterType = follower->getMonsterTypeFromSprite();
				followerBar.model = follower->sprite;
			}
			else
			{
				followerBar.monsterType = followerStats->type;
			}

			if ( HP != followerStats->HP || MAXHP != followerStats->MAXHP )
			{
				updateName = true;
			}
			HP = followerStats->HP;
			MAXHP = followerStats->MAXHP;

			MP = followerStats->MP;
			MAXMP = followerStats->MAXMP;
		}
		else
		{
			if ( !bPlayerBars )
			{
				HP = 0;
			}
		}

		if ( updateName && (followerStats && ((!bPlayerBars && follower) || bPlayerBars)) )
		{
			std::string followerName = "";
			followerBar.customPortraitPath = "";
			size_t maxNameLen = 0;
			if ( bPlayerBars )
			{
				maxNameLen = AllyStatusBarSettings_t::PlayerBars_t::entrySettings.maxNameLengthFullsize;
			}
			else
			{
				if ( !halfWidthBars )
				{
					if ( !shortBars )
					{
						maxNameLen = AllyStatusBarSettings_t::FollowerBars_t::entrySettings.maxNameLengthFullsize;
					}
					else
					{
						maxNameLen = AllyStatusBarSettings_t::FollowerBars_t::entrySettings.maxNameLengthCompact;
					}
				}
				else
				{
					if ( !shortBars )
					{
						maxNameLen = AllyStatusBarSettings_t::FollowerBars_t::entrySettings.maxNameLengthSplitscreenFullsize;
					}
					else
					{
						maxNameLen = AllyStatusBarSettings_t::FollowerBars_t::entrySettings.maxNameLengthSplitscreenCompact;
					}
				}
				if ( !shortBars )
				{
					if ( MAXHP >= 100 || HP >= 100 )
					{
						maxNameLen -= 1;
					}
					if ( MAXHP >= 100 && HP >= 100 )
					{
						maxNameLen -= 1;
					}
					if ( MAXHP >= 200 && HP >= 200 )
					{
						maxNameLen -= 1;
					}
				}
			}

			if ( bPlayerBars )
			{
				followerName = followerStats->name;
				if ( followerName.size() > maxNameLen )
				{
					followerName = followerName.substr(0, maxNameLen - 1);
					followerName += "..";
				}
			}
			else if ( strcmp(followerStats->name, "") && strcmp(followerStats->name, "nothing") )
			{
				if ( strlen(followerStats->name) > maxNameLen )
				{
					if ( followerStats->type == SKELETON )
					{
						if ( MonsterData_t::nameMatchesSpecialNPCName(*followerStats, "skeleton sentinel") )
						{
							followerName = MonsterData_t::monsterDataEntries[SKELETON].specialNPCs["skeleton sentinel"].shortname;
							followerBar.customPortraitPath = MonsterData_t::monsterDataEntries[SKELETON].specialNPCs["skeleton sentinel"].uniqueIcon;
						}
						else if ( MonsterData_t::nameMatchesSpecialNPCName(*followerStats, "skeleton knight") )
						{
							followerName = MonsterData_t::monsterDataEntries[SKELETON].specialNPCs["skeleton knight"].shortname;
							followerBar.customPortraitPath = MonsterData_t::monsterDataEntries[SKELETON].specialNPCs["skeleton knight"].uniqueIcon;
						}
						else
						{
							followerName = followerStats->name;
						}
					}
					else
					{
						followerName = followerStats->name;
					}

					if ( followerName.size() > maxNameLen )
					{
						followerName = followerName.substr(0, maxNameLen - 1);
						followerName += "..";
					}
				}
				else
				{
					followerName = followerStats->name;
				}
			}
			else
			{
				followerName = getMonsterLocalizedName(followerStats->type);
				if ( followerName.size() > maxNameLen )
				{
					if ( MonsterData_t::monsterDataEntries[followerStats->type].defaultShortDisplayName != "" )
					{
						followerName = MonsterData_t::monsterDataEntries[followerStats->type].defaultShortDisplayName;
					}
					if ( followerName.size() > maxNameLen )
					{
						followerName = followerName.substr(0, maxNameLen - 1);
						followerName += "..";
					}
				}
			}
			capitalizeString(followerName);
			followerBar.name = followerName;
		}

		char levelbuf[32];
		snprintf(levelbuf, sizeof(levelbuf), "Lv%d", followerBar.level);
		auto levelField = entryFrame->findField("level");
		levelField->setText(levelbuf);

		char buf[32];
		snprintf(buf, sizeof(buf), "%d/%d", HP, MAXHP);
		auto hpField = entryFrame->findField("hp");
		hpField->setText(buf);

		if ( bPlayerBars )
		{
			static ConsoleVariable<bool> cvar_playerbars_use_colors("/playerbars_use_colors", true);
			if ( *cvar_playerbars_use_colors )
			{
				nameField->setColor(playerColor(uid, colorblind_lobby, false));
			}
			else
			{
				nameField->setColor(hudColors.characterSheetLightNeutral);
			}
		}
		else
		{
			nameField->setColor(hudColors.characterSheetLightNeutral);
		}
		nameField->setText(followerBar.name.c_str());

		int hpWidth = (shortBars ? hpBarSettings.barCompactPixelWidth : hpBarSettings.barPixelWidth);
		if ( halfWidthBars )
		{
			hpWidth += hpBarSettings.barSplitscreenPixelWidthOffset;
		}

		Frame* portrait = entryFrame->findFrame("portrait");
		if ( shortBars )
		{
			portrait->setDisabled(true);
			SDL_Rect hpFramePos = hpFrame->getSize();
			hpFramePos.x = levelField->getSize().w - 40 - (hpWidth + 6);
			hpFramePos.y = 4;
			hpFrame->setSize(hpFramePos);

			hpField->setDisabled(true);

			nameField->setSize(SDL_Rect{ 0, 0, hpFramePos.x - 8, nameField->getSize().h });
			nameField->setHJustify(Field::justify_t::RIGHT);

			levelField->setSize(SDL_Rect{ 0, nameField->getSize().y, entryFrame->getSize().w - 16, levelField->getSize().h });

			if ( !followerDisplay.infiniteScrolling )
			{
				if ( auto textGet = nameField->getTextObject() )
				{
					int x = nameField->getSize().x + nameField->getSize().w - textGet->getWidth();
					selectorX = selectorX != 0 ? std::min(selectorX, x) : x;
				}
			}
		}
		else
		{
			portrait->setDisabled(false);
			SDL_Rect hpFramePos = hpFrame->getSize();
			hpFramePos.x = levelField->getSize().w - 40 - (hpWidth + 6);
			hpFramePos.y = 16;
			hpFrame->setSize(hpFramePos);

			hpField->setDisabled(false);

			portrait->setSize(SDL_Rect{ hpFramePos.x + 4 - portrait->getSize().w, 0, portrait->getSize().w, portrait->getSize().h });
			auto portraitImg = portrait->findImage("portrait img");
			if ( followerBar.customPortraitPath != "" )
			{
				portraitImg->path = followerBar.customPortraitPath;
			}
			else
			{
				portraitImg->path = monsterData.getAllyIconFromSprite(followerBar.model, followerBar.monsterType);
			}

			nameField->setSize(SDL_Rect{ hpFramePos.x, 0, entryFrame->getSize().w - hpFramePos.x, nameField->getSize().h });
			nameField->setHJustify(Field::justify_t::LEFT);

			levelField->setSize(SDL_Rect{ 0, 14, entryFrame->getSize().w - 16, levelField->getSize().h });

			if ( !followerDisplay.infiniteScrolling )
			{
				selectorX = selectorX != 0 ? std::min(selectorX, portrait->getSize().x) : portrait->getSize().x;
			}
		}

		if ( updateTitleFrame )
		{
			auto bgImgLeft = entryFrame->findImage("bg img left");
			bgImgLeft->disabled = false;
			auto bgImgMid = entryFrame->findImage("bg img mid");
			bgImgMid->disabled = false;
			auto bgImgRight = entryFrame->findImage("bg img right");
			bgImgRight->disabled = false;

			const int totalWidth = entryFrame->getSize().w - portrait->getSize().x;
			bgImgMid->pos.w = totalWidth - bgImgLeft->pos.w - bgImgRight->pos.w;
			/*bgImg->pos.h = entryFrame->getSize().h;*/
			bgImgLeft->pos.y = 0;
			bgImgMid->pos.y = 0;
			bgImgRight->pos.y = 0;
			bgImgLeft->pos.x = entryFrame->getSize().w - totalWidth - 8;
			bgImgMid->pos.x = bgImgLeft->pos.x + bgImgLeft->pos.w;
			bgImgRight->pos.x = bgImgMid->pos.x + bgImgMid->pos.w;

			selectorX = bgImgLeft->pos.x;
		}

		{ // HP
			int backgroundWidth = hpWidth - 6;
			real_t progressWidth = hpWidth - 8;

			// handle bar size changing
			{
				real_t multiplier = 1.0;
				const Sint32 maxHPWidth = (shortBars ? hpCompactMaxWidthAmount : hpMaxWidthAmount);
				if ( MAXHP < maxHPWidth )
				{
					// start at 30%, increase 2.5% every 5 HP past 20 MAXHP
					multiplier = (shortBars ? hpCompactBasePercentSize : hpBasePercentSize) / 100.0;
					real_t widthIntervalPercent = (shortBars ? hpCompactWidthIncreasePercentOnInterval : hpWidthIncreasePercentOnInterval) / 100.0;
					int intervalThreshold = (shortBars ? hpCompactIntervalToIncreaseWidth : hpIntervalToIncreaseWidth);
					int baseIntervalStart = (shortBars ? hpCompactIntervalStartValue : hpIntervalStartValue);
					multiplier += (widthIntervalPercent * ((std::max(0, MAXHP - baseIntervalStart) / intervalThreshold)));
				}

				int diff = static_cast<int>(std::max(0.0, progressWidth - progressWidth * multiplier)); // how many pixels the progress bar shrinks
				progressWidth -= diff; // scale the progress bars
				hpMid->pos.w = backgroundWidth - diff; // move the background bar by x pixels as above
				hpEndcap->pos.x = hpMid->pos.x + hpMid->pos.w; // move the background endcap by x pixels as above
			}

			HPBar.animatePreviousSetpoint = HPBar.animateSetpoint;
			real_t& hpForegroundValue = HPBar.animateValue;
			real_t& hpFadedValue = HPBar.animateValue2;

			HPBar.animateSetpoint = HP;
			if ( HPBar.animateSetpoint < HPBar.animatePreviousSetpoint ) // insta-change as losing health
			{
				hpForegroundValue = HPBar.animateSetpoint;
				HPBar.animateTicks = ticks;

				// flash for taking damage
				HPBar.flashTicks = ticks;
				HPBar.flashAnimState = -1;
				HPBar.flashType = Player::HUD_t::FLASH_ON_DAMAGE;
			}

			if ( HPBar.maxValue > MAXHP )
			{
				hpFadedValue = HPBar.animateSetpoint; // resetting game etc, stop fade animation sticking out of frame
			}

			HPBar.maxValue = MAXHP;
			if ( !followerBar.bInit )
			{
				hpForegroundValue = HPBar.animateSetpoint;
			}
			if ( hpForegroundValue < HPBar.animateSetpoint ) // gaining HP, animate
			{
				// flash for gaining HP, provided not already flashing
				/*if ( HPBar.flashAnimState == -1 || (HPBar.flashAnimState >= 0 && HPBar.flashType != FLASH_ON_DAMAGE) )
				{
				HPBar.flashTicks = ticks;
				HPBar.flashAnimState = -1;
				HPBar.flashType = FLASH_ON_RECOVERY;
				}*/

				if ( doAnimation )
				{
					real_t setpointDiff = std::max(0.0, HPBar.animateSetpoint - hpForegroundValue);
					real_t fpsScale = getFPSScale(144.0);
					hpForegroundValue += fpsScale * (setpointDiff / 20.0); // reach it in 20 intervals, scaled to FPS
				}
				hpForegroundValue = std::min(static_cast<real_t>(HPBar.animateSetpoint), hpForegroundValue);

				if ( abs(HPBar.animateSetpoint) - abs(hpForegroundValue) <= 1.0 )
				{
					hpForegroundValue = HPBar.animateSetpoint;
				}

				/*	int increment = 3;
				double scaledIncrement = (increment * (getFPSScale(144.0)));*/
				//real_t diff = std::max(.1, (HPBar.animateSetpoint * 10 - hpForegroundValue) / (maxValue / 5)); // 0.1-5 value
				//if ( HPBar.animateSetpoint * 10 >= maxValue )
				//{
				//	diff = 5;
				//}
				//scaledIncrement *= 0.2 * pow(diff, 2) + .5;

				//hpForegroundValue = std::min(HPBar.animateSetpoint * 10.0, hpForegroundValue + scaledIncrement);
				//messagePlayer(0, "%.2f | %.2f", hpForegroundValue);
			}
			else if ( hpForegroundValue > HPBar.animateSetpoint ) // losing HP, snap to value
			{
				hpForegroundValue = HPBar.animateSetpoint;
			}

			if ( hpFadedValue < HPBar.animateSetpoint )
			{
				hpFadedValue = hpForegroundValue;
				HPBar.animateTicks = ticks;
			}
			else if ( hpFadedValue > HPBar.animateSetpoint )
			{
				if ( ticks - HPBar.animateTicks > 30 /*|| stats[player.playernum]->HP <= 0*/ ) // fall after x ticks
				{
					if ( doAnimation )
					{
						real_t setpointDiff = std::max(0.01, hpFadedValue - HPBar.animateSetpoint);
						real_t fpsScale = getFPSScale(144.0);
						hpFadedValue -= fpsScale * (setpointDiff / 20.0); // reach it in 20 intervals, scaled to FPS
					}
					hpFadedValue = std::max(static_cast<real_t>(HPBar.animateSetpoint), hpFadedValue);
				}
			}
			else
			{
				HPBar.animateTicks = ticks;
			}

			real_t foregroundPercent = hpForegroundValue / HPBar.maxValue;
			hpProgress->pos.w = std::max(1, static_cast<int>((progressWidth)* foregroundPercent));
			hpProgressEndcap->pos.x = hpProgress->pos.x + hpProgress->pos.w;

			auto hpProgressEndcapDamaged = hpFrame->findImage("hp img progress damaged");
			hpProgressEndcapDamaged->disabled = true;
			hpProgressEndcapDamaged->pos.x = hpProgressEndcap->pos.x + (hpProgressEndcap->pos.w - hpProgressEndcapDamaged->pos.w);
			if ( hpForegroundValue < HPBar.maxValue ) // damaged
			{
				hpProgressEndcapDamaged->disabled = false;
			}

			real_t fadePercent = hpFadedValue / HPBar.maxValue;
			if ( HP <= 0 )
			{
				// hide all the progress elements when dead, as endcap/base don't shrink
				// hpProgress width 0px defaults to original size, so hide that too
				hpProgress->disabled = true;
				hpProgressEndcap->disabled = true;
				hpProgressBase->disabled = true;
				hpProgressEndcapDamaged->disabled = true;
			}
			else
			{
				hpProgress->disabled = false;
				hpProgressEndcap->disabled = false;
				hpProgressBase->disabled = false;
			}

			auto hpProgressEndCapFlash = hpFrame->findImage("hp img progress endcap flash");
			hpProgressEndCapFlash->disabled = true;
			const int framesPerAnimation = HPBar.flashType == Player::HUD_t::FLASH_ON_DAMAGE ? 1 : 2;
			const int numAnimationFrames = HPBar.flashType == Player::HUD_t::FLASH_ON_DAMAGE ? 20 : 2;
			if ( HPBar.flashTicks > 0 )
			{
				//messagePlayer(0, MESSAGE_DEBUG, "ticks: %d, animticks: %d, state: %d", ticks, HPBarFlashTicks, HPBarFlashAnimState);
				if ( HPBar.flashAnimState > numAnimationFrames || hpProgress->disabled )
				{
					HPBar.flashTicks = 0;
					HPBar.flashType = Player::HUD_t::FLASH_ON_DAMAGE;
					HPBar.flashAnimState = -1;
					hpProgressEndCapFlash->disabled = true;
				}
				else
				{
					hpProgressEndCapFlash->disabled = hpProgressEndcap->disabled;
					if ( ticks == HPBar.flashTicks )
					{
						HPBar.flashAnimState = 1;
						HPBar.flashProcessedOnTick = ticks;
					}
					else if ( (HPBar.flashProcessedOnTick != ticks)
						&& (ticks > HPBar.flashTicks)
						&& (ticks - HPBar.flashTicks) % framesPerAnimation == 0 )
					{
						++HPBar.flashAnimState;
						HPBar.flashProcessedOnTick = ticks;
					}

					if ( HPBar.flashType == Player::HUD_t::FLASH_ON_DAMAGE )
					{
						if ( HPBar.flashAnimState <= 6 )
						{
							hpProgressEndCapFlash->color = 0xFFFFFFFF;
						}

						if ( HPBar.flashAnimState == 0 )
						{
							hpProgress->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Mid_00.png";
							hpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_End_F00.png";
							hpProgressBase->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Base_00.png";
						}
						else if ( HPBar.flashAnimState >= 1 && HPBar.flashAnimState <= 2 )
						{
							hpProgress->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Mid_01.png";
							hpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_End_F01.png";
							hpProgressBase->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Base_01.png";
						}
						else if ( HPBar.flashAnimState == 3 )
						{
							hpProgress->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Mid_02.png";
							hpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_End_F02.png";
							hpProgressBase->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Base_02.png";
						}
						else if ( HPBar.flashAnimState >= 4 && HPBar.flashAnimState <= 5 )
						{
							hpProgress->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Mid_01.png";
							hpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_End_F01.png";
							hpProgressBase->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Base_01.png";
						}
						else if ( HPBar.flashAnimState == 6 )
						{
							hpProgress->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Mid_03.png";
							hpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_End_F03.png";
							hpProgressBase->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Base_03.png";
						}
						else
						{
							hpProgress->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Mid_00.png";
							hpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_End_F00.png";
							hpProgressBase->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Base_00.png";
							Uint8 r, g, b, a;
							getColor(hpProgressEndCapFlash->color, &r, &g, &b, &a);
							int decrement = 20;
							real_t fpsScale = getFPSScale(60.0);
							decrement *= fpsScale;
							a = std::max(0, (int)a - decrement);
							hpProgressEndCapFlash->color = makeColor(r, g, b, a);
						}
					}
					else
					{
						hpProgressEndCapFlash->color = 0xFFFFFFFF;
						hpProgressEndCapFlash->disabled = true;
						if ( HPBar.flashAnimState == 1 )
						{
							hpProgress->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Mid_03.png";
							hpProgressBase->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Base_03.png";
							hpProgressEndcap->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_End_03.png";
						}
					}
				}
			}
			else
			{
				HPBar.flashAnimState = -1;
				hpProgressEndCapFlash->disabled = true;
				hpProgress->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Mid_00.png";
				hpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_End_F00.png";
				hpProgressBase->path = "*#images/ui/HUD/allies/HUD_HPBar_Fill_Base_00.png";
			}
			if ( !hpProgressEndcap->disabled )
			{
				hpProgressEndCapFlash->pos.x = hpProgressEndcap->pos.x - (hpProgressEndCapFlash->pos.w - hpProgressEndcap->pos.w);
			}
		}

		auto mpFrame = entryFrame->findFrame("mp");
		if ( mpFrame )
		{ // MP
			auto mpMid = mpFrame->findImage("mp img mid");
			auto mpEndcap = mpFrame->findImage("mp img endcap");
			auto mpProgressBase = mpFrame->findImage("mp img progress base");
			auto mpProgress = mpFrame->findImage("mp img progress");
			auto mpProgressEndcap = mpFrame->findImage("mp img progress endcap");

			const int mpWidth = (shortBars ? mpBarSettings.barCompactPixelWidth : mpBarSettings.barPixelWidth);
			int backgroundWidth = mpWidth - 2;
			real_t progressWidth = mpWidth - 4;
			// handle bar size changing
			{
				real_t multiplier = 1.0;
				const Sint32 maxMPWidth = (shortBars ? mpCompactMaxWidthAmount : mpMaxWidthAmount);
				if ( MAXMP < maxMPWidth )
				{
					// start at 30%, increase 2.5% every 5 MP past 20 MAXMP
					multiplier = (shortBars ? mpCompactBasePercentSize : mpBasePercentSize) / 100.0;
					real_t widthIntervalPercent = (shortBars ? mpCompactWidthIncreasePercentOnInterval : mpWidthIncreasePercentOnInterval) / 100.0;
					int intervalThreshold = (shortBars ? mpCompactIntervalToIncreaseWidth : mpIntervalToIncreaseWidth);
					int baseIntervalStart = (shortBars ? mpCompactIntervalStartValue : mpIntervalStartValue);
					multiplier += (widthIntervalPercent * ((std::max(0, MAXMP - baseIntervalStart) / intervalThreshold)));
				}

				int diff = static_cast<int>(std::max(0.0, progressWidth - progressWidth * multiplier)); // how many pixels the progress bar shrinks
				progressWidth -= diff; // scale the progress bars
				mpMid->pos.w = backgroundWidth - diff; // move the background bar by x pixels as above
				mpEndcap->pos.x = mpMid->pos.x + mpMid->pos.w; // move the background endcap by x pixels as above
			}

			MPBar.animatePreviousSetpoint = MPBar.animateSetpoint;
			real_t& mpForegroundValue = MPBar.animateValue;
			real_t& mpFadedValue = MPBar.animateValue2;

			MPBar.animateSetpoint = MP;
			if ( MPBar.animateSetpoint < MPBar.animatePreviousSetpoint ) // insta-change as losing health
			{
				mpForegroundValue = MPBar.animateSetpoint;
				MPBar.animateTicks = ticks;

				// flash for taking damage
				MPBar.flashTicks = ticks;
				MPBar.flashProcessedOnTick = 0;
				MPBar.flashAnimState = -1;
				MPBar.flashType = Player::HUD_t::FLASH_ON_DAMAGE;
			}

			if ( MPBar.maxValue > MAXMP )
			{
				mpFadedValue = MPBar.animateSetpoint; // resetting game etc, stop fade animation sticking out of frame
			}

			MPBar.maxValue = MAXMP;
			if ( !followerBar.bInit )
			{
				mpForegroundValue = MPBar.animateSetpoint;
			}
			if ( mpForegroundValue < MPBar.animateSetpoint ) // gaining MP, animate
			{
				// flash for gaining MP, provided not already flashing
				/*if ( MPBar.flashAnimState == -1 || (MPBar.flashAnimState >= 0 && MPBar.flashType != FLASH_ON_DAMAGE) )
				{
				MPBar.flashTicks = ticks;
				MPBar.flashAnimState = -1;
				MPBar.flashType = FLASH_ON_RECOVERY;
				}*/
				if ( doAnimation )
				{
					real_t setpointDiff = std::max(.1, MPBar.animateSetpoint - mpForegroundValue);
					real_t fpsScale = getFPSScale(144.0);
					mpForegroundValue += fpsScale * (setpointDiff / 20.0); // reach it in 20 intervals, scaled to FPS
				}
				mpForegroundValue = std::min(static_cast<real_t>(MPBar.animateSetpoint), mpForegroundValue);

				/*if ( abs(MPBar.animateSetpoint) - abs(mpForegroundValue) <= 1.0 )
				{
				mpForegroundValue = MPBar.animateSetpoint;
				}*/
			}
			else if ( mpForegroundValue > MPBar.animateSetpoint ) // losing MP, snap to value
			{
				mpForegroundValue = MPBar.animateSetpoint;
			}

			if ( mpFadedValue < MPBar.animateSetpoint )
			{
				mpFadedValue = mpForegroundValue;
				MPBar.animateTicks = ticks;
			}
			else if ( mpFadedValue > MPBar.animateSetpoint )
			{
				if ( ticks - MPBar.animateTicks > 30 /*|| stats[player.playernum]->MP <= 0*/ ) // fall after x ticks
				{
					if ( doAnimation )
					{
						real_t setpointDiff = std::max(0.1, mpFadedValue - MPBar.animateSetpoint);
						real_t fpsScale = getFPSScale(144.0);
						mpFadedValue -= fpsScale * (setpointDiff / 20.0); // reach it in 20 intervals, scaled to FPS
					}
					mpFadedValue = std::max(static_cast<real_t>(MPBar.animateSetpoint), mpFadedValue);
				}
			}
			else
			{
				MPBar.animateTicks = ticks;
			}

			real_t foregroundPercent = mpForegroundValue / MPBar.maxValue;
			mpProgress->pos.w = std::max(1, static_cast<int>((progressWidth)* foregroundPercent));
			mpProgressEndcap->pos.x = mpProgress->pos.x + mpProgress->pos.w;

			auto mpProgressEndcapDamaged = mpFrame->findImage("mp img progress damaged");
			mpProgressEndcapDamaged->disabled = true;
			mpProgressEndcapDamaged->pos.x = mpProgressEndcap->pos.x + (mpProgressEndcap->pos.w - mpProgressEndcapDamaged->pos.w);
			if ( mpForegroundValue < MPBar.maxValue ) // damaged
			{
				mpProgressEndcapDamaged->disabled = false;
			}

			real_t fadePercent = mpFadedValue / MPBar.maxValue;
			if ( MP <= 0 )
			{
				// hide all the progress elements when dead, as endcap/base don't shrink
				// mpProgress width 0px defaults to original size, so hide that too
				mpProgress->disabled = true;
				mpProgressEndcap->disabled = true;
				mpProgressBase->disabled = true;
				mpProgressEndcapDamaged->disabled = true;
			}
			else
			{
				mpProgress->disabled = false;
				mpProgressEndcap->disabled = false;
				mpProgressBase->disabled = false;
			}

			auto mpProgressEndCapFlash = mpFrame->findImage("mp img progress endcap flash");
			mpProgressEndCapFlash->disabled = true;
			const int framesPerAnimation = MPBar.flashType == Player::HUD_t::FLASH_ON_DAMAGE ? 1 : 2;
			const int numAnimationFrames = MPBar.flashType == Player::HUD_t::FLASH_ON_DAMAGE ? 30 : 2;
			if ( MPBar.flashTicks > 0 )
			{
				//messagePlayer(0, MESSAGE_DEBUG, "ticks: %d, animticks: %d, state: %d", ticks, MPBarFlashTicks, MPBarFlashAnimState);
				if ( MPBar.flashAnimState > numAnimationFrames || mpProgress->disabled )
				{
					MPBar.flashTicks = 0;
					MPBar.flashType = Player::HUD_t::FLASH_ON_DAMAGE;
					MPBar.flashAnimState = -1;
					mpProgressEndCapFlash->disabled = true;
				}
				else
				{
					mpProgressEndCapFlash->disabled = mpProgressEndcap->disabled;
					bool processedOnTick = MPBar.flashProcessedOnTick == ticks;
					if ( ticks == MPBar.flashTicks )
					{
						MPBar.flashAnimState = 1;
						MPBar.flashProcessedOnTick = ticks;
					}
					else if ( (!processedOnTick)
						&& (ticks > MPBar.flashTicks)
						&& (ticks - MPBar.flashTicks) % framesPerAnimation == 0 )
					{
						++MPBar.flashAnimState;
						MPBar.flashProcessedOnTick = ticks;
					}

					if ( MPBar.flashType == Player::HUD_t::FLASH_ON_DAMAGE )
					{
						if ( MPBar.flashAnimState <= 16 && MPBar.flashAnimState >= 10 )
						{
							mpProgressEndCapFlash->color = 0xFFFFFFFF;
						}
						else if ( MPBar.flashAnimState == 0 )
						{
							mpProgressEndCapFlash->color = makeColor(255, 255, 255, 0);
							mpProgressEndCapFlash->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_MPEnd_F00.png";
						}

						if ( MPBar.flashAnimState <= 9 )
						{
							if ( MPBar.flashAnimState == 7 )
							{
								// we need the MP bar to flash long enough for long spellcast times
								// can adjust how many animStates we skip here to play with timing,
								// without changing other state machine code
								MPBar.flashAnimState = 9; // 1, 2 skip a few..
							}
							Uint8 r, g, b, a;
							getColor(mpProgressEndCapFlash->color, &r, &g, &b, &a);
							int increment = 10;
							real_t fpsScale = getFPSScale(60.0);
							increment *= fpsScale;
							a = std::min(255, (int)a + increment);
							mpProgressEndCapFlash->color = makeColor(r, g, b, a);

							mpProgress->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_00.png";
							mpProgressBase->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_End_F00.png";

							if ( MPBar.flashAnimState % 2 == 0
								&& !processedOnTick )
							{
								mpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_End_F00.png";
							}
						}
						else if ( MPBar.flashAnimState <= 10 )
						{
							mpProgress->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_00.png";
							mpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_End_F00.png";
							mpProgressBase->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Base_00.png";
						}
						else if ( MPBar.flashAnimState >= 11 && MPBar.flashAnimState <= 12 )
						{
							mpProgress->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_01.png";
							mpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_End_F01.png";
							mpProgressBase->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Base_01.png";
						}
						else if ( MPBar.flashAnimState == 13 )
						{
							mpProgress->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_02.png";
							mpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_End_F02.png";
							mpProgressBase->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Base_02.png";
						}
						else if ( MPBar.flashAnimState >= 14 && MPBar.flashAnimState <= 15 )
						{
							mpProgress->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_01.png";
							mpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_End_F01.png";
							mpProgressBase->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Base_01.png";
						}
						else if ( MPBar.flashAnimState == 16 )
						{
							mpProgress->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_03.png";
							mpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_End_F03.png";
							mpProgressBase->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Base_03.png";
						}
						else
						{
							mpProgress->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_00.png";
							mpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_End_F00.png";
							mpProgressBase->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Base_00.png";
							Uint8 r, g, b, a;
							getColor(mpProgressEndCapFlash->color, &r, &g, &b, &a);
							int decrement = 20;
							real_t fpsScale = getFPSScale(60.0);
							decrement *= fpsScale;
							a = std::max(0, (int)a - decrement);
							mpProgressEndCapFlash->color = makeColor(r, g, b, a);
						}
					}
					else
					{
						mpProgressEndCapFlash->color = 0xFFFFFFFF;
						mpProgressEndCapFlash->disabled = true;
						if ( MPBar.flashAnimState == 1 )
						{
							mpProgress->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_03.png";
							mpProgressBase->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Base_03.png";
							mpProgressEndcap->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_End_03.png";
						}
					}
				}
			}
			else
			{
				MPBar.flashAnimState = -1;
				mpProgress->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Mid_00.png";
				mpProgressEndCapFlash->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_End_F00.png";
				mpProgressBase->path = "*#images/ui/HUD/allies/HUD_MPBar_Fill_Base_00.png";
				mpProgressEndCapFlash->disabled = true;
			}
			if ( !mpProgressEndcap->disabled )
			{
				mpProgressEndCapFlash->pos.x = mpProgressEndcap->pos.x - (mpProgressEndCapFlash->pos.w - mpProgressEndcap->pos.w);
			}
		}
		followerBar.bInit = true;
		if ( followerBar.selected && !titleFrame )
		{
			if ( selector )
			{
				SDL_Color color;
				getColor(selector->color, &color.r, &color.g, &color.b, &color.a);
				selector->color = makeColor(color.r, color.g, color.b, 255 * entryFrame->getOpacity() / 100.0);
				selector->disabled = false;
				if ( auto imgGet = Image::get(selector->path.c_str()) )
				{
					selector->pos.w = imgGet->getWidth();
					selector->pos.h = imgGet->getHeight();
				}
				selector->pos.x = entryFrame->getSize().x + selectorX - 8 - selector->pos.w;
				selector->pos.y = entryFrame->getSize().y + entryFrame->getSize().h / 2 - selector->pos.h / 2;
			}
		}
		else if ( followerBar.selected && titleFrame && updateTitleFrame )
		{
			if ( titleSelector )
			{
				SDL_Color color;
				getColor(titleSelector->color, &color.r, &color.g, &color.b, &color.a);
				titleSelector->color = makeColor(color.r, color.g, color.b, 255 * entryFrame->getOpacity() / 100.0);
				titleSelector->disabled = false;
				if ( auto imgGet = Image::get(titleSelector->path.c_str()) )
				{
					titleSelector->pos.w = imgGet->getWidth();
					titleSelector->pos.h = imgGet->getHeight();
				}
				titleSelector->pos.y = entryFrame->getSize().y + entryFrame->getSize().h / 2 - titleSelector->pos.h / 2;
				titleSelector->pos.x = entryFrame->getSize().x + selectorX - titleSelector->pos.w;
				const int selectorAnimW = 4;
				if ( titleSelectorGlyph )
				{
					if ( halfWidthBars 
						|| (!players[player]->shootmode && !FollowerMenu[player].followerMenuIsOpen() && !CalloutMenu[player].calloutMenuIsOpen())
						|| followerDisplay.bCycleNextDisabled || list_Size(&stats[player]->FOLLOWERS) <= 1 )
					{
						titleSelectorGlyph->disabled = true;
					}
					else
					{
						titleSelectorGlyph->path = Input::inputs[player].getGlyphPathForBinding("Cycle NPCs");
						if ( auto imgGet = Image::get(titleSelectorGlyph->path.c_str()) )
						{
							titleSelectorGlyph->disabled = false;
							titleSelectorGlyph->pos.w = imgGet->getWidth();
							titleSelectorGlyph->pos.h = imgGet->getHeight();
							titleSelectorGlyph->pos.x = titleSelector->pos.x - 2 * selectorAnimW - titleSelectorGlyph->pos.w;
							titleSelectorGlyph->pos.y = titleSelector->pos.y + titleSelector->pos.h / 2 - titleSelectorGlyph->pos.h / 2;

							static ConsoleVariable<int> followerMenuOpenGlyphX("/followermenu_open_glyph_x", 6);
							static ConsoleVariable<int> followerMenuOpenGlyphY("/followermenu_open_glyph_y", 0);
							titleSelectorGlyph->pos.x += *followerMenuOpenGlyphX;
							titleSelectorGlyph->pos.y += *followerMenuOpenGlyphY;
							if ( titleSelectorGlyph->pos.y % 2 == 1 )
							{
								--titleSelectorGlyph->pos.y;
							}
						}
					}
				}

				titleSelector->pos.x += 4 - selectorAnimW * (cos(followerDisplay.animSelected * 2 * PI));
			}
		}

		if ( followerBar.selected && titleFrame && !doneTitleFrame )
		{
			updateTitleFrame = true;
			--barIndex;
		}
		else
		{
			updateTitleFrame = false;
			++it;
		}
	}

	followerDisplay.bHalfWidthBars = halfWidthBars;

	SDL_Rect baseFramePos = baseFrame->getSize();
	baseFramePos.h = baseFrameHeight;
	baseFrame->setSize(baseFramePos);
	baseFrame->setActualSize(SDL_Rect{
		baseFrame->getActualSize().x,
		baseFrame->getActualSize().y,
		baseFrame->getActualSize().w ,
		infiniteScrolling ? baseFramePos.h * 10 : currentY });


	if ( !bPlayerBars && titleFrame && hud_t.allyFollowerGlyphFrame && !hud_t.allyFollowerGlyphFrame->isDisabled() )
	{
		static ConsoleVariable<int> followerMenuCommandGlyphX("/followermenu_cmd_glyph_x", -96);
		static ConsoleVariable<int> followerMenuCommandGlyphY("/followermenu_cmd_glyph_y", 0);
		static ConsoleVariable<int> followerMenuRepeatGlyphX("/followermenu_repeat_glyph_x", 0);
		static ConsoleVariable<int> followerMenuRepeatGlyphY("/followermenu_repeat_glyph_y", 0);

		auto glyphFrame = hud_t.allyFollowerGlyphFrame;
		SDL_Rect glyphFramePos{ baseFrame->getSize().x, titleFrame->getSize().y, 150, 80 };
		glyphFramePos.x += *followerMenuCommandGlyphX;
		if ( !titleSelectorGlyph->disabled )
		{
			glyphFramePos.x -= titleSelectorGlyph->pos.w;
		}
		glyphFramePos.y += *followerMenuCommandGlyphY;
		glyphFrame->setSize(glyphFramePos);

		auto commandGlyph = glyphFrame->findImage("glyph command");
		auto commandImg = glyphFrame->findImage("img command");
		//auto commandText = glyphFrame->findField("command prompt txt");

		auto repeatGlyph = glyphFrame->findImage("glyph repeat");
		auto repeatImg = glyphFrame->findImage("img repeat");
		//auto repeatCmdText = glyphFrame->findField("repeat prompt txt");

		if ( auto imgGet = Image::get(commandImg->path.c_str()) )
		{
			commandImg->disabled = false;
			commandImg->pos.w = imgGet->getWidth();
			commandImg->pos.h = imgGet->getHeight();
			commandImg->pos.x = glyphFramePos.w - commandImg->pos.w;
			commandImg->pos.y = 0;

			commandGlyph->path = Input::inputs[player].getGlyphPathForBinding("Show NPC Commands");
			if ( auto imgGet = Image::get(commandGlyph->path.c_str()) )
			{
				commandGlyph->disabled = commandImg->disabled || followerDisplay.bOpenFollowerMenuDisabled;
				commandGlyph->pos.w = imgGet->getWidth();
				commandGlyph->pos.h = imgGet->getHeight();
				commandGlyph->pos.x = commandImg->pos.x - commandGlyph->pos.w;
				commandGlyph->pos.y = commandImg->pos.y + commandImg->pos.h / 2 - commandGlyph->pos.h / 2;
			}
			else
			{
				commandImg->disabled = true;
				commandGlyph->disabled = true;
			}
		}

		if ( FollowerMenu[player].optionPrevious == -1 )
		{
			repeatImg->disabled = true;
			repeatGlyph->disabled = true;
		}
		else
		{
			if ( auto imgGet = Image::get(repeatImg->path.c_str()) )
			{
				repeatImg->disabled = false;
				repeatImg->pos.w = imgGet->getWidth();
				repeatImg->pos.h = imgGet->getHeight();
				if ( commandImg->disabled )
				{
					repeatImg->pos.x = commandImg->pos.x - repeatImg->pos.w + *followerMenuRepeatGlyphX;
				}
				else
				{
					repeatImg->pos.x = commandGlyph->pos.x - repeatImg->pos.w + *followerMenuRepeatGlyphX;
				}
				repeatImg->pos.y = commandImg->pos.y + commandImg->pos.h / 2 - repeatImg->pos.h / 2 + *followerMenuRepeatGlyphY;
			}
			repeatGlyph->path = Input::inputs[player].getGlyphPathForBinding("Command NPC");
			if ( auto imgGet = Image::get(repeatGlyph->path.c_str()) )
			{
				repeatGlyph->disabled = repeatImg->disabled || followerDisplay.bCommandNPCDisabled;
				repeatGlyph->pos.w = imgGet->getWidth();
				repeatGlyph->pos.h = imgGet->getHeight();
				repeatGlyph->pos.x = repeatImg->pos.x - repeatGlyph->pos.w;
				repeatGlyph->pos.y = repeatImg->pos.y + repeatImg->pos.h / 2 - repeatGlyph->pos.h / 2;
			}
			else
			{
				repeatImg->disabled = true;
				repeatGlyph->disabled = true;
			}
		}
	}
}

void updateAllyFollowerFrame(const int player)
{
	if ( !players[player]->hud.allyFollowerFrame )
	{
		return;
	}

	auto& hud_t = players[player]->hud;
	Frame* baseFrame = hud_t.allyFollowerFrame;
	Frame* titleFrame = hud_t.allyFollowerTitleFrame;
	Frame* glyphFrame = hud_t.allyFollowerGlyphFrame;

	static ConsoleVariable<bool> cvar_followerbars("/followerbars", true);

	if ( !players[player]->isLocalPlayer() || !(*cvar_followerbars) )
	{
		baseFrame->setDisabled(true);
		titleFrame->setDisabled(true);
		glyphFrame->setDisabled(true);
		return;
	}

	if ( !players[player]->shootmode && !FollowerMenu[player].followerMenuIsOpen() 
		&& !CalloutMenu[player].calloutMenuIsOpen()
		&& players[player]->gui_mode != GUI_MODE_NONE )
	{
		baseFrame->setOpacity(0.0);
		baseFrame->setInheritParentFrameOpacity(false);
	}
	else
	{
		baseFrame->setInheritParentFrameOpacity(true);
		baseFrame->setOpacity(baseFrame->getParent()->getOpacity());
	}

	auto& infiniteScrolling = Player::HUD_t::FollowerDisplay_t::infiniteScrolling;

	baseFrame->setDisabled(false);
	SDL_Rect baseFramePos = baseFrame->getSize();
	baseFramePos.x = hud_t.hudFrame->getSize().w - baseFramePos.w;
	const int baseY = baseFramePos.y = players[player]->bUseCompactGUIWidth() ? AllyStatusBarSettings_t::FollowerBars_t::entrySettings.baseYSplitscreen : AllyStatusBarSettings_t::FollowerBars_t::entrySettings.baseY;
	baseFramePos.y = baseY + (infiniteScrolling ? AllyStatusBarSettings_t::FollowerBars_t::entrySettings.entryHeight : 0);
	baseFrame->setSize(baseFramePos);

	titleFrame->setDisabled(true);
	glyphFrame->setDisabled(true);
	if ( infiniteScrolling )
	{
		titleFrame->setSize(SDL_Rect{ baseFramePos.x, 0, baseFramePos.w, baseY + 2 * AllyStatusBarSettings_t::FollowerBars_t::entrySettings.entryHeight });
		titleFrame->setDisabled(false);
	}

	/*if ( enableDebugKeys && keystatus[SDLK_H] )
	{
		keystatus[SDLK_H] = 0;
		hud_t.followerBars.push_back(std::make_pair(0, Player::HUD_t::FollowerBar_t()));
	}

	if ( enableDebugKeys && keystatus[SDLK_J] )
	{
		keystatus[SDLK_J] = 0;
		if ( hud_t.followerBars.size() > 0 )
		{
			auto it = hud_t.followerBars.begin() + local_rng.rand() % hud_t.followerBars.size();
			it->second.expired = true;
		}
	}*/

	std::vector<Uint32> sortedUids;
	for ( node_t* node = stats[player]->FOLLOWERS.first; node != nullptr; node = node->next )
	{
		Entity* follower = nullptr;
		if ( (Uint32*)node->element )
		{
			follower = uidToEntity(*((Uint32*)node->element));
			sortedUids.push_back(*((Uint32*)node->element));
		}
		if ( follower )
		{
			Uint32 uid = follower->getUID();
			auto it = std::find_if(hud_t.followerBars.begin(), hud_t.followerBars.end(),
				[&uid](const std::pair<Uint32, Player::HUD_t::FollowerBar_t>& bar)
			{
				return bar.first == uid && !bar.second.expired;
			});
			if ( it == hud_t.followerBars.end() )
			{
				hud_t.followerBars.push_back(std::make_pair(uid, Player::HUD_t::FollowerBar_t()));
				auto& bar = hud_t.followerBars.at(hud_t.followerBars.size() - 1);
				bar.second.animFadeScroll = 1.0;
				bar.second.animFadeScrollDummy = 1.0;
			}
		}
	}

	int activeBars = 0;
	int realActiveBars = 0;
	bool erasedEntry = false;
	for ( auto it = hud_t.followerBars.begin(); it != hud_t.followerBars.end(); )
	{
		if ( it->second.dummy )
		{
			it = hud_t.followerBars.erase(it);
		}
		else if ( it->second.expired && it->second.animy >= 0.999 )
		{
			it = hud_t.followerBars.erase(it);
			erasedEntry = true;
		}
		else
		{
			++activeBars;
			++realActiveBars;
			++it;
		}
	}

	auto& followerDisplay = hud_t.followerDisplay;
	if ( !FollowerMenu[player].recentEntity )
	{
		// try find a new follower within the visible list
		const int kNumEntriesToShow = Player::HUD_t::FollowerDisplay_t::getNumEntriesToShow(player);
		if ( infiniteScrolling )
		{
			int index = 0;
			for ( auto& pair : hud_t.followerBars )
			{
				if ( index >= followerDisplay.scrollSetpoint && index < kNumEntriesToShow )
				{
					if ( Entity* follower = uidToEntity(pair.first) )
					{
						// check is valid follower in list
						if ( std::find(sortedUids.begin(), sortedUids.end(), pair.first) != sortedUids.end() )
						{
							FollowerMenu[player].recentEntity = follower;
							break;
						}
					}
				}
				++index;
			}
		}
		else if ( hud_t.followerBars.size() > kNumEntriesToShow )
		{
			int index = 0;
			for ( auto& pair : hud_t.followerBars )
			{
				if ( index >= followerDisplay.scrollSetpoint
					&& index < (followerDisplay.scrollSetpoint + kNumEntriesToShow) )
				{
					if ( Entity* follower = uidToEntity(pair.first) )
					{
						// check is valid follower in list
						if ( std::find(sortedUids.begin(), sortedUids.end(), pair.first) != sortedUids.end() )
						{
							FollowerMenu[player].recentEntity = follower;
							break;
						}
					}
				}
				++index;
			}
		}

		if ( !FollowerMenu[player].recentEntity ) // find the first one if nothing found before
		{
			for ( auto& pair : hud_t.followerBars )
			{
				if ( Entity* follower = uidToEntity(pair.first) )
				{
					// check is valid follower in list
					if ( std::find(sortedUids.begin(), sortedUids.end(), pair.first) != sortedUids.end() )
					{
						FollowerMenu[player].recentEntity = follower;
						break;
					}
				}
			}
		}
	}

	bool selectedFollower = false;
	Uint32 recentFollowerUID = FollowerMenu[player].recentEntity ? FollowerMenu[player].recentEntity->getUID() : 0;
	{
		int index = 0;
		for ( auto& pair : hud_t.followerBars )
		{
			pair.second.selected = false;
			if ( FollowerMenu[player].recentEntity )
			{
				if ( !selectedFollower && recentFollowerUID != 0 && pair.first == recentFollowerUID )
				{
					pair.second.selected = true;
					selectedFollower = true;
					if ( infiniteScrolling && erasedEntry )
					{
						// one-off check on deletion, need to snap the scroll to desired location.
						// otherwise, causes unneccessary scrolling for nothing as index is outdated.
						if ( followerDisplay.scrollSetpoint > (index + 1) )
						{
							followerDisplay.scrollSetpoint = index + 1;
							followerDisplay.scrollAnimateX = followerDisplay.scrollSetpoint;
						}
					}
				}
			}
			++index;
		}
	}

	if ( selectedFollower && (players[player]->shootmode || FollowerMenu[player].followerMenuIsOpen()) &&
		list_Size(&stats[player]->FOLLOWERS) > 0 && !players[player]->bUseCompactGUIWidth() )
	{
		glyphFrame->setDisabled(false);
	}

	if ( !FollowerMenu[player].recentEntity )
	{
		followerDisplay.lastUidSelected = 0;
		followerDisplay.animSelected = 0.0;
	}
	else
	{
		if ( followerDisplay.lastUidSelected != recentFollowerUID )
		{
			followerDisplay.animSelected = 1.0;
			followerDisplay.scrollTicks = ticks;
		}
		followerDisplay.lastUidSelected = recentFollowerUID;
	}

	{
		size_t position = 0;
		for ( Uint32 uid : sortedUids ) // sort the displayed list to match the stats->FOLLOWERS list order
		{
			if ( position < hud_t.followerBars.size() )
			{
				auto it2 = std::find(sortedUids.begin(), sortedUids.end(), hud_t.followerBars.at(position).first);
				if ( it2 == sortedUids.end() )
				{
					// this bar isn't in the follower list and expired, skip position to sort
					++position;
				}
			}

			auto it = std::find_if(hud_t.followerBars.begin() + position, hud_t.followerBars.end(),
				[uid](std::pair<Uint32, Player::HUD_t::FollowerBar_t>& pair) {
				return pair.first == uid;
			});

			while ( it != hud_t.followerBars.end() )
			{
				std::iter_swap(hud_t.followerBars.begin() + position, it);
				++position;

				if ( position < hud_t.followerBars.size() )
				{
					auto it2 = std::find(sortedUids.begin(), sortedUids.end(), hud_t.followerBars.at(position).first);
					if ( it2 == sortedUids.end() )
					{
						// this bar isn't in the follower list and expired, skip position to sort
						++position;
					}
				}

				it = std::find_if(hud_t.followerBars.begin() + position, hud_t.followerBars.end(),
					[uid](std::pair<Uint32, Player::HUD_t::FollowerBar_t>& pair) {
					return pair.first == uid;
				});

			}
		}

		if ( infiniteScrolling )
		{
			int barIndex = -1;
			size_t vecIndex = 0;
			while ( vecIndex < hud_t.followerBars.size() )
			{
				++barIndex;
				if ( hud_t.followerBars[vecIndex].second.dummy )
				{
					break;
				}
				if ( barIndex < (followerDisplay.scrollSetpoint - 1) )
				{
					hud_t.followerBars.push_back(hud_t.followerBars[vecIndex]);
					hud_t.followerBars[hud_t.followerBars.size() - 1].second.dummy = true;
					//messagePlayer(0, MESSAGE_DEBUG, "%.2f", hud_t.followerBars[hud_t.followerBars.size() - 1].second.animFadeScrollDummy);
					//hud_t.followerBars[hud_t.followerBars.size() - 1].second.animFadeScroll = 0.0;
					++activeBars;
				}
				++vecIndex;
			}
		}
	}

	followerDisplay.bCompact = followerDisplay.getCompactMode(player);

	updateAllyBarFrame(player, baseFrame, activeBars, realActiveBars, false);

	{
		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
		real_t setpointDiffX = fpsScale * 1.0 / 10.0;
		followerDisplay.animSelected -= setpointDiffX;
		followerDisplay.animSelected = std::max(0.0, followerDisplay.animSelected);
	}

	const int kNumEntriesToShow = Player::HUD_t::FollowerDisplay_t::getNumEntriesToShow(player);

	// scroll
	{
		int scrollAmount = 0;
		if ( infiniteScrolling )
		{
			scrollAmount = hud_t.followerBars.size();
		}
		else if ( hud_t.followerBars.size() > kNumEntriesToShow )
		{
			scrollAmount = (hud_t.followerBars.size() - kNumEntriesToShow);
		}
		int oldSetpoint = followerDisplay.scrollSetpoint;
		if ( scrollAmount > 0 )
		{
			int index = 0;
			bool foundSelected = false;
			for ( auto& pair : hud_t.followerBars )
			{
				if ( pair.second.selected )
				{
					foundSelected = true;
					if ( infiniteScrolling )
					{
						followerDisplay.scrollSetpoint = index + 1;
						break;
					}

					if ( index < followerDisplay.scrollSetpoint )
					{
						followerDisplay.scrollSetpoint = index;
					}
					else if ( index >= (followerDisplay.scrollSetpoint + kNumEntriesToShow) )
					{
						while ( index >= (followerDisplay.scrollSetpoint + kNumEntriesToShow) )
						{
							followerDisplay.scrollSetpoint += 1;
						}
					}
					break;
				}
				++index;
			}

			if ( !foundSelected )
			{
				followerDisplay.scrollSetpoint = 0;
				followerDisplay.scrollAnimateX = followerDisplay.scrollSetpoint;
			}
		}
		else
		{
			followerDisplay.scrollSetpoint = 0;
		}

		followerDisplay.scrollSetpoint = std::min(followerDisplay.scrollSetpoint, scrollAmount);
		followerDisplay.currentScrollRow = followerDisplay.scrollSetpoint;

		if ( abs(followerDisplay.scrollSetpoint - followerDisplay.scrollAnimateX) > 0.00001 )
		{
			if ( infiniteScrolling )
			{
				if ( followerDisplay.scrollSetpoint < followerDisplay.scrollAnimateX )
				{
					realActiveBars += std::max(0, followerDisplay.scrollSetpoint - 1); // don't delete as many if setpoint > 1
					followerDisplay.scrollAnimateX = followerDisplay.scrollSetpoint - 1;

					int index = 0;
					std::vector<real_t> oldAnimFadeScrolls;
					for ( auto& pair : hud_t.followerBars )
					{
						if ( index >= oldSetpoint )
						{
							oldAnimFadeScrolls.push_back(pair.second.dummy ? pair.second.animFadeScrollDummy : pair.second.animFadeScroll);
						}
						++index;
					}
					index = 0;
					for ( auto& pair : hud_t.followerBars )
					{
						if ( oldAnimFadeScrolls.size() > 0 )
						{
							if ( pair.second.dummy )
							{
								pair.second.animFadeScrollDummy = oldAnimFadeScrolls[0];
							}
							else
							{
								pair.second.animFadeScroll = oldAnimFadeScrolls[0];
							}
							oldAnimFadeScrolls.erase(oldAnimFadeScrolls.begin());
						}
						++index;
					}

					for ( int i = 0; i < realActiveBars; ++i )
					{
						if ( i + (realActiveBars - 1) < baseFrame->getFrames().size() )
						{
							baseFrame->getFrames()[i]->setOpacity(baseFrame->getFrames()[i + (realActiveBars - 1)]->getOpacity());
						}
					}

					for ( auto f : baseFrame->getFrames() )
					{
						if ( strcmp(f->getName(), "entry") || f->isToBeDeleted() )
						{
							continue;
						}
						--realActiveBars;
						if ( realActiveBars <= 0 )
						{
							f->removeSelf();
						}
					}
				}
			}

			followerDisplay.isInteractable = false;
			const real_t fpsScale = getFPSScale(60.0);
			real_t setpointDiff = 0.0;
			const real_t scrollSpeed = 3.0;
			if ( followerDisplay.scrollSetpoint - followerDisplay.scrollAnimateX > 0.0 )
			{
				real_t mult = 8.0;
				if ( ticks - followerDisplay.scrollTicks < TICKS_PER_SECOND )
				{
					mult *= (ticks - followerDisplay.scrollTicks) / (real_t)(TICKS_PER_SECOND);
				}
				mult = fmin(mult, 1.0);

				setpointDiff = mult * fpsScale * std::max(.03, (followerDisplay.scrollSetpoint - followerDisplay.scrollAnimateX)) / scrollSpeed;
			}
			else
			{
				real_t mult = 8.0;
				if ( ticks - followerDisplay.scrollTicks < TICKS_PER_SECOND )
				{
					mult *= (ticks - followerDisplay.scrollTicks) / (real_t)(TICKS_PER_SECOND);
				}
				mult = fmin(mult, 1.0);

				setpointDiff = mult * fpsScale * std::min(-.03, (followerDisplay.scrollSetpoint - followerDisplay.scrollAnimateX)) / scrollSpeed;
			}
			followerDisplay.scrollAnimateX += setpointDiff;
			if ( setpointDiff >= 0.0 )
			{
				followerDisplay.scrollAnimateX = std::min((real_t)followerDisplay.scrollSetpoint, followerDisplay.scrollAnimateX);
			}
			else
			{
				followerDisplay.scrollAnimateX = std::max((real_t)followerDisplay.scrollSetpoint, followerDisplay.scrollAnimateX);
			}
		}
		else
		{
			followerDisplay.scrollAnimateX = followerDisplay.scrollSetpoint;
		}

		int scrollHeight = 0;
		real_t scrollRemaining = followerDisplay.scrollAnimateX;
		bool scrollingCompleted = false;
		for ( auto f : baseFrame->getFrames() )
		{
			if ( strcmp(f->getName(), "entry") || f->isToBeDeleted() )
			{
				continue;
			}

			if ( !scrollingCompleted )
			{
				if ( scrollRemaining < 0.0 )
				{
					SDL_Rect pos = baseFrame->getSize();
					int height = AllyStatusBarSettings_t::PlayerBars_t::entrySettings.entryHeight;
					if ( infiniteScrolling && followerDisplay.bCompact )
					{
						height = AllyStatusBarSettings_t::PlayerBars_t::entrySettings.entryCompactHeight;
					}
					pos.y += -scrollRemaining * height;
					baseFrame->setSize(pos);
				}
				else if ( scrollRemaining >= 1.0 )
				{
					scrollHeight += f->getSize().h;
				}
				else
				{
					scrollHeight += f->getSize().h * scrollRemaining;
				}
				scrollRemaining -= 1.0;
			}
			{
				// change frame size to allow text overflow
				SDL_Rect pos = f->getSize();
				pos.h += 4;
				f->setSize(pos);
			}
			if ( scrollRemaining <= 0.0 )
			{
				scrollingCompleted = true;
			}
		}
		SDL_Rect actualSize = baseFrame->getActualSize();
		actualSize.y = scrollHeight;
		baseFrame->setActualSize(actualSize);
	}
}

void updateAllyPlayerFrame(const int player)
{
	if ( !players[player]->hud.allyPlayerFrame )
	{
		return;
	}

	auto& hud_t = players[player]->hud;
	Frame* baseFrame = hud_t.allyPlayerFrame;

	static ConsoleVariable<bool> cvar_playerbars("/playerbars", true);
	static ConsoleVariable<int> cvar_playerbars_debug("/playerbars_debug", -1);

	if ( !players[player]->isLocalPlayer() || !(*cvar_playerbars) )
	{
		baseFrame->setDisabled(true);
		return;
	}

	if ( !players[player]->shootmode && !FollowerMenu[player].followerMenuIsOpen() 
		&& !CalloutMenu[player].calloutMenuIsOpen()
		&& players[player]->gui_mode != GUI_MODE_NONE )
	{
		baseFrame->setOpacity(0.0);
		baseFrame->setInheritParentFrameOpacity(false);
	}
	else
	{
		baseFrame->setInheritParentFrameOpacity(true);
		baseFrame->setOpacity(baseFrame->getParent()->getOpacity());
	}

	baseFrame->setDisabled(false);
	SDL_Rect baseFramePos = baseFrame->getSize();
	baseFramePos.x = 8;
	baseFramePos.y = players[player]->bUseCompactGUIWidth() ? AllyStatusBarSettings_t::PlayerBars_t::entrySettings.baseYSplitscreen : AllyStatusBarSettings_t::PlayerBars_t::entrySettings.baseY;
	baseFrame->setSize(baseFramePos);

	if ( *cvar_playerbars_debug >= 0 )
	{
		if ( hud_t.playerBars.size() < *cvar_playerbars_debug )
		{
			while ( hud_t.playerBars.size() < *cvar_playerbars_debug )
			{
				hud_t.playerBars.push_back(std::make_pair(0, Player::HUD_t::FollowerBar_t()));
			}
		}
		else if ( hud_t.playerBars.size() > *cvar_playerbars_debug )
		{
			hud_t.playerBars.clear();
		}
	}
	/*if ( enableDebugKeys && keystatus[SDLK_H] )
	{
		keystatus[SDLK_H] = 0;
		hud_t.playerBars.push_back(std::make_pair(0, Player::HUD_t::FollowerBar_t()));
	}

	if ( enableDebugKeys && keystatus[SDLK_J] )
	{
		keystatus[SDLK_J] = 0;
		if ( hud_t.playerBars.size() > 0 )
		{
			auto it = hud_t.playerBars.begin() + local_rng.rand() % hud_t.playerBars.size();
			it->second.expired = true;
		}
	}*/

	for ( int i = 0; i < MAXPLAYERS; ++i )
	{
		if ( i == player )
		{
			continue;
		}
		if ( !client_disconnected[i] && players[i]->entity && !splitscreen )
		{
			auto it = std::find_if(hud_t.playerBars.begin(), hud_t.playerBars.end(),
				[&i](const std::pair<Uint32, Player::HUD_t::FollowerBar_t>& bar)
			{
				return bar.first == i && !bar.second.expired;
			});
			if ( it == hud_t.playerBars.end() )
			{
				hud_t.playerBars.push_back(std::make_pair(i, Player::HUD_t::FollowerBar_t()));
				auto& bar = hud_t.playerBars.at(hud_t.playerBars.size() - 1);
				bar.second.animFadeScroll = 1.0;
				bar.second.animFadeScrollDummy = 1.0;
			}
		}
	}

	int activeBars = 0;
	for ( auto it = hud_t.playerBars.begin(); it != hud_t.playerBars.end(); )
	{
		int playernum = it->first;
		if ( playernum >= 0 && playernum < MAXPLAYERS
			&& client_disconnected[playernum] )
		{
			it = hud_t.playerBars.erase(it);
		}
		else if ( it->second.expired && it->second.animy >= 0.999 )
		{
			it = hud_t.playerBars.erase(it);
		}
		else
		{
			++activeBars;
			++it;
		}
	}

	updateAllyBarFrame(player, baseFrame, activeBars, activeBars, true);
}

void createEnemyBar(const int player, Frame*& frame)
{
	auto& hud_t = players[player]->hud;
	frame = hud_t.hudFrame->addFrame("enemy bar");
	frame->setHollow(true);
	frame->setInheritParentFrameOpacity(false);
	frame->setOpacity(0.0);
	const int barTotalHeight = hud_t.ENEMYBAR_FRAME_HEIGHT;
	const int barStartY = (hud_t.hudFrame->getSize().h - hud_t.ENEMYBAR_FRAME_START_Y - 100);
	const int barWidth = hud_t.ENEMYBAR_FRAME_WIDTH;

	SDL_Rect pos{ (hud_t.hudFrame->getSize().w / 2) - barWidth / 2 - 6, barStartY, barWidth, barTotalHeight };
	frame->setSize(pos);

	auto bg = frame->addImage(pos, 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_Back_Body_01.png", "base img");
	bg->pos.x = 6;
	bg->pos.h = 34;
	bg->pos.y = 4;
	bg->pos.w = 548;
	bg->color = makeColor(255, 255, 255, 255);

	auto bgEndCap = frame->addImage(pos, 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_Back_Cap_01.png", "base img endcap");
	bgEndCap->pos.x = bg->pos.x + bg->pos.w;
	bgEndCap->pos.h = bg->pos.h;
	bgEndCap->pos.y = bg->pos.y;
	bgEndCap->pos.w = 8;
	bgEndCap->color = bg->color;

	auto dmgFrame = frame->addFrame("bar dmg frame");
	dmgFrame->setSize(SDL_Rect{ bg->pos.x, bg->pos.y, bg->pos.w + bgEndCap->pos.w, 34 });
	dmgFrame->setInheritParentFrameOpacity(false);
	auto dmg = dmgFrame->addImage(pos, 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_DMG_Body_01.png", "dmg img");
	dmg->pos.x = 0;
	dmg->pos.h = bg->pos.h;
	dmg->pos.y = 0;
	dmg->pos.w = 548 / 2 + 100;
	dmg->color = makeColor(255, 255, 255, 255);

	auto dmgEndCap = dmgFrame->addImage(pos, 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_DMG_Cap_01.png", "dmg img endcap");
	dmgEndCap->pos.x = dmg->pos.w;
	dmgEndCap->pos.h = dmg->pos.h;
	dmgEndCap->pos.y = 0;
	dmgEndCap->pos.w = 10;
	dmgEndCap->color = dmg->color;

	/*auto bubbles = dmgFrame->addImage(pos, 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_Bubbles_00.png", "img bubbles");
	bubbles->pos.x = 0;
	bubbles->pos.h = 20;
	bubbles->pos.y = dmgFrame->getSize().h / 2 - bubbles->pos.h / 2;
	if ( auto img = Image::get(bubbles->path.c_str()) )
	{
		bubbles->pos.w = img->getWidth();
	}*/

	auto progressFrame = frame->addFrame("bar progress frame");
	progressFrame->setSize(SDL_Rect{ bg->pos.x, bg->pos.y + 2, bg->pos.w + bgEndCap->pos.w, 30 });
	progressFrame->setOpacity(100.0);
	auto fg = progressFrame->addImage(pos, 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_Fill_Body_00.png", "progress img");
	fg->pos.x = 0;
	fg->pos.h = bg->pos.h - 4;
	fg->pos.y = 0;
	fg->pos.w = 548;

	auto fgEndCap = progressFrame->addImage(pos, 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_Fill_Cap_00.png", "progress img endcap");
	fgEndCap->pos.x = fg->pos.x + fg->pos.w;
	fgEndCap->pos.h = fg->pos.h;
	fgEndCap->pos.y = 0;
	if ( auto img = Image::get(fgEndCap->path.c_str()) )
	{
		fgEndCap->pos.w = img->getWidth();
	}

	auto skullFrame = frame->addFrame("skull frame");
	skullFrame->setSize(SDL_Rect{ 0, 0, 24, 44 });
	auto skull = skullFrame->addImage(skullFrame->getSize(), 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_Face4_00.png", "skull 0 img");
	skull = skullFrame->addImage(skullFrame->getSize(), 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_Face3_00.png", "skull 25 img");
	skull = skullFrame->addImage(skullFrame->getSize(), 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_Face2_00.png", "skull 50 img");
	skull = skullFrame->addImage(skullFrame->getSize(), 0xFFFFFFFF, "*#images/ui/HUD/enemybar/HUD_EnemyHP_Face1_00.png", "skull 100 img");

	std::string font = "fonts/pixel_maz.ttf#32#2";
	Uint32 color = makeColor(235, 191, 140, 255);
	auto enemyName = frame->addField("enemy name txt", 128);
	enemyName->setSize(SDL_Rect{ 0, 0, frame->getSize().w, frame->getSize().h});
	enemyName->setFont(font.c_str());
	enemyName->setColor(color);
	enemyName->setHJustify(Field::justify_t::CENTER);
	enemyName->setVJustify(Field::justify_t::CENTER);
	enemyName->setText("");
	enemyName->setOntop(true);

	auto dmgText = hud_t.hudFrame->addField("enemy dmg txt", 128);
	dmgText->setSize(SDL_Rect{ 0, 0, 0, 0 });
	dmgText->setFont("fonts/pixel_maz.ttf#32#2");
	dmgText->setColor(color);
	dmgText->setHJustify(Field::justify_t::LEFT);
	dmgText->setVJustify(Field::justify_t::TOP);
	dmgText->setText("0");
	dmgText->setOntop(true);
}

std::vector<std::vector<std::string>> playerXPCapPaths = {
	{
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_00.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_00a.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_00b.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_00c.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_00d.png",
	},
	{
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_01.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_01a.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_01b.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_01c.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_01d.png",
	},
	{
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_02.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_02a.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_02b.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_02c.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_02d.png",
	},
	{
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_03.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_03a.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_03b.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_03c.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_03d.png",
	},
	{
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_04.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_04a.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_04b.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_04c.png",
		"*#images/ui/HUD/xpbar/HUD_Exp_SandCap_04d.png",
	}
};

void createXPBar(const int player)
{
	auto& hud_t = players[player]->hud;
	hud_t.xpFrame = hud_t.hudFrame->addFrame("xp bar");
	hud_t.xpFrame->setHollow(true);

	const int xpBarStartY = (hud_t.hudFrame->getSize().h) - hud_t.XP_FRAME_START_Y;
	const int xpBarWidth = hud_t.XP_FRAME_WIDTH;
	const int xpBarTotalHeight = hud_t.XP_FRAME_HEIGHT;
	SDL_Rect pos { (hud_t.hudFrame->getSize().w / 2) - xpBarWidth / 2, xpBarStartY, xpBarWidth, xpBarTotalHeight };
	hud_t.xpFrame->setSize(pos);

	//auto bg = hud_t.xpFrame->addImage(pos, 0xFFFFFFFF, "*#images/ui/HUD/xpbar/HUD_Bars_Base_00.png", "xp img base");
	auto bg = hud_t.xpFrame->addImage(pos, 0xFFFFFFFF, "*#images/ui/HUD/xpbar/HUD_Exp_Surround_01.png", "xp img base");
	bg->pos.x = 0;
	bg->pos.h = 26;
	bg->pos.y = 4;
	auto bgFlair = hud_t.xpFrame->addImage(SDL_Rect{4, 10, 0, 14}, makeColor(255, 255, 255, 192), "*#images/ui/HUD/xpbar/HUD_Exp_GlassShine_03.png", "xp img base flair");

	// xpProgress only adjusts width
	const int progressBarHeight = 22;
	/*auto xpProgress = hud_t.xpFrame->addImage(SDL_Rect{ 0, 6, 1, progressBarHeight }, 0xFFFFFFFF,
		"*#images/ui/HUD/xpbar/HUD_Bars_ExpMid_00.png", "xp img progress");*/
	auto progressClipFrame = hud_t.xpFrame->addFrame("xp progress clipping frame");
	progressClipFrame->setSize(SDL_Rect{ 0, 6, 1, progressBarHeight });

	std::string bodyPath = "*#images/ui/HUD/xpbar/HUD_Exp_SandBody2_";
	int xpPathNum = player;
	if ( !colorblind_lobby )
	{
		switch ( player )
		{
			case 0:
			default:
				bodyPath += "00.png";
				break;
			case 1:
				bodyPath += "01.png";
				break;
			case 2:
				bodyPath += "02.png";
				break;
			case 3:
				bodyPath += "03.png";
				break;
		}
	}
	else
	{
		switch ( player )
		{
			case 0:
			default:
				bodyPath += "02.png";
				xpPathNum = 2;
				break;
			case 1:
				bodyPath += "03.png";
				xpPathNum = 3;
				break;
			case 2:
				bodyPath += "01.png";
				xpPathNum = 1;
				break;
			case 3:
				bodyPath += "04.png";
				xpPathNum = 4;
				break;
		}
	}
	if ( player >= playerXPCapPaths.size() )
	{
		xpPathNum = 0;
	}

	auto progressClipImg = progressClipFrame->addImage(SDL_Rect{ 0, 0, 634, progressBarHeight }, 0xFFFFFFFF,
		bodyPath.c_str(), "xp img progress clipped");

	auto xpProgress = hud_t.xpFrame->addImage(SDL_Rect{ 0, 6, 1, progressBarHeight }, 0xFFFFFFFF,
		bodyPath.c_str(), "xp img progress");

	// xpProgressEndCap only adjusts x position based on xpProgress->pos.x + xpProgress->pos.w
	/*auto xpProgressEndCap = hud_t.xpFrame->addImage(SDL_Rect{0, 6, 8, progressBarHeight }, 0xFFFFFFFF,
		"*#images/ui/HUD/xpbar/HUD_Bars_ExpEnd_00.png", "xp img progress endcap");*/

	auto xpProgressEndCap = hud_t.xpFrame->addImage(SDL_Rect{ 0, 6, 38, progressBarHeight }, 0xFFFFFFFF,
		playerXPCapPaths[xpPathNum][0].c_str(), "xp img progress endcap");


	const int endCapWidth = 26;
	SDL_Rect endCapPos {0, 0, endCapWidth, xpBarTotalHeight};
	auto endCapLeft = hud_t.xpFrame->addImage(endCapPos, 0xFFFFFFFF, "*#images/ui/HUD/xpbar/HUD_Bars_ExpCap1_00.png", "xp img endcap left");
	endCapLeft->ontop = true;
	endCapPos.x = pos.w - endCapPos.w;
	auto endCapRight = hud_t.xpFrame->addImage(endCapPos, 0xFFFFFFFF, "*#images/ui/HUD/xpbar/HUD_Bars_ExpCap2_00.png", "xp img endcap right");
	endCapRight->ontop = true;

	const int textWidth = 72;
	auto font = "fonts/pixel_maz.ttf#32#2";
	auto textStatic = hud_t.xpFrame->addField("xp text static", 16);
	textStatic->setText(Language::get(6106));
	textStatic->setOntop(true);
	textStatic->setSize(SDL_Rect{ pos.w / 2 - 4, 0, textWidth, pos.h }); // x - 4 to center the slash
	textStatic->setFont(font);
	textStatic->setVJustify(Field::justify_t::CENTER);
	textStatic->setHJustify(Field::justify_t::LEFT);
	textStatic->setColor(makeColor( 255, 255, 255, 255));

	auto text = hud_t.xpFrame->addField("xp text current", 16);
	text->setText("0");
	text->setOntop(true);
	text->setSize(SDL_Rect{ pos.w / 2 - (4 * 2) - textWidth, 0, textWidth, pos.h }); // x - 4 to center the slash
	text->setFont(font);
	text->setVJustify(Field::justify_t::CENTER);
	text->setHJustify(Field::justify_t::RIGHT);
	text->setColor(makeColor( 255, 255, 255, 255));

	auto textLevel = hud_t.xpFrame->addField("xp text lvl", 64);
	textLevel->setText("");
	textLevel->setOntop(true);
	textLevel->setDisabled(true);
	textLevel->setSize(SDL_Rect{ 0, 0, 0, pos.h }); // x - 4 to center the slash
	textLevel->setFont(font);
	textLevel->setVJustify(Field::justify_t::CENTER);
	textLevel->setHJustify(Field::justify_t::LEFT);
	textLevel->setColor(makeColor(255, 255, 255, 255));

	auto textClass = hud_t.xpFrame->addField("xp text class", 64);
	textClass->setText("");
	textClass->setOntop(true);
	textClass->setDisabled(true);
	textClass->setSize(SDL_Rect{ 0, 0, 0, pos.h }); // x - 4 to center the slash
	textClass->setFont(font);
	textClass->setVJustify(Field::justify_t::CENTER);
	textClass->setHJustify(Field::justify_t::LEFT);
	textClass->setColor(makeColor(255, 255, 255, 255));
}

void createHotbar(const int player)
{
	auto& hotbar_t = players[player]->hotbar;
	if ( !hotbar_t.hotbarFrame )
	{
		return;
	}
	Uint32 color = makeColor( 255, 255, 255, hotbarSlotOpacity);
	SDL_Rect slotPos{ 0, 0, hotbar_t.getSlotSize(), hotbar_t.getSlotSize() };
	std::array<int, NUM_HOTBAR_SLOTS> slotCreationOrder = {
		0, 2, 3, 5, 6, 8, 9, 1, 4, 7
	};
	for ( auto& i : slotCreationOrder )
	{
		char slotname[32];
		snprintf(slotname, sizeof(slotname), "hotbar slot %d", i);
		auto slot = hotbar_t.hotbarFrame->addFrame(slotname);
		slot->setSize(slotPos);
		slot->addImage(slotPos, color, "*#images/ui/HUD/hotbar/HUD_Quickbar_Slot_Box_02.png", "slot img");
		hotbar_t.hotbarSlotFrames[i] = slot;

		char glyphname[32];
		snprintf(glyphname, sizeof(glyphname), "hotbar glyph %d", i);
		auto path = Input::getGlyphPathForInput("ButtonA", false, Input::getControllerType(player));
		auto glyph = hotbar_t.hotbarFrame->addImage(slotPos, 0xFFFFFFFF, path.c_str(), glyphname);
		glyph->disabled = true;
	}

	auto font = "fonts/pixel_maz.ttf#32#2";

	for ( int i = 0; i < NUM_HOTBAR_SLOTS; ++i )
	{
		auto slot = hotbar_t.getHotbarSlotFrame(i);
		assert(slot);

		auto itemSlot = slot->addFrame("hotbar slot item");
		SDL_Rect itemSlotTempSize = slot->getSize();
		itemSlotTempSize.w -= 4;
		itemSlotTempSize.h -= 4;
		itemSlot->setSize(itemSlotTempSize); // slightly shrink to align inner item elements within rect.
		createPlayerInventorySlotFrameElements(itemSlot);
		itemSlot->setSize(slot->getSize());

		char numStr[32];
		if ( i + 1 == 10 )
		{
			snprintf(numStr, sizeof(numStr), "%d", 0);
		}
		else
		{
			snprintf(numStr, sizeof(numStr), "%d", i + 1);
		}
		auto text = slot->addField("slot num text", 32);
		text->setText(numStr);
		text->setSize(SDL_Rect{ 0, -4, slotPos.w, slotPos.h });
		text->setFont(font);
		text->setVJustify(Field::justify_t::TOP);
		text->setHJustify(Field::justify_t::LEFT);
		text->setOntop(true);
	}

	auto highlightFrame = hotbar_t.hotbarFrame->addFrame("hotbar highlight");
	highlightFrame->setSize(slotPos);
	highlightFrame->addImage(slotPos, color, "*#images/ui/HUD/hotbar/HUD_Quickbar_Slot_HighlightBox_02.png", "highlight img");

	auto itemSlot = highlightFrame->addFrame("hotbar slot item");
	SDL_Rect itemSlotTempSize = slotPos;
	itemSlotTempSize.w -= 4;
	itemSlotTempSize.h -= 4;
	itemSlot->setSize(itemSlotTempSize);
	createPlayerInventorySlotFrameElements(itemSlot); // slightly shrink to align inner item elements within rect.
	itemSlot->setSize(highlightFrame->getSize());

	{
		auto oldSelectedFrame = hotbar_t.hotbarFrame->addFrame("hotbar old selected item");
		SDL_Rect oldSelectedFramePos = slotPos;
		oldSelectedFramePos.w -= 2;
		oldSelectedFramePos.h -= 2;
		oldSelectedFrame->setSize(oldSelectedFramePos);
		oldSelectedFrame->setDisabled(true);

		const int itemSpriteSize = players[oldSelectedFrame->getOwner()]->inventoryUI.getItemSpriteSize();
		SDL_Rect itemSpriteBorder{ 5, 5, itemSpriteSize, itemSpriteSize };

		color = makeColor( 0, 255, 255, 255);
		auto oldImg = oldSelectedFrame->addImage(itemSpriteBorder,
			makeColor( 255, 255, 255, 128), "", "hotbar old selected item");
		oldImg->disabled = true;
		oldSelectedFrame->addImage(SDL_Rect{ 0, 0, oldSelectedFrame->getSize().w, oldSelectedFrame->getSize().h },
			color, "*images/system/hotbar_slot.png", "hotbar old selected highlight");

		auto oldCursorFrame = hotbar_t.hotbarFrame->addFrame("hotbar old item cursor");
		oldCursorFrame->setSize(SDL_Rect{ 0, 0, oldSelectedFramePos.w + 16, oldSelectedFramePos.h + 16 });
		oldCursorFrame->setDisabled(true);
		color = makeColor( 255, 255, 255, oldSelectedCursorOpacity);
		oldCursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/SelectorGrey_TL.png", "hotbar old cursor topleft");
		oldCursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/SelectorGrey_TR.png", "hotbar old cursor topright");
		oldCursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/SelectorGrey_BL.png", "hotbar old cursor bottomleft");
		oldCursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/SelectorGrey_BR.png", "hotbar old cursor bottomright");

		auto cursorFrame = hotbar_t.hotbarFrame->addFrame("shootmode selected item cursor");
		cursorFrame->setSize(SDL_Rect{ 0, 0, oldSelectedFramePos.w + 16, oldSelectedFramePos.h + 16 });
		cursorFrame->setDisabled(true);
		color = makeColor( 255, 255, 255, selectedCursorOpacity);
		cursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_TL.png", "shootmode selected cursor topleft");
		cursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_TR.png", "shootmode selected cursor topright");
		cursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_BL.png", "shootmode selected cursor bottomleft");
		cursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_BR.png", "shootmode selected cursor bottomright");
	}

	auto cancelPromptTxt = hotbar_t.hotbarFrame->addField("hotbar cancel prompt", 32);
	cancelPromptTxt->setText(Language::get(3063));
	cancelPromptTxt->setSize(SDL_Rect{ 0, 0, 100, 24 });
	cancelPromptTxt->setDisabled(true);
	cancelPromptTxt->setFont(font);
	cancelPromptTxt->setVJustify(Field::justify_t::TOP);
	cancelPromptTxt->setHJustify(Field::justify_t::LEFT);
	auto cancelPromptGlyph = hotbar_t.hotbarFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "", "hotbar cancel glyph");
	cancelPromptGlyph->disabled = true;

	auto text = highlightFrame->addField("slot num text", 32);
	text->setText("");
	text->setSize(SDL_Rect{ 0, -4, slotPos.w, slotPos.h });
	text->setFont(font);
	text->setVJustify(Field::justify_t::TOP);
	text->setHJustify(Field::justify_t::LEFT);
	text->setOntop(true);
}

void createUINavigation(const int player)
{
	auto& hud_t = players[player]->hud;
	auto& uiNavFrame = hud_t.uiNavFrame;
	uiNavFrame = hud_t.hudFrame->addFrame("ui navigation");
	uiNavFrame->setHollow(true);
	uiNavFrame->setBorder(0);
	uiNavFrame->setOwner(player);
	uiNavFrame->setSize(SDL_Rect{ 0, 0, hud_t.hudFrame->getSize().w, hud_t.hudFrame->getSize().h });
	uiNavFrame->setDisabled(true);
	{
		const int glyphSize = 32;
		const char* buttonFont = "fonts/pixel_maz.ttf#32#2";
		auto magicButton = uiNavFrame->addButton("magic button");
		magicButton->setText(Language::get(4115));
		magicButton->setFont(buttonFont);
		magicButton->setBackground("*#images/ui/HUD/HUD_Button_Base_Small_00.png");
		magicButton->setBackgroundActivated("*#images/ui/HUD/HUD_Button_Base_SmallPress_00.png");
		magicButton->setBackgroundHighlighted("*#images/ui/HUD/HUD_Button_Base_SmallHigh_00.png");
		magicButton->setSize(SDL_Rect{ 0, 0, 98, 38 });
		magicButton->setHideGlyphs(true);
		magicButton->setHideKeyboardGlyphs(true);
		magicButton->setHideSelectors(true);
		magicButton->setMenuConfirmControlType(0);
		magicButton->setColor(makeColor(255, 255, 255, 255));
		magicButton->setHighlightColor(makeColor(255, 255, 255, 255));
		magicButton->setCallback([](Button& button) {
			if ( inputs.getVirtualMouse(button.getOwner())->draw_cursor )
			{
				// prevent 1 frame flickering of hud.cursor after click
				players[button.getOwner()]->GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_INVENTORY);
			}
			if ( players[button.getOwner()]->inventory_mode == INVENTORY_MODE_ITEM )
			{
				players[button.getOwner()]->GUI.activateModule(Player::GUI_t::MODULE_INVENTORY);
				players[button.getOwner()]->gui_mode = GUI_MODE_INVENTORY;
				players[button.getOwner()]->inventoryUI.cycleInventoryTab();
				players[button.getOwner()]->inventoryUI.spellPanel.openSpellPanel();
			}
			else if ( players[button.getOwner()]->inventory_mode == INVENTORY_MODE_SPELL )
			{
				players[button.getOwner()]->GUI.activateModule(Player::GUI_t::MODULE_SPELLS);
				players[button.getOwner()]->gui_mode = GUI_MODE_INVENTORY;
				players[button.getOwner()]->inventoryUI.cycleInventoryTab();
				players[button.getOwner()]->inventoryUI.spellPanel.closeSpellPanel();
			}
		});
		auto magicButtonGlyph = uiNavFrame->addImage(SDL_Rect{ 0, 0, glyphSize, glyphSize },
			0xFFFFFFFF, "images/system/white.png", "magic button glyph")->disabled = true;

		auto statusButton = uiNavFrame->addButton("status button");
		statusButton->setText(Language::get(4118));
		statusButton->setFont(buttonFont);
		statusButton->setBackground("*#images/ui/HUD/HUD_Button_Base_Small_00.png");
		statusButton->setBackgroundActivated("*#images/ui/HUD/HUD_Button_Base_SmallPress_00.png");
		statusButton->setBackgroundHighlighted("*#images/ui/HUD/HUD_Button_Base_SmallHigh_00.png");
		statusButton->setSize(SDL_Rect{ 0, 0, 98, 38 });
		statusButton->setHideGlyphs(true);
		statusButton->setHideKeyboardGlyphs(true);
		statusButton->setHideSelectors(true);
		statusButton->setMenuConfirmControlType(0);
		statusButton->setColor(makeColor(255, 255, 255, 255));
		statusButton->setHighlightColor(makeColor(255, 255, 255, 255));
		statusButton->setCallback([](Button& button) {
			Player::soundActivate();
			if ( players[button.getOwner()]->hud.compactLayoutMode != Player::HUD_t::COMPACT_LAYOUT_CHARSHEET )
			{
				players[button.getOwner()]->inventoryUI.slideOutPercent = 1.0;
			}
			players[button.getOwner()]->hud.compactLayoutMode = Player::HUD_t::COMPACT_LAYOUT_CHARSHEET;
			if ( inputs.getVirtualMouse(button.getOwner())->draw_cursor )
			{
				// prevent 1 frame flickering of hud.cursor after click
				players[button.getOwner()]->GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_INVENTORY);
			}
			players[button.getOwner()]->GUI.activateModule(Player::GUI_t::MODULE_CHARACTERSHEET);
			if ( players[button.getOwner()]->characterSheet.selectedElement == Player::CharacterSheet_t::SHEET_UNSELECTED )
			{
				players[button.getOwner()]->characterSheet.selectElement(Player::CharacterSheet_t::SHEET_OPEN_MAP, false, false);
			}
			players[button.getOwner()]->GUI.warpControllerToModule(false);
		});
		auto statusButtonGlyph = uiNavFrame->addImage(SDL_Rect{ 0, 0, glyphSize, glyphSize },
			0xFFFFFFFF, "images/system/white.png", "status button glyph")->disabled = true;

		auto itemsButton = uiNavFrame->addButton("items button");
		itemsButton->setText(Language::get(4116));
		itemsButton->setFont(buttonFont);
		itemsButton->setBackground("*#images/ui/HUD/HUD_Button_Base_Small_00.png");
		itemsButton->setBackgroundActivated("*#images/ui/HUD/HUD_Button_Base_SmallPress_00.png");
		itemsButton->setBackgroundHighlighted("*#images/ui/HUD/HUD_Button_Base_SmallHigh_00.png");
		itemsButton->setSize(SDL_Rect{ 0, 0, 98, 38 });
		itemsButton->setHideGlyphs(true);
		itemsButton->setHideKeyboardGlyphs(true);
		itemsButton->setHideSelectors(true);
		itemsButton->setMenuConfirmControlType(0);
		itemsButton->setColor(makeColor(255, 255, 255, 255));
		itemsButton->setHighlightColor(makeColor(255, 255, 255, 255));
		itemsButton->setCallback([](Button& button) {
			if ( players[button.getOwner()]->hud.compactLayoutMode != Player::HUD_t::COMPACT_LAYOUT_INVENTORY )
			{
				Player::soundActivate();
			}
			players[button.getOwner()]->hud.compactLayoutMode = Player::HUD_t::COMPACT_LAYOUT_INVENTORY;
			if ( inputs.getVirtualMouse(button.getOwner())->draw_cursor )
			{
				// prevent 1 frame flickering of hud.cursor after click
				players[button.getOwner()]->GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_INVENTORY);
			}
			if ( players[button.getOwner()]->inventory_mode == INVENTORY_MODE_SPELL
				&& players[button.getOwner()]->GUI.activeModule == Player::GUI_t::MODULE_SPELLS )
			{
				players[button.getOwner()]->inventoryUI.cycleInventoryTab();
			}
			else
			{
				players[button.getOwner()]->openStatusScreen(GUI_MODE_INVENTORY, INVENTORY_MODE_ITEM, Player::GUI_t::MODULE_INVENTORY);
			}
		});

		auto itemsButtonGlyph = uiNavFrame->addImage(SDL_Rect{ 0, 0, glyphSize, glyphSize },
			0xFFFFFFFF, "images/system/white.png", "items button glyph")->disabled = true;

		auto skillsButton = uiNavFrame->addButton("skills button");
		skillsButton->setText(Language::get(4117));
		skillsButton->setFont(buttonFont);
		skillsButton->setBackground("*#images/ui/HUD/HUD_Button_Base_Small_00.png");
		skillsButton->setBackgroundActivated("*#images/ui/HUD/HUD_Button_Base_SmallPress_00.png");
		skillsButton->setBackgroundHighlighted("*#images/ui/HUD/HUD_Button_Base_SmallHigh_00.png");
		skillsButton->setSize(SDL_Rect{ 0, 0, 98, 38 });
		skillsButton->setHideGlyphs(true);
		skillsButton->setHideKeyboardGlyphs(true);
		skillsButton->setHideSelectors(true);
		skillsButton->setMenuConfirmControlType(0);
		skillsButton->setColor(makeColor(255, 255, 255, 255));
		skillsButton->setHighlightColor(makeColor(255, 255, 255, 255));
		skillsButton->setCallback([](Button& button) {
			players[button.getOwner()]->skillSheet.openSkillSheet();
		});

		auto skillsButtonGlyph = uiNavFrame->addImage(SDL_Rect{ 0, 0, glyphSize, glyphSize },
			0xFFFFFFFF, "images/system/white.png", "skills button glyph")->disabled = true;
	}
	{
		const int glyphSize = 32;
		const char* navFont = "fonts/pixel_maz.ttf#32#2";
		auto leftBumperNavigationTxt = uiNavFrame->addField("left bumper txt", 64);
		leftBumperNavigationTxt->setFont(navFont);
		leftBumperNavigationTxt->setHJustify(Field::justify_t::RIGHT);
		leftBumperNavigationTxt->setVJustify(Field::justify_t::CENTER);
		leftBumperNavigationTxt->setDisabled(true);

		auto leftBumperNavigationImg = uiNavFrame->addImage(SDL_Rect{ 0, 0, glyphSize, glyphSize },
			0xFFFFFFFF, "images/system/white.png", "left bumper img");
		leftBumperNavigationImg->disabled = true;

		auto rightBumperNavigationTxt = uiNavFrame->addField("right bumper txt", 64);
		rightBumperNavigationTxt->setFont(navFont);
		rightBumperNavigationTxt->setVJustify(Field::justify_t::CENTER);
		rightBumperNavigationTxt->setHJustify(Field::justify_t::LEFT);

		auto rightBumperNavigationImg = uiNavFrame->addImage(SDL_Rect{ 0, 0, glyphSize, glyphSize },
			0xFFFFFFFF, "images/system/white.png", "right bumper img");
		rightBumperNavigationImg->disabled = true;

		auto leftTriggerNavigationTxt = uiNavFrame->addField("left trigger txt", 64);
		leftTriggerNavigationTxt->setFont(navFont);
		leftTriggerNavigationTxt->setHJustify(Field::justify_t::RIGHT);
		leftTriggerNavigationTxt->setVJustify(Field::justify_t::CENTER);
		leftTriggerNavigationTxt->setDisabled(true);

		auto leftTriggerNavigationImg = uiNavFrame->addImage(SDL_Rect{ 0, 0, glyphSize, glyphSize },
			0xFFFFFFFF, "images/system/white.png", "left trigger img");
		leftTriggerNavigationImg->disabled = true;

		auto rightTriggerNavigationTxt = uiNavFrame->addField("right trigger txt", 64);
		rightTriggerNavigationTxt->setFont(navFont);
		rightTriggerNavigationTxt->setVJustify(Field::justify_t::CENTER);
		rightTriggerNavigationTxt->setHJustify(Field::justify_t::LEFT);

		auto rightTriggerNavigationImg = uiNavFrame->addImage(SDL_Rect{ 0, 0, glyphSize, glyphSize },
			0xFFFFFFFF, "images/system/white.png", "right trigger img");
		rightTriggerNavigationImg->disabled = true;

		auto additionalNavigationTxt = uiNavFrame->addField("additional txt", 64);
		additionalNavigationTxt->setFont(navFont);
		additionalNavigationTxt->setVJustify(Field::justify_t::CENTER);
		additionalNavigationTxt->setHJustify(Field::justify_t::LEFT);

		auto additionalNavigationImg = uiNavFrame->addImage(SDL_Rect{ 0, 0, glyphSize, glyphSize },
			0xFFFFFFFF, "images/system/white.png", "additional img");
		additionalNavigationImg->disabled = true;
	}
}

void Player::HUD_t::updateUINavigation()
{
	if ( !hudFrame )
	{
		return;
	}

	if ( !uiNavFrame )
	{
		createUINavigation(player.playernum);
		if ( !uiNavFrame )
		{
			return;
		}
	}

	bool leftTriggerPressed = Input::inputs[player.playernum].consumeBinaryToggle("UINavLeftTrigger")
		&& player.bControlEnabled && !gamePaused && !player.usingCommand();
	bool rightTriggerPressed = Input::inputs[player.playernum].consumeBinaryToggle("UINavRightTrigger")
		&& player.bControlEnabled && !gamePaused && !player.usingCommand();

	bShowUINavigation = false;
	if ( player.gui_mode != GUI_MODE_NONE 
		&& player.gui_mode != GUI_MODE_FOLLOWERMENU
		&& player.gui_mode != GUI_MODE_CALLOUT
		&& player.gui_mode != GUI_MODE_SIGN
		&& player.isLocalPlayer() && !player.shootmode )
	{
		/*if ( player.bUseCompactGUIHeight() * Frame::virtualScreenX || (keystatus[SDLK_Y] && enableDebugKeys) )
		{
			bShowUINavigation = true;
		}*/
		bShowUINavigation = true;
	}

	if ( !bShowUINavigation )
	{
		uiNavFrame->setDisabled(true);
		return;
	}
	uiNavFrame->setDisabled(false);
	uiNavFrame->setSize(SDL_Rect{ 0, 0, hudFrame->getSize().w, hudFrame->getSize().h });

	if ( player.bUseCompactGUIWidth() &&
		(player.hud.levelupFrame && !player.hud.levelupFrame->isDisabled()) )
	{
		uiNavFrame->setInvisible(true);
	}
	else
	{
		uiNavFrame->setInvisible(false);
	}

	auto leftBumperModule = player.GUI.handleModuleNavigation(true, true);
	auto leftBumperTxt = uiNavFrame->findField("left bumper txt");
	leftBumperTxt->setDisabled(true);
	auto leftBumperGlyph = uiNavFrame->findImage("left bumper img");
	leftBumperGlyph->disabled = true;
	auto rightBumperModule = player.GUI.handleModuleNavigation(true, false);
	auto rightBumperTxt = uiNavFrame->findField("right bumper txt");
	rightBumperTxt->setDisabled(true);
	auto rightBumperGlyph = uiNavFrame->findImage("right bumper img");
	rightBumperGlyph->disabled = true;

	auto leftTriggerTxt = uiNavFrame->findField("left trigger txt");
	leftTriggerTxt->setDisabled(true);
	auto leftTriggerGlyph = uiNavFrame->findImage("left trigger img");
	leftTriggerGlyph->disabled = true;
	auto rightTriggerTxt = uiNavFrame->findField("right trigger txt");
	rightTriggerTxt->setDisabled(true);
	auto rightTriggerGlyph = uiNavFrame->findImage("right trigger img");
	rightTriggerGlyph->disabled = true;

	auto additionalTxt = uiNavFrame->findField("additional txt");
	additionalTxt->setDisabled(true);
	auto additionalGlyph = uiNavFrame->findImage("additional img");
	additionalGlyph->disabled = true;
	if ( inputs.hasController(player.playernum) && !inputs.getVirtualMouse(player.playernum)->draw_cursor
		&& (!player.bUseCompactGUIHeight() && !player.bUseCompactGUIWidth()) )
	{
		if ( leftBumperModule != Player::GUI_t::MODULE_NONE )
		{
			switch ( leftBumperModule )
			{
				case Player::GUI_t::MODULE_INVENTORY:
				case Player::GUI_t::MODULE_SPELLS:
				case Player::GUI_t::MODULE_HOTBAR:
				case Player::GUI_t::MODULE_CHARACTERSHEET:
				case Player::GUI_t::MODULE_CHEST:
				case Player::GUI_t::MODULE_SHOP:
				case Player::GUI_t::MODULE_ALCHEMY:
					leftBumperTxt->setDisabled(false);
					leftBumperTxt->setText("/");
					break;
				default:
					break;
			}
		}
		if ( rightBumperModule != Player::GUI_t::MODULE_NONE )
		{
			switch ( rightBumperModule )
			{
				case Player::GUI_t::MODULE_INVENTORY:
				case Player::GUI_t::MODULE_SPELLS:
				case Player::GUI_t::MODULE_HOTBAR:
				case Player::GUI_t::MODULE_CHARACTERSHEET:
				case Player::GUI_t::MODULE_CHEST:
				case Player::GUI_t::MODULE_SHOP:
				case Player::GUI_t::MODULE_ALCHEMY:
					rightBumperTxt->setDisabled(false);
					rightBumperTxt->setText(Language::get(4092));
					break;
				default:
					break;
			}
		}
		if ( player.GUI.activeModule == Player::GUI_t::MODULE_INVENTORY || player.GUI.activeModule == Player::GUI_t::MODULE_HOTBAR )
		{

		}
		else if ( player.GUI.activeModule == Player::GUI_t::MODULE_CHARACTERSHEET )
		{
			auto selectedElement = player.characterSheet.selectedElement;
			if ( selectedElement >= Player::CharacterSheet_t::SHEET_STR 
				&& selectedElement <= Player::CharacterSheet_t::SHEET_WGT )
			{
				additionalTxt->setDisabled(false);
				additionalTxt->setText(Language::get(4111));
			}
			else if ( selectedElement == Player::CharacterSheet_t::SHEET_CHAR_RACE_SEX
				|| selectedElement == Player::CharacterSheet_t::SHEET_CHAR_CLASS )
			{
				additionalTxt->setDisabled(false);
				additionalTxt->setText(Language::get(4111));
			}
			else if ( selectedElement == Player::CharacterSheet_t::SHEET_DUNGEON_FLOOR )
			{
				additionalTxt->setDisabled(false);
				additionalTxt->setText(Language::get(4112));
			}
			else if ( selectedElement == Player::CharacterSheet_t::SHEET_SKILL_LIST
				|| selectedElement == Player::CharacterSheet_t::SHEET_OPEN_LOG 
				|| selectedElement == Player::CharacterSheet_t::SHEET_OPEN_MAP )
			{
				additionalTxt->setDisabled(false);
				// options to use specific text 'open log' etc
				//if ( selectedElement == Player::CharacterSheet_t::SHEET_SKILL_LIST )
				//{
				//	additionalTxt->setText(Language::get(4095));
				//}
				//else if ( selectedElement == Player::CharacterSheet_t::SHEET_OPEN_LOG )
				//{
				//	additionalTxt->setText(Language::get(4106));
				//}
				//else if ( selectedElement == Player::CharacterSheet_t::SHEET_OPEN_MAP )
				//{
				//	additionalTxt->setText(Language::get(4105));
				//}
				additionalTxt->setText(Language::get(4107)); // activate
			}
			else if ( selectedElement == Player::CharacterSheet_t::SHEET_GOLD )
			{
				additionalTxt->setDisabled(false);
				if ( player.GUI.isDropdownActive() )
				{
					additionalTxt->setText(Language::get(4053));
				}
				else
				{
					additionalTxt->setText(Language::get(4108));
				}
			}
			else if ( selectedElement == Player::CharacterSheet_t::SHEET_TIMER )
			{
				additionalTxt->setDisabled(false);
				if ( player.characterSheet.showGameTimerAlways )
				{
					additionalTxt->setText(Language::get(4110));
				}
				else
				{
					additionalTxt->setText(Language::get(4109));
				}
			}
			if ( !additionalTxt->isDisabled() )
			{
				if ( selectedElement == Player::CharacterSheet_t::SHEET_GOLD
					&& player.GUI.isDropdownActive() )
				{
					additionalGlyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuCancel");
				}
				else
				{
					additionalGlyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuConfirm");
				}
			}
		}
	}

	int lowestLeftY = 8;
	int lowestRightY = 8;

	int leftAnchorX = 0;
	int rightAnchorX = 0;
	PanelJustify_t justify = player.inventoryUI.inventoryPanelJustify;
	if ( player.inventoryUI.frame )
	{
		auto inventoryBgFrame = player.inventoryUI.frame->findFrame("inventory base");

		Frame::image_t* invBaseImg = inventoryBgFrame->findImage("inventory base img");

		if ( justify == PANEL_JUSTIFY_LEFT )
		{
			leftAnchorX = inventoryBgFrame->getSize().x + 8;
			leftAnchorX += invBaseImg->pos.w;

			rightAnchorX = player.inventoryUI.frame->getSize().w - leftAnchorX;
		}
		else
		{
			rightAnchorX = inventoryBgFrame->getSize().x - 8;
			rightAnchorX += invBaseImg->pos.x;

			leftAnchorX = player.inventoryUI.frame->getSize().w - rightAnchorX;
		}
	}

	if ( inputs.hasController(player.playernum) && !inputs.getVirtualMouse(player.playernum)->draw_cursor
		&& (!player.bUseCompactGUIHeight() && !player.bUseCompactGUIWidth()) )
	{
		if ( (player.GUI.activeModule == Player::GUI_t::MODULE_INVENTORY
			|| player.GUI.activeModule == Player::GUI_t::MODULE_SPELLS
			|| player.GUI.activeModule == Player::GUI_t::MODULE_HOTBAR
			|| player.GUI.activeModule == Player::GUI_t::MODULE_CHARACTERSHEET
			|| player.GUI.activeModule == Player::GUI_t::MODULE_SHOP
			|| player.GUI.activeModule == Player::GUI_t::MODULE_CHEST) )
		{
			if ( !GenericGUI[player.playernum].tinkerGUI.bOpen && !GenericGUI[player.playernum].alchemyGUI.bOpen
				&& !GenericGUI[player.playernum].featherGUI.bOpen
				&& !GenericGUI[player.playernum].itemfxGUI.bOpen )
			{
				justify = PANEL_JUSTIFY_LEFT;
				leftTriggerGlyph->disabled = false;
				leftTriggerGlyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("UINavLeftTrigger");
				SDL_Rect textPos;
				textPos.x = (justify == PANEL_JUSTIFY_LEFT) ? leftAnchorX : rightAnchorX;
				textPos.y = 8;
				textPos.w = leftTriggerTxt->getTextObject()->getWidth();
				textPos.h = Font::get(leftTriggerTxt->getFont())->height() + 8;
				if ( justify == PANEL_JUSTIFY_LEFT )
				{
					leftTriggerTxt->setHJustify(Field::justify_t::LEFT);
				}
				else
				{
					leftTriggerTxt->setHJustify(Field::justify_t::RIGHT);
				}

				SDL_Rect imgPos{0, 0, 0, 0};
				if ( auto imgGet = Image::get(leftTriggerGlyph->path.c_str()) )
				{
					imgPos.w = imgGet->getWidth();
					imgPos.h = imgGet->getHeight();
				}
				imgPos.x = (justify == PANEL_JUSTIFY_LEFT) ? leftAnchorX : rightAnchorX;
				imgPos.y = textPos.y - (imgPos.h - textPos.h) / 2;

				if ( justify == PANEL_JUSTIFY_LEFT )
				{
					leftTriggerGlyph->pos = imgPos;
					textPos.x = leftTriggerGlyph->pos.x + leftTriggerGlyph->pos.w + 8;
					leftTriggerTxt->setSize(textPos);
				}
				else
				{
					imgPos.x -= imgPos.w;
					leftTriggerGlyph->pos = imgPos;
					textPos.x = leftTriggerGlyph->pos.x - 8 - textPos.w;
					leftTriggerTxt->setSize(textPos);
				}
				leftTriggerTxt->setDisabled(false);
				if ( player.inventory_mode == INVENTORY_MODE_ITEM )
				{
					leftTriggerTxt->setText(Language::get(4093));
				}
				else if ( player.inventory_mode == INVENTORY_MODE_SPELL )
				{
					leftTriggerTxt->setText(Language::get(4094));
				}
			}

			if ( !player.inventoryUI.chestGUI.bOpen && !player.shopGUI.bOpen
				&& !GenericGUI[player.playernum].tinkerGUI.bOpen && !GenericGUI[player.playernum].alchemyGUI.bOpen
				&& !GenericGUI[player.playernum].featherGUI.bOpen
				&& !GenericGUI[player.playernum].itemfxGUI.bOpen )
			{
				justify = PANEL_JUSTIFY_RIGHT;
				rightTriggerGlyph->disabled = false;
				rightTriggerGlyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("UINavRightTrigger");
				SDL_Rect textPos;
				textPos.x = (justify == PANEL_JUSTIFY_LEFT) ? leftAnchorX : rightAnchorX;
				textPos.y = 8;
				textPos.w = rightTriggerTxt->getTextObject()->getWidth();
				textPos.h = Font::get(rightTriggerTxt->getFont())->height() + 8;
				if ( justify == PANEL_JUSTIFY_LEFT )
				{
					rightTriggerTxt->setHJustify(Field::justify_t::LEFT);
				}
				else
				{
					rightTriggerTxt->setHJustify(Field::justify_t::RIGHT);
				}

				SDL_Rect imgPos{ 0, 0, 0, 0 };
				if ( auto imgGet = Image::get(rightTriggerGlyph->path.c_str()) )
				{
					imgPos.w = imgGet->getWidth();
					imgPos.h = imgGet->getHeight();
				}
				imgPos.x = (justify == PANEL_JUSTIFY_LEFT) ? leftAnchorX : rightAnchorX;
				imgPos.y = textPos.y - (imgPos.h - textPos.h) / 2;

				if ( justify == PANEL_JUSTIFY_LEFT )
				{
					rightTriggerGlyph->pos = imgPos;
					textPos.x = rightTriggerGlyph->pos.x + rightTriggerGlyph->pos.w + 8;
					rightTriggerTxt->setSize(textPos);
				}
				else
				{
					imgPos.x -= imgPos.w;
					rightTriggerGlyph->pos = imgPos;
					textPos.x = rightTriggerGlyph->pos.x - 8 - textPos.w;
					rightTriggerTxt->setSize(textPos);
				}
				rightTriggerTxt->setDisabled(false);
				rightTriggerTxt->setText(Language::get(4095));

				if ( !additionalTxt->isDisabled() )
				{
					if ( justify == PANEL_JUSTIFY_LEFT )
					{
						additionalTxt->setHJustify(Field::justify_t::LEFT);
					}
					else
					{
						additionalTxt->setHJustify(Field::justify_t::RIGHT);
					}
					additionalGlyph->disabled = false;
					SDL_Rect textPos;
					textPos.w = additionalTxt->getTextObject()->getWidth();
					textPos.h = Font::get(additionalTxt->getFont())->height() + 8;
					if ( justify == PANEL_JUSTIFY_LEFT )
					{
						textPos.x = rightTriggerTxt->getSize().x;
					}
					else
					{
						textPos.x = rightTriggerTxt->getSize().x + rightTriggerTxt->getSize().w - textPos.w;
					}
					textPos.y = std::max(lowestRightY, rightTriggerTxt->getSize().y + rightTriggerTxt->getSize().h);

					SDL_Rect imgPos{ 0, 0, 0, 0 };
					if ( auto imgGet = Image::get(additionalGlyph->path.c_str()) )
					{
						imgPos.w = imgGet->getWidth();
						imgPos.h = imgGet->getHeight();
					}
					imgPos.x = rightTriggerGlyph->pos.x + rightTriggerGlyph->pos.w / 2 - imgPos.w / 2;
					imgPos.y = textPos.y - (imgPos.h - textPos.h) / 2;
					additionalGlyph->pos = imgPos;

					additionalTxt->setSize(textPos);
				}
			}
		}

		if ( leftTriggerPressed	&& !leftTriggerTxt->isDisabled() )
		{
			leftTriggerPressed = false;
			if ( !inputs.getUIInteraction(player.playernum)->selectedItem && !player.GUI.isDropdownActive()
			&& (inputs.hasController(player.playernum) && !player.shootmode
				&& (player.GUI.activeModule == Player::GUI_t::MODULE_INVENTORY
					|| player.GUI.activeModule == Player::GUI_t::MODULE_SPELLS
					|| player.GUI.activeModule == Player::GUI_t::MODULE_HOTBAR
					|| player.GUI.activeModule == Player::GUI_t::MODULE_CHARACTERSHEET
					|| player.GUI.activeModule == Player::GUI_t::MODULE_CHEST
					|| player.GUI.activeModule == Player::GUI_t::MODULE_SHOP)) )
			{
				player.gui_mode = GUI_MODE_INVENTORY;
				if ( player.shootmode )
				{
					player.openStatusScreen(GUI_MODE_INVENTORY, INVENTORY_MODE_ITEM);
				}
				player.inventoryUI.cycleInventoryTab();
			}
		}

		if ( rightTriggerPressed && !rightTriggerTxt->isDisabled() )
		{
			rightTriggerPressed = false;
			if ( !inputs.getUIInteraction(player.playernum)->selectedItem && !player.GUI.isDropdownActive()
				&& (inputs.hasController(player.playernum) && !player.shootmode
					&& (player.GUI.activeModule == Player::GUI_t::MODULE_INVENTORY
						|| player.GUI.activeModule == Player::GUI_t::MODULE_SPELLS
						|| player.GUI.activeModule == Player::GUI_t::MODULE_HOTBAR
						|| player.GUI.activeModule == Player::GUI_t::MODULE_CHARACTERSHEET)) )
			{
				if ( !player.skillSheet.bSkillSheetOpen )
				{
					player.skillSheet.openSkillSheet();
				}
			}
		}

		if ( !leftTriggerTxt->isDisabled() )
		{
			lowestLeftY = std::max(lowestLeftY, leftTriggerTxt->getSize().y + leftTriggerTxt->getSize().h);
			lowestLeftY = std::max(lowestLeftY, leftTriggerGlyph->pos.y + leftTriggerGlyph->pos.h);
		}
		if ( !rightTriggerTxt->isDisabled() )
		{
			lowestRightY = std::max(lowestRightY, rightTriggerTxt->getSize().y + rightTriggerTxt->getSize().h);
			lowestRightY = std::max(lowestRightY, rightTriggerGlyph->pos.y + rightTriggerGlyph->pos.h);
		}

		if ( !leftBumperTxt->isDisabled() )
		{
			leftBumperGlyph->disabled = false;
			leftBumperGlyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("UINavLeftBumper");
			SDL_Rect textPos;
			textPos.x = leftTriggerGlyph->pos.x;
			textPos.y = lowestLeftY;
			textPos.w = leftBumperTxt->getTextObject()->getWidth();
			textPos.h = Font::get(leftBumperTxt->getFont())->height() + 8;

			SDL_Rect imgPos{ 0, 0, 0, 0 };
			if ( auto imgGet = Image::get(leftBumperGlyph->path.c_str()) )
			{
				imgPos.w = imgGet->getWidth();
				imgPos.h = imgGet->getHeight();
			}
			imgPos.x = textPos.x;
			imgPos.y = textPos.y - (imgPos.h - textPos.h) / 2;
			leftBumperGlyph->pos = imgPos;

			textPos.x = imgPos.x + 4 + imgPos.w;
			leftBumperTxt->setSize(textPos);
		}
		if ( !rightBumperTxt->isDisabled() )
		{
			rightBumperGlyph->disabled = false;
			rightBumperGlyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("UINavRightBumper");
			SDL_Rect textPos;
			textPos.x = leftBumperTxt->getSize().x + leftBumperTxt->getSize().w + 8;
			textPos.y = leftBumperTxt->getSize().y;
			textPos.w = rightBumperTxt->getTextObject()->getWidth();
			textPos.h = Font::get(rightBumperTxt->getFont())->height() + 8;

			SDL_Rect imgPos{ 0, 0, 0, 0 };
			if ( auto imgGet = Image::get(rightBumperGlyph->path.c_str()) )
			{
				imgPos.w = imgGet->getWidth();
				imgPos.h = imgGet->getHeight();
			}
			imgPos.x = textPos.x;
			imgPos.y = textPos.y - (imgPos.h - textPos.h) / 2;

			textPos.x += imgPos.w + 4;
			rightBumperTxt->setSize(textPos);
			rightBumperGlyph->pos = imgPos;
		}
	}

	auto magicButton = uiNavFrame->findButton("magic button");
	auto magicButtonGlyph = uiNavFrame->findImage("magic button glyph");
	auto itemsButton = uiNavFrame->findButton("items button");
	auto itemsButtonGlyph = uiNavFrame->findImage("items button glyph");
	auto statusButton = uiNavFrame->findButton("status button");
	auto statusButtonGlyph = uiNavFrame->findImage("status button glyph");
	auto skillsButton = uiNavFrame->findButton("skills button");
	auto skillsButtonGlyph = uiNavFrame->findImage("skills button glyph");

	static ConsoleVariable<bool> cvar_spell_unread_blink("/spell_unread_blink", true);
	if ( *cvar_spell_unread_blink 
		&& player.magic.bHasUnreadNewSpell && ticks % TICKS_PER_SECOND >= TICKS_PER_SECOND / 2 )
	{
		magicButton->setTextColor(hudColors.characterSheetGreen);
		magicButton->setTextHighlightColor(hudColors.characterSheetGreen);
	}
	else
	{
		magicButton->setTextColor(makeColor(255, 255, 255, 255));
		magicButton->setTextHighlightColor(makeColor(255, 255, 255, 255));
	}

	struct ButtonsAndGlyphs {
		std::string name;
		Button* button = nullptr;
		Frame::image_t* glyph = nullptr;
		std::string inputName;
		CompactLayoutModes layoutMode;
		ButtonsAndGlyphs(std::string _name, 
			Button* _button, 
			Frame::image_t* _glyph,
			std::string _inputName, 
			CompactLayoutModes _layoutMode) :
			name(_name),
			button(_button),
			glyph(_glyph),
			inputName(_inputName),
			layoutMode(_layoutMode)
		{
		}
	};
	std::vector<ButtonsAndGlyphs> allButtonsAndGlyphs;
	allButtonsAndGlyphs.emplace_back(
		ButtonsAndGlyphs{ "magic button", magicButton, magicButtonGlyph, 
		"UINavLeftTrigger", COMPACT_LAYOUT_INVENTORY });
	allButtonsAndGlyphs.emplace_back(
		ButtonsAndGlyphs{ "status button", statusButton, statusButtonGlyph, 
		"UINavRightTrigger", COMPACT_LAYOUT_INVENTORY });
	allButtonsAndGlyphs.emplace_back(
		ButtonsAndGlyphs{ "items button", itemsButton, itemsButtonGlyph,
		"UINavLeftTrigger", COMPACT_LAYOUT_CHARSHEET });
	allButtonsAndGlyphs.emplace_back(
		ButtonsAndGlyphs{ "skills button", skillsButton, skillsButtonGlyph,
		"UINavRightTrigger", COMPACT_LAYOUT_CHARSHEET });

	int buttonWidth = 98;
	int buttonHeight = 38;
	int alignPaddingX = 2;
	int leftAlignX = uiNavFrame->getSize().w / 2 - buttonWidth - alignPaddingX;
	int rightAlignX = uiNavFrame->getSize().w / 2 + alignPaddingX;
	int topAlignY = 34;
	int bottomAlignY = topAlignY + 52;

	int numButtonsToShow = 2;

	for ( auto& buttonAndGlyph : allButtonsAndGlyphs )
	{
		auto& button = buttonAndGlyph.button;
		button->setDisabled(true);
		SDL_Rect buttonPos = button->getSize();
		auto& glyph = buttonAndGlyph.glyph;
		glyph->disabled = true;

		if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor && inputs.hasController(player.playernum) )
		{
			button->setColor(makeColor(255, 255, 255, 255));
		}
		else
		{
			button->setColor(makeColor(255, 255, 255, 255));
		}

		if ( player.bUseCompactGUIHeight() || player.bUseCompactGUIWidth() )
		{
			if ( player.inventoryUI.chestGUI.bOpen )
			{
				if ( buttonAndGlyph.inputName == "UINavRightTrigger" )
				{
					button->setInvisible(true);
					continue;
				}
			}
			if ( player.shopGUI.bOpen )
			{
				if ( buttonAndGlyph.inputName == "UINavRightTrigger" 
					|| (inputs.getVirtualMouse(player.playernum)->draw_cursor && player.bUseCompactGUIWidth()) )
				{
					button->setInvisible(true);
					continue;
				}
			}
			if ( GenericGUI[player.playernum].isGUIOpen() || player.GUI.isDropdownActive()
				|| player.minimap.mapWindow || player.messageZone.logWindow || player.hud.statusFxFocusedWindowActive )
			{
				button->setDisabled(true);
				continue;
			}
		}

		if ( buttonAndGlyph.name == "magic button" || buttonAndGlyph.name == "items button" )
		{
			if ( inputs.bPlayerUsingKeyboardControl(player.playernum) 
				&& inputs.getVirtualMouse(player.playernum)->draw_cursor
				&& (!player.bUseCompactGUIHeight() && !player.bUseCompactGUIWidth())
				&& !GenericGUI[player.playernum].isGUIOpen()
				&& !player.minimap.mapWindow
				&& !player.messageZone.logWindow
				&& !player.hud.statusFxFocusedWindowActive )
			{
				if ( player.inventory_mode == INVENTORY_MODE_ITEM )
				{
					if ( buttonAndGlyph.name == "magic button" )
					{
						button->setDisabled(false);
						glyph->disabled = false;

						buttonPos.x = leftAnchorX;
						buttonPos.y = 8;
						buttonAndGlyph.inputName = "Spell List";
					}
				}
				else if ( player.inventory_mode == INVENTORY_MODE_SPELL )
				{
					if ( buttonAndGlyph.name == "items button" )
					{
						button->setDisabled(false);
						glyph->disabled = false;

						buttonPos.x = leftAnchorX;
						buttonPos.y = 8;
						buttonAndGlyph.inputName = "Spell List";
					}
				}
			}
			else if ( player.bUseCompactGUIHeight() || player.bUseCompactGUIWidth() )
			{
				if ( !player.bUseCompactGUIWidth() )
				{
					// align next to inventory
					buttonPos.x = leftAnchorX;
				}
				else
				{
					buttonPos.x = leftAlignX;
				}
				if ( numButtonsToShow < 4 )
				{
					buttonPos.y = topAlignY;
					if ( !player.bUseCompactGUIWidth() )
					{
						if ( players[player.playernum]->hud.xpFrame )
						{
							SDL_Rect xpFramePos = players[player.playernum]->hud.xpFrame->getSize();
							buttonPos.y = xpFramePos.y + 8;
						}
					}
					
					if ( compactLayoutMode == COMPACT_LAYOUT_INVENTORY )
					{
						if ( buttonAndGlyph.name == "items button" && player.inventory_mode == INVENTORY_MODE_ITEM )
						{
							// leave disabled
							button->setDisabled(true);
							glyph->disabled = true;
						}
						else if ( buttonAndGlyph.name == "magic button" && player.inventory_mode == INVENTORY_MODE_SPELL )
						{
							// leave disabled
							button->setDisabled(true);
							glyph->disabled = true;
						}
						else
						{
							button->setDisabled(false);
							glyph->disabled = false;
						}
					}
					else if ( buttonAndGlyph.layoutMode == compactLayoutMode )
					{
						button->setDisabled(false);
						glyph->disabled = false;
					}
				}
				else
				{
					button->setDisabled(false);
					glyph->disabled = false;
					if ( buttonAndGlyph.name == "magic button" )
					{
						buttonPos.y = topAlignY;
					}
					else if ( buttonAndGlyph.name == "items button" )
					{
						buttonPos.y = bottomAlignY;
					}
				}
			}
			buttonPos.w = buttonWidth;
			buttonPos.h = buttonHeight;
			button->setSize(buttonPos);
		}
		if ( buttonAndGlyph.name == "status button" || buttonAndGlyph.name == "skills button" )
		{
			if ( inputs.bPlayerUsingKeyboardControl(player.playernum)
				&& inputs.getVirtualMouse(player.playernum)->draw_cursor
				&& (!player.bUseCompactGUIHeight() && !player.bUseCompactGUIWidth()) )
			{
				// leave disabled
			}
			else if ( player.bUseCompactGUIHeight() || player.bUseCompactGUIWidth() )
			{
				if ( !player.bUseCompactGUIWidth() )
				{
					// align next to right panel
					buttonPos.x = rightAnchorX - buttonPos.w;
				}
				else
				{
					buttonPos.x = rightAlignX;
				}
				if ( numButtonsToShow < 4 )
				{
					buttonPos.y = topAlignY;
					if ( !player.bUseCompactGUIWidth() )
					{
						if ( players[player.playernum]->hud.xpFrame )
						{
							SDL_Rect xpFramePos = players[player.playernum]->hud.xpFrame->getSize();
							buttonPos.y = xpFramePos.y + 8;
						}
					}
					if ( buttonAndGlyph.layoutMode == compactLayoutMode )
					{
						button->setDisabled(false);
						glyph->disabled = false;
					}
				}
				else
				{
					button->setDisabled(false);
					glyph->disabled = false;
					if ( buttonAndGlyph.name == "status button" )
					{
						buttonPos.y = topAlignY;
					}
					else if ( buttonAndGlyph.name == "skills button" )
					{
						buttonPos.y = bottomAlignY;
					}
				}
			}
			buttonPos.w = buttonWidth;
			buttonPos.h = buttonHeight;
			button->setSize(buttonPos);
		}

		if ( !button->isDisabled() )
		{
			glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding(buttonAndGlyph.inputName.c_str());
			glyph->ontop = true;
			if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
			{
				glyph->disabled = false;
			}
			else
			{
				glyph->disabled = false;
			}
			if ( auto imgGet = Image::get(glyph->path.c_str()) )
			{
				glyph->pos.w = (int)imgGet->getWidth();
				glyph->pos.h = (int)imgGet->getHeight();
			}

			glyph->pos.x = button->getSize().x + button->getSize().w / 2 - glyph->pos.w / 2; // center the x for the glyph
			const int glyphToImgPadY = 8;
			glyph->pos.y = button->getSize().y + button->getSize().h - glyphToImgPadY; // just below the button with some padding
		}
		button->setInvisible(button->isDisabled());
	}

	for ( auto& buttonAndGlyph : allButtonsAndGlyphs )
	{
		auto& button = buttonAndGlyph.button;
		if ( !button->isDisabled() && !button->isInvisible() )
		{
			if ( player.GUI.bModuleAccessibleWithMouse(Player::GUI_t::MODULE_INVENTORY)
				&& inputs.getVirtualMouse(player.playernum)->draw_cursor
				&& button->isHighlighted() )
			{
				player.GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_INVENTORY);
				SDL_Rect pos = button->getAbsoluteSize();
				// make sure to adjust absolute size to camera viewport
				pos.x -= player.camera_virtualx1();
				pos.y -= player.camera_virtualy1();
				player.hud.setCursorDisabled(false);
				player.hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, inputs.getVirtualMouse(player.playernum)->draw_cursor);
			}

			if ( buttonAndGlyph.inputName == "UINavLeftTrigger" && leftTriggerPressed
				&& player.GUI.bModuleAccessibleWithMouse(Player::GUI_t::MODULE_INVENTORY) )
			{
				leftTriggerPressed = false;
				button->activate();
			}
			else if ( buttonAndGlyph.inputName == "UINavRightTrigger" && rightTriggerPressed
				&& player.GUI.bModuleAccessibleWithMouse(Player::GUI_t::MODULE_INVENTORY) )
			{
				rightTriggerPressed = false;
				button->activate();
			}
		}
	}
}

bool StatusEffectQueue_t::insertEffect(int effectID, int spellID)
{
	if ( spellID >= 0 && spellID < NUM_SPELLS )
	{
		effectID = spellID + kSpellEffectOffset;
		if ( StatusEffectDefinitions_t::sustainedSpellDefinitionExists(effectID) )
		{
			if ( StatusEffectDefinitions_t::getSustainedSpell(effectID).neverDisplay )
			{
				return false;
			}
		}
	}
	if ( (effectID >= 0 && effectID < NUMEFFECTS) 
		|| effectID == kEffectBread 
		|| effectID == kEffectBloodHunger
		|| effectID == kEffectAutomatonHunger
		|| effectID >= kSpellEffectOffset )
	{
		if ( StatusEffectDefinitions_t::effectDefinitionExists(effectID) )
		{
			if ( StatusEffectDefinitions_t::getEffect(effectID).neverDisplay )
			{
				return false;
			}
		}
		for ( auto& q : effectQueue )
		{
			if ( effectID == q.effect )
			{
				return false;
			}
		}
	}

	effectQueue.push_back(StatusEffectQueueEntry_t(effectID));
	effectQueue.back().pos.x = getBaseEffectPosX();
	effectQueue.back().pos.y = getBaseEffectPosY();
	notificationQueue.push_back(StatusEffectQueueEntry_t(effectID));
	notificationQueue.back().pos.x = getBaseEffectPosX();
	notificationQueue.back().pos.y = getBaseEffectPosY();

	// fall back if notificationTargetPosition doesn't have an effect to go to.
	notificationQueue.back().notificationTargetPosition.x = 0;
	notificationQueue.back().notificationTargetPosition.y = statusEffectFrame->getSize().h - notificationQueue.back().notificationTargetPosition.h;
	requiresAnimUpdate = true;
	return true;
}

std::string StatusEffectQueue_t::StatusEffectDefinitions_t::getEffectImgPath(StatusEffectQueue_t::EffectDefinitionEntry_t& entry, int variation)
{
	if ( entry.imgPath == "" )
	{
		if ( entry.imgPathVariations.size() > 0 && variation >= 0 )
		{
			return entry.imgPathVariations[std::min(variation, (int)entry.imgPathVariations.size() - 1)];
		}
		node_t* spellImageNode = nullptr;
		int spellID = entry.useSpellIDForImg;
		if ( variation >= 0 )
		{
			spellID = entry.useSpellIDForImgVariations[std::min(variation, (int)entry.useSpellIDForImgVariations.size() - 1)];
		}
		if ( spellID >= 0 && spellID < NUM_SPELLS )
		{
			spellImageNode = ItemTooltips.getSpellNodeFromSpellID(spellID);
		}
		if ( spellImageNode )
		{
			string_t* string = (string_t*)spellImageNode->element;
			if ( string )
			{
				return string->data;
			}
		}
		return "images/sprites/null.png";
	}
	if ( entry.imgPath == "" )
	{
		return "images/sprites/null.png";
	}
	return entry.imgPath;
}

void StatusEffectQueueEntry_t::setAnimatePosition(int destx, int desty, int destw, int desth)
{
	animateStartX = pos.x;
	animateStartY = pos.y;
	animateStartW = pos.w;
	animateStartH = pos.h;
	animateSetpointX = destx;
	animateSetpointY = desty;
	animateSetpointW = destw;
	animateSetpointH = desth;
	animateX = 0.0;
	animateY = 0.0;
	animateW = 0.0;
	animateH = 0.0;
}

void StatusEffectQueueEntry_t::setAnimatePosition(int destx, int desty)
{
	animateStartX = pos.x;
	animateStartY = pos.y;
	animateStartW = pos.w;
	animateStartH = pos.h;
	animateSetpointX = destx;
	animateSetpointY = desty;
	animateSetpointW = 0;
	animateSetpointH = 0;
	animateX = 0.0;
	animateY = 0.0;
	animateW = 0.0;
	animateH = 0.0;
}

const real_t kStatusEffectQueueAnimSpeedMult = 4.0;

void StatusEffectQueueEntry_t::animate()
{
	const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
	real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - animateX)) / (5.0 / kStatusEffectQueueAnimSpeedMult);
	real_t setpointDiffY = fpsScale * std::max(.1, (1.0 - animateY)) / (5.0 / kStatusEffectQueueAnimSpeedMult);
	animateX += setpointDiffX;
	animateY += setpointDiffY;
	animateX = std::min(1.0, animateX);
	animateY = std::min(1.0, animateY);

	int destX = animateSetpointX - animateStartX;
	int destY = animateSetpointY - animateStartY;

	pos.x = animateStartX + destX * animateX;
	pos.y = animateStartY + destY * animateY;
}

void StatusEffectQueue_t::loadStatusEffectsJSON()
{
	if ( !PHYSFS_getRealDir("/data/status_effects.json") )
	{
		printlog("[JSON]: Error: Could not find file: data/status_effects.json");
	}
	else
	{
		std::string inputPath = PHYSFS_getRealDir("/data/status_effects.json");
		inputPath.append("/data/status_effects.json");

		File* fp = FileIO::open(inputPath.c_str(), "rb");
		if ( !fp )
		{
			printlog("[JSON]: Error: Could not open json file %s", inputPath.c_str());
		}
		else
		{
			char buf[65536];
			int count = fp->read(buf, sizeof(buf[0]), sizeof(buf));
			buf[count] = '\0';
			rapidjson::StringStream is(buf);
			FileIO::close(fp);

			rapidjson::Document d;
			d.ParseStream(is);
			if ( !d.HasMember("version") )
			{
				printlog("[JSON]: Error: No 'version' value in json file, or JSON syntax incorrect! %s", inputPath.c_str());
			}
			else
			{
				StatusEffectDefinitions_t::reset();
				int defaultTooltipWidth = 200;
				if ( d.HasMember("default_tooltip_width") )
				{
					defaultTooltipWidth = d["default_tooltip_width"].GetInt();
				}
				if ( d.HasMember("colors") )
				{
					if ( d["colors"].HasMember("notification_text") )
					{
						StatusEffectDefinitions_t::notificationTextColor = makeColor(
							d["colors"]["notification_text"]["r"].GetInt(),
							d["colors"]["notification_text"]["g"].GetInt(),
							d["colors"]["notification_text"]["b"].GetInt(),
							d["colors"]["notification_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("tooltip_desc_text") )
					{
						StatusEffectDefinitions_t::tooltipDescColor = makeColor(
							d["colors"]["tooltip_desc_text"]["r"].GetInt(),
							d["colors"]["tooltip_desc_text"]["g"].GetInt(),
							d["colors"]["tooltip_desc_text"]["b"].GetInt(),
							d["colors"]["tooltip_desc_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("tooltip_heading_text") )
					{
						StatusEffectDefinitions_t::tooltipHeadingColor = makeColor(
							d["colors"]["tooltip_heading_text"]["r"].GetInt(),
							d["colors"]["tooltip_heading_text"]["g"].GetInt(),
							d["colors"]["tooltip_heading_text"]["b"].GetInt(),
							d["colors"]["tooltip_heading_text"]["a"].GetInt());
					}
				}
				if ( d.HasMember("notification_font") )
				{
					StatusEffectDefinitions_t::notificationFont = d["notification_font"].GetString();
				}
				if ( d.HasMember("sustained_effects") )
				{
					for ( rapidjson::Value::ConstMemberIterator itr = d["sustained_effects"].MemberBegin();
						itr != d["sustained_effects"].MemberEnd(); ++itr )
					{
						int id = -1;
						if ( itr->value.HasMember("id") )
						{
							id = itr->value["id"].GetInt();
						}
						int spellID = -1;
						if ( itr->value.HasMember("spell_id") )
						{
							spellID = itr->value["spell_id"].GetInt();
						}
						StatusEffectDefinitions_t::allSustainedSpells.insert(
							std::make_pair(spellID, EffectDefinitionEntry_t()));
						auto& entry = StatusEffectDefinitions_t::allSustainedSpells[spellID];
						entry.effect_id = id;
						entry.spell_id = spellID;
						entry.internal_name = itr->name.GetString();
						if ( itr->value["name"].IsArray() )
						{
							for ( auto arr = itr->value["name"].Begin();
								arr != itr->value["name"].End(); ++arr )
							{
								entry.nameVariations.push_back(arr->GetString());
							}
						}
						else
						{
							entry.name = itr->value["name"].GetString();
						}
						std::string buf = itr->value["desc"].GetString();
						entry.desc = "\x1E ";
						int index = 0;
						for ( auto s : buf )
						{
							if ( index == 0 && (buf[0] == '+' || buf[0] == '-') )
							{
								entry.desc = "";
							}
							entry.desc += s;
							if ( s == '\n' )
							{
								if ( index + 1 < buf.size() )
								{
									if ( buf[index + 1] == '+' || buf[index + 1] == '-' )
									{
										// skip adding dot
										++index;
										continue;
									}
								}
								entry.desc += "\x1E ";
							}
							++index;
						}
						entry.imgPath = itr->value["img_path"].GetString();
						entry.useSpellIDForImg = itr->value["img_from_spell_id"].GetInt();
						entry.neverDisplay = false;
						if ( itr->value.HasMember("never_display") )
						{
							entry.neverDisplay = itr->value["never_display"].GetBool();
						}
						entry.tooltipWidth = defaultTooltipWidth;
						if ( itr->value.HasMember("tooltip_width") )
						{
							entry.tooltipWidth = itr->value["tooltip_width"].GetInt();
						}
					}
				}
				if ( d.HasMember("effects") )
				{
					for ( rapidjson::Value::ConstMemberIterator itr = d["effects"].MemberBegin();
						itr != d["effects"].MemberEnd(); ++itr )
					{
						int id = -1;
						if ( itr->value.HasMember("id") )
						{
							id = itr->value["id"].GetInt();
						}
						StatusEffectDefinitions_t::allEffects.insert(
							std::make_pair(id, EffectDefinitionEntry_t()));
						auto& entry = StatusEffectDefinitions_t::allEffects[id];
						entry.effect_id = id;
						if ( itr->value["name"].IsArray() )
						{
							for ( auto arr = itr->value["name"].Begin();
								arr != itr->value["name"].End(); ++arr )
							{
								entry.nameVariations.push_back(arr->GetString());
							}
						}
						else
						{
							entry.name = itr->value["name"].GetString();
						}
						if ( itr->value["desc"].IsArray() )
						{
							for ( auto arr = itr->value["desc"].Begin();
								arr != itr->value["desc"].End(); ++arr )
							{
								std::string buf = arr->GetString();
								int index = 0;
								std::string formattedStr = "\x1E ";
								for ( auto s : buf )
								{
									if ( index == 0 && (buf[0] == '+' || buf[0] == '-') )
									{
										formattedStr = "";
									}
									formattedStr += s;
									if ( s == '\n' )
									{
										if ( index + 1 < buf.size() )
										{
											if ( buf[index + 1] == '+' || buf[index + 1] == '-' )
											{
												// skip adding dot
												++index;
												continue;
											}
										}
										formattedStr += "\x1E ";
									}
									++index;
								}
								entry.descVariations.push_back(formattedStr);
							}
						}
						else
						{
							std::string buf = itr->value["desc"].GetString();
							entry.desc = "\x1E ";
							int index = 0;
							for ( auto s : buf )
							{
								if ( index == 0 && (buf[0] == '+' || buf[0] == '-') )
								{
									entry.desc = "";
								}
								entry.desc += s;
								if ( s == '\n' )
								{
									if ( index + 1 < buf.size() )
									{
										if ( buf[index + 1] == '+' || buf[index + 1] == '-' )
										{
											// skip adding dot
											++index;
											continue;
										}
									}
									entry.desc += "\x1E ";
								}
								++index;
							}
						}
						entry.internal_name = itr->name.GetString();
						if ( itr->value["img_path"].IsArray() )
						{
							for ( auto arr = itr->value["img_path"].Begin();
								arr != itr->value["img_path"].End(); ++arr )
							{
								entry.imgPathVariations.push_back(arr->GetString());
							}
						}
						else
						{
							entry.imgPath = itr->value["img_path"].GetString();
						}
						if ( itr->value["img_from_spell_id"].IsArray() )
						{
							for ( auto arr = itr->value["img_from_spell_id"].Begin();
								arr != itr->value["img_from_spell_id"].End(); ++arr )
							{
								entry.useSpellIDForImgVariations.push_back(arr->GetInt());
							}
						}
						else
						{
							entry.useSpellIDForImg = itr->value["img_from_spell_id"].GetInt();
						}
						entry.sustainedSpellID = -1;
						if ( itr->value.HasMember("use_entry_for_sustained_spell") )
						{
							entry.sustainedSpellID = itr->value["use_entry_for_sustained_spell"].GetInt();
						}
						entry.neverDisplay = false;
						if ( itr->value.HasMember("never_display") )
						{
							entry.neverDisplay = itr->value["never_display"].GetBool();
						}
						entry.tooltipWidth = defaultTooltipWidth;
						if ( itr->value.HasMember("tooltip_width") )
						{
							entry.tooltipWidth = itr->value["tooltip_width"].GetInt();
						}
					}
				}
				printlog("[JSON]: Successfully read json file %s", inputPath.c_str());
			}
		}
	}
}

int StatusEffectQueue_t::getBaseEffectPosX()
{
	if ( players[player]->bUseCompactGUIHeight() )
	{
		return statusEffectFrame->getSize().w / 2 - 100;
	}
	return statusEffectFrame->getSize().w / 2 - 100;
}
int StatusEffectQueue_t::getBaseEffectPosY()
{
	if ( players[player]->bUseCompactGUIHeight() )
	{
		if ( players[player]->bUseCompactGUIWidth() && !players[player]->hotbar.useHotbarFaceMenu )
		{
			return statusEffectFrame->getSize().h / 2 + 32;
		}
		return statusEffectFrame->getSize().h / 2;
	}
	return statusEffectFrame->getSize().h / 2 - 50;
}

int StatusEffectQueueEntry_t::getEffectSpriteNormalWidth()
{
	if ( effect == StatusEffectQueue_t::kEffectBread
		|| effect == StatusEffectQueue_t::kEffectBloodHunger )
	{
		return 76;
	}
	else if ( effect == StatusEffectQueue_t::kEffectAutomatonHunger )
	{
		return 64;
	}
	return 32;
}
int StatusEffectQueueEntry_t::getEffectSpriteNormalHeight()
{
	if ( effect == StatusEffectQueue_t::kEffectBread
		|| effect == StatusEffectQueue_t::kEffectBloodHunger )
	{
		return 60;
	}
	else if ( effect == StatusEffectQueue_t::kEffectAutomatonHunger )
	{
		return 64;
	}
	return 32;
}

int getStatusEffectMovementAmount(int player)
{
	int movementAmount = 50;
	if ( players[player]->bUseCompactGUIHeight() )
	{
		movementAmount = 25;
	}
	return movementAmount;
}

real_t StatusEffectQueueEntry_t::getStatusEffectLargestScaling(int player)
{
	if ( effect == StatusEffectQueue_t::kEffectBread 
		|| effect == StatusEffectQueue_t::kEffectBloodHunger 
		|| effect == StatusEffectQueue_t::kEffectAutomatonHunger )
	{
		return 2.0;
	}
	return 3.0;
}

real_t StatusEffectQueueEntry_t::getStatusEffectMidScaling(int player)
{
	if ( effect == StatusEffectQueue_t::kEffectBread 
		|| effect == StatusEffectQueue_t::kEffectBloodHunger
		|| effect == StatusEffectQueue_t::kEffectAutomatonHunger )
	{
		return 1.5;
	}
	return 2.0;
}

void StatusEffectQueueEntry_t::animateNotification(int player)
{
	auto& statusEffectQueue = StatusEffectQueue[player];
	real_t animspeed = 5.0 / kStatusEffectQueueAnimSpeedMult;
	const int movementAmount = getStatusEffectMovementAmount(player);
	switch ( notificationState )
	{
		case STATE_1:
			if ( notificationStateInit == STATE_1 )
			{
				notificationStateInit = STATE_2;
				setAnimatePosition(
					statusEffectQueue.getBaseEffectPosX() - movementAmount,
					statusEffectQueue.getBaseEffectPosY() - movementAmount,
					getEffectSpriteNormalWidth(), getEffectSpriteNormalHeight());
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_2;
			}
			animspeed *= 2.0;
			break;
		case STATE_2:
			if ( notificationStateInit == STATE_2 )
			{
				notificationStateInit = STATE_3;
				setAnimatePosition(
					statusEffectQueue.getBaseEffectPosX() - movementAmount - (getStatusEffectLargestScaling(player) - 1.0) * getEffectSpriteNormalWidth() / 2,
					statusEffectQueue.getBaseEffectPosY() - movementAmount - (getStatusEffectLargestScaling(player) - 1.0) * getEffectSpriteNormalHeight() / 2,
					getEffectSpriteNormalWidth() * getStatusEffectLargestScaling(player),
					getEffectSpriteNormalHeight() * getStatusEffectLargestScaling(player));
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_3;
			}
			animspeed *= 4.0;
			break;
		case STATE_3:
			if ( notificationStateInit == STATE_3 )
			{
				notificationStateInit = STATE_4;
				setAnimatePosition(
					statusEffectQueue.getBaseEffectPosX() - movementAmount - (getStatusEffectMidScaling(player) - 1.0) * getEffectSpriteNormalWidth() / 2,
					statusEffectQueue.getBaseEffectPosY() - movementAmount - (getStatusEffectMidScaling(player) - 1.0) * getEffectSpriteNormalHeight() / 2,
					getEffectSpriteNormalWidth() * getStatusEffectMidScaling(player),
					getEffectSpriteNormalHeight() * getStatusEffectMidScaling(player));
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_4;
			}
			animspeed *= 4.0;
			break;
		case STATE_4:
			if ( notificationStateInit == STATE_4 )
			{
				notificationStateInit = STATE_END;
				setAnimatePosition(notificationTargetPosition.x,
					notificationTargetPosition.y,
					notificationTargetPosition.w,
					notificationTargetPosition.h);
			}
			if ( notificationTargetPosition.x != animateSetpointX
				|| notificationTargetPosition.y != animateSetpointY
				|| notificationTargetPosition.w != animateSetpointW
				|| notificationTargetPosition.h != animateSetpointH )
			{
				// re update this as our target moved.
				setAnimatePosition(notificationTargetPosition.x,
					notificationTargetPosition.y,
					notificationTargetPosition.w,
					notificationTargetPosition.h);
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_END;
			}
			animspeed *= 2.0;
			break;
		case STATE_END:
			return;
		default:
			break;
	}

	const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
	real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - animateX)) / (animspeed);
	real_t setpointDiffY = fpsScale * std::max(.1, (1.0 - animateY)) / (animspeed);
	real_t setpointDiffW = fpsScale * std::max(.1, (1.0 - animateW)) / (animspeed);
	real_t setpointDiffH = fpsScale * std::max(.1, (1.0 - animateH)) / (animspeed);
	animateX += setpointDiffX;
	animateY += setpointDiffY;
	animateX = std::min(1.0, animateX);
	animateY = std::min(1.0, animateY);
	animateW += setpointDiffW;
	animateH += setpointDiffH;
	animateW = std::min(1.0, animateW);
	animateH = std::min(1.0, animateH);

	int destX = animateSetpointX - animateStartX;
	int destY = animateSetpointY - animateStartY;
	int destW = animateSetpointW - animateStartW;
	int destH = animateSetpointH - animateStartH;

	pos.x = animateStartX + destX * animateX;
	pos.y = animateStartY + destY * animateY;
	pos.w = animateStartW + destW * animateW;
	pos.h = animateStartH + destH * animateH;
}

void createStatusEffectQueue(const int player)
{
	auto& statusEffectQueue = StatusEffectQueue[player];
	if ( statusEffectQueue.statusEffectFrame )
	{
		return;
	}
	auto& hud_t = players[player]->hud;
	statusEffectQueue.statusEffectFrame = hud_t.hudFrame->addFrame("status effects");
	statusEffectQueue.statusEffectFrame->setHollow(true);
	statusEffectQueue.statusEffectFrame->setBorder(0);
	statusEffectQueue.statusEffectFrame->setOwner(player);
	statusEffectQueue.statusEffectFrame->setSize(SDL_Rect{ 0, 0, 0, 0 });

	auto automatonHungerFrame = statusEffectQueue.statusEffectFrame->addFrame("automaton hunger notification");
	automatonHungerFrame->setHollow(true);
	automatonHungerFrame->setDisabled(true);
	automatonHungerFrame->setSize(SDL_Rect{ 0, 0, 64, 64 });
	auto automaton_flame_img = automatonHungerFrame->addImage(SDL_Rect{ 0, 0, 64, 64 }, 0xFFFFFFFF, "images/system/Hunger_boiler_fire.png", "flame");

	auto notif_frame = statusEffectQueue.statusEffectFrame->addFrame("notification frame");
	notif_frame->setHollow(true);
	notif_frame->setDisabled(true);
	notif_frame->setSize(SDL_Rect{ 0, 0, 0, 0 });
	auto notif = notif_frame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "images/system/white.png", "notification img");
	notif->disabled = true;
	auto notif_txt = notif_frame->addField("notification txt", 128);
	//notif_txt->setFont("fonts/pixel_maz_multiline.ttf#16#2");
	notif_txt->setFont("fonts/pixelmix.ttf#16#2");
	notif_txt->setText("");
	notif_txt->setDisabled(true);
	notif_txt->setColor(makeColor(255, 255, 255, 255));
	notif_txt->setVJustify(Field::justify_t::CENTER);
	notif_txt->setHJustify(Field::justify_t::CENTER);

	auto innerFrame = statusEffectQueue.statusEffectFrame->addFrame("effects");
	innerFrame->setHollow(true);
}

const int breadStatusEffectHeight = 60;

std::string& StatusEffectQueue_t::EffectDefinitionEntry_t::getName(int variation)
{
	if ( variation >= 0 )
	{
		return nameVariations[std::min(variation, (int)nameVariations.size() - 1)];
	}
	return name;
}

std::string& StatusEffectQueue_t::EffectDefinitionEntry_t::getDesc(int variation)
{
	if ( variation >= 0 )
	{
		return descVariations[std::min(variation, (int)descVariations.size() - 1)];
	}
	return desc;
}

void StatusEffectQueue_t::createStatusEffectTooltip()
{
	auto& tooltipFrame = statusEffectTooltipFrame;
	if ( tooltipFrame )
	{
		return;
	}
	char name[32];
	snprintf(name, sizeof(name), "player statusfx tooltip %d", player);
	tooltipFrame = gameUIFrame[player]->addFrame(name);
	tooltipFrame->setHollow(true);
	tooltipFrame->setDisabled(true);
	tooltipFrame->setInheritParentFrameOpacity(false);
	tooltipFrame->setBorder(0);
	tooltipFrame->setOwner(player);
	tooltipFrame->setSize(SDL_Rect{ 0, 0, 0, 0 });

	{
		Uint32 color = makeColor(255, 255, 255, 255);
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TL_Blue_00.png", skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TR_Blue_00.png", skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_T_Blue_00.png", skillsheetEffectBackgroundImages[TOP].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_L_00.png", skillsheetEffectBackgroundImages[MIDDLE_LEFT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_R_00.png", skillsheetEffectBackgroundImages[MIDDLE_RIGHT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			makeColor(22, 24, 29, 255), "images/system/white.png", skillsheetEffectBackgroundImages[MIDDLE].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_BL_00.png", skillsheetEffectBackgroundImages[BOTTOM_LEFT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_BR_00.png", skillsheetEffectBackgroundImages[BOTTOM_RIGHT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_B_00.png", skillsheetEffectBackgroundImages[BOTTOM].c_str());
		imageSetWidthHeight9x9(tooltipFrame, skillsheetEffectBackgroundImages);

		auto heading_txt = tooltipFrame->addField("heading txt", 128);
		heading_txt->setFont("fonts/pixel_maz_multiline.ttf#16#2");
		heading_txt->setText("");
		heading_txt->setColor(makeColor(255, 255, 255, 255));
		heading_txt->setVJustify(Field::justify_t::CENTER);
		heading_txt->setHJustify(Field::justify_t::LEFT);

		auto desc_txt = tooltipFrame->addField("desc txt", 1024);
		desc_txt->setFont("fonts/pixel_maz_multiline.ttf#16#2");
		desc_txt->setText("");
		desc_txt->setColor(makeColor(0, 192, 255, 255));
		desc_txt->setVJustify(Field::justify_t::LEFT);
		desc_txt->setHJustify(Field::justify_t::LEFT);
	}
}

void Player::HUD_t::updateStatusEffectTooltip()
{
	StatusEffectQueue[player.playernum].createStatusEffectTooltip();
}

void Player::HUD_t::closeStatusFxWindow()
{
	bool wasActive = statusFxFocusedWindowActive;
	statusFxFocusedWindowActive = false;

	StatusEffectQueue[player.playernum].focusedWindowAnim = 0.0;
	if ( statusEffectFocusedWindow )
	{
		statusEffectFocusedWindow->setDisabled(true);
	}
	if ( StatusEffectQueue[player.playernum].statusEffectFrame )
	{
		StatusEffectQueue[player.playernum].statusEffectFrame->setDisabled(false);
	}

	if ( wasActive )
	{
		player.GUI.returnToPreviousActiveModule();
	}
}

void Player::HUD_t::updateStatusEffectFocusedWindow()
{
	if ( !statusEffectFocusedWindow )
	{
		char name[32];
		snprintf(name, sizeof(name), "player statusfx window %d", player.playernum);
		statusEffectFocusedWindow = gameUIFrame[player.playernum]->addFrame(name);
		statusEffectFocusedWindow->setHollow(false);
		statusEffectFocusedWindow->setBorder(0);
		statusEffectFocusedWindow->setOwner(player.playernum);
		statusEffectFocusedWindow->setSize(SDL_Rect{ 0, 0, 0, 0 });
		statusEffectFocusedWindow->setDisabled(true);

		/*auto img = statusEffectFocusedWindow->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, 
			"*#images/ui/HUD/statusfx/background_panel.png", "background");
		img->disabled = false;*/

		auto backgroundFrame = statusEffectFocusedWindow->addFrame("background frame");
		{
			auto heading_txt = backgroundFrame->addField("heading txt", 128);
			heading_txt->setFont("fonts/pixel_maz_multiline.ttf#16#2");
			heading_txt->setText(Language::get(4345));
			heading_txt->setColor(makeColor(255, 255, 255, 255));
			heading_txt->setVJustify(Field::justify_t::CENTER);
			heading_txt->setHJustify(Field::justify_t::CENTER);
			heading_txt->setSize(SDL_Rect{ 16, 2, 256, 30 });
			heading_txt->setColor(hudColors.characterSheetNeutral);

			backgroundFrame->addImage(SDL_Rect{ 24, 0, 0, 30 },
				0xFFFFFFFF, "*#images/ui/Inventory/tooltips/HoverFxMenu_T03.png", skillsheetEffectBackgroundImages[TOP].c_str());
			backgroundFrame->addImage(SDL_Rect{ 0, 0, 24, 30 },
				0xFFFFFFFF, "*#images/ui/Inventory/tooltips/HoverFxMenu_TL03.png", skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
			backgroundFrame->addImage(SDL_Rect{ 0, 0, 24, 30 },
				0xFFFFFFFF, "*#images/ui/Inventory/tooltips/HoverFxMenu_TR03.png", skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
			backgroundFrame->addImage(SDL_Rect{ 24, 30, 0, 12 },
				makeColor(22, 24, 29, 255), 
							"*#images/ui/Inventory/tooltips/HoverFxMenu_C03.png", skillsheetEffectBackgroundImages[MIDDLE].c_str());
			auto ml = backgroundFrame->addImage(SDL_Rect{ 0, 30, 24, 12 },
				0xFFFFFFFF, "*#images/ui/Inventory/tooltips/HoverFxMenu_L03.png", skillsheetEffectBackgroundImages[MIDDLE_LEFT].c_str());
			ml->tiled = true;
			auto mr = backgroundFrame->addImage(SDL_Rect{ 0, 30, 24, 12 },
				0xFFFFFFFF, "*#images/ui/Inventory/tooltips/HoverFxMenu_R03.png", skillsheetEffectBackgroundImages[MIDDLE_RIGHT].c_str());
			mr->tiled = true;

			backgroundFrame->addImage(SDL_Rect{ 24, 96, 0, 14 },
				0xFFFFFFFF, "*#images/ui/Inventory/tooltips/HoverFxMenu_B03.png", skillsheetEffectBackgroundImages[BOTTOM].c_str());
			backgroundFrame->addImage(SDL_Rect{ 0, 96, 24, 14 },
				0xFFFFFFFF, "*#images/ui/Inventory/tooltips/HoverFxMenu_BL03.png", skillsheetEffectBackgroundImages[BOTTOM_LEFT].c_str());
			backgroundFrame->addImage(SDL_Rect{ 0, 96, 24, 14 },
				0xFFFFFFFF, "*#images/ui/Inventory/tooltips/HoverFxMenu_BR03.png", skillsheetEffectBackgroundImages[BOTTOM_RIGHT].c_str());

			auto dismiss = backgroundFrame->addButton("dismiss button");
			dismiss->setSize(SDL_Rect{ 0, 0, 90, 34 });
			dismiss->setColor(makeColor(255, 255, 255, 255));
			dismiss->setHighlightColor(makeColor(255, 255, 255, 255));
			dismiss->setBackground("*#images/ui/Inventory/chests/Button_TakeAll_00.png");
			dismiss->setBackgroundHighlighted("*#images/ui/Inventory/chests/Button_TakeAllHigh_00.png");
			dismiss->setBackgroundActivated("*#images/ui/Inventory/chests/Button_TakeAllPress_00.png");
			dismiss->setText(Language::get(5835));
			dismiss->setFont(smallfont_outline);
			dismiss->setTextHighlightColor(makeColor(201, 162, 100, 255));
			dismiss->setDisabled(true);
			dismiss->setHideGlyphs(true);
			dismiss->setHideKeyboardGlyphs(true);
			dismiss->setMenuConfirmControlType(0);
			dismiss->setHideSelectors(true);
			dismiss->setOntop(true);
			dismiss->setCallback([](Button& button) {
				players[button.getOwner()]->hud.closeStatusFxWindow();
				Player::soundCancel();
			});

			auto noEffectTxt = backgroundFrame->addField("no effect txt", 128);
			noEffectTxt->setFont(smallfont_outline);
			noEffectTxt->setText(Language::get(4346));
			noEffectTxt->setDisabled(true);
			noEffectTxt->setColor(makeColor(255, 255, 255, 255));
			noEffectTxt->setVJustify(Field::justify_t::CENTER);
			noEffectTxt->setHJustify(Field::justify_t::CENTER);
		}

		auto automatonHungerFrame = statusEffectFocusedWindow->addFrame("automaton hunger notification");
		automatonHungerFrame->setHollow(true);
		automatonHungerFrame->setDisabled(true);
		automatonHungerFrame->setSize(SDL_Rect{ 0, 0, 64, 64 });
		auto automaton_flame_img = automatonHungerFrame->addImage(SDL_Rect{ 0, 0, 64, 64 }, 0xFFFFFFFF, "images/system/Hunger_boiler_fire.png", "flame");

		auto notif_frame = statusEffectFocusedWindow->addFrame("notification frame");
		notif_frame->setHollow(true);
		notif_frame->setDisabled(true);
		notif_frame->setSize(SDL_Rect{ 0, 0, 0, 0 });
		auto notif = notif_frame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "images/system/white.png", "notification img");
		notif->disabled = true;
		auto notif_txt = notif_frame->addField("notification txt", 128);
		//notif_txt->setFont("fonts/pixel_maz_multiline.ttf#16#2");
		notif_txt->setFont("fonts/pixelmix.ttf#16#2");
		notif_txt->setText("");
		notif_txt->setDisabled(true);
		notif_txt->setColor(makeColor(255, 255, 255, 255));
		notif_txt->setVJustify(Field::justify_t::CENTER);
		notif_txt->setHJustify(Field::justify_t::CENTER);

		auto innerFrame = statusEffectFocusedWindow->addFrame("effects");
		innerFrame->setHollow(true);
	}

	auto& animBackground = StatusEffectQueue[player.playernum].focusedWindowAnim;
	if ( player.shootmode
		|| player.inventory_mode != INVENTORY_MODE_ITEM
		|| (player.inventoryUI.bCompactView && compactLayoutMode != COMPACT_LAYOUT_INVENTORY) )
	{
		closeStatusFxWindow();
		return;
	}
	/*if ( enableDebugKeys && keystatus[SDLK_g] )
	{
		statusFxFocusedWindowActive = true;
	}*/
	statusEffectFocusedWindow->setDisabled(true);
	if ( StatusEffectQueue[player.playernum].statusEffectFrame && statusFxFocusedWindowActive )
	{
		statusEffectFocusedWindow->setDisabled(false);
		StatusEffectQueue[player.playernum].statusEffectFrame->setDisabled(true);

		Frame* srcFrame = StatusEffectQueue[player.playernum].statusEffectFrame;
		Frame* destFrame = statusEffectFocusedWindow;
		destFrame->setSize(SDL_Rect{ player.camera_virtualx1(),
				player.camera_virtualy1(),
				player.camera_virtualWidth(),
				player.camera_virtualHeight() });

		const int offsetH = 6;

		SDL_Rect destPos = destFrame->getSize();
		destPos.h += offsetH;
		destFrame->setSize(destPos);


		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
		real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - animBackground)) / (2.5);

		animBackground += setpointDiffX;
		animBackground = std::min(1.0, animBackground);

		size_t f = 0;
		for ( auto srcf : srcFrame->getFrames() )
		{
			Frame* destf = destFrame->getFrames()[f];
			if ( !strcmp(destf->getName(), "background frame") )
			{
				++f;
				destf = destFrame->getFrames()[f];
			}

			SDL_Rect srcSize = srcf->getSize();
			srcSize.x += srcFrame->getSize().x;
			srcSize.y += srcFrame->getSize().y;
			destf->setSize(srcSize);
			destf->setDisabled(srcf->isDisabled());

			if ( !strcmp(srcf->getName(), "effects") )
			{
				int numFrameImages = srcf->getImages().size();
				while ( destf->getImages().size() < numFrameImages )
				{
					auto img = destf->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "inner img");
					img->disabled = true;
				}
				while ( destf->getImages().size() > numFrameImages )
				{
					destf->getImages().erase(destf->getImages().begin());
					numFrameImages = destf->getImages().size();
				}
			}

			size_t i = 0;
			for ( auto srcImg : srcf->getImages() )
			{
				auto destImg = destf->getImages()[i];
				destImg->pos = srcImg->pos;
				destImg->path = srcImg->path;
				destImg->disabled = srcImg->disabled;
				++i;
			}

			size_t t = 0;
			for ( auto srcTxt : srcf->getFields() )
			{
				auto destTxt = destf->getFields()[t];
				destTxt->setText(srcTxt->getText());
				destTxt->setSize(srcTxt->getSize());
				destTxt->setDisabled(srcTxt->isDisabled());
				++t;
			}
			++f;
		}

		auto& effectQueue = StatusEffectQueue[player.playernum].effectQueue;
		auto bgFrame = destFrame->findFrame("background frame");
		SDL_Rect bgPos{ 0, 0, 
			std::max(126, StatusEffectQueue[player.playernum].effectsBoundingBox.w), 
			std::max(32, StatusEffectQueue[player.playernum].effectsBoundingBox.y - 
				StatusEffectQueue[player.playernum].effectsBoundingBox.h)};
		if ( effectQueue.size() == 0 )
		{
			bgPos.w = std::max(bgPos.w, 126 + 18);
			bgPos.h = std::max(bgPos.h, 32 + 24);
		}
		{
			bgPos.h += 42;
			bgPos.w += 28;
			int startx = std::max(4, player.hud.hpFrame->getSize().x - 4);
			bgPos.x = -(bgPos.w) + (bgPos.w + startx) * animBackground;
			//bgPos.x = startx;
			bgFrame->setInheritParentFrameOpacity(false);
			bgFrame->setOpacity(animBackground * 100.0);
			bgFrame->setSize(bgPos);

			int maxHeight = bgPos.h;
			int interimHeight = 0;
			{
				auto tl = bgFrame->findImage(skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
				auto tmid = bgFrame->findImage(skillsheetEffectBackgroundImages[TOP].c_str());
				tmid->pos.w = bgPos.w - tl->pos.w * 2;
				auto tr = bgFrame->findImage(skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
				tr->pos.x = tmid->pos.x + tmid->pos.w;

				interimHeight = tmid->pos.y + tmid->pos.h;
				bgPos.w = tr->pos.x + tr->pos.w;
			}
			{
				const int middleOffsetY = 12;
				auto ml = bgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE_LEFT].c_str());
				ml->pos.h = maxHeight - interimHeight - middleOffsetY;
				auto mmid = bgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE].c_str());
				mmid->pos.h = ml->pos.h;
				mmid->pos.w = bgPos.w - (ml->pos.w) * 2;
				mmid->color = hudColors.itemContextMenuOptionImg;
				auto mr = bgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE_RIGHT].c_str());
				mr->pos.h = ml->pos.h;
				mr->pos.x = mmid->pos.x + mmid->pos.w;

				interimHeight = mmid->pos.y + mmid->pos.h;
			}
			{
				auto bl = bgFrame->findImage(skillsheetEffectBackgroundImages[BOTTOM_LEFT].c_str());
				bl->pos.y = interimHeight;
				auto bmid = bgFrame->findImage(skillsheetEffectBackgroundImages[BOTTOM].c_str());
				bmid->pos.y = interimHeight;
				bmid->pos.w = bgPos.w - bl->pos.w * 2;
				auto br = bgFrame->findImage(skillsheetEffectBackgroundImages[BOTTOM_RIGHT].c_str());
				br->pos.y = interimHeight;
				br->pos.x = bmid->pos.x + bmid->pos.w;

				bgPos.h = br->pos.y + br->pos.h;
			}
			bgPos.y = srcFrame->getSize().y + (srcFrame->getSize().h - bgPos.h + offsetH);
			bgPos.y += 4;
			bgFrame->setSize(bgPos);
		}

		auto dismiss = bgFrame->findButton("dismiss button");
		dismiss->setDisabled(true);
		auto noEffectTxt = bgFrame->findField("no effect txt");
		noEffectTxt->setDisabled(true);
		if ( effectQueue.size() == 0 )
		{
			dismiss->setDisabled(false);
			noEffectTxt->setDisabled(false);
		}
		if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
		{
			if ( Input::inputs[player.playernum].binaryToggle("MenuLeftClick") && inputs.bPlayerUsingKeyboardControl(player.playernum) )
			{
				Input::inputs[player.playernum].consumeBinaryToggle("MenuLeftClick");
				if ( !bgFrame->capturesMouse() )
				{
					closeStatusFxWindow();
					Player::soundCancel();
					return;
				}
			}
		}
		else
		{
			if ( StatusEffectQueue[player.playernum].statusEffectTooltipFrame )
			{
				SDL_Rect tooltipPos = StatusEffectQueue[player.playernum].statusEffectTooltipFrame->getSize();

				SDL_Rect tooltipAbsoluteSize = StatusEffectQueue[player.playernum].statusEffectTooltipFrame->getAbsoluteSize();
				SDL_Rect bgAbsoluteSize = bgFrame->getAbsoluteSize();

				int positionDiffX = tooltipAbsoluteSize.x;
				positionDiffX -= (bgAbsoluteSize.x + bgAbsoluteSize.w + 4);
				int positionDiffY = tooltipAbsoluteSize.y;
				positionDiffY -= (bgAbsoluteSize.y);

				tooltipPos.x = std::max(tooltipPos.x, tooltipPos.x - positionDiffX);
				tooltipPos.y -= positionDiffY;
				int overflow = tooltipPos.y + tooltipPos.h - player.camera_virtualy2();
				if ( overflow > 0 )
				{
					tooltipPos.y -= overflow;
				}

				StatusEffectQueue[player.playernum].statusEffectTooltipFrame->setSize(tooltipPos);
			}
		}

		if ( inputs.hasController(player.playernum) )
		{
			if ( Input::inputs[player.playernum].binaryToggle("MenuCancel")
				|| Input::inputs[player.playernum].binaryToggle("MenuConfirm") )
			{
				Input::inputs[player.playernum].consumeBinaryToggle("MenuCancel");
				Input::inputs[player.playernum].consumeBinaryToggle("MenuConfirm");
				closeStatusFxWindow();
				Player::soundCancel();
				return;
			}
		}

		if ( player.GUI.bModuleAccessibleWithMouse(Player::GUI_t::MODULE_STATUS_EFFECTS) )
		{
			if ( (dismiss->isHighlighted() || !inputs.getVirtualMouse(player.playernum)->draw_cursor )
				&& !dismiss->isDisabled() && animBackground >= 0.99 )
			{
				player.GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_STATUS_EFFECTS);
				if ( player.GUI.activeModule != Player::GUI_t::MODULE_STATUS_EFFECTS )
				{
					player.GUI.activateModule(Player::GUI_t::MODULE_STATUS_EFFECTS);
				}
				SDL_Rect pos = dismiss->getAbsoluteSize();
				// make sure to adjust absolute size to camera viewport
				pos.x -= player.camera_virtualx1();
				pos.y -= player.camera_virtualy1();
				
				player.hud.setCursorDisabled(false);
				player.hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, inputs.getVirtualMouse(player.playernum)->draw_cursor);
			}
		}

		{
			SDL_Rect btnSize = dismiss->getSize();
			dismiss->setSize(SDL_Rect{ bgPos.w / 2 - btnSize.w / 2,
				bgPos.h - btnSize.h - 8, btnSize.w, btnSize.h });
			SDL_Rect txtSize = noEffectTxt->getSize();
			txtSize.w = bgPos.w;
			txtSize.h = 24;
			txtSize.x = 0;
			txtSize.y = btnSize.y - 24;
			if ( txtSize.y % 2 == 1 )
			{
				txtSize.y--;
			}

			auto heading_txt = bgFrame->findField("heading txt");
			SDL_Rect headerTxtSize = heading_txt->getSize();
			headerTxtSize.w = bgPos.w;
			headerTxtSize.x = 0;
			heading_txt->setSize(headerTxtSize);

			noEffectTxt->setSize(txtSize);
			dismiss->setInvisible(dismiss->isDisabled());
		}
	}
	else
	{
		closeStatusFxWindow();
		return;
	}

	if ( player.hud.hudFrame && player.hud.hudFrame->isDisabled() )
	{
		closeStatusFxWindow();
		return;
	}
	return;
	//Frame* fxFrame = nullptr;
	//if ( !statusEffectFocusedWindow )
	//{
	//	char name[32];
	//	snprintf(name, sizeof(name), "player statusfx window %d", player.playernum);
	//	statusEffectFocusedWindow = gameUIFrame[player.playernum]->addFrame(name);
	//	Frame* frame = statusEffectFocusedWindow;
	//	frame->setHollow(false);
	//	frame->setDisabled(true);
	//	frame->setInheritParentFrameOpacity(true);
	//	frame->setBorder(0);
	//	frame->setOwner(player.playernum);
	//	frame->setSize(SDL_Rect{ 0, 0, 0, 0 });

	//	{
	//		Uint32 color = makeColor(255, 255, 255, 255);
	//		frame->addImage(SDL_Rect{ 0, 0, 6, 6 },
	//			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_TL03.png", skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
	//		frame->addImage(SDL_Rect{ 0, 0, 6, 6 },
	//			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_TR03.png", skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
	//		frame->addImage(SDL_Rect{ 0, 0, 6, 6 },
	//			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_T03.png", skillsheetEffectBackgroundImages[TOP].c_str());
	//		frame->addImage(SDL_Rect{ 0, 0, 6, 6 },
	//			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_L03.png", skillsheetEffectBackgroundImages[MIDDLE_LEFT].c_str());
	//		frame->addImage(SDL_Rect{ 0, 0, 6, 6 },
	//			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_R03.png", skillsheetEffectBackgroundImages[MIDDLE_RIGHT].c_str());
	//		frame->addImage(SDL_Rect{ 0, 0, 6, 6 },
	//			makeColor(22, 24, 29, 255), "*#images/ui/Inventory/tooltips/HoverItemMenu_C03.png", skillsheetEffectBackgroundImages[MIDDLE].c_str());
	//		frame->addImage(SDL_Rect{ 0, 0, 6, 6 },
	//			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_BL03.png", skillsheetEffectBackgroundImages[BOTTOM_LEFT].c_str());
	//		frame->addImage(SDL_Rect{ 0, 0, 6, 6 },
	//			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_BR03.png", skillsheetEffectBackgroundImages[BOTTOM_RIGHT].c_str());
	//		frame->addImage(SDL_Rect{ 0, 0, 6, 6 },
	//			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_B03.png", skillsheetEffectBackgroundImages[BOTTOM].c_str());
	//		imageSetWidthHeight9x9(frame, skillsheetEffectBackgroundImages);

	//		auto heading_txt = frame->addField("heading txt", 128);
	//		heading_txt->setFont("fonts/pixel_maz_multiline.ttf#16#2");
	//		heading_txt->setText("Status Effects");
	//		heading_txt->setColor(makeColor(255, 255, 255, 255));
	//		heading_txt->setVJustify(Field::justify_t::CENTER);
	//		heading_txt->setHJustify(Field::justify_t::LEFT);
	//		/*
	//		auto desc_txt = tooltipFrame->addField("desc txt", 1024);
	//		desc_txt->setFont("fonts/pixel_maz_multiline.ttf#16#2");
	//		desc_txt->setText("");
	//		desc_txt->setColor(makeColor(0, 192, 255, 255));
	//		desc_txt->setVJustify(Field::justify_t::LEFT);
	//		desc_txt->setHJustify(Field::justify_t::LEFT);*/
	//	}

	//	auto automatonBgFrame = frame->addFrame("automaton bg");
	//	automatonBgFrame->setSize(SDL_Rect{ 0, 0, 64, 64 });
	//	automatonBgFrame->setDisabled(true);
	//	automatonBgFrame->addImage(SDL_Rect{ 0, 0, 64, 64 }, 0xFFFFFFFF, "", "flame");

	//	fxFrame = frame->addFrame("effects");
	//}
	//else
	//{
	//	fxFrame = statusEffectFocusedWindow->findFrame("effects");
	//}

	//bool rebuildWindow = true;
	//if ( keystatus[SDLK_g] )
	//{
	//	keystatus[SDLK_g] = 0;
	//	if ( statusEffectFocusedWindow->isDisabled() )
	//	{
	//		statusEffectFocusedWindow->setDisabled(false);
	//		rebuildWindow = true;
	//	}
	//	else
	//	{
	//		statusEffectFocusedWindow->setDisabled(true);
	//	}
	//}

	//if ( rebuildWindow && StatusEffectQueue[player.playernum].statusEffectFrame )
	//{
	//	statusEffectFocusedWindow->setDisabled(false);
	//	auto& effectQueue = StatusEffectQueue[player.playernum].effectQueue;
	//	auto& notificationQueue = StatusEffectQueue[player.playernum].notificationQueue;
	//	auto statusFx = StatusEffectQueue[player.playernum].statusEffectFrame->findFrame("effects");

	//	statusEffectFocusedWindow->setSize(statusFx->getSize());
	//	fxFrame->setSize(statusFx->getSize());

	//	int numFrameImages = fxFrame->getImages().size();
	//	while ( effectQueue.size() > numFrameImages )
	//	{
	//		auto img = fxFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "inner img");
	//		img->disabled = true;
	//		numFrameImages = fxFrame->getImages().size();
	//	}
	//	while ( effectQueue.size() < numFrameImages )
	//	{
	//		fxFrame->getImages().erase(fxFrame->getImages().begin());
	//		numFrameImages = fxFrame->getImages().size();
	//	}
	//	auto& frameImages = fxFrame->getImages();
	//	for ( auto img : frameImages )
	//	{
	//		img->disabled = true;
	//	}

	//	auto automatonHungerFrame = statusEffectFocusedWindow->findFrame("automaton bg");
	//	auto flameImg = automatonHungerFrame->findImage("flame");
	//	automatonHungerFrame->setDisabled(true);
	//	auto frameImagesIterator = frameImages.begin();
	//	auto srcFrameImagesIterator = statusFx->getImages().begin();
	//	size_t index = 0;
	//	SDL_Rect windowSizeLimitMin{ 0, 0, 0, 0 };
	//	SDL_Rect windowSizeLimitMax{ 0, 0, 0, 0 };
	//	for ( auto it = effectQueue.rbegin(); it != effectQueue.rend(); )
	//	{
	//		auto& q = (*it);
	//		Frame::image_t* frameImg = nullptr;
	//		Frame::image_t* srcFrameImg = nullptr;
	//		if ( frameImagesIterator != frameImages.end() )
	//		{
	//			frameImg = *frameImagesIterator;
	//		}
	//		if ( srcFrameImagesIterator != statusFx->getImages().end() )
	//		{
	//			srcFrameImg = *srcFrameImagesIterator;
	//		}

	//		bool existsInNotifications = false;
	//		for ( auto it2 = notificationQueue.begin(); it2 != notificationQueue.end(); ++it2 )
	//		{
	//			if ( (*it2).effect == q.effect )
	//			{
	//				existsInNotifications = true;
	//				break;
	//			}
	//		}

	//		StatusEffectQueue[player.playernum].updateEntryImage(q, frameImg);
	//		frameImg->pos.x = q.animateSetpointX;
	//		frameImg->pos.y = q.animateSetpointY;
	//		frameImg->disabled = (srcFrameImg && !existsInNotifications) ? srcFrameImg->disabled : false;

	//		if ( windowSizeLimitMin.x == 0 && index == 0 )
	//		{
	//			windowSizeLimitMin.x = frameImg->pos.x;
	//		}
	//		else
	//		{
	//			windowSizeLimitMin.x = std::min(frameImg->pos.x, windowSizeLimitMin.x);
	//		}
	//		if ( windowSizeLimitMin.y == 0 && index == 0 )
	//		{
	//			windowSizeLimitMin.y = frameImg->pos.y;
	//		}
	//		else
	//		{
	//			windowSizeLimitMin.y = std::min(frameImg->pos.y, windowSizeLimitMin.y);
	//		}
	//		windowSizeLimitMax.x = std::max(frameImg->pos.x + frameImg->pos.w, windowSizeLimitMax.x);
	//		windowSizeLimitMax.y = std::max(frameImg->pos.y + frameImg->pos.h, windowSizeLimitMax.y);

	//		if ( q.effect == StatusEffectQueue_t::kEffectAutomatonHunger )
	//		{
	//			auto srcFrame = StatusEffectQueue[player.playernum].statusEffectFrame->findFrame("automaton hunger notification");
	//			automatonHungerFrame->setDisabled(srcFrame->isDisabled());

	//			SDL_Rect pos = srcFrame->getSize();
	//			pos.x = q.animateSetpointX;
	//			pos.y = q.animateSetpointY;

	//			int heightDiff = q.getEffectSpriteNormalHeight() - pos.h;
	//			pos.y += heightDiff;

	//			automatonHungerFrame->setSize(pos);

	//			auto srcImg = srcFrame->findImage("flame");
	//			flameImg->pos = SDL_Rect{ 0, -heightDiff, q.getEffectSpriteNormalWidth(), q.getEffectSpriteNormalHeight() };
	//			flameImg->path = srcImg->path;
	//			flameImg->disabled = !existsInNotifications ? srcImg->disabled : false;
	//		}

	//		++it;
	//		if ( frameImagesIterator != frameImages.end() )
	//		{
	//			++frameImagesIterator;
	//		}
	//		if ( srcFrameImagesIterator != statusFx->getImages().end() )
	//		{
	//			++srcFrameImagesIterator;
	//		}
	//		++index;
	//	}

	//	// rearrange icons to fit size
	//	{
	//		int borderX = 16;
	//		int borderY = 32;
	//		int bodyW = windowSizeLimitMax.x - windowSizeLimitMin.x;
	//		int bodyH = windowSizeLimitMax.y - windowSizeLimitMin.y;
	//		fxFrame->setSize(SDL_Rect{ borderX, borderY, bodyW, bodyH });
	//		for ( auto img : frameImages )
	//		{
	//			img->pos.x -= (windowSizeLimitMin.x);
	//			img->pos.y -= (windowSizeLimitMin.y);
	//		}
	//		SDL_Rect automatonHungerFramePos = automatonHungerFrame->getSize();
	//		automatonHungerFramePos.x += borderX;
	//		automatonHungerFramePos.y += borderY;
	//		automatonHungerFramePos.x -= (windowSizeLimitMin.x);
	//		automatonHungerFramePos.y -= (windowSizeLimitMin.y);
	//		automatonHungerFrame->setSize(automatonHungerFramePos);

	//		SDL_Rect windowPos{ 0, 0, borderX * 2 + bodyW, borderY + bodyH + 16 };
	//		statusEffectFocusedWindow->setSize(windowPos);
	//		imageResizeToContainer9x9(statusEffectFocusedWindow, SDL_Rect{ 0, 0, windowPos.w, windowPos.h },
	//			skillsheetEffectBackgroundImages);

	//		auto heading_txt = statusEffectFocusedWindow->findField("heading txt");
	//		heading_txt->setSize(SDL_Rect{4, 4, windowPos.w - 4 * 2, 24});
	//	}
	//}
}

void StatusEffectQueue_t::animateStatusEffectTooltip(bool showTooltip)
{
	if ( !statusEffectTooltipFrame )
	{
		return;
	}
	auto tooltipFrame = statusEffectTooltipFrame;
	if ( static_cast<int>(tooltipFrame->getOpacity()) != tooltipOpacitySetpoint )
	{
		const real_t fpsScale = getFPSScale(144.0);
		if ( tooltipOpacitySetpoint == 0 )
		{
			if ( !inputs.getVirtualMouse(player)->draw_cursor )
			{
				tooltipOpacityAnimate = 0.0;
			}
			else
			{
				if ( ticks - tooltipDeselectedTick > 5 )
				{
					real_t factor = 10.0;
					real_t setpointDiff = fpsScale * std::max(.05, (tooltipOpacityAnimate)) / (factor);
					tooltipOpacityAnimate -= setpointDiff;
					tooltipOpacityAnimate = std::max(0.0, tooltipOpacityAnimate);
				}
			}
		}
		else
		{
			real_t setpointDiff = fpsScale * std::max(.05, (1.0 - tooltipOpacityAnimate)) / (1);
			tooltipOpacityAnimate += setpointDiff;
			tooltipOpacityAnimate = std::min(1.0, tooltipOpacityAnimate);
		}
		tooltipFrame->setOpacity(tooltipOpacityAnimate * 100);
	}
	else
	{
		tooltipFrame->setOpacity(tooltipOpacitySetpoint);
	}

	if ( players[player]->hud.hudFrame && players[player]->hud.hudFrame->isDisabled() )
	{
		tooltipFrame->setDisabled(true);
	}

	if ( tooltipFrame->isDisabled() || !showTooltip )
	{
		tooltipShowingEffectID = -1;
		tooltipShowingEffectVariable = -1;
		return;
	}

	tooltipOpacitySetpoint = 0;
	tooltipOpacityAnimate = 1.0;
	tooltipFrame->setDisabled(false);
	tooltipFrame->setOpacity(100.0);
	tooltipDeselectedTick = ticks;
}

bool StatusEffectQueue_t::doStatusEffectTooltip(StatusEffectQueueEntry_t& entry, SDL_Rect pos)
{
	auto tooltipFrame = statusEffectTooltipFrame;
	if ( !tooltipFrame )
	{
		return false;
	}
	auto tooltipHeader = tooltipFrame->findField("heading txt");
	tooltipHeader->setColor(StatusEffectDefinitions_t::tooltipHeadingColor);
	auto tooltipDesc = tooltipFrame->findField("desc txt");
	tooltipDesc->setColor(StatusEffectDefinitions_t::tooltipDescColor);
	int fontHeight = Font::get(tooltipDesc->getFont())->height(true);
	int tooltipInnerWidth = 200;

	bool refreshTooltip = (tooltipShowingEffectID != entry.effect) || (tooltipShowingEffectVariable != entry.customVariable);
	if ( refreshTooltip )
	{
		if ( entry.effect >= StatusEffectQueue_t::kSpellEffectOffset )
		{
			int effectID = entry.effect - StatusEffectQueue_t::kSpellEffectOffset;
			if ( StatusEffectQueue_t::StatusEffectDefinitions_t::sustainedSpellDefinitionExists(effectID) )
			{
				auto& definition = StatusEffectQueue_t::StatusEffectDefinitions_t::getSustainedSpell(effectID);
				if ( effectID == SPELL_SHADOW_TAG )
				{
					int variation = 2;
					if ( players[player] && players[player]->entity )
					{
						if ( players[player]->entity->creatureShadowTaggedThisUid != 0
							&& uidToEntity(players[player]->entity->creatureShadowTaggedThisUid) )
						{
							variation = 1;
							std::string formatString = definition.getName(variation).c_str();
							char buf[256] = "";
							Entity* tagged = uidToEntity(players[player]->entity->creatureShadowTaggedThisUid);
							if ( tagged->behavior == &actMonster )
							{
								int type = tagged->getMonsterTypeFromSprite();
								if ( type != NOTHING )
								{
									snprintf(buf, sizeof(buf), formatString.c_str(), getMonsterLocalizedName((Monster)type).c_str());
								}
								else
								{
									strcpy(buf, "");
								}
							}
							else if ( tagged->behavior == &actPlayer )
							{
								snprintf(buf, sizeof(buf), formatString.c_str(), stats[tagged->skill[2]]->name);
							}
							std::string formattedName = buf;
							uppercaseString(formattedName);
							tooltipHeader->setText(formattedName.c_str());
						}
					}
					if ( variation == 2 )
					{
						std::string newHeader = definition.getName(variation).c_str();
						uppercaseString(newHeader);
						tooltipHeader->setText(newHeader.c_str());
					}
					tooltipDesc->setText(definition.getDesc(-1).c_str()); // always -1 default desc
					tooltipInnerWidth = definition.tooltipWidth;
				}
				else
				{
					int variation = -1;
					std::string newHeader = definition.getName(variation).c_str();
					uppercaseString(newHeader);
					tooltipHeader->setText(newHeader.c_str());
					tooltipDesc->setText(definition.getDesc(variation).c_str());
					tooltipInnerWidth = definition.tooltipWidth;
				}
			}
		}
		else
		{
			int effectID = entry.effect;
			if ( StatusEffectQueue_t::StatusEffectDefinitions_t::effectDefinitionExists(effectID) )
			{
				auto& definition = StatusEffectQueue_t::StatusEffectDefinitions_t::getEffect(effectID);
				int variation = -1;
				if ( effectID == EFF_SHAPESHIFT )
				{
					if ( players[player] && players[player]->entity )
					{
						switch ( players[player]->entity->effectShapeshift )
						{
							case RAT:
								variation = 0;
								break;
							case SPIDER:
								variation = 1;
								break;
							case TROLL:
								variation = 2;
								break;
							case CREATURE_IMP:
								variation = 3;
								break;
							default:
								break;
						}
					}
				}
				else if ( effectID == EFF_VAMPIRICAURA )
				{
					bool sustained = false;
					for ( node_t* node = channeledSpells[player].first; node != nullptr; node = node->next )
					{
						spell_t* spell = (spell_t*)node->element;
						if ( spell && spell->ID == SPELL_VAMPIRIC_AURA )
						{
							sustained = true;
							break;
						}
					}
					if ( sustained )
					{
						variation = 1;
					}
					else
					{
						variation = 0;
					}
				}
				else if ( effectID == StatusEffectQueue_t::kEffectBread
					|| effectID == StatusEffectQueue_t::kEffectBloodHunger )
				{
					if ( entry.customVariable >= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_OVERSATIATED) )
					{
						variation = 0;
					}
					else if ( entry.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_STARVING) )
					{
						variation = 3;
					}
					else if ( entry.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_WEAK) )
					{
						variation = 2;
					}
					else if ( entry.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_HUNGRY) )
					{
						variation = 1;
					}
				}
				else if ( effectID == StatusEffectQueue_t::kEffectAutomatonHunger )
				{
					int nameVariation = 1;
					int descVariation = 1;
					if ( entry.customVariable >= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_AUTOMATON_SUPERHEATED) )
					{
						nameVariation = 3;
						descVariation = 0;
					}
					else if ( entry.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_AUTOMATON_CRITICAL) )
					{
						nameVariation = 5;
						if ( svFlags & SV_FLAG_HUNGER )
						{
							descVariation = 2;
						}
						else
						{
							descVariation = 3;
						}
					}
					else
					{
						nameVariation = 4;
						descVariation = 1;
					}

					std::string newHeader = definition.getName(nameVariation).c_str();
					uppercaseString(newHeader);
					tooltipHeader->setText(newHeader.c_str());
					tooltipDesc->setText(definition.getDesc(descVariation).c_str());
					tooltipInnerWidth = definition.tooltipWidth;
				}
				else if ( effectID == StatusEffectQueue_t::kEffectWanted
					|| effectID == StatusEffectQueue_t::kEffectWantedInShop )
				{
					auto& definition2 = StatusEffectQueue_t::StatusEffectDefinitions_t::getEffect(kEffectWanted);
					std::string newHeader = definition2.getName(variation).c_str();
					uppercaseString(newHeader);
					tooltipHeader->setText(newHeader.c_str());
					tooltipDesc->setText("");
					tooltipInnerWidth = definition.tooltipWidth;
					if ( auto h = ShopkeeperPlayerHostility.getPlayerHostility(player) )
					{
						char buf[128];
						memset(buf, 0, sizeof(buf));
						snprintf(buf, sizeof(buf), definition.getDesc(0).c_str(), getMonsterLocalizedName(h->playerRace).c_str());
						std::string descStr = buf;
						if ( h->wantedLevel == ShopkeeperPlayerHostility.FAILURE_TO_IDENTIFY )
						{
							if ( descStr != "" ) { descStr += '\n'; }
							descStr += definition.getDesc(4);
						}
						if ( h->numKills > 0 )
						{
							//snprintf(buf, sizeof(buf), definition.getDesc(1).c_str(), h->numKills);
							if ( descStr != "" ) { descStr += '\n'; }
							//descStr += buf;
							descStr += definition.getDesc(1);
						}
						if ( h->numAggressions > 0 )
						{
							//snprintf(buf, sizeof(buf), definition.getDesc(2).c_str(), h->numAggressions);
							if ( descStr != "" ) { descStr += '\n'; }
							//descStr += buf;
							descStr += definition.getDesc(2);
						}
						if ( h->numAccessories > 0 )
						{
							//snprintf(buf, sizeof(buf), definition.getDesc(3).c_str(), h->numAccessories);
							if ( descStr != "" ) { descStr += '\n'; }
							//descStr += buf;
							descStr += definition.getDesc(3);
						}
						tooltipDesc->setText(descStr.c_str());
					}
				}
				else if ( effectID == StatusEffectQueue_t::kEffectDisabledHPRegen )
				{
					variation = 0;
					if ( !(svFlags & SV_FLAG_HUNGER) )
					{
						variation = 1;
					}

					std::string newHeader = definition.getName(-1).c_str();
					uppercaseString(newHeader);
					tooltipHeader->setText(newHeader.c_str());
					tooltipDesc->setText(definition.getDesc(variation).c_str());
					tooltipInnerWidth = definition.tooltipWidth;
				}
				else if ( effectID == StatusEffectQueue_t::kEffectBountyTarget )
				{
					std::string newHeader = definition.getName(1).c_str();
					uppercaseString(newHeader);
					tooltipHeader->setText(newHeader.c_str());
					tooltipDesc->setText(definition.getDesc(variation).c_str());
					tooltipInnerWidth = definition.tooltipWidth;
				}

				if ( effectID != StatusEffectQueue_t::kEffectAutomatonHunger
					&& effectID != StatusEffectQueue_t::kEffectWanted
					&& effectID != StatusEffectQueue_t::kEffectWantedInShop
					&& effectID != StatusEffectQueue_t::kEffectBountyTarget
					&& effectID != StatusEffectQueue_t::kEffectDisabledHPRegen )
				{
					std::string newHeader = definition.getName(variation).c_str();
					uppercaseString(newHeader);
					tooltipHeader->setText(newHeader.c_str());
					tooltipDesc->setText(definition.getDesc(variation).c_str());
					tooltipInnerWidth = definition.tooltipWidth;
				}
			}
		}
	}
	else
	{
		if ( entry.effect >= StatusEffectQueue_t::kSpellEffectOffset )
		{
			int effectID = entry.effect - StatusEffectQueue_t::kSpellEffectOffset;
			if ( StatusEffectQueue_t::StatusEffectDefinitions_t::sustainedSpellDefinitionExists(effectID) )
			{
				auto& definition = StatusEffectQueue_t::StatusEffectDefinitions_t::getSustainedSpell(effectID);
				tooltipInnerWidth = definition.tooltipWidth;
			}
		}
		else
		{
			int effectID = entry.effect;
			if ( StatusEffectQueue_t::StatusEffectDefinitions_t::effectDefinitionExists(effectID) )
			{
				auto& definition = StatusEffectQueue_t::StatusEffectDefinitions_t::getEffect(effectID);
				tooltipInnerWidth = definition.tooltipWidth;
			}
		}
	}

	tooltipInnerWidth = std::max(tooltipInnerWidth, (int)tooltipHeader->getTextObject()->getWidth() + (tooltipHeader->getSize().x * 2));

	const int padx = 16;
	const int pady1 = 4;
	tooltipHeader->setSize(SDL_Rect{ padx, pady1, tooltipInnerWidth, fontHeight + 4 });

	auto descPos = tooltipDesc->getSize();
	descPos.w = tooltipInnerWidth;
	tooltipDesc->setSize(descPos);
	if ( refreshTooltip )
	{
		tooltipDesc->reflowTextToFit(0);
	}

	const int pady2 = 6;
	descPos.x = padx + 4;
	descPos.y = tooltipHeader->getSize().y + tooltipHeader->getSize().h + pady2;
	descPos.h = tooltipDesc->getNumTextLines() * fontHeight + 4;
	tooltipDesc->setSize(descPos);

	tooltipFrame->setDisabled(false);
	SDL_Rect tooltipPos;
	tooltipPos.w = tooltipInnerWidth + padx * 2;
	tooltipPos.h = tooltipHeader->getSize().y + tooltipHeader->getSize().h + pady2 + descPos.h + 8;
	tooltipPos.x = pos.x + pos.w;
	tooltipPos.y = pos.y - tooltipPos.h - 8;
	tooltipPos.y = std::max(0, tooltipPos.y);
	tooltipFrame->setSize(tooltipPos);
	imageResizeToContainer9x9(tooltipFrame, SDL_Rect{0, 0, tooltipPos.w, tooltipPos.h}, skillsheetEffectBackgroundImages);
	tooltipShowingEffectID = entry.effect;
	tooltipShowingEffectVariable = entry.customVariable;
	return true;
}

const int StatusEffectQueue_t::kEffectBread = -2;
const int StatusEffectQueue_t::kEffectBloodHunger = -3;
const int StatusEffectQueue_t::kEffectAutomatonHunger = -4;
const int StatusEffectQueue_t::kEffectWanted = -5;
const int StatusEffectQueue_t::kEffectWantedInShop = -6;
const int StatusEffectQueue_t::kEffectBurning = -7;
const int StatusEffectQueue_t::kEffectFreeAction = -8;
const int StatusEffectQueue_t::kEffectLesserWarning = -9;
const int StatusEffectQueue_t::kEffectDisabledHPRegen = -10;
const int StatusEffectQueue_t::kEffectResistBurning = -11;
const int StatusEffectQueue_t::kEffectResistPoison = -12;
const int StatusEffectQueue_t::kEffectSlowDigestion = -13;
const int StatusEffectQueue_t::kEffectStrangulation = -14;
const int StatusEffectQueue_t::kEffectWarning = -15;
const int StatusEffectQueue_t::kEffectWaterBreathing = -16;
const int StatusEffectQueue_t::kEffectConflict = -17;
const int StatusEffectQueue_t::kEffectWaterWalking = -18;
const int StatusEffectQueue_t::kEffectLifesaving = -19;
const int StatusEffectQueue_t::kEffectPush = -20;
const int StatusEffectQueue_t::kEffectSneak = -21;
const int StatusEffectQueue_t::kEffectDrunkGoatman = -22;
const int StatusEffectQueue_t::kEffectBountyTarget = -23;
const int StatusEffectQueue_t::kEffectInspiration = -24;
const int StatusEffectQueue_t::kEffectRetaliation = -25;
const int StatusEffectQueue_t::kSpellEffectOffset = 10000;

Frame* StatusEffectQueue_t::getStatusEffectFrame()
{
	return statusEffectFrame;
}

void StatusEffectQueue_t::handleNavigation(std::map<int, StatusEffectQueueEntry_t*>& grid, 
	bool& tooltipShowing, const bool hungerEffectInEffectQueue)
{
	if ( !inputs.hasController(player) 
		|| inputs.getVirtualMouse(player)->draw_cursor 
		|| players[player]->shootmode )
	{
		return;
	}

	if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_STATUS_EFFECTS
		&& players[player]->GUI.activeModule == Player::GUI_t::MODULE_INVENTORY )
	{
		
	}

	if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_STATUS_EFFECTS )
	{
		return;
	}

	if ( effectQueue.size() == 0 )
	{
		return;
	}


	StatusEffectQueueEntry_t::Dir_t inputDirection = StatusEffectQueueEntry_t::Dir_t::NONE;
	if ( Input::inputs[player].consumeBinaryToggle("InventoryMoveUp") )
	{
		inputDirection = StatusEffectQueueEntry_t::Dir_t::UP;
	}
	if ( Input::inputs[player].consumeBinaryToggle("InventoryMoveUpAnalog") )
	{
		inputDirection = StatusEffectQueueEntry_t::Dir_t::UP;
	}
	if ( Input::inputs[player].consumeBinaryToggle("InventoryMoveDown") )
	{
		inputDirection = StatusEffectQueueEntry_t::Dir_t::DOWN;
	}
	if ( Input::inputs[player].consumeBinaryToggle("InventoryMoveDownAnalog") )
	{
		inputDirection = StatusEffectQueueEntry_t::Dir_t::DOWN;
	}
	if ( Input::inputs[player].consumeBinaryToggle("InventoryMoveLeft") )
	{
		inputDirection = StatusEffectQueueEntry_t::Dir_t::LEFT;
	}
	if ( Input::inputs[player].consumeBinaryToggle("InventoryMoveLeftAnalog") )
	{
		inputDirection = StatusEffectQueueEntry_t::Dir_t::LEFT;
	}
	if ( Input::inputs[player].consumeBinaryToggle("InventoryMoveRight") )
	{
		inputDirection = StatusEffectQueueEntry_t::Dir_t::RIGHT;
	}
	if ( Input::inputs[player].consumeBinaryToggle("InventoryMoveRightAnalog") )
	{
		inputDirection = StatusEffectQueueEntry_t::Dir_t::RIGHT;
	}

	selectedElement = std::max(0, selectedElement);
	selectedElement = std::min(selectedElement, (int)(effectQueue.size() - 1));

	StatusEffectQueueEntry_t* selectedEntry = nullptr;

	int miny = 10;
	int maxy = 0;
	std::vector<int>minx;
	std::vector<int>maxx;
	for ( int i = 0; i < 32; ++i )
	{
		maxx.push_back(0);
		minx.push_back(32);
	}
	for ( auto& slot : grid )
	{
		int x = slot.first % 10000;
		int y = slot.first / 10000;

		miny = std::min(y, miny);
		maxy = std::max(y, maxy);
		minx[y] = std::min(x, minx[y]);
		maxx[y] = std::max(x, maxx[y]);
	}

	// clear navigation graph
	for ( auto& q : effectQueue )
	{
		q.navigation.clear();
	}

	for ( auto& slot : grid )
	{
		int x = slot.first % 10000;
		int y = slot.first / 10000;

		if ( slot.second->index == (size_t)selectedElement )
		{
			selectedEntry = slot.second;
		}

		if ( grid.find((x + 1) + y * 10000) != grid.end() )
		{
			auto dest = grid[(x + 1) + y * 10000];
			slot.second->navigation[StatusEffectQueueEntry_t::Dir_t::RIGHT] = dest->index;
		}
		else
		{
			if ( hungerEffectInEffectQueue )
			{
				auto dest = grid[0 + 0 * 10000];
				slot.second->navigation[StatusEffectQueueEntry_t::Dir_t::RIGHT] = dest->index;
			}
			else
			{
				auto dest = grid[(minx[y]) + y * 10000];
				slot.second->navigation[StatusEffectQueueEntry_t::Dir_t::RIGHT] = dest->index;
			}
		}
		if ( grid.find((x - 1) + y * 10000) != grid.end() )
		{
			auto dest = grid[(x - 1) + y * 10000];
			slot.second->navigation[StatusEffectQueueEntry_t::Dir_t::LEFT] = dest->index;
		}
		else
		{
			if ( hungerEffectInEffectQueue && !(x == 0 && y == 0) )
			{
				auto dest = grid[0 + 0 * 10000];
				slot.second->navigation[StatusEffectQueueEntry_t::Dir_t::LEFT] = dest->index;
			}
			else
			{
				auto dest = grid[maxx[y] + y * 10000];
				slot.second->navigation[StatusEffectQueueEntry_t::Dir_t::LEFT] = dest->index;
			}
		}
		if ( grid.find(x + (y + 1) * 10000) != grid.end() )
		{
			auto dest = grid[x + (y + 1) * 10000];
			slot.second->navigation[StatusEffectQueueEntry_t::Dir_t::UP] = dest->index;
		}
		else
		{
			int destx = std::min(std::max(x, minx[0]), maxx[0]);
			auto dest = grid[destx + (0) * 10000];
			slot.second->navigation[StatusEffectQueueEntry_t::Dir_t::UP] = dest->index;
		}
		if ( grid.find(x + (y - 1) * 10000) != grid.end() )
		{
			auto dest = grid[x + (y - 1) * 10000];
			slot.second->navigation[StatusEffectQueueEntry_t::Dir_t::DOWN] = dest->index;
		}
		else
		{
			int desty = maxy;
			while ( desty > 0 )
			{
				if ( grid.find(x + (desty) * 10000) != grid.end() )
				{
					auto dest = grid[x + (desty) * 10000];
					slot.second->navigation[StatusEffectQueueEntry_t::Dir_t::DOWN] = dest->index;
					break;
				}
				--desty;
			}
		}
	}

	if ( selectedEntry && inputDirection != StatusEffectQueueEntry_t::Dir_t::NONE )
	{
		auto findIndex = selectedEntry->navigation.find(inputDirection);
		if ( findIndex != selectedEntry->navigation.end() )
		{
			selectedElement = (*findIndex).second;
			Player::soundMovement();
		}
	}

	auto innerFrame = statusEffectFrame->findFrame("effects");
	auto& frameImages = innerFrame->getImages();
	auto frameImagesIterator = frameImages.begin();
	for ( auto it = effectQueue.rbegin(); it != effectQueue.rend(); )
	{
		auto& q = (*it);

		Frame::image_t* frameImg = nullptr;
		if ( frameImagesIterator != frameImages.end() )
		{
			frameImg = *frameImagesIterator;
		}

		if ( q.index == selectedElement )
		{
			SDL_Rect size = statusEffectFrame->getAbsoluteSize();
			int mouseDetectionPadding = 2;

			SDL_Rect frameImgPos = frameImg->pos;
			bool oldDisabled = frameImg->disabled;
			updateEntryImage(q, frameImg);
			frameImg->disabled = oldDisabled;
			frameImgPos.x = q.animateSetpointX;
			frameImgPos.y = q.animateSetpointY;

			size.x += frameImgPos.x - (mouseDetectionPadding);
			size.y += frameImgPos.y - (mouseDetectionPadding);
			size.w = frameImgPos.w + (mouseDetectionPadding * 2);
			size.h = frameImgPos.h + (mouseDetectionPadding * 2);
			tooltipShowing = doStatusEffectTooltip(q, size);
			players[player]->hud.setCursorDisabled(false);

			// make sure to adjust absolute size to camera viewport
			size.x -= players[player]->camera_virtualx1();
			size.y -= players[player]->camera_virtualy1();

			players[player]->hud.updateCursorAnimation(size.x - 1 + mouseDetectionPadding, size.y - 1 + mouseDetectionPadding,
				frameImgPos.w, frameImgPos.h, inputs.getVirtualMouse(player)->draw_cursor);
			break;
		}

		++it;
		if ( frameImagesIterator != frameImages.end() )
		{
			++frameImagesIterator;
		}
	}
}

const bool kAllowGhostStatusEffects = false;

void StatusEffectQueue_t::updateAllQueuedEffects()
{
	bool effectsEnabled = true;
	if ( !players[player]->entity && ((multiplayer == SINGLE && splitscreen) || multiplayer != SINGLE) )
	{
		effectsEnabled = false;
		resetQueue();
	}
	if ( players[player]->ghost.isActive() && !kAllowGhostStatusEffects )
	{
		effectsEnabled = false;
		resetQueue();
	}

	std::unordered_set<int> effectSet;
	for ( auto it = effectQueue.rbegin(); it != effectQueue.rend(); ++it )
	{
		effectSet.insert((*it).effect);
	}

	std::vector<int> effectsToSkipAnimThisFrame;
	std::set<int> effectsToSkipAnim;
	std::unordered_set<int> spellsActive;
	int count = 0; //This is just for debugging purposes.
	for ( node_t* node = channeledSpells[player].first; node && effectsEnabled; node = node->next, count++ )
	{
		spell_t* spell = (spell_t*)node->element;
		if ( !spell )
		{
			break;
		}
		spellsActive.insert(spell->ID);
		if ( StatusEffectDefinitions_t::sustainedSpellDefinitionExists(spell->ID) )
		{
			if ( StatusEffectDefinitions_t::getSustainedSpell(spell->ID).effect_id == -1 )
			{
				// unique sustained effect
				int effectID = spell->ID + kSpellEffectOffset;
				if ( effectSet.find(effectID) == effectSet.end() )
				{
					insertEffect(-1, spell->ID);
				}
			}
		}
	}

	for ( auto& eff : effectSet )
	{
		if ( eff >= kSpellEffectOffset && (eff - kSpellEffectOffset) == SPELL_SHADOW_TAG )
		{
			if ( players[player] && players[player]->entity
				&& players[player]->entity->creatureShadowTaggedThisUid != 0
				&& uidToEntity(players[player]->entity->creatureShadowTaggedThisUid) )
			{
				// shadow tag still active, check uid
				for ( auto it = effectQueue.rbegin(); it != effectQueue.rend(); ++it )
				{
					if ( (*it).effect == kSpellEffectOffset + SPELL_SHADOW_TAG )
					{
						if ( (*it).customVariable != players[player]->entity->creatureShadowTaggedThisUid )
						{
							deleteEffect(eff);
							break;
						}
					}
				}
			}
			else
			{
				deleteEffect(eff);
			}
		}
		else if ( eff >= kSpellEffectOffset && spellsActive.find(eff - kSpellEffectOffset) == spellsActive.end() )
		{
			// effect has expired.
			deleteEffect(eff);
		}
	}

	for ( int i = 0; i <= NUMEFFECTS && effectsEnabled; ++i )
	{
		if ( i == NUMEFFECTS )
		{
			if ( players[player] && players[player]->entity )
			{
				if ( players[player]->entity->creatureShadowTaggedThisUid != 0
					&& uidToEntity(players[player]->entity->creatureShadowTaggedThisUid) )
				{
					if ( insertEffect(-1, SPELL_SHADOW_TAG) )
					{
						effectQueue.back().customVariable = players[player]->entity->creatureShadowTaggedThisUid;
						notificationQueue.back().customVariable = players[player]->entity->creatureShadowTaggedThisUid;
					}
				}
			}
		}
	    else
	    {
			bool skipAnim = false;
			bool effectActive = stats[player]->EFFECTS[i];
			if ( i == EFF_LEVITATING && !effectActive )
			{
				bool tmp = stats[player]->EFFECTS[EFF_FLUTTER];
				stats[player]->EFFECTS[EFF_FLUTTER] = false;
				effectActive = isLevitating(stats[player]);
				stats[player]->EFFECTS[EFF_FLUTTER] = tmp;
			}
			else if ( i == EFF_MAGICREFLECT && !effectActive )
			{
				if ( stats[player]->amulet )
				{
					if ( stats[player]->amulet->type == AMULET_MAGICREFLECTION )
					{
						effectActive = true;
					}
				}
				if ( stats[player]->cloak )
				{
					if ( stats[player]->cloak->type == CLOAK_MAGICREFLECTION )
					{
						effectActive = true;
					}
				}
			}
			else if ( i == EFF_INVISIBLE && !effectActive && players[player]->entity )
			{
				bool oldSneaking = stats[player]->sneaking;
				stats[player]->sneaking = false;
				bool activeWithoutSneak = players[player]->entity->isInvisible();
				stats[player]->sneaking = oldSneaking;
				effectActive = players[player]->entity->isInvisible();
				if ( !activeWithoutSneak )
				{
					skipAnim = true;
					effectsToSkipAnim.insert(i);
				}
			}
			else if ( i == EFF_TELEPATH )
			{
				skipAnim = true;
				effectsToSkipAnim.insert(i);
			}
			else if ( i == EFF_BLIND )
			{
				if ( stats[player]->mask && stats[player]->mask->type == TOOL_BLINDFOLD_TELEPATHY )
				{
					skipAnim = true;
					effectsToSkipAnim.insert(i);
				}
			}
			else if ( i == EFF_DRUNK && stats[player]->type == GOATMAN )
			{
				effectActive = false;
			}
			
			if ( !players[player]->entity )
			{
				skipAnim = true;
			}

		    if ( effectActive )
		    {
			    if ( effectSet.find(i) == effectSet.end() )
			    {
					if ( i == EFF_SHAPESHIFT )
					{
						if ( players[player] && players[player]->entity )
						{
							insertEffect(i, -1);
						}
					}
					else
					{
						insertEffect(i, -1);
					}
					if ( skipAnim )
					{
						effectsToSkipAnimThisFrame.push_back(i);
					}
			    }
				else if ( i == EFF_SHAPESHIFT )
				{
					if ( !players[player] || !players[player]->entity )
					{
						deleteEffect(i);
					}
				}
		    }
		    else
		    {
			    if ( effectSet.find(i) != effectSet.end() )
			    {
				    deleteEffect(i);
			    }
		    }
		}
	}

	auto wantedLevel = ShopkeeperPlayerHostility.getWantedLevel(player);
	bool wantedOutsideOfShop = false;
	bool wantedInsideShop = false;
	bool inshop = false;

	std::map<int, bool> miscEffects;
	for ( int i = kEffectBurning; i >= kEffectRetaliation; --i )
	{
		miscEffects[i] = false;
	}
	if ( players[player] && players[player]->ghost.isActive() && kAllowGhostStatusEffects )
	{
		if ( players[player]->ghost.my->skill[3] == 1 ) // ghost sneaking
		{
			miscEffects[kEffectSneak] = true;
		}
	}
	if ( players[player] && players[player]->entity )
	{
		if ( players[player]->entity->flags[BURNING] )
		{
			miscEffects[kEffectBurning] = true;
		}
		if ( !(svFlags & SV_FLAG_HUNGER) )
		{
			miscEffects[kEffectDisabledHPRegen] = true;
		}
		if ( stats[player] )
		{
			bool cursedItemIsBuff = shouldInvertEquipmentBeatitude(stats[player]);
			if ( ((stats[player]->mask && stats[player]->mask->type == TOOL_BLINDFOLD_FOCUS)
				|| (stats[player]->type == GOATMAN && stats[player]->EFFECTS[EFF_DRUNK])) )
			{
				miscEffects[kEffectFreeAction] = true;
			}
			if ( stats[player]->type == GOATMAN && stats[player]->EFFECTS[EFF_DRUNK] )
			{
				miscEffects[kEffectDrunkGoatman] = true;
			}
			if ( stats[player]->helmet && stats[player]->helmet->type == HAT_BOUNTYHUNTER )
			{
				for ( auto target : achievementObserver.playerAchievements[player].bountyTargets )
				{
					if ( uidToEntity(target) )
					{
						miscEffects[kEffectBountyTarget] = true;
						break;
					}
				}
			}
			if ( stats[player]->mask && stats[player]->mask->type == MASK_MOUTHKNIFE )
			{
				miscEffects[kEffectRetaliation] = true;
			}
			if ( stats[player]->helmet && 
				(stats[player]->helmet->type == HAT_LAURELS
					|| stats[player]->helmet->type == HAT_TURBAN
					|| stats[player]->helmet->type == HAT_CROWN) )
			{
				miscEffects[kEffectInspiration] = true;
			}
			if ( stats[player]->shoes && stats[player]->shoes->type == ARTIFACT_BOOTS )
			{
				miscEffects[kEffectLesserWarning] = true;
			}
			if ( stats[player]->breastplate && stats[player]->breastplate->type == VAMPIRE_DOUBLET )
			{
				if ( (svFlags & SV_FLAG_HUNGER) )
				{
					miscEffects[kEffectDisabledHPRegen] = true;
				}
			}
			if ( stats[player]->breastplate && stats[player]->breastplate->type == MACHINIST_APRON )
			{
				miscEffects[kEffectResistBurning] = true;
			}
			if ( stats[player]->amulet && stats[player]->amulet->type == AMULET_POISONRESISTANCE )
			{
				miscEffects[kEffectResistPoison] = true;
			}
			if ( stats[player]->ring && stats[player]->ring->type == RING_SLOWDIGESTION
				&& (stats[player]->ring->beatitude >= 0 || cursedItemIsBuff) )
			{
				if ( (svFlags & SV_FLAG_HUNGER) )
				{
					miscEffects[kEffectSlowDigestion] = true;
				}
			}
			if ( stats[player]->amulet && stats[player]->amulet->type == AMULET_STRANGULATION
				&& stats[player]->type != SKELETON )
			{
				miscEffects[kEffectStrangulation] = true;
			}
			if ( stats[player]->amulet && stats[player]->amulet->type == AMULET_WATERBREATHING )
			{
				miscEffects[kEffectWaterBreathing] = true;
			}
			if ( stats[player]->ring && stats[player]->ring->type == RING_WARNING )
			{
				miscEffects[kEffectWarning] = true;
			}
			if ( stats[player]->ring && stats[player]->ring->type == RING_CONFLICT )
			{
				miscEffects[kEffectConflict] = true;
			}
			if ( (stats[player]->ring && stats[player]->ring->type == RING_STRENGTH)
				|| (stats[player]->gloves && stats[player]->gloves->type == GAUNTLETS_STRENGTH)
				|| stats[player]->EFFECTS[EFF_POTION_STR] )
			{
				miscEffects[kEffectPush] = true;
			}
			if ( (stats[player]->shoes && stats[player]->shoes->type == IRON_BOOTS_WATERWALKING)
				|| skillCapstoneUnlocked(player, PRO_SWIMMING) )
			{
				miscEffects[kEffectWaterWalking] = true;
			}
			if ( (stats[player]->amulet && stats[player]->amulet->type == AMULET_LIFESAVING)
				|| (((stats[player]->playerRace == RACE_SKELETON && stats[player]->appearance == 0) 
					|| stats[player]->type == SKELETON) && stats[player]->MP >= 75) )
			{
				miscEffects[kEffectLifesaving] = true;
			}
			if ( stats[player]->sneaking == 1 && !stats[player]->defending && !skillCapstoneUnlocked(player, PRO_STEALTH) )
			{
				miscEffects[kEffectSneak] = true;
			}
		}

		int playerx = static_cast<int>(players[player]->entity->x) >> 4;
		int playery = static_cast<int>(players[player]->entity->y) >> 4;
		if ( playerx >= 0 && playerx < map.width && playery >= 0 && playery < map.height )
		{
			// if the criminal was inside a shop
			if ( shoparea[playery + playerx * map.height] )
			{
				inshop = true;
			}
		}
		if ( wantedLevel != ShopkeeperPlayerHostility_t::NO_WANTED_LEVEL )
		{
			/*if ( inshop ) // if we want a re-notify while in the shop
			{
				if ( effectSet.find(kEffectWantedInShop) == effectSet.end() )
				{
					insertEffect(kEffectWantedInShop, -1);
				}
				if ( effectSet.find(kEffectWanted) != effectSet.end() )
				{
					deleteEffect(kEffectWanted);
				}
			}
			else*/
			{
				if ( effectSet.find(kEffectWantedInShop) != effectSet.end() )
				{
					if ( effectSet.find(kEffectWanted) != effectSet.end() )
					{
						deleteEffect(kEffectWanted);
					}
					for ( auto it = effectQueue.begin(); it != effectQueue.end(); )
					{
						if ( (*it).effect == kEffectWantedInShop )
						{
							(*it).effect = kEffectWanted;
							break;
						}
						++it;
					}
				}
				else if ( effectSet.find(kEffectWanted) == effectSet.end() )
				{
					insertEffect(kEffectWanted, -1);
				}
			}
		}
	}

	for ( int i = kEffectBurning; i >= kEffectRetaliation; --i )
	{
		if ( miscEffects[i] == false )
		{
			if ( effectSet.find(i) != effectSet.end() )
			{
				deleteEffect(i);
			}
		}
		else
		{
			if ( !players[player]->entity )
			{
				effectsToSkipAnim.insert(i);
			}
			if ( i == kEffectSneak )
			{
				effectsToSkipAnim.insert(i);
			}
			if ( effectSet.find(i) == effectSet.end() )
			{
				insertEffect(i, -1);

				if ( i == kEffectSneak )
				{
					effectsToSkipAnimThisFrame.push_back(i);
				}
			}
		}
	}

	if ( wantedLevel == ShopkeeperPlayerHostility_t::NO_WANTED_LEVEL )
	{
		if ( effectSet.find(kEffectWanted) != effectSet.end() )
		{
			deleteEffect(kEffectWanted);
		}
		if ( effectSet.find(kEffectWantedInShop) != effectSet.end() )
		{
			deleteEffect(kEffectWantedInShop);
		}
	}

	bool hungerIconActive = (effectSet.find(kEffectBread) != effectSet.end() 
		|| effectSet.find(kEffectBloodHunger) != effectSet.end()
		|| effectSet.find(kEffectAutomatonHunger) != effectSet.end());
	if ( !players[player]->entity )
	{
		if ( effectSet.find(kEffectBread) != effectSet.end() )
		{
			effectsToSkipAnimThisFrame.push_back(kEffectBread);
		}
		if ( effectSet.find(kEffectBloodHunger) != effectSet.end() )
		{
			effectsToSkipAnimThisFrame.push_back(kEffectBloodHunger);
		}
		if ( effectSet.find(kEffectAutomatonHunger) != effectSet.end() )
		{
			effectsToSkipAnimThisFrame.push_back(kEffectAutomatonHunger);
		}
	}

	Frame* statusEffectFrame = getStatusEffectFrame();
	auto automatonHungerFrame = statusEffectFrame->findFrame("automaton hunger notification");
	automatonHungerFrame->setDisabled(true);
	auto automatonFlameImg = automatonHungerFrame->findImage("flame");

	int iconSize = 32;
	int movex = splitscreen ? 4 : 0;
	if ( hungerIconActive )
	{
		if ( effectSet.find(kEffectBread) != effectSet.end() )
		{
			movex += 76;
		}
		else
		{
			movex += 64;
		}
		movex += 4;
	}
	const int startrowx = movex;
	int movey = statusEffectFrame->getSize().h - iconSize;
	const int spacing = 36;
	int numEffectsOnLine = 0;

	for ( auto eff : effectsToSkipAnimThisFrame )
	{
		for ( auto& notif : notificationQueue )
		{
			if ( notif.effect == eff )
			{
				notif.notificationState = StatusEffectQueueEntry_t::STATE_END;
				notif.notificationStateInit = StatusEffectQueueEntry_t::STATE_END;

				notif.notificationTargetPosition.x = movex;

				for ( auto& entry : effectQueue )
				{
					if ( entry.effect == eff )
					{
						entry.animateSetpointX = notif.notificationTargetPosition.x;
						entry.animateSetpointY = notif.notificationTargetPosition.y;
						entry.animateSetpointW = entry.notificationTargetPosition.w;
						entry.animateSetpointH = entry.notificationTargetPosition.h;

						entry.animateStartX = entry.animateSetpointX;
						entry.animateStartY = entry.animateSetpointY;
						entry.animateStartW = entry.animateSetpointW;
						entry.animateStartH = entry.animateSetpointH;
						entry.pos.x = entry.animateSetpointX;
						entry.pos.y = entry.animateSetpointY;
						entry.pos.w = entry.animateSetpointW;
						entry.pos.h = entry.animateSetpointH;

						notif.pos = entry.pos;
					}
				}
			}
		}
	}

	auto notificationFrame = statusEffectFrame->findFrame("notification frame");
	notificationFrame->setDisabled(true);
	auto notificationImg = notificationFrame->findImage("notification img");
	notificationImg->disabled = true;
	auto notificationTxt = notificationFrame->findField("notification txt");
	notificationTxt->setDisabled(true);
	notificationTxt->setFont(StatusEffectDefinitions_t::notificationFont.c_str());
	notificationTxt->setColor(StatusEffectDefinitions_t::notificationTextColor);
	if ( notificationQueue.size() >= 1 )
	{
		auto& notif = notificationQueue.front();
		notif.animateNotification(player);
		updateEntryImage(notif, notificationImg);
		if ( notif.notificationState == StatusEffectQueueEntry_t::STATE_2
			|| notif.notificationState == StatusEffectQueueEntry_t::STATE_3 )
		{
			if ( notif.effect >= kSpellEffectOffset )
			{
				int effectID = notif.effect - kSpellEffectOffset;
				if ( StatusEffectDefinitions_t::sustainedSpellDefinitionExists(effectID) )
				{
					auto& definition = StatusEffectDefinitions_t::getSustainedSpell(effectID);
					if ( notif.notificationState == StatusEffectQueueEntry_t::STATE_2 )
					{
						int variation = -1;
						if ( effectID == SPELL_SHADOW_TAG )
						{
							variation = 0;
							notificationTxt->setText("");
							if ( players[player] && players[player]->entity )
							{
								if ( players[player]->entity->creatureShadowTaggedThisUid != 0
									&& uidToEntity(players[player]->entity->creatureShadowTaggedThisUid) )
								{
									std::string formatString = definition.getName(variation).c_str();
									char buf[256] = "";
									Entity* tagged = uidToEntity(players[player]->entity->creatureShadowTaggedThisUid);
									if ( tagged->behavior == &actMonster )
									{
										int type = tagged->getMonsterTypeFromSprite();
										if ( type != NOTHING )
										{
											snprintf(buf, sizeof(buf), formatString.c_str(), getMonsterLocalizedName((Monster)type).c_str());
										}
										else
										{
											strcpy(buf, "");
										}
									}
									else if ( tagged->behavior == &actPlayer )
									{
										snprintf(buf, sizeof(buf), formatString.c_str(), stats[tagged->skill[2]]->name);
									}
									std::string formattedName = buf;
									notificationTxt->setText(formattedName.c_str());
								}
							}
						}
						else
						{
							notificationTxt->setText(definition.getName(variation).c_str());
						}
					}
					notificationTxt->setDisabled(false);
				}
			}
			else
			{
				int effectID = notif.effect;
				if ( StatusEffectDefinitions_t::effectDefinitionExists(effectID) )
				{
					auto& definition = StatusEffectDefinitions_t::getEffect(effectID);
					if ( notif.notificationState == StatusEffectQueueEntry_t::STATE_2 )
					{
						int variation = -1;
						if ( effectID == EFF_SHAPESHIFT )
						{
							if ( players[player] && players[player]->entity )
							{
								switch ( players[player]->entity->effectShapeshift )
								{
									case RAT:
										variation = 0;
										break;
									case SPIDER:
										variation = 1;
										break;
									case TROLL:
										variation = 2;
										break;
									case CREATURE_IMP:
										variation = 3;
										break;
									default:
										break;
								}
							}
						}
						else if ( effectID == StatusEffectQueue_t::kEffectBread
							|| effectID == StatusEffectQueue_t::kEffectBloodHunger )
						{
							if ( notif.customVariable >= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_OVERSATIATED) )
							{
								variation = 0;
							}
							else if ( notif.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_STARVING) )
							{
								variation = 3;
							}
							else if ( notif.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_WEAK) )
							{
								variation = 2;
							}
							else if ( notif.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_HUNGRY) )
							{
								variation = 1;
							}
						}
						else if ( effectID == StatusEffectQueue_t::kEffectAutomatonHunger )
						{
							if ( notif.customVariable >= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_AUTOMATON_SUPERHEATED) )
							{
								variation = 0;
							}
							else if ( notif.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_AUTOMATON_CRITICAL) )
							{
								variation = 2;
							}
							else
							{
								variation = 1;
							}
						}
						else if ( effectID == StatusEffectQueue_t::kEffectBountyTarget )
						{
							variation = 0;
						}
						else if ( effectID == EFF_VAMPIRICAURA )
						{
							bool sustained = false;
							for ( node_t* node = channeledSpells[player].first; node != nullptr; node = node->next )
							{
								spell_t* spell = (spell_t*)node->element;
								if ( spell && spell->ID == SPELL_VAMPIRIC_AURA )
								{
									sustained = true;
									break;
								}
							}
							if ( sustained )
							{
								variation = 1;
							}
							else
							{
								variation = 0;
							}
						}
						notificationTxt->setText(definition.getName(variation).c_str());
					}
					if ( notificationImg->path != "" )
					{
						notificationTxt->setDisabled(false);
					}
				}
			}
			if ( auto textGet = notificationTxt->getTextObject() )
			{
				SDL_Rect txtPos;
				txtPos.w = textGet->getWidth();
				txtPos.h = textGet->getHeight() * textGet->getNumTextLines() + 4;

				const int movementAmount = getStatusEffectMovementAmount(player);
				txtPos.x = (getBaseEffectPosX() - movementAmount - (notif.getStatusEffectLargestScaling(player) - 1.0) * notif.getEffectSpriteNormalWidth() / 2)
					+ (notif.getEffectSpriteNormalWidth() * notif.getStatusEffectLargestScaling(player)) / 2 - txtPos.w / 2;
				txtPos.y = getBaseEffectPosY() - movementAmount - txtPos.h;
				notificationTxt->setSize(txtPos);
			}
		}
		if ( notif.notificationState == StatusEffectQueueEntry_t::STATE_END )
		{
			notificationQueue.pop_front();
		}

		if ( notif.effect == kEffectAutomatonHunger )
		{
			automatonHungerFrame->setDisabled(false);
			automatonHungerFrame->setSize(notificationImg->pos);
		}
	}

	if ( !notificationImg->disabled || !notificationTxt->isDisabled() )
	{
		notificationFrame->setDisabled(false);
		notificationFrame->setSize(SDL_Rect{ 0, 0, statusEffectFrame->getSize().w, statusEffectFrame->getSize().h });
	}


	auto innerFrame = statusEffectFrame->findFrame("effects");
	int numFrameImages = innerFrame->getImages().size();
	while ( effectQueue.size() > numFrameImages )
	{
		auto img = innerFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "inner img");
		img->disabled = true;
		numFrameImages = innerFrame->getImages().size();
	}
	while ( effectQueue.size() < numFrameImages )
	{
		innerFrame->getImages().erase(innerFrame->getImages().begin());
		numFrameImages = innerFrame->getImages().size();
	}
	auto& frameImages = innerFrame->getImages();
	for ( auto img : frameImages )
	{
		img->disabled = true;
	}

	auto frameImagesIterator = frameImages.begin();
	bool bFrameCapturesMouse = false;
	if ( !players[player]->shootmode && inputs.getVirtualMouse(player)->draw_cursor 
		&& !players[player]->skillSheet.bSkillSheetOpen
		&& !players[player]->bookGUI.bBookOpen
		&& !players[player]->signGUI.bSignOpen
		&& !(players[player]->bUseCompactGUIHeight() && !players[player]->hud.statusFxFocusedWindowActive)
		&& !inputs.getUIInteraction(player)->selectedItem && !players[player]->GUI.isDropdownActive() )
	{
		if ( bFrameCapturesMouse = statusEffectFrame->capturesMouse() )
		{
			if ( !players[player]->hud.statusFxFocusedWindowActive )
			{
				if ( (playerInventoryFrames[player].backpackFrame
					&& !playerInventoryFrames[player].backpackFrame->isDisabled() 
					&& playerInventoryFrames[player].backpackFrame->capturesMouse())
					|| (playerInventoryFrames[player].invSlotsFrame
						&& playerInventoryFrames[player].invSlotsFrame->capturesMouse()) )
				{
					bFrameCapturesMouse = false;
				}
			}
		}
	}
	bool tooltipShowing = false;
	Sint32 mousex = (inputs.getMouse(player, Inputs::X) / (float)xres) * (float)Frame::virtualScreenX;
	Sint32 mousey = (inputs.getMouse(player, Inputs::Y) / (float)yres) * (float)Frame::virtualScreenY;
	bool lowDurationFlash = !((ticks % 50) - (ticks % 25));

	if ( bCompactWidth != players[player]->bUseCompactGUIWidth() )
	{
		requiresAnimUpdate = true;
	}
	if ( bCompactHeight != players[player]->bUseCompactGUIHeight() )
	{
		requiresAnimUpdate = true;
	}
	bCompactWidth = players[player]->bUseCompactGUIWidth();
	bCompactHeight = players[player]->bUseCompactGUIHeight();
	effectsPerRow = 4;
	if ( bCompactWidth )
	{
		effectsPerRow = 3;
	}

	int gridx = 1;
	int gridy = 0;
	std::map<int, StatusEffectQueueEntry_t*> grid;
	size_t index = 0;
	bool hungerEffectInEffectQueue = false;
	bool moduleActive = players[player]->GUI.activeModule == Player::GUI_t::MODULE_STATUS_EFFECTS;
	effectsBoundingBox = SDL_Rect{ 0, 0, 0, 0 };
	for ( auto it = effectQueue.rbegin(); it != effectQueue.rend(); )
	{
		auto& q = (*it);

		q.index = index;
		++index;

		Frame::image_t* frameImg = nullptr;
		if ( frameImagesIterator != frameImages.end() )
		{
			frameImg = *frameImagesIterator;
		}

		bool existsInNotifications = false;
		for ( auto it2 = notificationQueue.begin(); it2 != notificationQueue.end(); ++it2 )
		{
			if ( (*it2).effect == q.effect )
			{
				existsInNotifications = true;
				if ( effectsToSkipAnim.find(q.effect) != effectsToSkipAnim.end() )
				{
					updateEntryImage(q, frameImg);
				}
				break;
			}
		}
		if ( !existsInNotifications )
		{
			updateEntryImage(q, frameImg);

			if ( q.effect == kEffectAutomatonHunger )
			{
				automatonHungerFrame->setDisabled(false);
				automatonHungerFrame->setSize(frameImg->pos);
			}

			if ( bFrameCapturesMouse && !tooltipShowing )
			{
				SDL_Rect size = statusEffectFrame->getAbsoluteSize();
				int mouseDetectionPadding = 2;
				size.x += frameImg->pos.x - (mouseDetectionPadding);
				size.y += frameImg->pos.y - (mouseDetectionPadding);
				size.w = frameImg->pos.w + (mouseDetectionPadding * 2);
				size.h = frameImg->pos.h + (mouseDetectionPadding * 2);
				if ( rectContainsPoint(size, mousex, mousey) )
				{
					if ( players[player]->GUI.activeModule == Player::GUI_t::MODULE_STATUS_EFFECTS )
					{
						tooltipShowing = doStatusEffectTooltip(q, size);
					}
					players[player]->GUI.activateModule(Player::GUI_t::MODULE_STATUS_EFFECTS);
					players[player]->hud.setCursorDisabled(false);

					// make sure to adjust absolute size to camera viewport
					size.x -= players[player]->camera_virtualx1();
					size.y -= players[player]->camera_virtualy1();

					players[player]->hud.updateCursorAnimation(size.x - 1 + mouseDetectionPadding, size.y - 1 + mouseDetectionPadding, 
						frameImg->pos.w, frameImg->pos.h, inputs.getVirtualMouse(player)->draw_cursor);
				}
			}
		}
		int animatePosX = movex;
		int animatePosY = movey;
		if ( q.effect == kEffectBread || q.effect == kEffectBloodHunger )
		{
			animatePosX = 0;
			animatePosY = statusEffectFrame->getSize().h - q.getEffectSpriteNormalHeight();
		}
		else if ( q.effect == kEffectAutomatonHunger )
		{
			animatePosX = 0;
			animatePosY = 4 + statusEffectFrame->getSize().h - q.getEffectSpriteNormalHeight();
		}

		effectsBoundingBox.y = std::max(effectsBoundingBox.y, animatePosY + q.getEffectSpriteNormalHeight());
		effectsBoundingBox.w = std::max(effectsBoundingBox.w, animatePosX + q.getEffectSpriteNormalWidth());
		if ( effectsBoundingBox.h == 0 )
		{
			effectsBoundingBox.h = animatePosY;
		}
		else
		{
			effectsBoundingBox.h = std::min(effectsBoundingBox.h, animatePosY);
		}

		// low duration flash
		bool effectIsSustained = false;
		if ( StatusEffectDefinitions_t::effectDefinitionExists(q.effect) )
		{
			auto& definition = StatusEffectDefinitions_t::getEffect(q.effect);
			if ( definition.sustainedSpellID >= 0 )
			{
				if ( spellsActive.find(definition.sustainedSpellID) != spellsActive.end() )
				{
					effectIsSustained = true;
				}
			}
		}

		q.lowDuration = false;
		if ( !effectIsSustained && q.effect >= 0 && q.effect < NUMEFFECTS )
		{
			bool lowDuration = stats[player]->EFFECTS_TIMERS[q.effect] > 0 &&
				(stats[player]->EFFECTS_TIMERS[q.effect] < TICKS_PER_SECOND * 5);
			if ( q.effect == EFF_NAUSEA_PROTECTION )
			{
				lowDuration = false;
			}
			else if ( q.effect == EFF_BLIND && stats[player]->mask
				&& (stats[player]->mask->type == TOOL_BLINDFOLD
					|| stats[player]->mask->type == TOOL_BLINDFOLD_FOCUS
					|| stats[player]->mask->type == TOOL_BLINDFOLD_TELEPATHY) )
			{
				lowDuration = false;
			}
			else if ( q.effect == EFF_TELEPATH && stats[player]->mask
				&& (stats[player]->mask->type == TOOL_BLINDFOLD_TELEPATHY) )
			{
				lowDuration = false;
			}
			q.lowDuration = lowDuration;
			if ( lowDuration && lowDurationFlash )
			{
				frameImg->disabled = true;
			}
		}
		else if ( q.effect == kEffectBread || q.effect == kEffectBloodHunger || q.effect == kEffectAutomatonHunger )
		{
			if ( q.effect == kEffectAutomatonHunger )
			{
				if ( q.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_AUTOMATON_CRITICAL) )
				{
					q.lowDuration = true;
					if ( lowDurationFlash )
					{
						frameImg->disabled = true;
						automatonHungerFrame->setDisabled(true);
					}
				}
			}
			else
			{
				if ( q.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_WEAK) )
				{
					q.lowDuration = true;
					if ( lowDurationFlash )
					{
						frameImg->disabled = true;
					}
				}
			}
		}
		else if ( q.effect == kEffectBurning )
		{
			q.lowDuration = true;
			if ( lowDurationFlash )
			{
				frameImg->disabled = true;
			}
		}
		else if ( q.effect == kEffectPush )
		{
			q.lowDuration = false;
			if ( !((stats[player]->ring && stats[player]->ring->type == RING_STRENGTH)
				|| (stats[player]->gloves && stats[player]->gloves->type == GAUNTLETS_STRENGTH)) )
			{
				bool lowDuration = stats[player]->EFFECTS_TIMERS[EFF_POTION_STR] > 0 &&
					(stats[player]->EFFECTS_TIMERS[EFF_POTION_STR] < TICKS_PER_SECOND * 5);
				q.lowDuration = lowDuration;
				if ( lowDurationFlash && lowDuration )
				{
					frameImg->disabled = true;
				}
			}
		}

		if ( requiresAnimUpdate )
		{
			q.setAnimatePosition(animatePosX, animatePosY);
		}
		for ( auto it2 = notificationQueue.begin(); it2 != notificationQueue.end(); ++it2 )
		{
			if ( (*it2).effect == q.effect )
			{
				(*it2).notificationTargetPosition.x = animatePosX;
				(*it2).notificationTargetPosition.y = animatePosY;
				break;
			}
		}

		++it;
		if ( frameImagesIterator != frameImages.end() )
		{
			++frameImagesIterator;
		}

		q.animate();

		if ( q.effect == kEffectBread || q.effect == kEffectBloodHunger || q.effect == kEffectAutomatonHunger )
		{
			assert(grid.find(0 + 0 * 10000) == grid.end());
			grid[0 + 0 * 10000] = &q;

			hungerEffectInEffectQueue = true;
			continue; // don't advance position as this is fixed
		}

		assert(grid.find(gridx + gridy * 10000) == grid.end());
		grid[gridx + gridy * 10000] = &q;


		++gridx;
		movex += spacing;
		++numEffectsOnLine;
		if ( numEffectsOnLine >= effectsPerRow )
		{
			numEffectsOnLine = 0;
			movex = startrowx;
			movey -= spacing;
			gridx = 1;
			++gridy;
		}
	}

	handleNavigation(grid, tooltipShowing, hungerEffectInEffectQueue);

	if ( stats[player] && stats[player]->type == AUTOMATON && !automatonHungerFrame->isDisabled() )
	{
		SDL_Rect automatonHungerFramePos = automatonHungerFrame->getSize();
		SDL_Rect boilerFlamePos = automatonHungerFramePos;
		boilerFlamePos.x = 0;
		boilerFlamePos.y = 0;
		if ( stats[player]->HUNGER > 300 )
		{
			if ( stats[player]->HUNGER > 1200 )
			{
				automatonFlameImg->path = "images/system/Hunger_boiler_hotfire.png";
				automatonFlameImg->pos = boilerFlamePos;
			}
			else
			{
				automatonFlameImg->path = "images/system/Hunger_boiler_fire.png";
				if ( stats[player]->HUNGER > 600 )
				{
					automatonFlameImg->pos = boilerFlamePos;
				}
				else
				{
					float percent = (stats[player]->HUNGER - 200) / 400.f; // always show a little bit more at the bottom (10-20%)
					automatonFlameImg->pos = boilerFlamePos;
					int newHeight = boilerFlamePos.h * percent;
					int heightDiff = boilerFlamePos.h - newHeight;
					automatonFlameImg->pos.y -= heightDiff;
					automatonHungerFramePos.y += heightDiff;
					automatonHungerFramePos.h -= heightDiff;
					automatonHungerFrame->setSize(automatonHungerFramePos);
				}
			}
		}
		else
		{
			automatonHungerFrame->setDisabled(true);
		}
	}

	animateStatusEffectTooltip(tooltipShowing);

	if ( moduleActive && inputs.getVirtualMouse(player)->draw_cursor )
	{
		if ( !tooltipShowing /*&& !players[player]->hud.statusFxFocusedWindowActive*/ )
		{
			players[player]->GUI.activateModule(Player::GUI_t::MODULE_NONE);
		}
	}

	requiresAnimUpdate = false;
}

void StatusEffectQueue_t::updateEntryImage(StatusEffectQueueEntry_t& entry, Frame::image_t* img)
{
	if ( img )
	{
		img->path = "";
		if ( entry.effect == kEffectBread || entry.effect == kEffectBloodHunger )
		{
			if ( StatusEffectDefinitions_t::effectDefinitionExists(entry.effect) )
			{
				int variation = -1;
				if ( entry.customVariable >= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_OVERSATIATED) )
				{
					variation = 0;
				}
				else if ( entry.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_STARVING) )
				{
					variation = 3;
				}
				else if ( entry.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_WEAK) )
				{
					variation = 2;
				}
				else if ( entry.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_HUNGRY) )
				{
					variation = 1;
				}
				if ( variation >= 0 )
				{
					img->path = StatusEffectDefinitions_t::getEffectImgPath(StatusEffectDefinitions_t::getEffect(entry.effect), variation);
				}
				else
				{
					img->path = "";
				}
			}
		}
		else if ( entry.effect == kEffectAutomatonHunger )
		{
			int variation = 1;
			if ( entry.customVariable >= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_AUTOMATON_SUPERHEATED) )
			{
				variation = 0;
			}
			else if ( entry.customVariable <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_AUTOMATON_CRITICAL) )
			{
				variation = 2;
			}
			img->path = StatusEffectDefinitions_t::getEffectImgPath(StatusEffectDefinitions_t::getEffect(entry.effect), variation);
		}
		else
		{
			if ( entry.effect >= kSpellEffectOffset )
			{
				int effectID = entry.effect - kSpellEffectOffset;
				if ( StatusEffectDefinitions_t::sustainedSpellDefinitionExists(effectID) )
				{
					img->path = StatusEffectDefinitions_t::getEffectImgPath(StatusEffectDefinitions_t::getSustainedSpell(effectID));
				}
			}
			else
			{
				int effectID = entry.effect;
				if ( StatusEffectDefinitions_t::effectDefinitionExists(effectID) )
				{
					int variation = -1;
					if ( effectID == EFF_SHAPESHIFT )
					{
						if ( players[player] && players[player]->entity )
						{
							switch ( players[player]->entity->effectShapeshift )
							{
								case RAT:
									variation = 0;
									break;
								case SPIDER:
									variation = 1;
									break;
								case TROLL:
									variation = 2;
									break;
								case CREATURE_IMP:
									variation = 3;
									break;
								default:
									break;
							}
						}
						if ( variation == -1 )
						{
							img->path = "";
						}
						else
						{
							img->path = StatusEffectDefinitions_t::getEffectImgPath(StatusEffectDefinitions_t::getEffect(effectID), variation);
						}
					}
					else
					{
						img->path = StatusEffectDefinitions_t::getEffectImgPath(StatusEffectDefinitions_t::getEffect(effectID), variation);
					}
				}
			}
		}

		SDL_Rect dest{ 0, 0, entry.pos.w, entry.pos.h };
		dest.x = entry.pos.x;
		dest.y = entry.pos.y;
		img->pos = dest;
		img->disabled = false;

		if ( img->path.size() > 1 && img->path[0] != '*' )
		{
			img->path.insert(0, 1, '*');
		}
	}
}

void updateStatusEffectQueue(const int player)
{
	auto& statusEffectQueue = StatusEffectQueue[player];
	Frame* statusEffectFrame = statusEffectQueue.getStatusEffectFrame();
	if ( !statusEffectFrame )
	{
		return;
	}
	if ( gamePaused && multiplayer == SINGLE )
	{
		return;
	}
	auto& hud_t = players[player]->hud;
	SDL_Rect mainFramePos{ 0, 0, players[player]->camera_virtualWidth(), players[player]->camera_virtualHeight() / 2 };
	mainFramePos.x = hud_t.hpFrame->getSize().x;
	mainFramePos.y = hud_t.hpFrame->getSize().y - mainFramePos.h;
	mainFramePos.w -= mainFramePos.x;
	if ( players[player]->hud.statusFxFocusedWindowActive )
	{
		mainFramePos.x += 8 * statusEffectQueue.focusedWindowAnim;
		mainFramePos.y -= 8 * statusEffectQueue.focusedWindowAnim;
	}
	statusEffectFrame->setSize(mainFramePos);
	auto innerFrame = statusEffectFrame->findFrame("effects");
	innerFrame->setSize(SDL_Rect{ 0, 0, statusEffectFrame->getSize().w, statusEffectFrame->getSize().h });

	const int hungerEffectID = ((stats[player] && stats[player]->type == AUTOMATON) ? StatusEffectQueue_t::kEffectAutomatonHunger
		: (playerRequiresBloodToSustain(player) ? StatusEffectQueue_t::kEffectBloodHunger : StatusEffectQueue_t::kEffectBread));

	// hunger icon
	if ( stats[player] && stats[player]->type != AUTOMATON )
	{
		statusEffectQueue.deleteEffect(StatusEffectQueue_t::kEffectAutomatonHunger);
	}

	bool effectsEnabled = true;
	if ( !players[player]->entity && ((multiplayer == SINGLE && splitscreen) || multiplayer != SINGLE) )
	{
		effectsEnabled = false;
	}
	if ( players[player]->ghost.isActive() && !kAllowGhostStatusEffects )
	{
		effectsEnabled = false;
	}

	if ( effectsEnabled && stats[player] && stats[player]->type != AUTOMATON
		&& (svFlags & SV_FLAG_HUNGER) 
		&& (stats[player]->HUNGER <= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_HUNGRY) 
			|| stats[player]->HUNGER >= getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_OVERSATIATED)) )
	{
		statusEffectQueue.deleteEffect(StatusEffectQueue_t::kEffectAutomatonHunger);
		if ( hungerEffectID == StatusEffectQueue_t::kEffectBloodHunger )
		{
			statusEffectQueue.deleteEffect(StatusEffectQueue_t::kEffectBread); // delete opposite if present
		}
		if ( hungerEffectID == StatusEffectQueue_t::kEffectBread )
		{
			statusEffectQueue.deleteEffect(StatusEffectQueue_t::kEffectBloodHunger); // delete opposite if present
		}

		const int HUNGER_NONE = 1000;
		const int HUNGER_OVERSATIATED = getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_OVERSATIATED);
		const int HUNGER_HUNGRY = getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_HUNGRY);
		const int HUNGER_WEAK = getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_WEAK);
		const int HUNGER_STARVING = getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_STARVING);
		int hungerStateToSet = HUNGER_NONE;
		if ( stats[player]->HUNGER >= HUNGER_OVERSATIATED )
		{
			hungerStateToSet = HUNGER_OVERSATIATED;
		}
		else if ( stats[player]->HUNGER <= HUNGER_STARVING )
		{
			hungerStateToSet = HUNGER_STARVING;
		}
		else if ( stats[player]->HUNGER <= HUNGER_WEAK )
		{
			hungerStateToSet = HUNGER_WEAK;
		}
		else if ( stats[player]->HUNGER <= HUNGER_HUNGRY )
		{
			hungerStateToSet = HUNGER_HUNGRY;
		}
		StatusEffectQueueEntry_t* entry = nullptr;
		StatusEffectQueueEntry_t* notif = nullptr;


		for ( auto& q : statusEffectQueue.effectQueue )
		{
			if ( q.effect == hungerEffectID )
			{
				entry = &(q);
				for ( auto& n : statusEffectQueue.notificationQueue )
				{
					if ( n.effect == hungerEffectID )
					{
						notif = &(n);
					}
					break;
				}
				break;
			}
		}
		if ( entry && entry->customVariable != hungerStateToSet )
		{
			if ( notif && notif->customVariable != hungerStateToSet )
			{
				// reset the notification
				bool erased = false;
				for ( auto it = statusEffectQueue.notificationQueue.begin(); it != statusEffectQueue.notificationQueue.end(); ++it )
				{
					if ( (*it).effect == hungerEffectID )
					{
						statusEffectQueue.notificationQueue.erase(it);
						erased = true;
						break;
					}
				}
				statusEffectQueue.notificationQueue.push_back(StatusEffectQueueEntry_t(hungerEffectID));
				statusEffectQueue.notificationQueue.back().pos.x = statusEffectQueue.getBaseEffectPosX();
				statusEffectQueue.notificationQueue.back().pos.y = statusEffectQueue.getBaseEffectPosY();

				// fall back if notificationTargetPosition doesn't have an effect to go to.
				statusEffectQueue.notificationQueue.back().notificationTargetPosition.x = 0;
				statusEffectQueue.notificationQueue.back().notificationTargetPosition.y = statusEffectQueue.statusEffectFrame->getSize().h 
					- statusEffectQueue.notificationQueue.back().notificationTargetPosition.h;
				statusEffectQueue.requiresAnimUpdate = true;
				entry->customVariable = hungerStateToSet;
				statusEffectQueue.notificationQueue.back().customVariable = hungerStateToSet;
			}
			else
			{
				// else, delete and reapply
				statusEffectQueue.deleteEffect(hungerEffectID);
				if ( statusEffectQueue.insertEffect(hungerEffectID, -1) )
				{
					if ( statusEffectQueue.effectQueue.back().effect == hungerEffectID )
					{
						statusEffectQueue.effectQueue.back().customVariable = hungerStateToSet;
						statusEffectQueue.notificationQueue.back().customVariable = hungerStateToSet;
					}
				}
			}
		}
		else
		{
			// new effect, does not exist
			if ( statusEffectQueue.insertEffect(hungerEffectID, -1) )
			{
				if ( statusEffectQueue.effectQueue.back().effect == hungerEffectID )
				{
					statusEffectQueue.effectQueue.back().customVariable = hungerStateToSet;
					statusEffectQueue.notificationQueue.back().customVariable = hungerStateToSet;
				}
			}
		}
	}
	else if ( effectsEnabled )
	{
		statusEffectQueue.deleteEffect(StatusEffectQueue_t::kEffectBloodHunger);
		statusEffectQueue.deleteEffect(StatusEffectQueue_t::kEffectBread);

		if ( hungerEffectID == StatusEffectQueue_t::kEffectAutomatonHunger )
		{
			const int HUNGER_NONE = 1000;
			const int HUNGER_SUPERHEATED = getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_AUTOMATON_SUPERHEATED);
			const int HUNGER_CRITICAL = getEntityHungerInterval(player, nullptr, stats[player], HUNGER_INTERVAL_AUTOMATON_CRITICAL);
			int hungerStateToSet = HUNGER_NONE;
			if ( stats[player]->HUNGER >= HUNGER_SUPERHEATED )
			{
				hungerStateToSet = HUNGER_SUPERHEATED;
			}
			else if ( stats[player]->HUNGER <= HUNGER_CRITICAL )
			{
				hungerStateToSet = HUNGER_CRITICAL;
			}
			StatusEffectQueueEntry_t* entry = nullptr;
			StatusEffectQueueEntry_t* notif = nullptr;

			for ( auto& q : statusEffectQueue.effectQueue )
			{
				if ( q.effect == hungerEffectID )
				{
					entry = &(q);
					for ( auto& n : statusEffectQueue.notificationQueue )
					{
						if ( n.effect == hungerEffectID )
						{
							notif = &(n);
						}
						break;
					}
					break;
				}
			}
			if ( entry && entry->customVariable != hungerStateToSet )
			{
				if ( notif && notif->customVariable != hungerStateToSet )
				{
					// reset the notification
					bool erased = false;
					for ( auto it = statusEffectQueue.notificationQueue.begin(); it != statusEffectQueue.notificationQueue.end(); ++it )
					{
						if ( (*it).effect == hungerEffectID )
						{
							statusEffectQueue.notificationQueue.erase(it);
							erased = true;
							break;
						}
					}
					statusEffectQueue.notificationQueue.push_back(StatusEffectQueueEntry_t(hungerEffectID));
					statusEffectQueue.notificationQueue.back().pos.x = statusEffectQueue.getBaseEffectPosX();
					statusEffectQueue.notificationQueue.back().pos.y = statusEffectQueue.getBaseEffectPosY();

					// fall back if notificationTargetPosition doesn't have an effect to go to.
					statusEffectQueue.notificationQueue.back().notificationTargetPosition.x = 0;
					statusEffectQueue.notificationQueue.back().notificationTargetPosition.y = statusEffectFrame->getSize().h
						- statusEffectQueue.notificationQueue.back().notificationTargetPosition.h;
					statusEffectQueue.requiresAnimUpdate = true;
					entry->customVariable = hungerStateToSet;
					statusEffectQueue.notificationQueue.back().customVariable = hungerStateToSet;
				}
				else
				{
					// else, delete and reapply
					statusEffectQueue.deleteEffect(hungerEffectID);
					if ( statusEffectQueue.insertEffect(hungerEffectID, -1) )
					{
						if ( statusEffectQueue.effectQueue.back().effect == hungerEffectID )
						{
							statusEffectQueue.effectQueue.back().customVariable = hungerStateToSet;
							statusEffectQueue.notificationQueue.back().customVariable = hungerStateToSet;
						}
					}
				}
			}
			else
			{
				// new effect, does not exist
				if ( statusEffectQueue.insertEffect(hungerEffectID, -1) )
				{
					if ( statusEffectQueue.effectQueue.back().effect == hungerEffectID )
					{
						statusEffectQueue.effectQueue.back().customVariable = hungerStateToSet;
						statusEffectQueue.notificationQueue.back().customVariable = hungerStateToSet;
					}
				}
			}
		}
	}

	statusEffectQueue.updateAllQueuedEffects();
}

void Player::Inventory_t::updateInventoryMiscTooltip()
{
	if ( !frame )
	{
		return;
	}
	if ( !miscTooltipFrame )
	{
		auto tooltipFrame = frame->addFrame("misc tooltip");
		miscTooltipFrame = tooltipFrame;
		tooltipFrame->setSize(SDL_Rect{ 212, 0, 200, 200 });
		tooltipFrame->setHollow(true);
		tooltipFrame->setInheritParentFrameOpacity(false);
		tooltipFrame->setDisabled(true);
		Uint32 color = makeColor(255, 255, 255, 255);
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TL_00.png", skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TR_00.png", skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_T_00.png", skillsheetEffectBackgroundImages[TOP].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_L_00.png", skillsheetEffectBackgroundImages[MIDDLE_LEFT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_R_00.png", skillsheetEffectBackgroundImages[MIDDLE_RIGHT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			makeColor(22, 24, 29, 255), "images/system/white.png", skillsheetEffectBackgroundImages[MIDDLE].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_BL_00.png", skillsheetEffectBackgroundImages[BOTTOM_LEFT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_BR_00.png", skillsheetEffectBackgroundImages[BOTTOM_RIGHT].c_str());
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_B_00.png", skillsheetEffectBackgroundImages[BOTTOM].c_str());
		imageSetWidthHeight9x9(tooltipFrame, skillsheetEffectBackgroundImages);
		imageResizeToContainer9x9(tooltipFrame, SDL_Rect{ 0, 0, 200, 200 }, skillsheetEffectBackgroundImages);
		auto txt = tooltipFrame->addField("tooltip text", 1024);
		const char* tooltipFont = "fonts/pixel_maz_multiline.ttf#16#2";
		txt->setFont(tooltipFont);
		txt->setColor(makeColor(188, 154, 114, 255));
	}

	auto tooltipFrame = miscTooltipFrame;
	if ( tooltipFrame->isDisabled() )
	{
		miscTooltipOpacitySetpoint = 0;
		miscTooltipOpacityAnimate = 1.0;
	}

	if ( static_cast<int>(tooltipFrame->getOpacity()) != miscTooltipOpacitySetpoint )
	{
		const real_t fpsScale = getFPSScale(144.0);
		if ( miscTooltipOpacitySetpoint == 0 )
		{
			if ( ticks - miscTooltipDeselectedTick > 5 )
			{
				real_t factor = 10.0;
				real_t setpointDiff = fpsScale * std::max(.05, (miscTooltipOpacityAnimate)) / (factor);
				miscTooltipOpacityAnimate -= setpointDiff;
				miscTooltipOpacityAnimate = std::max(0.0, miscTooltipOpacityAnimate);
			}
		}
		else
		{
			real_t setpointDiff = fpsScale * std::max(.05, (1.0 - miscTooltipOpacityAnimate)) / (1);
			miscTooltipOpacityAnimate += setpointDiff;
			miscTooltipOpacityAnimate = std::min(1.0, miscTooltipOpacityAnimate);
		}
		tooltipFrame->setOpacity(miscTooltipOpacityAnimate * 100);
	}
	else
	{
		tooltipFrame->setOpacity(miscTooltipOpacitySetpoint);
	}

	Button* autosortBtn = nullptr;
	if ( player.shootmode )
	{
		miscTooltipOpacitySetpoint = 0;
		miscTooltipOpacityAnimate = 0.0;
		return;
	}
	if ( !playerInventoryFrames[player.playernum].autosortFrame )
	{
		return;
	}
	else
	{
		autosortBtn = playerInventoryFrames[player.playernum].autosortFrame->findButton("autosort button");
		if ( !autosortBtn || !autosortBtn->isHighlighted() || !autosortBtn->isSelected() || autosortBtn->isDisabled() )
		{
			return;
		}
	}

	miscTooltipOpacitySetpoint = 0;
	miscTooltipOpacityAnimate = 1.0;
	tooltipFrame->setDisabled(false);
	tooltipFrame->setOpacity(100.0);
	miscTooltipDeselectedTick = ticks;

	Uint32 defaultColor = hudColors.characterSheetNeutral;
	auto txt = tooltipFrame->findField("tooltip text");
	txt->setColor(defaultColor);

	if ( true )
	{
		const int maxWidth = 200;
		const int padx = 16;
		const int pady1 = 8;
		const int pady2 = 8;
		const int padyMid = 4;
		const int padxMid = 4;
		SDL_Rect tooltipPos = SDL_Rect{ 400, 0, maxWidth, 100 };
		bool usingMouse = !inputs.getVirtualMouse(player.playernum)->lastMovementFromController;
		bool updateTxt = false;
		if ( player.bUseCompactGUIHeight() )
		{
			if ( strcmp(player.characterSheet.getHoverTextString("autosort_button_mouse_compact").c_str(), txt->getText()) )
			{
				txt->setText(player.characterSheet.getHoverTextString("autosort_button_mouse_compact").c_str());
				updateTxt = true;
			}
		}
		else
		{
			if ( strcmp(player.characterSheet.getHoverTextString("autosort_button_mouse").c_str(), txt->getText()) )
			{
				txt->setText(player.characterSheet.getHoverTextString("autosort_button_mouse").c_str());
				updateTxt = true;
			}
		}

		SDL_Rect txtPos = SDL_Rect{ padx, pady1, maxWidth - padx * 2, 80 };
		txt->setSize(txtPos);
		Font* actualFont = Font::get(txt->getFont());
		int txtHeight = txt->getNumTextLines() * actualFont->height(true);
		txtPos.h = txtHeight + padyMid;
		auto txtGet = Text::get(txt->getLongestLine().c_str(), txt->getFont(),
			txt->getTextColor(), txt->getOutlineColor());
		txtPos.w = txtGet->getWidth();
		txt->setSize(txtPos);

		tooltipPos.w = txtPos.w + padx * 2;
		tooltipPos.h = pady1 + txtPos.h + pady2;

		if ( updateTxt )
		{
			txt->reflowTextToFit(0);
		}

		int tooltipCoordX = 0;
		PanelJustify_t justify = paperDollPanelJustify;
		auto inventoryBgFrame = playerInventoryFrames[player.playernum].inventoryBgFrame;
		if ( !bCompactView )
		{
			Frame::image_t* invBaseImg = invBaseImg = playerInventoryFrames[player.playernum].defaultInvImg;

			if ( justify == PANEL_JUSTIFY_LEFT )
			{
				tooltipCoordX = inventoryBgFrame->getSize().x + 8;
				tooltipCoordX += invBaseImg->pos.w;
			}
			else
			{
				tooltipCoordX = inventoryBgFrame->getSize().x - 8;
				tooltipCoordX += invBaseImg->pos.x;
				tooltipCoordX -= tooltipPos.w;
			}
		}
		else
		{
			Frame::image_t* compactImg = compactImg = playerInventoryFrames[player.playernum].compactCharImg;
			if ( justify == PANEL_JUSTIFY_LEFT )
			{
				tooltipCoordX = inventoryBgFrame->getSize().x + 8;
				tooltipCoordX += compactImg->pos.w;
			}
			else
			{
				tooltipCoordX = inventoryBgFrame->getSize().x - 8;
				tooltipCoordX += compactImg->pos.x;
				tooltipCoordX -= tooltipPos.w;
			}
		}
		tooltipPos.x = tooltipCoordX;
		tooltipPos.y = autosortBtn->getSize().y;
		tooltipFrame->setSize(tooltipPos);
		imageResizeToContainer9x9(tooltipFrame, SDL_Rect{ 0, 0, tooltipPos.w, tooltipPos.h },
			skillsheetEffectBackgroundImages);
	}
}

void createWorldTooltipPrompts(const int player)
{
	auto& hud_t = players[player]->hud;
	auto& worldTooltipFrame = hud_t.worldTooltipFrame;
	worldTooltipFrame = hud_t.hudFrame->addFrame("world tooltip");
	worldTooltipFrame->setHollow(true);
	worldTooltipFrame->setBorder(0);
	worldTooltipFrame->setOwner(player);
	worldTooltipFrame->setSize(SDL_Rect{ 0, 0, 0, 0 });
	worldTooltipFrame->setDisabled(true);

	const char* promptFont = "fonts/pixel_maz_multiline.ttf#16#2";

	Uint32 iconColor = makeColor(255, 255, 255, Player::HUD_t::actionPromptIconOpacity);
	Uint32 iconBackingColor = makeColor(255, 255, 255, Player::HUD_t::actionPromptIconBackingOpacity);

	auto text = worldTooltipFrame->addField("prompt text", 256);
	text->setFont(promptFont);
	text->setText("");
	text->setDisabled(true);
	text->setSize(SDL_Rect{ 0, 0, 0, 0 });

	auto text2 = worldTooltipFrame->addField("prompt cycle text", 256);
	text2->setFont(promptFont);
	text2->setText("");
	text2->setDisabled(true);
	text2->setSize(SDL_Rect{ 0, 0, 0, 0 });

	auto text3 = worldTooltipFrame->addField("prompt callout text", 256);
	text3->setFont(promptFont);
	text3->setText("");
	text3->setDisabled(true);
	text3->setSize(SDL_Rect{ 0, 0, 0, 0 });

	const int iconSize = 24;
	SDL_Rect iconPos{ 0, 0, iconSize, iconSize };

	auto icon = worldTooltipFrame->addImage(iconPos,
		iconColor, "images/system/white.png", "icon img");
	icon->disabled = true;

	auto glyph = worldTooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "images/system/white.png", "glyph img");
	glyph->disabled = true;

	auto glyphAdditional = worldTooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "images/system/white.png", "glyph img 2");
	glyphAdditional->disabled = true;

	auto glyphAdditional2 = worldTooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "images/system/white.png", "glyph img 3");
	glyphAdditional2->disabled = true;

	auto glyphAdditional3 = worldTooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "images/system/white.png", "glyph img 4");
	glyphAdditional3->disabled = true;

	auto cursor = worldTooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "images/system/white.png", "cursor img");
	cursor->disabled = true;
}

const char* Player::HUD_t::getCrosshairPath()
{
	switch ( playerSettings[multiplayer ? 0 : player.playernum].shootmodeCrosshair )
	{
		case 0:
		default:
			return "*#images/ui/Crosshairs/cross.png";
			break;
		case 1:
			return "*#images/ui/Crosshairs/cursor_thicc.png";
			break;
		case 2:
			return "*#images/ui/Crosshairs/cursor_plusA.png";
			break;
		case 3:
			return "*#images/ui/Crosshairs/cursor_plusB.png";
			break;
		case 4:
			return "*#images/ui/Crosshairs/cursor_crosshair.png";
			break;
		case 5:
			return "*#images/ui/Crosshairs/cursor_xB.png";
			break;
		case 6:
			return "*#images/ui/Crosshairs/cursor_carrot.png";
			break;
		case 7:
			return "*#images/ui/Crosshairs/cursor_circleB.png";
			break;
		case 8:
			return "*#images/ui/Crosshairs/cursor_dotsB.png";
			break;
		case 9:
			return "*#images/ui/Crosshairs/cursor_dotsC.png";
			break;
		case 10:
			return "*#images/ui/Crosshairs/cursor_smiley.png";
			break;
		case 11:
			return "*#images/ui/Crosshairs/cursor_nethack.png";
			break;
	}
}

void Player::HUD_t::updateWorldTooltipPrompts()
{
	if ( !hudFrame )
	{
		return;
	}

	if ( !worldTooltipFrame )
	{
		createWorldTooltipPrompts(player.playernum);
		if ( !worldTooltipFrame )
		{
			return;
		}
	}

	worldTooltipFrame->setDisabled(true);

	if ( !player.shootmode || nohud || gamePaused )
	{
		return;
	}

	SDL_Rect promptPos{ player.camera_virtualWidth() / 2, player.camera_virtualHeight() / 2, 0, 0 };

	FollowerRadialMenu& followerMenu = FollowerMenu[player.playernum];
	CalloutRadialMenu& calloutMenu = CalloutMenu[player.playernum];

	auto icon = worldTooltipFrame->findImage("icon img");
	icon->disabled = true;
	auto glyph = worldTooltipFrame->findImage("glyph img");
	glyph->disabled = true;
	auto glyphAdditional = worldTooltipFrame->findImage("glyph img 2");
	glyphAdditional->disabled = true;
	auto cursor = worldTooltipFrame->findImage("cursor img");
	cursor->disabled = true;
	auto text = worldTooltipFrame->findField("prompt text");
	text->setDisabled(true);
	auto textCycle = worldTooltipFrame->findField("prompt cycle text");
	textCycle->setDisabled(true);
	auto textCallout = worldTooltipFrame->findField("prompt callout text");
	textCallout->setDisabled(true);
	auto glyphCycle = worldTooltipFrame->findImage("glyph img 3");
	glyphCycle->disabled = true;
	auto glyphCallout = worldTooltipFrame->findImage("glyph img 4");
	glyphCallout->disabled = true;

	SDL_Rect textPos{ 0, 0, 0, 0 };
	const int skillIconToGlyphPadding = 4;
	const int nominalGlyphHeight = 26;

	bool usingTinkeringKit = false;
	bool useBracketsReticle = false;
	bool useSneakingReticle = false;
	if ( player.entity && stats[player.playernum] ) {
		if ( stats[player.playernum]->defending ) {
			auto shield = stats[player.playernum]->shield;
			if ( shield && shield->type == TOOL_TINKERING_KIT ) {
				useBracketsReticle = true;
				usingTinkeringKit = true;
			}
		}
		if ( stats[player.playernum]->sneaking ) {
			useBracketsReticle = true;
			useSneakingReticle = true;
		}
	}
	else if ( player.ghost.isActive() )
	{
		if ( player.ghost.my->skill[3] == 1 )
		{
			useSneakingReticle = true;
		}
	}

	bool followerInteract = followerMenu.selectMoveTo && (followerMenu.optionSelected == ALLY_CMD_MOVETO_SELECT
		|| followerMenu.optionSelected == ALLY_CMD_ATTACK_SELECT);
	bool calloutInteract = calloutMenu.selectMoveTo && (calloutMenu.optionSelected == CalloutRadialMenu::CALLOUT_CMD_SELECT);

	if ( followerInteract || calloutInteract )
	{
		bool forceBlankInteractText = false;
		auto optionSelected = followerInteract ? followerMenu.optionSelected : calloutMenu.optionSelected;
		if ( !player.worldUI.isEnabled() )
		{
			cursor->path = "#*images/ui/Crosshairs/cursor_xB.png";
			if ( auto imgGet = Image::get(cursor->path.c_str()) )
			{
				cursor->disabled = false;
				promptPos.x -= (int)imgGet->getWidth() / 2;
				promptPos.y -= (int)imgGet->getHeight() / 2;
				SDL_Rect cursorPos{ 0, 0, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
				cursor->pos = cursorPos;
				cursor->color = makeColor(255, 255, 255, 191);
			}
			textPos.x = cursor->pos.x + 24;
			textPos.y = cursor->pos.y + 20;
		}
		else
		{
			if ( optionSelected == ALLY_CMD_MOVETO_SELECT )
			{
				cursor->path = "#*images/ui/Crosshairs/cursor_xB.png";
				if ( auto imgGet = Image::get(cursor->path.c_str()) )
				{
					cursor->disabled = false;
					promptPos.x -= (int)imgGet->getWidth() / 2;
					promptPos.y -= (int)imgGet->getHeight() / 2;
					SDL_Rect cursorPos{ 0, 0, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
					cursor->pos = cursorPos;
					cursor->color = makeColor(255, 255, 255, 191);
				}

				textPos.x = cursor->pos.x + cursor->pos.w / 2;
				textPos.y = cursor->pos.y + cursor->pos.h / 2;
				if ( auto imgGet = Image::get("images/system/selectedcursor.png") )
				{
					textPos.x -= (int)imgGet->getWidth() / 2;
					textPos.y -= (int)imgGet->getHeight() / 2;
				}

				if ( textPos.x < 0 )
				{
					promptPos.x += textPos.x;
					cursor->pos.x -= textPos.x;
					textPos.x = 0;
				}
				if ( textPos.y < 0 )
				{
					promptPos.y += textPos.y;
					cursor->pos.y -= textPos.y;
					textPos.y = 0;
				}
			}
			else
			{
				if ( player.worldUI.isEnabled() && !player.worldUI.bTooltipInView )
				{
					forceBlankInteractText = true;

					cursor->path = getCrosshairPath();
					if ( auto imgGet = Image::get(cursor->path.c_str()) )
					{
						cursor->disabled = false;
						promptPos.x -= (int)imgGet->getWidth() / 2;
						promptPos.y -= (int)imgGet->getHeight() / 2;
						SDL_Rect cursorPos{ 0, 0, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
						cursor->pos = cursorPos;
						cursor->color = makeColor(255, 255, 255, 255 * playerSettings[multiplayer ? 0 : player.playernum].shootmodeCrosshairOpacity / 100.f);
					}

					textPos.x = cursor->pos.x + cursor->pos.w / 2;
					textPos.y = cursor->pos.y + cursor->pos.h / 2;
					if ( auto imgGet = Image::get("images/system/selectedcursor.png") )
					{
						textPos.x -= (int)imgGet->getWidth() / 2;
						textPos.y -= (int)imgGet->getHeight() / 2;
					}

					if ( textPos.x < 0 )
					{
						promptPos.x += textPos.x;
						cursor->pos.x -= textPos.x;
						textPos.x = 0;
					}
					if ( textPos.y < 0 )
					{
						promptPos.y += textPos.y;
						cursor->pos.y -= textPos.y;
						textPos.y = 0;
					}
				}
				else
				{
					cursor->path = "images/system/selectedcursor.png";
					if ( auto imgGet = Image::get(cursor->path.c_str()) )
					{
						cursor->disabled = false;
						promptPos.x -= (int)imgGet->getWidth() / 2;
						promptPos.y -= (int)imgGet->getHeight() / 2;
						SDL_Rect cursorPos{ 0, 0, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
						cursor->pos = cursorPos;
						cursor->color = makeColor(255, 255, 255, 255 * playerSettings[multiplayer ? 0 : player.playernum].shootmodeCrosshairOpacity / 100.f);
					}
				}
			}

			textPos.x += 40;
			textPos.y += 20;
		}

		auto glyphPathPressed = Input::inputs[player.playernum].getGlyphPathForBinding("Use", true);
		auto glyphPathUnpressed = Input::inputs[player.playernum].getGlyphPathForBinding("Use", false);
		auto glyphAdditionalPathPressed = Input::inputs[player.playernum].getGlyphPathForBinding("Defend", true);
		auto glyphAdditionalPathUnpressed = Input::inputs[player.playernum].getGlyphPathForBinding("Defend", false);
		if ( ticks % 50 < 25 )
		{
			glyph->path = glyphPathPressed;
			if ( auto imgGet = Image::get(glyph->path.c_str()) )
			{
				glyph->disabled = false;
				SDL_Rect glyphPos{ textPos.x, textPos.y, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
				glyph->pos = glyphPos;
				if ( auto imgGetUnpressed = Image::get(glyphPathUnpressed.c_str()) )
				{
					const int unpressedHeight = imgGetUnpressed->getHeight();
					if ( unpressedHeight != glyph->pos.h )
					{
						glyph->pos.y -= (glyph->pos.h - unpressedHeight);
					}

					if ( unpressedHeight != nominalGlyphHeight )
					{
						glyph->pos.y -= (unpressedHeight - nominalGlyphHeight) / 2;
					}
				}
				textPos.x += glyph->pos.w;
			}
		}
		else
		{
			glyph->path = glyphPathUnpressed;
			if ( auto imgGet = Image::get(glyph->path.c_str()) )
			{
				glyph->disabled = false;
				SDL_Rect glyphPos{ textPos.x, textPos.y, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
				glyph->pos = glyphPos;
				textPos.x += glyph->pos.w;

				if ( glyph->pos.h != nominalGlyphHeight )
				{
					glyph->pos.y -= (glyph->pos.h - nominalGlyphHeight) / 2;
				}
			}
		}

		textPos.x += skillIconToGlyphPadding;

		if ( Input::inputs[player.playernum].binary("Defend") )
		{
			glyphAdditional->path = glyphAdditionalPathUnpressed;
			if ( auto imgGet = Image::get(glyphAdditional->path.c_str()) )
			{
				glyphAdditional->disabled = false;
				SDL_Rect glyphPos{ textPos.x, textPos.y, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
				glyphAdditional->pos = glyphPos;
				if ( auto imgGetUnpressed = Image::get(glyphAdditionalPathUnpressed.c_str()) )
				{
					const int unpressedHeight = imgGetUnpressed->getHeight();
					if ( unpressedHeight != glyphAdditional->pos.h )
					{
						glyphAdditional->pos.y -= (glyphAdditional->pos.h - unpressedHeight);
					}

					if ( unpressedHeight != nominalGlyphHeight )
					{
						glyphAdditional->pos.y -= (unpressedHeight - nominalGlyphHeight) / 2;
					}
				}
				textPos.x += glyphAdditional->pos.w;
				textPos.x += skillIconToGlyphPadding;
			}
		}

		if ( calloutInteract )
		{
			icon->path = "*images/ui/HUD/HUD_Ally_Callout_00.png";
		}
		else
		{
			for ( auto& skill : player.skillSheet.skillSheetData.skillEntries )
			{
				if ( skill.skillId == PRO_LEADERSHIP )
				{
					if ( skillCapstoneUnlocked(player.playernum, PRO_LEADERSHIP) )
					{
						icon->path = skill.skillIconPathLegend;
					}
					else
					{
						icon->path = skill.skillIconPath;
					}
					break;
				}
			}
		}

		if ( auto imgGet = Image::get(icon->path.c_str()) )
		{
			icon->disabled = false;
			SDL_Rect iconPos{ textPos.x, textPos.y, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
			icon->pos = iconPos;
			textPos.x += icon->pos.w + skillIconToGlyphPadding;
		}
		

		if ( followerInteract && optionSelected == ALLY_CMD_MOVETO_SELECT )
		{
			if ( followerMenu.followerToCommand
				&& (followerMenu.followerToCommand->getMonsterTypeFromSprite() == SENTRYBOT
					|| followerMenu.followerToCommand->getMonsterTypeFromSprite() == SPELLBOT)
				)
			{
				text->setDisabled(false);
				if ( !glyphAdditional->disabled )
				{
					std::string txt = Language::get(4201);
					txt += Language::get(3650);
					text->setText(txt.c_str());
				}
				else
				{
					text->setText(Language::get(3650));
				}
			}
			else
			{
				text->setDisabled(false);
				if ( !glyphAdditional->disabled )
				{
					std::string txt = Language::get(4201);
					txt += Language::get(3039);
					text->setText(txt.c_str());
				}
				else
				{
					text->setText(Language::get(3039));
				}
			}
		}
		else
		{
			if ( followerInteract )
			{
				if ( !strcmp(followerMenu.interactText, "") || forceBlankInteractText )
				{
					if ( followerMenu.followerToCommand )
					{
						int type = followerMenu.followerToCommand->getMonsterTypeFromSprite();
						if ( followerMenu.allowedInteractItems(type)
							|| followerMenu.allowedInteractFood(type)
							|| followerMenu.allowedInteractWorld(type)
							)
						{
							text->setDisabled(false);
							text->setText(Language::get(4041)); // "Interact with..."
						}
						else
						{
							text->setDisabled(false);
							text->setText(Language::get(4042)); // "Attack..."
						}
					}
					else
					{
						text->setDisabled(false);
						text->setText(Language::get(4041)); // "Interact with..."
					}
				}
				else
				{
					text->setDisabled(false);
					text->setText(followerMenu.interactText);
				}
			}
			else if ( calloutInteract )
			{
				if ( !strcmp(calloutMenu.interactText, "") || forceBlankInteractText )
				{
					text->setDisabled(false);
					text->setText(Language::get(4348)); // "Call out..."
				}
				else
				{
					text->setDisabled(false);
					text->setText(calloutMenu.interactText);
				}
			}
		}

		if ( !glyphAdditional->disabled )
		{
			if ( !strstr(text->getText(), Language::get(4201)) ) // no "(ALL) " text
			{
				glyphAdditional->disabled = true;
				textPos.x -= glyphAdditional->pos.w + skillIconToGlyphPadding;
				icon->pos.x -= glyphAdditional->pos.w + skillIconToGlyphPadding;
				//textPos.x -= icon->pos.w + skillIconToGlyphPadding;
			}
		}
	}
	else
	{
		if ( !player.entity && !player.ghost.isActive() )
		{
			cursor->disabled = true;
		}
		else if ( player.worldUI.bTooltipInView )
		{
			cursor->path = "images/system/selectedcursor.png";
			if ( auto imgGet = Image::get(cursor->path.c_str()) )
			{
				cursor->disabled = false;
				promptPos.x -= (int)imgGet->getWidth() / 2;
				promptPos.y -= (int)imgGet->getHeight() / 2;
				SDL_Rect cursorPos{ 0, 0, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
				cursor->pos = cursorPos;
				cursor->color = makeColor(255, 255, 255, 255 * playerSettings[multiplayer ? 0 : player.playernum].shootmodeCrosshairOpacity / 100.f);
			}

			textPos.x += 40;
			textPos.y += 20;

			auto glyphPathPressed = Input::inputs[player.playernum].getGlyphPathForBinding("Use", true);
			auto glyphPathUnpressed = Input::inputs[player.playernum].getGlyphPathForBinding("Use", false);
			if ( ticks % 50 < 25 )
			{
				glyph->path = glyphPathPressed;
				if ( auto imgGet = Image::get(glyph->path.c_str()) )
				{
					glyph->disabled = false;
					SDL_Rect glyphPos{ textPos.x, textPos.y, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
					glyph->pos = glyphPos;
					if ( auto imgGetUnpressed = Image::get(glyphPathUnpressed.c_str()) )
					{
						const int unpressedHeight = imgGetUnpressed->getHeight();
						if ( unpressedHeight != glyph->pos.h )
						{
							glyph->pos.y -= (glyph->pos.h - unpressedHeight);
						}

						if ( unpressedHeight != nominalGlyphHeight )
						{
							glyph->pos.y -= (unpressedHeight - nominalGlyphHeight) / 2;
						}
					}
					textPos.x += glyph->pos.w;
				}
			}
			else
			{
				glyph->path = glyphPathUnpressed;
				if ( auto imgGet = Image::get(glyph->path.c_str()) )
				{
					glyph->disabled = false;
					SDL_Rect glyphPos{ textPos.x, textPos.y, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
					glyph->pos = glyphPos;
					textPos.x += glyph->pos.w;

					if ( glyph->pos.h != nominalGlyphHeight )
					{
						glyph->pos.y -= (glyph->pos.h - nominalGlyphHeight) / 2;
					}
				}
			}
			textPos.x += skillIconToGlyphPadding;

			if ( usingTinkeringKit )
			{
				for ( auto& skill : player.skillSheet.skillSheetData.skillEntries )
				{
					if ( skill.skillId == PRO_LOCKPICKING )
					{
						if ( skillCapstoneUnlocked(player.playernum, PRO_LOCKPICKING) )
						{
							icon->path = skill.skillIconPathLegend;
						}
						else
						{
							icon->path = skill.skillIconPath;
						}
						break;
					}
				}

				if ( auto imgGet = Image::get(icon->path.c_str()) )
				{
					icon->disabled = false;
					SDL_Rect iconPos{ textPos.x, textPos.y, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
					icon->pos = iconPos;
					textPos.x += icon->pos.w + skillIconToGlyphPadding;
				}
			}

			text->setDisabled(false);
			text->setText(player.worldUI.interactText.c_str());
		}
		else
		{
			if ( useSneakingReticle )
			{
				cursor->path = "*#images/system/sneakingcursor.png";
			}
			else if ( useBracketsReticle )
			{
				cursor->path = "*#images/system/selectedcursor.png";
			}
			else
			{
				cursor->path = getCrosshairPath();
			}
			if ( auto imgGet = Image::get(cursor->path.c_str()) )
			{
				cursor->disabled = false;
				promptPos.x -= (int)imgGet->getWidth() / 2;
				promptPos.y -= (int)imgGet->getHeight() / 2;
				SDL_Rect cursorPos{ 0, 0, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
				cursor->pos = cursorPos;
				cursor->color = makeColor(255, 255, 255, 255 * playerSettings[multiplayer ? 0 : player.playernum].shootmodeCrosshairOpacity / 100.f);
			}

			if ( usingTinkeringKit )
			{
				if ( player.worldUI.isEnabled() )
				{
					textPos.x = cursor->pos.x + cursor->pos.w / 2;
					textPos.y = cursor->pos.y + cursor->pos.h / 2;
					if ( auto imgGet = Image::get("images/system/selectedcursor.png") )
					{
						textPos.x -= (int)imgGet->getWidth() / 2;
						textPos.y -= (int)imgGet->getHeight() / 2;
					}

					if ( textPos.x < 0 )
					{
						promptPos.x += textPos.x;
						cursor->pos.x -= textPos.x;
						textPos.x = 0;
					}
					if ( textPos.y < 0 )
					{
						promptPos.y += textPos.y;
						cursor->pos.y -= textPos.y;
						textPos.y = 0;
					}

					// skip cursor here, no tooltip in view
					textPos.x += 40;
					textPos.y += 20;

					auto glyphPathPressed = Input::inputs[player.playernum].getGlyphPathForBinding("Use", true);
					auto glyphPathUnpressed = Input::inputs[player.playernum].getGlyphPathForBinding("Use", false);
					if ( ticks % 50 < 25 )
					{
						glyph->path = glyphPathPressed;
						if ( auto imgGet = Image::get(glyph->path.c_str()) )
						{
							glyph->disabled = false;
							SDL_Rect glyphPos{ textPos.x, textPos.y, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
							glyph->pos = glyphPos;
							if ( auto imgGetUnpressed = Image::get(glyphPathUnpressed.c_str()) )
							{
								const int unpressedHeight = imgGetUnpressed->getHeight();
								if ( unpressedHeight != glyph->pos.h )
								{
									glyph->pos.y -= (glyph->pos.h - unpressedHeight);
								}

								if ( unpressedHeight != nominalGlyphHeight )
								{
									glyph->pos.y -= (unpressedHeight - nominalGlyphHeight) / 2;
								}
							}
							textPos.x += glyph->pos.w;
						}
					}
					else
					{
						glyph->path = glyphPathUnpressed;
						if ( auto imgGet = Image::get(glyph->path.c_str()) )
						{
							glyph->disabled = false;
							SDL_Rect glyphPos{ textPos.x, textPos.y, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
							glyph->pos = glyphPos;
							textPos.x += glyph->pos.w;

							if ( glyph->pos.h != nominalGlyphHeight )
							{
								glyph->pos.y -= (glyph->pos.h - nominalGlyphHeight) / 2;
							}
						}
					}
					textPos.x += skillIconToGlyphPadding;

					for ( auto& skill : player.skillSheet.skillSheetData.skillEntries )
					{
						if ( skill.skillId == PRO_LOCKPICKING )
						{
							if ( skillCapstoneUnlocked(player.playernum, PRO_LOCKPICKING) )
							{
								icon->path = skill.skillIconPathLegend;
							}
							else
							{
								icon->path = skill.skillIconPath;
							}
							break;
						}
					}

					if ( auto imgGet = Image::get(icon->path.c_str()) )
					{
						icon->disabled = false;
						SDL_Rect iconPos{ textPos.x, textPos.y, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
						icon->pos = iconPos;
						textPos.x += icon->pos.w + skillIconToGlyphPadding;
					}

					text->setDisabled(false);
					text->setText(Language::get(3663));
				}
				else
				{
					textPos.x = cursor->pos.x + 15;
					textPos.y = cursor->pos.y + 11;

					text->setDisabled(false);
					text->setText(Language::get(3663));
				}
			}
		}
	}

	if ( !text->isDisabled() )
	{
		textPos.w = text->getTextObject()->getWidth();
		textPos.h = Font::get(text->getFont())->height() + 8;
		textPos.y -= 1;
		text->setVJustify(Field::justify_t::CENTER);
		text->setSize(textPos);

		promptPos.w = text->getSize().x + text->getSize().w;
		promptPos.h = text->getSize().y + text->getSize().h;
	}
	if ( !glyph->disabled )
	{
		promptPos.w = std::max(glyph->pos.x + glyph->pos.w, promptPos.w);
		promptPos.h = std::max(glyph->pos.y + glyph->pos.h, promptPos.h);
	}
	if ( !icon->disabled )
	{
		if ( icon->pos.h != nominalGlyphHeight )
		{
			icon->pos.y -= (icon->pos.h - nominalGlyphHeight) / 2;
		}

		promptPos.w = std::max(icon->pos.x + icon->pos.w, promptPos.w);
		promptPos.h = std::max(icon->pos.y + icon->pos.h, promptPos.h);
	}
	if ( !cursor->disabled )
	{
		promptPos.w = std::max(cursor->pos.x + cursor->pos.w, promptPos.w);
		promptPos.h = std::max(cursor->pos.y + cursor->pos.h, promptPos.h);
	}

	auto prevGlyphPos = glyph->pos;
	if ( false && !text->isDisabled() && !glyph->disabled )
	{
		if ( CalloutMenu[player.playernum].calloutMenuIsOpen() )
		{
			auto glyphPathUnpressed = Input::inputs[player.playernum].getGlyphPathForBinding("Call Out", false);
			auto glyphPathPressed = Input::inputs[player.playernum].getGlyphPathForBinding("Call Out", true);

			if ( ticks % 50 < 25 )
			{
				glyphCallout->path = glyphPathPressed;
				if ( auto imgGet = Image::get(glyphCallout->path.c_str()) )
				{
					glyphCallout->disabled = false;
					glyphCallout->pos = SDL_Rect{ 0, 0, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
					glyphCallout->pos.y = std::max(icon->pos.y + icon->pos.h - 4, prevGlyphPos.y + prevGlyphPos.h) + 4;
					glyphCallout->pos.x = prevGlyphPos.x + prevGlyphPos.w / 2 - glyphCallout->pos.w / 2;
					if ( glyphCallout->pos.x % 2 == 1 )
					{
						++glyphCallout->pos.x;
					}
					if ( auto imgGetUnpressed = Image::get(glyphPathUnpressed.c_str()) )
					{
						const int unpressedHeight = imgGetUnpressed->getHeight();
						if ( unpressedHeight != glyphCallout->pos.h )
						{
							glyphCallout->pos.y -= (glyphCallout->pos.h - unpressedHeight);
						}

						/*if ( unpressedHeight != nominalGlyphHeight )
						{
							prevGlyphPos.y -= (unpressedHeight - nominalGlyphHeight) / 2;
						}*/
					}
					textPos.x += prevGlyphPos.w;
				}
			}
			else
			{
				glyphCallout->path = glyphPathUnpressed;
				if ( auto imgGet = Image::get(glyphCallout->path.c_str()) )
				{
					glyphCallout->disabled = false;
					glyphCallout->pos = SDL_Rect{ 0, 0, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
					glyphCallout->pos.y = std::max(icon->pos.y + icon->pos.h - 4, prevGlyphPos.y + prevGlyphPos.h) + 4;
					glyphCallout->pos.x = prevGlyphPos.x + prevGlyphPos.w / 2 - glyphCallout->pos.w / 2;
					if ( glyphCallout->pos.x % 2 == 1 )
					{
						++glyphCallout->pos.x;
					}
				}
			}

			if ( !glyphCallout->disabled )
			{
				glyphCallout->color = makeColor(255, 255, 255, 255);
				textCallout->setText(Language::get(6049));
				textCallout->setColor(makeColor(255, 255, 255, 255));
				SDL_Rect textPos = text->getSize();
				textPos.x = glyphCallout->pos.x + glyphCallout->pos.w + 4;
				textPos.y = glyphCallout->pos.y + 2;

				if ( auto imgGet = Image::get(glyphPathPressed.c_str()) )
				{
					if ( imgGet->getHeight() != glyphCallout->pos.h )
					{
						textPos.y += (glyphCallout->pos.h - imgGet->getHeight()) / 2;
					}
				}
				if ( glyphCallout->pos.h != nominalGlyphHeight )
				{
					textPos.y += (glyphCallout->pos.h - nominalGlyphHeight) / 2;
				}
				textPos.w = textCallout->getTextObject()->getWidth();
				textCallout->setSize(textPos);
				textCallout->setDisabled(false);

				promptPos.w = std::max(textPos.x + textPos.w, promptPos.w);
				promptPos.h = std::max(textPos.y + textPos.h, promptPos.h);
				promptPos.w = std::max(glyphCallout->pos.x + glyphCallout->pos.w, promptPos.w);
				promptPos.h = std::max(glyphCallout->pos.y + glyphCallout->pos.h, promptPos.h);

				prevGlyphPos = glyphCallout->pos;
			}
		}
	}

	if ( player.worldUI.isEnabled() )
	{
		if ( !text->isDisabled() && !glyph->disabled && player.worldUI.tooltipsInRange.size() > 1 )
		{
			if ( Input::inputs[player.playernum].input("Interact Tooltip Next").type != Input::binding_t::bindtype_t::INVALID )
			{
				auto glyphPathUnpressed = Input::inputs[player.playernum].getGlyphPathForBinding("Interact Tooltip Next", false);
				auto glyphPathPressed = Input::inputs[player.playernum].getGlyphPathForBinding("Interact Tooltip Next", true);

				if ( ticks % 50 < 25 )
				{
					glyphCycle->path = glyphPathPressed;
					if ( auto imgGet = Image::get(glyphCycle->path.c_str()) )
					{
						glyphCycle->disabled = false;
						glyphCycle->pos = SDL_Rect{ 0, 0, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
						glyphCycle->pos.y = prevGlyphPos.y + prevGlyphPos.h + 4;
						glyphCycle->pos.x = prevGlyphPos.x + prevGlyphPos.w / 2 - glyphCycle->pos.w / 2;
						if ( glyphCycle->pos.x % 2 == 1 )
						{
							++glyphCycle->pos.x;
						}
						if ( auto imgGetUnpressed = Image::get(glyphPathUnpressed.c_str()) )
						{
							const int unpressedHeight = imgGetUnpressed->getHeight();
							if ( unpressedHeight != glyphCycle->pos.h )
							{
								glyphCycle->pos.y -= (glyphCycle->pos.h - unpressedHeight);
							}

							/*if ( unpressedHeight != nominalGlyphHeight )
							{
								glyph->pos.y -= (unpressedHeight - nominalGlyphHeight) / 2;
							}*/
						}
						textPos.x += prevGlyphPos.w;
					}
				}
				else
				{
					glyphCycle->path = glyphPathUnpressed;
					if ( auto imgGet = Image::get(glyphCycle->path.c_str()) )
					{
						glyphCycle->disabled = false;
						glyphCycle->pos = SDL_Rect{ 0, 0, (int)imgGet->getWidth(), (int)imgGet->getHeight() };
						glyphCycle->pos.y = prevGlyphPos.y + prevGlyphPos.h + 4;
						glyphCycle->pos.x = prevGlyphPos.x + prevGlyphPos.w / 2 - glyphCycle->pos.w / 2;
						if ( glyphCycle->pos.x % 2 == 1 )
						{
							++glyphCycle->pos.x;
						}
					}
				}

				if ( !glyphCycle->disabled )
				{
					//glyphCycle->pos.x += 16;
					//interactPrompt.promptAnim = 1.0;
					glyphCycle->color = makeColor(255, 255, 255, 255 * interactPrompt.promptAnim);
					textCycle->setText(Language::get(4326));
					textCycle->setColor(makeColor(255, 255, 255, 255 * interactPrompt.promptAnim));
					SDL_Rect textPos = text->getSize();
					textPos.x = glyphCycle->pos.x + glyphCycle->pos.w + 4;
					textPos.y = glyphCycle->pos.y + 2;

					if ( auto imgGet = Image::get(glyphPathPressed.c_str()) )
					{
						if ( imgGet->getHeight() != glyphCycle->pos.h )
						{
							textPos.y += (glyphCycle->pos.h - imgGet->getHeight()) / 2;
						}
					}
					if ( glyphCycle->pos.h != nominalGlyphHeight )
					{
						textPos.y += (glyphCycle->pos.h - nominalGlyphHeight) / 2;
					}
					textPos.w = textCycle->getTextObject()->getWidth();
					glyphCycle->pos.y += 4 * sin(interactPrompt.cycleAnim * PI);
					textPos.y += 4 * sin(interactPrompt.cycleAnim * PI);
					textCycle->setSize(textPos);
					textCycle->setDisabled(false);

					promptPos.w = std::max(textPos.x + textPos.w, promptPos.w);
					promptPos.h = std::max(textPos.y + textPos.h, promptPos.h);
					promptPos.w = std::max(glyphCycle->pos.x + glyphCycle->pos.w, promptPos.w);
					promptPos.h = std::max(glyphCycle->pos.y + glyphCycle->pos.h, promptPos.h);

					if ( interactPrompt.processedOnTick != ticks )
					{
						interactPrompt.processedOnTick = ticks;
						++interactPrompt.activeTicks;
					}

					if ( interactPrompt.activeTicks > TICKS_PER_SECOND / 10 )
					{
						const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
						real_t setpointDiff = fpsScale * std::max(.1, (1.0 - interactPrompt.promptAnim)) / 2.5;
						interactPrompt.promptAnim += setpointDiff;
						interactPrompt.promptAnim = std::min(1.0, interactPrompt.promptAnim);
					}
				}

				const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
				real_t setpointDiff = fpsScale * 0.15;
				interactPrompt.cycleAnim += setpointDiff;
				interactPrompt.cycleAnim = std::min(1.0, interactPrompt.cycleAnim);
			}
		}
	}
	if ( textCycle->isDisabled() )
	{
		interactPrompt.promptAnim = 0.0;
		interactPrompt.activeTicks = 0;
		interactPrompt.cycleAnim = 1.0;
	}
	worldTooltipFrame->setSize(promptPos);
	worldTooltipFrame->setDisabled(false);
}

std::string actionPromptBackingIconPath00 = "";
std::string actionPromptBackingIconPath20 = "";
std::string actionPromptBackingIconPath60 = "";
std::string actionPromptBackingIconPath100 = "";

void createActionPrompts(const int player)
{
	auto& hud_t = players[player]->hud;
	auto& actionPromptFrame = hud_t.actionPromptsFrame;
	actionPromptFrame = hud_t.hudFrame->addFrame("action prompts");
	actionPromptFrame->setHollow(true);
	actionPromptFrame->setBorder(0);
	actionPromptFrame->setOwner(player);
	actionPromptFrame->setSize(SDL_Rect{ 0, 0, hud_t.hudFrame->getSize().w, hud_t.hudFrame->getSize().h });
	actionPromptFrame->setDisabled(true);

	const int iconSize = Player::HUD_t::actionPromptIconSize;
	const int glyphSize = 32;
	const int iconBackingSize = Player::HUD_t::actionPromptBackingSize;
	const int maxWidth = std::max(iconSize, iconBackingSize);
	const int maxHeight = std::max(iconSize, iconBackingSize);
	const int promptHeight = maxHeight + glyphSize; // vertical space for prompts

	SDL_Rect iconPos{ maxWidth / 2 - iconSize / 2 - 1, 
		promptHeight - maxHeight / 2 - iconSize / 2 - 1, 
		iconSize, 
		iconSize };
	SDL_Rect iconBackingPos{ maxWidth / 2 - iconBackingSize / 2, 
		promptHeight - maxHeight / 2 - iconBackingSize / 2, 
		iconBackingSize, 
		iconBackingSize };

	const char* promptFont = "fonts/pixel_maz_multiline.ttf#16#2";

	Uint32 iconColor = makeColor(255, 255, 255, Player::HUD_t::actionPromptIconOpacity);
	Uint32 iconBackingColor = makeColor(255, 255, 255, Player::HUD_t::actionPromptIconBackingOpacity);

	auto mainHand = actionPromptFrame->addFrame("action mainhand");
	mainHand->setSize(SDL_Rect{ 400, 400, maxWidth, promptHeight });
	mainHand->addImage(iconBackingPos,
		iconBackingColor, actionPromptBackingIconPath00.c_str(), "action img backing");
	mainHand->addImage(iconPos,
		iconColor, "images/system/white.png", "action img");
	Frame::image_t* glyph = actionPromptFrame->addImage(SDL_Rect{ 0, 0, mainHand->getSize().w, glyphSize },
		0xFFFFFFFF, "images/system/white.png", "action mainhand glyph");
	glyph->ontop = true;
	auto mainHandText = actionPromptFrame->addField("action mainhand text", 64);
	mainHandText->setFont(promptFont);
	mainHandText->setText(Language::get(5963));
	mainHandText->setHJustify(Field::justify_t::CENTER);

	auto offHand = actionPromptFrame->addFrame("action offhand");
	offHand->setSize(SDL_Rect{ 440, 400, maxWidth, promptHeight });
	offHand->addImage(iconBackingPos,
		iconBackingColor, actionPromptBackingIconPath00.c_str(), "action img backing");
	offHand->addImage(iconPos,
		iconColor, "images/system/white.png", "action img");
	glyph = actionPromptFrame->addImage(SDL_Rect{ 0, 0, mainHand->getSize().w, glyphSize },
		0xFFFFFFFF, "images/system/white.png", "action offhand glyph");
	glyph->ontop = true;
	auto offHandText = actionPromptFrame->addField("action offhand text", 64);
	offHandText->setFont(promptFont);
	offHandText->setText(Language::get(5964));
	offHandText->setHJustify(Field::justify_t::CENTER);

	auto magic = actionPromptFrame->addFrame("action magic");
	magic->setSize(SDL_Rect{ 480, 400, maxWidth, promptHeight });
	magic->addImage(iconBackingPos,
		iconBackingColor, actionPromptBackingIconPath00.c_str(), "action img backing");
	magic->addImage(iconPos,
		iconColor, "images/system/white.png", "action img");
	glyph = actionPromptFrame->addImage(SDL_Rect{ 0, 0, mainHand->getSize().w, glyphSize },
		0xFFFFFFFF, "images/system/white.png", "action magic glyph");
	glyph->ontop = true;
	auto magicText = actionPromptFrame->addField("action magic text", 64);
	magicText->setFont(promptFont);
	magicText->setText(Language::get(5965));
	magicText->setHJustify(Field::justify_t::CENTER);

	auto sneak = actionPromptFrame->addFrame("action sneak");
	sneak->setSize(SDL_Rect{ 480, 400, maxWidth, promptHeight });
	sneak->addImage(iconBackingPos,
		iconBackingColor, actionPromptBackingIconPath00.c_str(), "action img backing");
	sneak->addImage(iconPos,
		iconColor, "images/system/white.png", "action img");
	glyph = actionPromptFrame->addImage(SDL_Rect{ 0, 0, mainHand->getSize().w, glyphSize },
		0xFFFFFFFF, "images/system/white.png", "action sneak glyph");
	glyph->ontop = true;
	auto sneakText = actionPromptFrame->addField("action sneak text", 64);
	sneakText->setFont(promptFont);
	sneakText->setText(Language::get(5964));
	sneakText->setHJustify(Field::justify_t::CENTER);
}

void drawActionPromptCooldownCallback(const Widget& widget, SDL_Rect rect)
{
	const int player = widget.getOwner();

	const Frame* parent = static_cast<const Frame*>(widget.getParent());
	{
		SDL_Rect drawRect = rect;
		drawRect.x += 22;
		drawRect.y += 22;
		drawRect.w = 44;
		drawRect.h = 44;
		real_t opacity = 192;
		if ( parent && parent->getOpacity() < 100.0 )
		{
			opacity *= parent->getOpacity() / 100.0;
		}
		const auto& ghost = players[player]->ghost;
		int prompt = reinterpret_cast<intptr_t>(widget.getUserData()) - 1;
		real_t cooldownProgress = 0.0;
		bool errorFlash = false;
		int actionPoints = 0;
		switch ( static_cast<Player::HUD_t::ActionPrompts>(prompt) )
		{
			case Player::HUD_t::ACTION_PROMPT_MAGIC:
				cooldownProgress = (ghost.cooldownTeleport / (real_t)ghost.cooldownTeleportDelay);
				if ( ghost.errorFlashTeleportTicks > 0 && (Player::Ghost_t::errorFlashTicks - ghost.errorFlashTeleportTicks) % 20 < 10 )
				{
					errorFlash = true;
				}
				break;
			case Player::HUD_t::ACTION_PROMPT_OFFHAND:
				if ( ghost.pushPoints > 0 )
				{
					cooldownProgress = 0.0;
				}
				else
				{
					cooldownProgress = (ghost.cooldownPush / (real_t)ghost.cooldownPushDelay);
				}
				actionPoints = ghost.pushPoints;
				if ( ghost.errorFlashPushTicks > 0 && (Player::Ghost_t::errorFlashTicks - ghost.errorFlashPushTicks) % 20 < 10 )
				{
					errorFlash = true;
				}
				break;
			case Player::HUD_t::ACTION_PROMPT_MAINHAND:
				cooldownProgress = (ghost.cooldownChill / (real_t)ghost.cooldownChillDelay);
				if ( ghost.errorFlashChillTicks > 0 && (Player::Ghost_t::errorFlashTicks - ghost.errorFlashChillTicks) % 20 < 10 )
				{
					errorFlash = true;
				}
				break;
			case Player::HUD_t::ACTION_PROMPT_SNEAK:
				break;
			default:
				break;
		}
		if ( cooldownProgress > 0.0 )
		{
			if ( errorFlash )
			{
				drawClockwiseSquareMesh("images/ui/HUD/HUD_ActionPromptBacking00_02_Cooldown.png",
					cooldownProgress,
					drawRect, makeColor(255, 255, 255, opacity));
			}
			else
			{
				Uint8 r, g, b, a;
				getColor(hudColors.characterSheetRed, &r, &g, &b, &a);
				drawClockwiseSquareMesh("images/ui/HUD/HUD_ActionPromptBacking00_02_Cooldown.png",
					cooldownProgress,
					drawRect, makeColor(r, g, b, opacity));
			}
		}
		/*if ( actionPoints > 0 )
		{
			std::string str = std::to_string(actionPoints);
			if ( auto textGet = Text::get(str.c_str(), smallfont_outline, makeColorRGB(255, 255, 255), 0) )
			{
				textGet->drawColor(SDL_Rect{ 0,0,0,0 }, SDL_Rect{ drawRect.x - 6, drawRect.y + 1, 0, 0 },
					SDL_Rect{ 0, 0, Frame::virtualScreenX, Frame::virtualScreenY },
					makeColor(255, 255, 255, 255));
			}
		}*/
	}
}

int Player::HUD_t::actionPromptOffsetX = 280;
int Player::HUD_t::actionPromptOffsetXGhostPrompts = 140;
int Player::HUD_t::actionPromptOffsetY = 22;
int Player::HUD_t::actionPromptBackingSize = 44;
int Player::HUD_t::actionPromptIconSize = 32;
int Player::HUD_t::actionPromptIconOpacity = 255;
int Player::HUD_t::actionPromptIconBackingOpacity = 255;
static ConsoleVariable<bool> disableActionPrompts(
	"/disableactionprompts", false, "Disable action prompts in HUD");
void Player::HUD_t::updateActionPrompts()
{
	if ( !hudFrame )
	{
		return;
	}

	if ( !actionPromptsFrame )
	{
		createActionPrompts(player.playernum);
		if ( !actionPromptsFrame )
		{
			return;
		}
	}


	int playercount = 0;
	for (int c = 0; c < MAXPLAYERS; ++c) {
	    if (!client_disconnected[c] && players[c]->isLocalPlayer()) {
	        ++playercount;
	    }
	}

	bool ghostPrompts = player.ghost.isActive();
	static ConsoleVariable<int> actionPromptCompactHeightY("/actionpromptcompactheighty", 16);
	bShowActionPrompts = *disableActionPrompts;
	bShortHPMPForActionBars = false;

	if ( playercount == 2 && !*MainMenu::vertical_splitscreen && !ghostPrompts
		&& !*disableActionPrompts && *MainMenu::clipped_splitscreen )
	{
		bShortHPMPForActionBars = true;
	}

	if ( playercount > 2
		|| (playercount == 2 
			&& (*MainMenu::vertical_splitscreen 
				/*|| !player.shootmode */
				|| (!player.shootmode && player.hud.compactLayoutMode == Player::HUD_t::COMPACT_LAYOUT_CHARSHEET)
				|| (!player.hotbar.useHotbarFaceMenu && *MainMenu::clipped_splitscreen))) 
		|| *disableActionPrompts )
	{
		if ( !ghostPrompts )
		{
			actionPromptsFrame->setDisabled(true);
			bShowActionPrompts = false;
			return;
		}
	}
	actionPromptsFrame->setDisabled(false);
	actionPromptsFrame->setSize(SDL_Rect{ 0, 0, hudFrame->getSize().w, hudFrame->getSize().h });

	bool tempHideActionPrompts = false;
	bool fadeOut = false;
	if ( ghostPrompts )
	{
		if ( player.bUseCompactGUIHeight() && CalloutMenu[player.playernum].calloutMenuIsOpen() && !CalloutMenu[player.playernum].selectMoveTo )
		{
			tempHideActionPrompts = true;
		}
	}

	if ( tempHideActionPrompts )
	{
		if ( fadeOut )
		{
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			real_t setpointDiff = fpsScale * std::max(.1, (1.0 - animHideActionPrompts)) / 2.5;
			animHideActionPrompts += setpointDiff;
			animHideActionPrompts = std::min(1.0, animHideActionPrompts);
		}
		else
		{
			animHideActionPrompts = 1.0;
		}
	}
	else
	{
		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
		real_t setpointDiff = fpsScale * std::max(.1, (animHideActionPrompts)) / 2.5;
		animHideActionPrompts -= setpointDiff;
		animHideActionPrompts = std::max(0.0, animHideActionPrompts);
	}

	actionPromptsFrame->setInheritParentFrameOpacity(false);
	real_t opacity = 1.0;
	if ( auto parent = actionPromptsFrame->getParent() )
	{
		opacity *= actionPromptsFrame->getParent()->getOpacity() / 100.0;
	}
	actionPromptsFrame->setOpacity((opacity - animHideActionPrompts) * 100.0);

	const int iconSize = Player::HUD_t::actionPromptIconSize;
	const int glyphSize = 32;
	const int iconBackingSize = Player::HUD_t::actionPromptBackingSize;
	const int maxWidth = std::max(iconSize, iconBackingSize);
	const int maxHeight = std::max(iconSize, iconBackingSize);
	const int promptHeight = maxHeight + glyphSize; // vertical space for prompts

	SDL_Rect iconPos{ maxWidth / 2 - iconSize / 2 - 0,
		maxHeight / 2 - iconSize / 2 - 0,
		iconSize,
		iconSize };
	SDL_Rect iconBackingPos{ maxWidth / 2 - iconBackingSize / 2,
		maxHeight / 2 - iconBackingSize / 2,
		iconBackingSize,
		iconBackingSize };

	struct PromptInfo {
		std::string name;
		ActionPrompts promptType;
		std::string inputName;
	};

	std::vector<PromptInfo> allPrompts;
	const std::string blockBinding = Input::inputs[player.playernum].binding("Defend");
	const std::string sneakBinding = Input::inputs[player.playernum].binding("Sneak");
	bool sneakingSeparateFromBlock = false;// blockBinding != sneakBinding;
	if ( ghostPrompts )
	{
		sneakingSeparateFromBlock = true;
		allPrompts.emplace_back(PromptInfo{ "action sneak", ACTION_PROMPT_SNEAK, "Sneak" });
		allPrompts.emplace_back(PromptInfo{ "action offhand", ACTION_PROMPT_OFFHAND, "Use" });
		allPrompts.emplace_back(PromptInfo{ "action magic", ACTION_PROMPT_MAGIC, "Cast Spell" });
		allPrompts.emplace_back(PromptInfo{ "action mainhand", ACTION_PROMPT_MAINHAND, "Attack" });
	}
	else if ( sneakingSeparateFromBlock )
	{
		allPrompts.emplace_back(PromptInfo{ "action offhand", ACTION_PROMPT_OFFHAND, "Defend" });
		allPrompts.emplace_back(PromptInfo{ "action sneak", ACTION_PROMPT_SNEAK, "Sneak" });
		allPrompts.emplace_back(PromptInfo{ "action magic", ACTION_PROMPT_MAGIC, "Cast Spell" });
		allPrompts.emplace_back(PromptInfo{ "action mainhand", ACTION_PROMPT_MAINHAND, "Attack" });
	}
	else
	{
		allPrompts.emplace_back(PromptInfo{ "action offhand", ACTION_PROMPT_OFFHAND, "Defend" });
		allPrompts.emplace_back(PromptInfo{ "action sneak", ACTION_PROMPT_SNEAK, "Sneak" });
		allPrompts.emplace_back(PromptInfo{ "action magic", ACTION_PROMPT_MAGIC, "Cast Spell" });
		allPrompts.emplace_back(PromptInfo{ "action mainhand", ACTION_PROMPT_MAINHAND, "Attack" });
	}

	Uint32 iconBackingColor = makeColor(255, 255, 255, Player::HUD_t::actionPromptIconBackingOpacity);
	Uint32 iconColor = makeColor(255, 255, 255, Player::HUD_t::actionPromptIconOpacity);
	Uint32 iconFadedColor = makeColor(255, 255, 255, Player::HUD_t::actionPromptIconOpacity * .5);
	Uint32 iconFadedBackingColor = makeColor(255, 255, 255, Player::HUD_t::actionPromptIconBackingOpacity * .5);

	int index = 0;
	for ( auto& promptInfo : allPrompts )
	{
		if ( auto prompt = actionPromptsFrame->findFrame(promptInfo.name.c_str()) )
		{
			prompt->setDisabled(false);

			std::string glyphName = promptInfo.name + " glyph";
			auto img = prompt->findImage("action img");
			auto glyph = actionPromptsFrame->findImage(glyphName.c_str());
			auto imgBacking = prompt->findImage("action img backing");

			SDL_Rect promptPos = prompt->getSize();
			promptPos.w = maxWidth;
			promptPos.h = promptHeight;
			int actionPromptOffsetXTotal = actionPromptOffsetX;
			prompt->setDrawCallback(nullptr);
			prompt->setUserData(nullptr);
			if ( ghostPrompts )
			{
				actionPromptOffsetXTotal = actionPromptOffsetXGhostPrompts;
				prompt->setUserData((void*)(intptr_t)(promptInfo.promptType + 1));
				prompt->setDrawCallback([](const Widget& widget, SDL_Rect rect) {
					drawActionPromptCooldownCallback(widget, rect);
				});
			}
			else if ( !player.hotbar.useHotbarFaceMenu )
			{
				actionPromptOffsetXTotal += 22;
			}
			switch ( index )
			{
				case 0: // to the left of hotbar
					promptPos.x = hudFrame->getSize().w / 2 - actionPromptOffsetXTotal;
					break;
				case 1: // to the left after the previous
					promptPos.x = hudFrame->getSize().w / 2 - actionPromptOffsetXTotal;
					promptPos.x -= 16;
					promptPos.x -= promptPos.w;
					break;
				case 2: // to the right of hotbar
					promptPos.x = hudFrame->getSize().w / 2 + actionPromptOffsetXTotal;
					promptPos.x -= promptPos.w;
					break;
				case 3: // to the right after the previous
					promptPos.x = hudFrame->getSize().w / 2 + actionPromptOffsetXTotal;
					promptPos.x += 16;
					break;
				default:
					break;
			}
			promptPos.y = hudFrame->getSize().h + player.hotbar.getHotbarStartY2() - promptPos.h;
			promptPos.y += maxHeight / 2;
			promptPos.y += actionPromptOffsetY;
			if ( player.bUseCompactGUIHeight() )
			{
				promptPos.y += *actionPromptCompactHeightY;
			}
			prompt->setSize(promptPos);

			img->pos = iconPos;
			imgBacking->pos = iconBackingPos;
			img->color = iconColor;
			imgBacking->color = iconBackingColor;

			Field* promptText = nullptr;
			switch ( promptInfo.promptType )
			{
				case ACTION_PROMPT_MAINHAND:
					promptText = actionPromptsFrame->findField("action mainhand text");
					break;
				case ACTION_PROMPT_OFFHAND:
					promptText = actionPromptsFrame->findField("action offhand text");
					break;
				case ACTION_PROMPT_MAGIC:
					promptText = actionPromptsFrame->findField("action magic text");
					break;
				case ACTION_PROMPT_SNEAK:
					promptText = actionPromptsFrame->findField("action sneak text");
					break;
				default:
					break;
			}

			if ( promptInfo.promptType == ACTION_PROMPT_SNEAK && !sneakingSeparateFromBlock )
			{
				prompt->setDisabled(true);
				promptText->setDisabled(true);
				glyph->disabled = true;
				++index;
				continue;
			}

			std::string textForPrompt = "";
			int skillForPrompt = getActionIconForPlayer(promptInfo.promptType, textForPrompt);
			if ( promptInfo.promptType == ACTION_PROMPT_OFFHAND && sneakingSeparateFromBlock && !ghostPrompts
				&& skillForPrompt == PRO_STEALTH )
			{
				// offhand wants to display sneak - redundant, hide this prompt
				prompt->setDisabled(true);
				promptText->setDisabled(true);
				glyph->disabled = true;
				++index;
				continue;
			}

			if ( player.shootmode || player.gui_mode == GUI_MODE_FOLLOWERMENU 
				|| player.gui_mode == GUI_MODE_SIGN
				|| player.gui_mode == GUI_MODE_CALLOUT )
			{
				promptText->setDisabled(true);
			}
			else
			{
				promptText->setDisabled(false);
				promptText->setText(textForPrompt.c_str());
				SDL_Rect textPos;
				auto textGetLongestLine = Text::get(promptText->getLongestLine().c_str(),
					promptText->getFont(),
					promptText->getTextColor(),
					promptText->getOutlineColor());
				textPos.w = textGetLongestLine->getWidth();
				textPos.h = promptText->getNumTextLines() * Font::get(promptText->getFont())->height();
				textPos.x = promptPos.x + promptPos.w / 2 - textPos.w / 2;
				//textPos.y = promptPos.y + imgBacking->pos.y - textPos.h - 4; -- top aligned
				textPos.y = promptPos.y + imgBacking->pos.y + imgBacking->pos.h + 1;
				promptText->setSize(textPos);
			}

			std::string skillImg = "";
			if ( skillForPrompt >= 0 && skillForPrompt < NUMPROFICIENCIES )
			{
				for ( auto& skill : player.skillSheet.skillSheetData.skillEntries )
				{
					if ( skill.skillId == skillForPrompt )
					{
						if ( skillCapstoneUnlocked(player.playernum, skillForPrompt) )
						{
							skillImg = skill.skillIconPathLegend32px;
						}
						else
						{
							skillImg = skill.skillIconPath32px;
						}
						break;
					}
				}
				if ( stats[player.playernum]->getModifiedProficiency(skillForPrompt) >= SKILL_LEVEL_LEGENDARY )
				{
					imgBacking->path = actionPromptBackingIconPath100;
				}
				else if ( stats[player.playernum]->getModifiedProficiency(skillForPrompt) >= SKILL_LEVEL_EXPERT )
				{
					imgBacking->path = actionPromptBackingIconPath60;
				}
				else if ( stats[player.playernum]->getModifiedProficiency(skillForPrompt) >= SKILL_LEVEL_BASIC )
				{
					imgBacking->path = actionPromptBackingIconPath20;
				}
				else
				{
					imgBacking->path = actionPromptBackingIconPath00;
				}
			}
			else if ( ghostPrompts )
			{
				imgBacking->path = actionPromptBackingIconPath00;
				switch ( promptInfo.promptType )
				{
					case ACTION_PROMPT_MAGIC:
						skillImg = "*images/ui/HUD/HUD_Ghost_Haunt.png";
						img->pos.x -= 2;
						img->pos.y -= 2;
						img->pos.w = 36;
						img->pos.h = 36;
						break;
					case ACTION_PROMPT_MAINHAND:
						skillImg = "*images/ui/HUD/HUD_Ghost_Chill.png";
						img->pos.x -= 2;
						img->pos.y -= 2;
						img->pos.w = 36;
						img->pos.h = 36;
						break;
					case ACTION_PROMPT_OFFHAND:
						skillImg = "*images/ui/HUD/HUD_Ghost_Push.png";
						img->pos.x -= 2;
						img->pos.y -= 2;
						img->pos.w = 36;
						img->pos.h = 36;
						break;
					case ACTION_PROMPT_SNEAK:
						for ( auto& skill : player.skillSheet.skillSheetData.skillEntries )
						{
							if ( skill.skillId == PRO_STEALTH )
							{
								skillImg = skill.skillIconPath32px;
								break;
							}
						}
						break;
				default:
					break;
				}
			}
			if ( skillImg == "" )
			{
				prompt->setDisabled(true);
			}
			else
			{
				prompt->setDisabled(false);
				img->path = skillImg;
				if ( img->path[0] != '*' )
				{
					img->path = '*' + img->path;
				}
			}

			bool pressed = false;
			/*if ( skillForPrompt == PRO_SHIELD && stats[player.playernum]->defending )
			{
				pressed = true;
			}
			if ( skillForPrompt == PRO_STEALTH && !stats[player.playernum]->defending
				&& stats[player.playernum]->sneaking )
			{
				pressed = true;
			}*/

			std::string bindingName = promptInfo.inputName.c_str();
			if ( !ghostPrompts )
			{
				if ( skillForPrompt == PRO_STEALTH && promptInfo.promptType == ACTION_PROMPT_OFFHAND )
				{
					bindingName = "Sneak";
				}
			}
			glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding(bindingName.c_str(), pressed);
			glyph->disabled = prompt->isDisabled();
			if ( !player.shootmode || player.gui_mode == GUI_MODE_FOLLOWERMENU 
				|| player.gui_mode == GUI_MODE_SIGN
				|| player.gui_mode == GUI_MODE_CALLOUT )
			{
				glyph->disabled = true;
			}
			else if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
			{
				glyph->disabled = false;
			}
			else
			{
				glyph->disabled = false;
			}
			if ( auto imgGet = Image::get(glyph->path.c_str()) )
			{
				glyph->pos.w = (int)imgGet->getWidth();
				glyph->pos.h = (int)imgGet->getHeight();
			}
			glyph->pos.x = prompt->getSize().x + prompt->getSize().w / 2 - glyph->pos.w / 2; // center the x for the glyph
			int glyphToImgPadY = 0;
			if ( Input::inputs[player.playernum].input(bindingName.c_str()).type == Input::binding_t::bindtype_t::MOUSE_BUTTON )
			{
				glyphToImgPadY += 4;
			}
			int pressedOffset = 0;
			/*if ( pressed )
			{
				if ( auto imgGet = Image::get(Input::inputs[player.playernum].getGlyphPathForBinding(promptInfo.inputName.c_str()).c_str()) )
				{
					int unpressedHeight = (int)imgGet->getHeight();
					if ( glyph->pos.h != unpressedHeight )
					{
						pressedOffset = (unpressedHeight - glyph->pos.h);
					}
				}
			}*/
			glyph->pos.y = prompt->getSize().y + img->pos.y + img->pos.h - glyphToImgPadY + pressedOffset; // just above the skill img with some padding

			if ( !ghostPrompts )
			{
				if ( promptInfo.promptType == ACTION_PROMPT_SNEAK )
				{
					if ( !(!stats[player.playernum]->defending && stats[player.playernum]->sneaking) )
					{
						//glyph->disabled = true;
						img->color = iconFadedColor;
						//imgBacking->color = iconFadedBackingColor;
					}
				}
				if ( promptInfo.promptType == ACTION_PROMPT_OFFHAND && skillForPrompt == PRO_SHIELD
					&& sneakingSeparateFromBlock )
				{
					if ( !stats[player.playernum]->defending )
					{
						//glyph->disabled = true;
						img->color = iconFadedColor;
						//imgBacking->color = iconFadedBackingColor;
					}
				}
			}
		}
		++index;
	}
}

static Frame* createMinimap(int player);

void createGameTimerFrame(const int player)
{
	auto& hud_t = players[player]->hud;
	hud_t.gameTimerFrame = hud_t.hudFrame->addFrame("timer");
	hud_t.gameTimerFrame->setHollow(true);
	hud_t.gameTimerFrame->setDisabled(true);
	hud_t.gameTimerFrame->setSize(SDL_Rect{ 0, 0, 142, 24 });

	auto txt = hud_t.gameTimerFrame->addField("timer txt", 64);
	txt->setText("00:00:00");
	txt->setSize(SDL_Rect{ 0, 0, hud_t.gameTimerFrame->getSize().w, hud_t.gameTimerFrame->getSize().h });
	txt->setFont("fonts/pixel_maz_multiline.ttf#16#2");
	txt->setVJustify(Field::justify_t::TOP);
	txt->setHJustify(Field::justify_t::LEFT);
	txt->setColor(makeColor(255, 255, 255, 255));

	auto seed = hud_t.gameTimerFrame->addField("seed txt", 64);
	seed->setText("");
	seed->setSize(SDL_Rect{ 0, 0, hud_t.gameTimerFrame->getSize().w, hud_t.gameTimerFrame->getSize().h });
	seed->setFont("fonts/pixel_maz_multiline.ttf#16#2");
	seed->setVJustify(Field::justify_t::TOP);
	seed->setHJustify(Field::justify_t::RIGHT);
	seed->setColor(makeColor(255, 255, 255, 255));
	seed->setDisabled(true);
}

void createMapPromptFrame(const int player)
{
	auto& hud_t = players[player]->hud;
	hud_t.mapPromptFrame = hud_t.hudFrame->addFrame("map prompts");
	hud_t.mapPromptFrame->setHollow(true);
	hud_t.mapPromptFrame->setDisabled(true);
	hud_t.mapPromptFrame->setSize(SDL_Rect{ 0, 0, 142, 24 });

	auto promptBg = hud_t.mapPromptFrame->addImage(SDL_Rect{ 0, 0, 280, 40 },
		0xFFFFFFFF, "*#images/ui/MapAndLog/HUD_MapPromptBase_00.png", "prompt bg");

	auto imgPromptFrame = hud_t.mapPromptFrame->addFrame("img prompt frame");
	imgPromptFrame->setHollow(true);

	auto scaleImg = imgPromptFrame->addImage(SDL_Rect{ 0, 0, 24, 24 },
		0xFFFFFFFF, "*#images/ui/MapAndLog/HUD_Map_Zoom_00.png", "scale img");
	auto scalePrompt = imgPromptFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "*#images/system/white.png", "scale prompt");

	auto expandImg = imgPromptFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "*#images/ui/MapAndLog/HUD_Map_Scale_00.png", "expand img");
	auto expandPrompt = imgPromptFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "*#images/system/white.png", "expand prompt");
}

static void checkControllerState(int player) {
    auto& controllerFrame = players[player]->hud.controllerFrame;
    assert(controllerFrame);
	if (multiplayer != SINGLE) {
		player = 0;
	}
    if (inputs.getPlayerIDAllowedKeyboard() != player) {
        auto controller = inputs.getController(player);
        if (!controller || (controller && !controller->isActive())) {
            if (controllerFrame->isHollow()) {
                controllerFrame->setHollow(false);
                controllerFrame->setDisabled(false);
                MainMenu::controllerDisconnected(player);
            }
            return;
        }
    }
    controllerFrame->setDisabled(true);
    controllerFrame->setHollow(true);
}

void HUDDrawGameEndHint(const int player, SDL_Rect rect)
{
	if ( multiplayer == CLIENT || multiplayer == SERVER )
	{
		bool everyonedead = true;
		for ( int i = 0; i < MAXPLAYERS; ++i )
		{
			if ( players[i] )
			{
				if ( multiplayer == SERVER && (!client_disconnected[i] && players[i]->entity) )
				{
					everyonedead = false;
				}
				else if ( multiplayer == CLIENT && players[i]->entity )
				{
					everyonedead = false;
				}
			}
		}

		if ( players[player]->bControlEnabled )
		{
			players[player]->hud.animDeadPromptDisplay = true;
		}

		if ( everyonedead && players[player]->hud.animDeadPromptDisplay )
		{
			static ConsoleVariable<float> cvar_anim_dead_prompt_speed("/anim_dead_prompt_speed", 0.003);
			players[player]->hud.animDeadPrompt += *cvar_anim_dead_prompt_speed;
			if ( players[player]->hud.animDeadPrompt >= 1.0 )
			{
				players[player]->hud.animDeadPrompt = 0.0;
			}
			rect.x += rect.w / 2;
			rect.y += 8 - 1;
			if ( players[player]->hud.xpFrame && !players[player]->hud.xpFrame->isDisabled() )
			{
				rect.y += players[player]->hud.xpFrame->getSize().y;
				rect.y += players[player]->hud.xpFrame->getSize().h;
			}
			if ( auto textGet = Text::get(Language::get(6052), smallfont_outline, makeColorRGB(255, 255, 255), 0) )
			{
				Uint8 r, g, b, a;
				getColor(hudColors.characterSheetRed, &r, &g, &b, nullptr);
				real_t opacity = 0.5 + .4 * (1.0 * cos(players[player]->hud.animDeadPrompt * 2 * PI) + 1.0);
				Uint32 color = makeColor(r, g, b, std::max(0.25, std::min(opacity, 1.0)) * 255);
				rect.x -= textGet->getWidth() / 2;
				textGet->drawColor(SDL_Rect{ 0, 0, 0, 0 }, SDL_Rect{ rect.x, rect.y, 0, 0 },
					SDL_Rect{ 0, 0, Frame::virtualScreenX, Frame::virtualScreenY },
					color);
			}
		}
		else
		{
			players[player]->hud.animDeadPromptDisplay = false;
			players[player]->hud.animDeadPrompt = 0.0;
		}
	}
	else
	{
		players[player]->hud.animDeadPromptDisplay = false;
		players[player]->hud.animDeadPrompt = 0.0;
	}
}

void Player::HUD_t::processHUD()
{
	const SDL_Rect hudSize{
	    players[player.playernum]->camera_virtualx1(),
		players[player.playernum]->camera_virtualy1(),
		players[player.playernum]->camera_virtualWidth(),
		players[player.playernum]->camera_virtualHeight()};

	if ( !hudFrame )
	{
	    char name[32];
	    snprintf(name, sizeof(name), "player hud %d", player.playernum);
		hudFrame = gameUIFrame[player.playernum]->addFrame(name);
		hudFrame->setHollow(true);
		hudFrame->setBorder(0);
		hudFrame->setOwner(player.playernum);
		hudFrame->setDrawCallback([](const Widget& widget, SDL_Rect rect) {
			HUDDrawGameEndHint(widget.getOwner(), rect);
		});
	}

	if ( !minotaurSharedDisplay && player.playernum == 0 )
	{
		minotaurSharedDisplay = gameUIFrame[player.playernum]->addFrame("minotaur shared display");
		minotaurSharedDisplay->setHollow(true);
		minotaurSharedDisplay->setOwner(player.playernum);
		minotaurSharedDisplay->setDisabled(true);
		minotaurSharedDisplay->setInheritParentFrameOpacity(false);
		auto img = minotaurSharedDisplay->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "*images/ui/HUD/HUD_Minotaur_00.png",
			"mino img");
		if ( auto imgGet = Image::get(img->path.c_str()) )
		{
			img->pos.w = imgGet->getWidth();
			img->pos.h = imgGet->getHeight();
		}
		minotaurSharedDisplay->setSize(SDL_Rect{ 0, 0, img->pos.w, img->pos.h });
	}

	if ( !minotaurDisplay )
	{
		minotaurDisplay = hudFrame->addFrame("minotaur display");
		minotaurDisplay->setHollow(true);
		minotaurDisplay->setOwner(player.playernum);
		minotaurDisplay->setDisabled(true);
		minotaurDisplay->setInheritParentFrameOpacity(false);
		auto img = minotaurDisplay->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "*images/ui/HUD/HUD_Minotaur_00.png",
			"mino img");
		if ( auto imgGet = Image::get(img->path.c_str()) )
		{
			img->pos.w = imgGet->getWidth();
			img->pos.h = imgGet->getHeight();
		}
		minotaurDisplay->setSize(SDL_Rect{ 0, 0, img->pos.w, img->pos.h });
	}

    if ( !controllerFrame )
    {
        controllerFrame = gameUIFrame[player.playernum]->addFrame("reconnect_controller");
        controllerFrame->setColor(0);
        controllerFrame->setOwner(player.playernum);
        controllerFrame->setBorder(0);
        controllerFrame->setDisabled(true);
        controllerFrame->setHollow(true);
        controllerFrame->setTickCallback([](Widget& widget){
            const int player = widget.getOwner();
            const bool disabled = ticks % TICKS_PER_SECOND >= TICKS_PER_SECOND / 2;
	        const SDL_Rect hudSize{
	            players[player]->camera_virtualx1(),
		        players[player]->camera_virtualy1(),
		        players[player]->camera_virtualWidth(),
		        players[player]->camera_virtualHeight()};
            auto frame = static_cast<Frame*>(&widget); assert(frame);
            auto image = frame->findImage("controller"); assert(image);
            image->pos.x = (hudSize.w - image->pos.w) / 2;
            image->pos.y = (hudSize.h - image->pos.h) / 2;
            image->disabled = disabled;
            auto field = frame->findField("label"); assert(field);
            field->setSize(image->pos);
            field->setInvisible(disabled);
            });

        auto dimmer = controllerFrame->addImage(
            SDL_Rect{0, 0, hudSize.w, hudSize.h},
            makeColor(0, 0, 0, 191),
            "#*images/system/white.png",
            "dimmer");

        const char* path = Input::getControllerGlyph(player.playernum);
        auto image = Image::get(path);
        const int w = image->getWidth();
        const int h = image->getHeight();
        const int x = (hudSize.w - w) / 2;
        const int y = (hudSize.h - h) / 2;
        auto controller = controllerFrame->addImage(
            SDL_Rect{x, y, w, h},
            0xffffffff, path,
            "controller");
     
        char fmt[16];
        snprintf(fmt, sizeof(fmt), Language::get(5477), player.playernum + 1);

        auto field = controllerFrame->addField("label", 16);
        field->setSize(SDL_Rect{x, y, w, h});
        field->setJustify(Field::justify_t::CENTER);
        field->setText(fmt);
        field->setFont(bigfont_outline); 
		field->setColor(playerColor(player.playernum, colorblind_lobby, false));
    }

    controllerFrame->setSize(hudSize);
	hudFrame->setSize(hudSize);

	if ( gamePaused || nohud || !players[player.playernum]->isLocalPlayer() )
	{
		// hide
		hudFrame->setDisabled(true);
		controllerFrame->setDisabled(true);
	}
	else
	{
		hudFrame->setDisabled(false);
		if ( !controllerFrame->isHollow() )
		{
		    controllerFrame->setDisabled(false);
		}
	}

	static ConsoleVariable<bool> cvar_disable_controller_reconnect("/disable_controller_reconnect", false);
	if ( !*cvar_disable_controller_reconnect )
	{
		if ( MainMenu::isPlayerSignedIn(player.playernum) && players[player.playernum]->isLocalPlayer() )
		{
			checkControllerState(player.playernum);
		}
	}
	static ConsoleVariable<int> cvar_ui_above_hotbar_y("/ui_above_hotbar_y", 56);
	offsetHUDAboveHotbarHeight = 0;
	if ( player.bUseCompactGUIWidth() )
	{
#ifndef NINTENDO
		if ( inputs.hasController(player.playernum) )
		{
			if ( !playerSettings[multiplayer ? 0 : player.playernum].gamepad_facehotbar || *cvar_hotbar_compact_disable )
			{
				offsetHUDAboveHotbarHeight = *cvar_ui_above_hotbar_y;
			}
		}
		else if ( inputs.bPlayerUsingKeyboardControl(player.playernum) )
		{
            offsetHUDAboveHotbarHeight = *cvar_ui_above_hotbar_y;
		}
#else
		if ( !playerSettings[multiplayer ? 0 : player.playernum].gamepad_facehotbar || *cvar_hotbar_compact_disable )
		{
			offsetHUDAboveHotbarHeight = *cvar_ui_above_hotbar_y;
		}
#endif // NINTENDO
	}

	if ( !gamePaused && (player.entity || player.ghost.isActive()) && player.shootmode)
	{
		inputs.getVirtualMouse(player.playernum)->draw_cursor = false;
	}

    if ( !this->minimapFrame )
    {
		this->minimapFrame = createMinimap(player.playernum);
    }
	if ( !mapPromptFrame )
	{
		createMapPromptFrame(player.playernum);
	}
	if ( !gameTimerFrame )
	{
		createGameTimerFrame(player.playernum);
	}
	if ( !xpFrame )
	{
		createXPBar(player.playernum);
	}
	if ( !hpFrame )
	{
		createHPMPBars(player.playernum);
	}
	if ( !calloutPromptFrame )
	{
		createCalloutPromptFrame(player.playernum);
	}
	if ( !enemyBarFrame )
	{
		createEnemyBar(player.playernum, enemyBarFrame);
	}
	if ( !enemyBarFrameHUD )
	{
		createEnemyBar(player.playernum, enemyBarFrameHUD);
	}
	if ( !StatusEffectQueue[player.playernum].statusEffectFrame )
	{
		createStatusEffectQueue(player.playernum);
	}
	if ( !allyFollowerTitleFrame )
	{
		createAllyFollowerTitleFrame(player.playernum);
	}
	if ( !allyFollowerFrame )
	{
		createAllyFollowerFrame(player.playernum);
	}
	if ( !allyPlayerFrame )
	{
		createAllyPlayerFrame(player.playernum);
	}

	updateMinimapPrompts();
	updateGameTimer();
	updateAllyFollowerFrame(player.playernum);
	updateAllyPlayerFrame(player.playernum);
	updateXPBar();
	updateHPBar();
	updateMPBar();
	updateCalloutPromptFrame(player.playernum);
	updateActionPrompts();
	updateUINavigation();
	enemyHPDamageBarHandler[player.playernum].cullExpiredHPBars();
	enemyBarFrame->setDisabled(true);
	enemyBarFrameHUD->setDisabled(true);
	for ( auto& HPBar : enemyHPDamageBarHandler[player.playernum].HPBars )
	{
		updateEnemyBar2(enemyBarFrame, &HPBar.second);
	}
	updateStatusEffectQueue(player.playernum);
}

void Player::MessageZone_t::createChatbox()
{
	char name[32];
	snprintf(name, sizeof(name), "player chat %d", player.playernum);
	if ( !gameUIFrame[player.playernum]->findFrame(name) )
	{
		Frame* chatMainFrame = gameUIFrame[player.playernum]->addFrame(name);
		chatMainFrame->setHollow(true);
		chatMainFrame->setBorder(0);
		chatMainFrame->setOwner(player.playernum);
		chatMainFrame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
			players[player.playernum]->camera_virtualy1(),
			players[player.playernum]->camera_virtualWidth(),
			players[player.playernum]->camera_virtualHeight() });
		chatFrame = chatMainFrame;
		Frame* messages = chatMainFrame->addFrame("message box");
		messages->setHollow(true);
		messages->setInheritParentFrameOpacity(false);

		static const char* bigfont = "fonts/pixelmix.ttf#16#2";
		SDL_Rect entryPos{ 0, 0, messages->getSize().w, messages->getSize().h };
		for ( int i = 0; i < MESSAGE_MAX_ENTRIES; ++i )
		{
			char msgName[32];
			snprintf(msgName, sizeof(msgName), "message %d", i);
			auto entry = messages->addField(msgName, ADD_MESSAGE_BUFFER_LENGTH);
			entry->setFont(bigfont);
			entry->setSize(entryPos);
			entry->setDisabled(true);
			entry->setVJustify(Field::justify_t::TOP);
		}
	}
}

static ConsoleVariable<int> cvar_log_lineheight_offset("/log_lineheight_offset", -6);
static ConsoleVariable<int> cvar_log_lineheight_min("/log_lineheight_minimum", 24);
static ConsoleVariable<int> cvar_log_multiline_pady("/log_multiline_pady", -4);
const char* Player::MessageZone_t::bigfont = "fonts/pixelmix.ttf#16#2";
const char* Player::MessageZone_t::smallfont = "fonts/pixel_maz_multiline.ttf#16#2";
static ConsoleVariable<int> cvar_message_fade_min("/message_fade_min", 25);
void Player::MessageZone_t::processChatbox()
{
	if (!chatFrame) {
		createChatbox();
	}

	chatFrame->setSize(SDL_Rect{ player.camera_virtualx1(),
		player.camera_virtualy1(),
		player.camera_virtualWidth(),
		player.camera_virtualHeight() });

	int playercount = 0;
	for (int c = 0; c < MAXPLAYERS; ++c) {
	    if (!client_disconnected[c] && players[c]->isLocalPlayer()) {
	        ++playercount;
	    }
	}

	Frame* messageBoxFrame = chatFrame->findFrame("message box");
	messageBoxFrame->setDisabled(gamePaused || (!player.shootmode && playercount > 2));
	if (messageBoxFrame->isDisabled()) {
		return;
	}

	static const char* bigfont = "fonts/pixelmix.ttf#16#2";
	static const char* smallfont = "fonts/pixel_maz_multiline.ttf#16#2";
	static ConsoleVariable<bool> cvar_smallmessages("/smallmessages", false);
    //static ConsoleVariable<bool> cvar_top_aligned("/topmessages", false);
	//static ConsoleVariable<std::string> alignment("/alignmessages", "");
	static ConsoleVariable<std::string> cvar_setalignment("/alignmessages", "");
	static ConsoleVariable<int> cvar_messages_left_y("/messages_left_y", 200);
	useBigFont = !player.bUseCompactGUIHeight() && !player.bUseCompactGUIWidth();// || (playercount == 2 && !*MainMenu::vertical_splitscreen);
	if ( *cvar_smallmessages )
	{
		useBigFont = false;
	}

	if ( *cvar_setalignment == "left" )
	{
		messageAlignment = ALIGN_LEFT_BOTTOM;
	}
	else if ( *cvar_setalignment == "top" )
	{
		messageAlignment = ALIGN_LEFT_TOP;
	}
	else if ( *cvar_setalignment == "center" )
	{
		messageAlignment = ALIGN_CENTER_BOTTOM;
	}

	actualAlignment = ALIGN_LEFT_BOTTOM;
	if ( player.bUseCompactGUIHeight() && player.bUseCompactGUIWidth() )
	{
		actualAlignment = ALIGN_LEFT_TOP;
	}
	else if ( messageAlignment == ALIGN_CENTER_BOTTOM )
	{
		if ( !player.bUseCompactGUIHeight() )
		{
			// allowed in tall or singleplayer
			actualAlignment = messageAlignment;
		}
		else
		{
			actualAlignment = ALIGN_LEFT_TOP; // else default to top-left in wide 2-player
			if ( !player.shootmode 
				&& (player.gui_mode == GUI_MODE_INVENTORY || player.gui_mode == GUI_MODE_SHOP) )
			{
				actualAlignment = ALIGN_LEFT_BOTTOM;
			}
		}
	}
	else if ( messageAlignment == ALIGN_LEFT_BOTTOM )
	{
		actualAlignment = messageAlignment; // ok in all configs
	}
	else if ( messageAlignment == ALIGN_LEFT_TOP )
	{
		actualAlignment = messageAlignment;
		if ( playercount <= 2 && !player.shootmode
			&& (player.gui_mode == GUI_MODE_INVENTORY || player.gui_mode == GUI_MODE_SHOP) )
		{
			actualAlignment = ALIGN_LEFT_BOTTOM;
		}
	}

	switch ( actualAlignment )
	{
		case ALIGN_CENTER_BOTTOM:
			bottomAlignedMessages = true;
			break;
		case ALIGN_LEFT_BOTTOM:
			bottomAlignedMessages = true;
			break;
		case ALIGN_LEFT_TOP:
			bottomAlignedMessages = false;
			break;
		default:
			break;
	}

	const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
	if ( player.bUseCompactGUIWidth() && actualAlignment == ALIGN_LEFT_TOP &&
		((player.hud.levelupFrame && !player.hud.levelupFrame->isDisabled())
		|| (player.hud.skillupFrame && !player.hud.skillupFrame->isDisabled())) )
	{
		animFade -= fpsScale * std::max(.1, (animFade)) / (2.5);
		animFade = std::max(0.0, animFade);
	}
	else
	{
		animFade += fpsScale * std::max(.1, (1.0 - animFade)) / (5.0);
		animFade = std::min(1.0, animFade);
	}

	messageBoxFrame->setOpacity(*cvar_message_fade_min + (100.0 - *cvar_message_fade_min) * animFade);

    bool pushPaddingX = !player.shootmode
		&& actualAlignment != ALIGN_CENTER_BOTTOM
		&& (player.gui_mode == GUI_MODE_INVENTORY || player.gui_mode == GUI_MODE_SHOP)
        && ((playercount == 1 
			&& player.inventoryUI.getSizeY() > player.inventoryUI.DEFAULT_INVENTORY_SIZEY) ||
        (playercount == 2 && !*MainMenu::vertical_splitscreen));

	auto& messageLayoutSetting = messageZoneSettings.getLayout(player.playernum, actualAlignment);
	MESSAGE_MAX_ENTRIES = messageLayoutSetting.maxMessages;

	const int leftAlignedPaddingX = pushPaddingX ? 240 : 8;
	int leftAlignedBottomY = *cvar_messages_left_y;
	leftAlignedBottomY += messageLayoutSetting.offsetY;
	if ( player.bUseCompactGUIHeight() )
	{
		if ( StatusEffectQueue[player.playernum].statusEffectFrame )
		{
			const int hungerIconSize = 64;
			if ( actualAlignment == ALIGN_LEFT_BOTTOM )
			{
				leftAlignedBottomY = players[player.playernum]->camera_virtualy2()
					- (StatusEffectQueue[player.playernum].statusEffectFrame->getSize().y
						+ StatusEffectQueue[player.playernum].statusEffectFrame->getSize().h
						- hungerIconSize - 8);
			}
		}
	}
	const int topAlignedPaddingX = 8;
	int topAlignedPaddingY = 8;
	if ( player.hud.allyPlayerFrame && actualAlignment == ALIGN_LEFT_TOP && !splitscreen )
	{
		SDL_Rect allyPlayerPos = player.hud.allyPlayerFrame->getSize();
		if ( !player.hud.allyPlayerFrame->isDisabled() && allyPlayerPos.h > 0 )
		{
			topAlignedPaddingY = 4 + allyPlayerPos.y + allyPlayerPos.h;
		}
	}
	if ( player.hud.xpFrame && actualAlignment == ALIGN_LEFT_TOP )
	{
		SDL_Rect xpFramePos = player.hud.xpFrame->getSize();
		topAlignedPaddingY = std::max(topAlignedPaddingY, 4 + std::max(xpFramePos.y, 0) + xpFramePos.h);
		if ( !(player.bUseCompactGUIHeight() && player.bUseCompactGUIWidth()) )
		{
			topAlignedPaddingY += 4;
		}
	}
	SDL_Rect messageboxTopAlignedPos{
	    topAlignedPaddingX,
	    topAlignedPaddingY,
		player.camera_virtualWidth() - topAlignedPaddingX * 2,
		player.camera_virtualHeight() - topAlignedPaddingY };
	SDL_Rect messageboxLeftAlignedPos{
	    leftAlignedPaddingX,
	    0,
		player.camera_virtualWidth() - leftAlignedPaddingX * 2,
		player.camera_virtualHeight() - leftAlignedBottomY };


	SDL_Rect messageBoxSize = bottomAlignedMessages ?
	    messageboxLeftAlignedPos : messageboxTopAlignedPos;

	for ( int i = 0; i < MESSAGE_MAX_ENTRIES; ++i )
	{
	    char msgName[32];
		snprintf(msgName, sizeof(msgName), "message %d", i);
		if ( auto entry = messageBoxFrame->findField(msgName) )
		{
			entry->setDisabled(true);

			// set alignment
			if ( actualAlignment == ALIGN_CENTER_BOTTOM ) {
				entry->setHJustify(Field::justify_t::CENTER);
			} else {
				entry->setHJustify(Field::justify_t::LEFT);
			}
		}
	}

	const bool messageDrawDescending = (actualAlignment == ALIGN_LEFT_TOP);
	const int entryPaddingY = playercount > 2 ? 0 : 4;

	int currentY = messageDrawDescending ?
	    0 : messageBoxSize.h;

	int index = 0;
	int currentline = 0;

	auto it = notification_messages.begin();
	auto end = notification_messages.end();
	auto rit = notification_messages.rbegin();
	auto rend = notification_messages.rend();
	int textLinePadding = useBigFont ? 0 : -4;
	for ( ; messageDrawDescending ? rit != rend : it != end; ++it, ++rit )
	{
	    Message* current = messageDrawDescending ? *rit : *it;
		if ( currentline >= MESSAGE_MAX_ENTRIES)
		{
			break;
		}

		Uint32 color = (current->text->color & 0x00ffffff) | ((Uint32)current->alpha << 24);

	    char msgName[32];
		snprintf(msgName, sizeof(msgName), "message %d", index);
		if ( auto entry = messageBoxFrame->findField(msgName) )
		{
			entry->setDisabled(false);
			entry->setColor(color);

			std::string data = messageSanitizePercentSign(current->text->data, nullptr);
			char str[ADD_MESSAGE_BUFFER_LENGTH];
			snprintf(str, sizeof(str), data.c_str());

			entry->setText(str);
			entry->setFont(useBigFont ? bigfont : smallfont);
			entry->setPaddingPerLine(useBigFont ? 0 : *cvar_log_multiline_pady);
            Font* fontGet = Font::get(entry->getFont());
			Text* textGet = entry->getTextObject();

			int w = textGet->getWidth();
			int h = textGet->getHeight() * (current->text->lines + textLinePadding);
			int textHeight = h;
			if ( !useBigFont )
			{
				int h2 = (int)(std::max(*cvar_log_lineheight_min + 2, 
					((int)textGet->getHeight() + textLinePadding) * textGet->getNumTextLines() + textLinePadding));
				textHeight = h2;
				h = textHeight + *cvar_log_lineheight_offset;
			}

			if (!messageDrawDescending) {
				currentY -= h;
				currentY -= entryPaddingY;
			}

			SDL_Rect pos = entry->getSize();
			pos.x = 0;
			pos.y = currentY;
			pos.w = messageBoxFrame->getSize().w;
			pos.h = textHeight;
			entry->setSize(pos);

			if (messageDrawDescending) {
				currentY += h;
			    currentY += entryPaddingY;
			}
		}
		++index;
		currentline += current->text->lines;
	}

	messageBoxFrame->setSize(messageBoxSize);
}

ConsoleVariable<bool> shareMinimap("/shareminimap", true);
ConsoleVariable<bool> cvar_minimap_prompt_vertical("/minimap_prompt_vertical", false);
Frame* minimapFrame = nullptr; // shared minimap
SDL_Rect Player::Minimap_t::sharedMinimapPos{ 0, 0, 0, 0 };
int Player::Minimap_t::fullSize = 200;
int Player::Minimap_t::compactSize = 200;
int Player::Minimap_t::compact2pVerticalSize = 200;
real_t Player::Minimap_t::fullBigScale = 100.0;
real_t Player::Minimap_t::compactBigScale = 100.0;
real_t Player::Minimap_t::compact2pVerticalBigScale = 100.0;
bool Player::Minimap_t::bUpdateMainMenuSettingScale = false;
real_t Player::Minimap_t::mainMenuSettingScale = 1.0;

void doSharedMinimap() {
    if (!minimapFrame) {
		minimapFrame = gui->addFrame("shared_minimap");
		minimapFrame->setColor(0);
		minimapFrame->setHollow(true);
		minimapFrame->setInvisible(true);
		minimapFrame->setDrawCallback([](const Widget& widget, SDL_Rect rect){
            drawMinimap(widget.getOwner(), rect, true);
            });
		minimapFrame->setTickCallback([](Widget& widget){
	        int playercount = 0;
	        for (int c = 0; c < MAXPLAYERS; ++c) {
		        if (!client_disconnected[c] && players[c]->isLocalPlayer()) {
			        ++playercount;
		        }
	        }
            if (gamePaused || intro || MainMenu::isCutsceneActive() || playercount < 3 || !*shareMinimap) {
				minimapFrame->setInvisible(true);
            } else {
				minimapFrame->setInvisible(false);
            }
            if (playercount == 3) {
                const int size = std::min(Frame::virtualScreenX / 2, Frame::virtualScreenY / 2);
				minimapFrame->setSize(SDL_Rect{
                    (Frame::virtualScreenX + ((Frame::virtualScreenX / 2) - size)) / 2,
                    (Frame::virtualScreenY + ((Frame::virtualScreenY / 2) - size)) / 2,
                    size, size});
            } else if (playercount == 4) {
                constexpr int size = 128;
				minimapFrame->setSize(SDL_Rect{
                    (Frame::virtualScreenX - size) / 2,
                    Frame::virtualScreenY / 2,
                    size, size});
            }
			Player::Minimap_t::sharedMinimapPos = static_cast<Frame*>(&widget)->getSize();
            });
    }
	minimapFrame->setOwner(clientnum);
}

static Frame* createMinimap(int player) {
    std::string name = "minimap";
    name.append(std::to_string(player));
    auto& minimap = players[player]->minimap;
    minimap.real_scale = minimapScale;
    minimap.scale = minimapScale;
    Frame* parent = players[player]->hud.hudFrame;
    Frame* window = parent->addFrame(name.c_str());
    window->setSize(SDL_Rect{0, 0, 0, 0});
    window->setColor(0);
    window->setOwner(player);
    window->setDrawCallback([](const Widget& widget, SDL_Rect rect){
        drawMinimap(widget.getOwner(), rect, false);
        });

    window->setTickCallback([](Widget& widget){
        int playercount = 0;
	    for (int c = 0; c < MAXPLAYERS; ++c) {
	        if (!client_disconnected[c] && players[c]->isLocalPlayer()) {
	            ++playercount;
	        }
	    }

	    widget.setInvisible(*shareMinimap && playercount > 2);
		auto player = widget.getOwner();
		auto& input = Input::inputs[player];
		auto& minimap = players[player]->minimap;
        bool reducedSize = playercount > 2 /*|| (playercount == 2 && *MainMenu::vertical_splitscreen)*/;
		
		minimap.bExpandPromptEnabled = true;
		minimap.bScalePromptEnabled = false;
		if ( !players[player]->shootmode )
		{
			minimap.bExpandPromptEnabled = false;
			minimap.bScalePromptEnabled = false;
		}
		else if ( players[player]->worldUI.isEnabled()
			&& players[player]->worldUI.bTooltipInView
			&& players[player]->worldUI.tooltipsInRange.size() > 1 )
		{
			const std::string scaleBinding = input.binding("Minimap Scale");
            const std::string expandBinding = input.binding("Toggle Minimap");
            const std::string cycleNextBinding = input.binding("Interact Tooltip Next");
            const std::string cyclePrevBinding = input.binding("Interact Tooltip Prev");
			if ( scaleBinding == cycleNextBinding
				|| scaleBinding == cyclePrevBinding )
			{
				minimap.bScalePromptEnabled = false;
			}
			if ( expandBinding == cycleNextBinding
				|| expandBinding == cyclePrevBinding )
			{
				minimap.bExpandPromptEnabled = false;
			}
		}

        if ( !gamePaused && players[player]->bControlEnabled && minimap.bScalePromptEnabled
			&& !players[player]->usingCommand() && players[player]->shootmode && input.consumeBinaryToggle("Minimap Scale")) {
            if (minimap.scale > 75.0) {
                minimap.real_scale = 75.0;
            }
            else if (minimap.scale > 50.0) {
                minimap.real_scale = 50.0;
            }
            else if (minimap.scale > 25.0) {
                minimap.real_scale = 25.0;
            }
            else {
                minimap.real_scale = reducedSize ? 75.0 :  100.0;
            }
        }

        auto& scale_ang = minimap.scale_ang;
        auto& scale = minimap.scale;
		minimap.animating = true;
		if (minimap.big) {
            if (scale_ang < PI / 2.0) {
                scale_ang += ((PI / 144.0) * 2.0) * getFPSScale(144.0);
                if (scale_ang > PI / 2.0) {
                    scale_ang = PI / 2.0;
                }
            }
			if ( scale_ang >= PI / 2.0 )
			{
				minimap.animating = false;
			}
        } else {
            if (scale_ang > 0.0) {
                scale_ang -= ((PI / 144.0) * 2.0) * getFPSScale(144.0);
                if (scale_ang < 0.0) {
                    scale_ang = 0.0;
                }
            }
			if ( scale_ang <= 0.0 )
			{
				minimap.animating = false;
			}
        }

        real_t factor0 = 1.0 - sin(scale_ang);
        real_t factor1 = sin(scale_ang);
        //real_t scale_small = std::min(reducedSize ? 25.0 : 50.0, minimap.real_scale);
        //real_t scale_big = std::min(reducedSize ? 75.0 : 100.0, minimap.real_scale);
		real_t scale_small = 50.0;
		real_t scale_big = Player::Minimap_t::fullBigScale;
		int maxSize = Player::Minimap_t::fullSize;
		static ConsoleVariable<int> cvar_minimap_compact_offset_y("/minimap_compact_offset_y", 44);
		int mapBigOffsetY = 0;
		if ( players[player]->bUseCompactGUIHeight() ) // 2p wide
		{
			maxSize = Player::Minimap_t::compactSize;
			scale_big = Player::Minimap_t::compactBigScale;
			mapBigOffsetY = *cvar_minimap_compact_offset_y;
		}
		else if ( !players[player]->bUseCompactGUIHeight() && players[player]->bUseCompactGUIWidth() ) // 2p vertical
		{
			maxSize = Player::Minimap_t::compact2pVerticalSize;
			scale_big = Player::Minimap_t::compact2pVerticalBigScale;
		}
		
		{
			real_t scale = factor0 * scale_small;
			players[player]->minimap.minimapPos.w = (int)((scale / 100.0) * maxSize);
			players[player]->minimap.minimapPos.h = (int)((scale / 100.0) * maxSize);
		}

        scale = factor0 * scale_small + factor1 * scale_big;

        Frame* parent = players[player]->hud.hudFrame;

		int mapHeightOffset = 0;
		if ( players[player]->hud.mapPromptFrame && !players[player]->hud.mapPromptFrame->isDisabled() )
		{
			mapHeightOffset = players[player]->hud.mapPromptFrame->getSize().h;
		}
		else if ( players[player]->hud.gameTimerFrame && !players[player]->hud.gameTimerFrame->isDisabled()
			// ignore if ui raised above hotbar and vertical split layout
			&& (!(players[player]->hud.offsetHUDAboveHotbarHeight > 0 && splitscreen && !players[player]->bUseCompactGUIHeight() && players[player]->bUseCompactGUIWidth())) )
		{
			mapHeightOffset = players[player]->hud.gameTimerFrame->getSize().h;
		}
		mapHeightOffset += players[player]->hud.offsetHUDAboveHotbarHeight;

		const int scaledSize = (int)((scale / 100.0) * maxSize);
        int x = factor0 * (parent->getSize().w - scaledSize) +
            factor1 * (parent->getSize().w - scaledSize) / 2;
        int y = factor0 * (parent->getSize().h - scaledSize - mapHeightOffset) +
            factor1 * (parent->getSize().h - scaledSize - mapBigOffsetY) / 2;

        auto frame = static_cast<Frame*>(&widget);
        frame->setSize(SDL_Rect{x, y, (int)(scaledSize), (int)(scaledSize)});
		players[player]->minimap.minimapPos.x = x;
		players[player]->minimap.minimapPos.y = y;
		if ( frame->isInvisible() )
		{
			frame->setHollow(true);
		}
		else
		{
			frame->setHollow(true);
		}
        });

    return window;
}

void openMinimap(int player) {
    Frame* minimap = players[player]->hud.minimapFrame;
    if (minimap) {
        players[player]->minimap.big = (players[player]->minimap.big==false);
    }
}

void Player::MessageZone_t::processLogFrame()
{
	if ( !logParentFrame )
	{
		Frame* f = gameUIFrame[player.playernum]->addFrame("log parent frame");
		f->setHollow(true);
		f->setDisabled(true);
		f->setBorder(0);
		f->setOwner(player.playernum);
		logParentFrame = f;
	}

	if ( logWindow )
	{
		logParentFrame->setDisabled(false);
	}
	else
	{
		if ( player.hud.hudFrame )
		{
			logParentFrame->setDisabled(player.hud.hudFrame->isDisabled());
		}
		else
		{
			logParentFrame->setDisabled(true);
		}
	}

	if ( !logParentFrame->isDisabled() )
	{
		logParentFrame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
			players[player.playernum]->camera_virtualy1(),
			players[player.playernum]->camera_virtualWidth(),
			players[player.playernum]->camera_virtualHeight() });
	}
}
void Player::Minimap_t::processMapFrame()
{
	if ( !mapParentFrame )
	{
		Frame* f = gameUIFrame[player.playernum]->addFrame("map parent frame");
		f->setHollow(true);
		f->setDisabled(true);
		f->setBorder(0);
		f->setOwner(player.playernum);
		mapParentFrame = f;
	}

	if ( mapWindow )
	{
		mapParentFrame->setDisabled(false);
	}
	else
	{
		if ( player.hud.hudFrame )
		{
			mapParentFrame->setDisabled(player.hud.hudFrame->isDisabled());
		}
		else
		{
			mapParentFrame->setDisabled(true);
		}
	}

	if ( !mapParentFrame->isDisabled() )
	{
		mapParentFrame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
			players[player.playernum]->camera_virtualy1(),
			players[player.playernum]->camera_virtualWidth(),
			players[player.playernum]->camera_virtualHeight() });
	}
}

void openMapWindow(int player) {
	if ( !players[player]->minimap.mapParentFrame )
	{
		return;
	}
    auto& frame = players[player]->minimap.mapWindow;
    if (frame) {
        frame->removeSelf();
        frame = nullptr;
		if ( players[player]->gui_mode == GUI_MODE_NONE ) {
			players[player]->shootmode = true;
		}
		else
		{
			players[player]->GUI.returnToPreviousActiveModule();
		}
		Player::soundCancel();
        return;
    }

	players[player]->GUI.previousModule = players[player]->GUI.activeModule;
	bool bOldShootmode = players[player]->shootmode;
	if ( players[player]->shootmode )
	{
		players[player]->openStatusScreen(GUI_MODE_NONE,
			INVENTORY_MODE_ITEM, Player::GUI_t::MODULE_MAP);
	}
	else
	{
		players[player]->openStatusScreen(GUI_MODE_INVENTORY,
			players[player]->inventory_mode, Player::GUI_t::MODULE_MAP); // Reset the GUI to the inventory.
	}

	Player::soundActivate();

    auto& otherWindow = players[player]->messageZone.logWindow;
    if (otherWindow) {
        otherWindow->removeSelf();
        otherWindow = nullptr;
    }
    Frame* parent = players[player]->minimap.mapParentFrame;
    const SDL_Rect size = parent->getSize();
    int _w = std::max(Frame::virtualScreenX / 2, size.w - 432);
    int _h = std::max(Frame::virtualScreenY / 2, size.h - 256);
	int yoffset = 32;
	const bool bCompact = players[player]->bUseCompactGUIHeight() || players[player]->bUseCompactGUIWidth();
	if ( bCompact )
	{
		if ( players[player]->bUseCompactGUIHeight() && players[player]->bUseCompactGUIWidth() )
		{
			static ConsoleVariable<int> cvar_map_splitscreen_w("/map_splitscreen_wborder", 64);
			static ConsoleVariable<int> cvar_map_splitscreen_h("/map_splitscreen_hborder", 16);
			static ConsoleVariable<int> cvar_map_splitscreen_offset_y("/map_splitscreen_offset_y", 0);
			_w = size.w - *cvar_map_splitscreen_w;
			_h = size.h - *cvar_map_splitscreen_h;
			yoffset = *cvar_map_splitscreen_offset_y;
		}
		else if ( players[player]->bUseCompactGUIHeight() )
		{
			static ConsoleVariable<int> cvar_map_splitscreen_2p_wide_w("/map_splitscreen_2p_wide_wborder", 64);
			static ConsoleVariable<int> cvar_map_splitscreen_2p_wide_h("/map_splitscreen_2p_wide_hborder", 8);
			static ConsoleVariable<int> cvar_map_splitscreen_2p_wide_offset_y("/map_splitscreen_2p_wide_offset_y", 0);
			_w = size.w - *cvar_map_splitscreen_2p_wide_w;
			_h = size.h - *cvar_map_splitscreen_2p_wide_h;
			yoffset = *cvar_map_splitscreen_2p_wide_offset_y;
		}
		else if ( players[player]->bUseCompactGUIWidth() )
		{
			static ConsoleVariable<int> cvar_map_splitscreen_2p_tall_w("/map_splitscreen_2p_tall_wborder", 64);
			static ConsoleVariable<int> cvar_map_splitscreen_2p_tall_h("/map_splitscreen_2p_tall_hborder", 64);
			static ConsoleVariable<int> cvar_map_splitscreen_2p_wide_offset_y("/map_splitscreen_2p_tall_offset_y", 0);
			if ( *MainMenu::clipped_splitscreen )
			{
				*cvar_map_splitscreen_2p_tall_h = 156;
				*cvar_map_splitscreen_2p_wide_offset_y = 2;
			}
			else
			{
				*cvar_map_splitscreen_2p_tall_h = 256;
				*cvar_map_splitscreen_2p_wide_offset_y = 32;
			}
			_w = size.w - *cvar_map_splitscreen_2p_tall_w;
			_h = size.h - *cvar_map_splitscreen_2p_tall_h;
			yoffset = *cvar_map_splitscreen_2p_wide_offset_y;
		}
	}
    int w = std::min(_w, _h);
    int h = std::min(_w, _h);
    frame = parent->addFrame("minimap_window");
    frame->setOwner(player);
    frame->setSize(SDL_Rect{(size.w - w) / 2, (size.h - h) / 2 - yoffset, w, h});
    frame->setBorderColor(makeColor(51, 33, 26, 255));
    frame->setColor(0);
    //frame->setBorder(2);
    frame->setBorder(0);
    frame->setColor(makeColor(mapBgColor->x, mapBgColor->y, mapBgColor->z, mapBgColor->w));
    frame->setTickCallback([](Widget& widget){
        const int player = widget.getOwner();
        auto frame = static_cast<Frame*>(&widget);
        if (players[player]->shootmode) {
            players[player]->minimap.mapWindow = nullptr;
            frame->removeSelf();
        }
        });

    // frame images
    {
        frame->addImage(
            SDL_Rect{0, 0, 16, 32},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_TL00.png",
            "TL");
        frame->addImage(
            SDL_Rect{16, 0, w - 32, 32},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_T00.png",
            "T");
        frame->addImage(
            SDL_Rect{w - 16, 0, 16, 32},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_TR00.png",
            "TR");
        auto L = frame->addImage(
            SDL_Rect{0, 32, 4, h - 48},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_L00.png",
            "L");
        L->ontop = true;
        auto R = frame->addImage(
            SDL_Rect{w - 4, 32, 4, h - 48},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_R00.png",
            "R");
        R->ontop = true;
        auto BL = frame->addImage(
            SDL_Rect{0, h - 16, 16, 16},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_BL00.png",
            "BL");
        BL->ontop = true;
        auto B = frame->addImage(
            SDL_Rect{16, h - 4, w - 32, 4},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_B00.png",
            "B");
        B->ontop = true;
        auto BR = frame->addImage(
            SDL_Rect{w - 16, h - 16, 16, 16},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_BR00.png",
            "BR");
        BR->ontop = true;
    }

    auto container = frame->addFrame("container");
	container->setSize(SDL_Rect{0, 32, w, h - 32});
    container->setBorderColor(makeColor(51, 33, 26, 255));
	//container->setBorder(2);
	container->setBorder(0);
	container->setColor(0);

    const int map_size = std::min(w - 32, h - 64);
	auto minimap = container->addFrame("minimap");
	minimap->setSize(SDL_Rect{(w - map_size) / 2, (h - 32 - map_size) / 2, map_size, map_size});
	minimap->setColor(0);
    minimap->setBorder(0);

    struct Position {
        real_t x;
        real_t y;
    };
	static Position minimap_cursor[MAXPLAYERS];
	minimap_cursor[player].x = map_size / 2;
	minimap_cursor[player].y = map_size / 2;

	if ( !bOldShootmode && players[player]->GUI.previousModule == Player::GUI_t::MODULE_CHARACTERSHEET )
	{
		if ( !inputs.getVirtualMouse(player)->draw_cursor )
		{
			Input::inputs[player].consumeBinary("MinimapPing"); // clicked from button
		}
	}

	minimap->setDrawCallback([](const Widget& widget, SDL_Rect rect){
	    int player = widget.getOwner();
		if ( ::minimapFrame && !::minimapFrame->isInvisible() )
		{
			drawMinimap(0, rect, true); // use the same texture
		}
		else
		{
			drawMinimap(player, rect, false);
		}
        if (!inputs.getVirtualMouse(player)->draw_cursor) {
	        auto& cursor = minimap_cursor[player];
			auto image = Image::get("*#images/ui/MapAndLog/cursor.png");
			SDL_Rect pos;
			pos.x = cursor.x - image->getWidth() / 2 + rect.x;
			pos.y = cursor.y - image->getHeight() / 2 + rect.y;
			pos.w = image->getWidth();
			pos.h = image->getHeight();
			image->drawColor(nullptr, pos, SDL_Rect{0, 0, Frame::virtualScreenX, Frame::virtualScreenY}, 0xffffffff);
        }
		else
		{
			auto frame = ((Frame*)(widget.getParent()))->getParent();
			if ( Button* button = frame->findButton("close") )
			{
				if ( button->isHighlighted() )
				{
					players[player]->GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_MAP);
					if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_MAP )
					{
						players[player]->GUI.activateModule(Player::GUI_t::MODULE_MAP);
					}
					SDL_Rect pos = button->getAbsoluteSize();
					// make sure to adjust absolute size to camera viewport
					pos.x -= players[player]->camera_virtualx1();
					pos.y -= players[player]->camera_virtualy1();
					players[player]->hud.setCursorDisabled(false);
					players[player]->hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, inputs.getVirtualMouse(player)->draw_cursor);
				}
			}
		}
        });

	minimap->setTickCallback([](Widget& widget){
	    int player = widget.getOwner();
	    auto& input = Input::inputs[player];
	    auto minimap = static_cast<Frame*>(&widget);

		auto frame = ((Frame*)(widget.getParent()))->getParent();
		if ( Frame::image_t* closeGlyph = frame->findImage("close glyph") )
		{
			closeGlyph->disabled = true;
			if ( inputs.hasController(player) && !inputs.getVirtualMouse(player)->draw_cursor )
			{
				Button* closeBtn = frame->findButton("close");
				SDL_Rect closeBtnPos = closeBtn->getSize();
				closeBtn->setSize(closeBtnPos);

				closeGlyph->path = Input::inputs[player].getGlyphPathForBinding("MinimapClose");
				if ( auto imgGet = Image::get(closeGlyph->path.c_str()) )
				{
					closeGlyph->pos.w = imgGet->getWidth();
					closeGlyph->pos.h = imgGet->getHeight();
					closeGlyph->disabled = false;
				}
				closeGlyph->pos.x = closeBtn->getSize().x + closeBtn->getSize().w / 2 - closeGlyph->pos.w / 2;
				if ( closeGlyph->pos.x % 2 == 1 )
				{
					++closeGlyph->pos.x;
				}
				closeGlyph->pos.y = closeBtn->getSize().y + closeBtn->getSize().h - 4;
			}
		}

	    static ConsoleVariable<float> speed("/minimap_cursor_speed", 4.f);

	    // gamepad moves cursor with right stick
	    auto& cursor = minimap_cursor[player];
		const real_t fpsScale = getFPSScale(60.0); // ported from 60Hz
		float leftright = (input.analog("MinimapRight") - input.analog("MinimapLeft"));
		float updown = (input.analog("MinimapDown") - input.analog("MinimapUp"));
        cursor.x += (leftright) * (*speed * fpsScale);
        cursor.y += (updown) * (*speed * fpsScale);
        cursor.x = std::min(std::max((real_t)0, cursor.x), (real_t)minimap->getSize().w);
        cursor.y = std::min(std::max((real_t)0, cursor.y), (real_t)minimap->getSize().h);
        input.consumeBindingsSharedWithBinding("MinimapRight");
        input.consumeBindingsSharedWithBinding("MinimapLeft");
        input.consumeBindingsSharedWithBinding("MinimapDown");
        input.consumeBindingsSharedWithBinding("MinimapUp");
        if (input.consumeBinaryToggle("MinimapClose")) {
			input.consumeBindingsSharedWithBinding("MinimapClose");
            if (players[player]->minimap.mapWindow) {
                players[player]->minimap.mapWindow->removeSelf();
                players[player]->minimap.mapWindow = nullptr;
                if (players[player]->gui_mode == GUI_MODE_NONE) {
                    players[player]->shootmode = true;
                }
				else
				{
					players[player]->GUI.returnToPreviousActiveModule();
				}
				Player::soundCancel();
            }
        }

        static ConsoleVariable<bool> minimapGimpEnabled("/minimap_gimp_enabled", true);

        // minimap pings
		if (minimapPingGimpTimer[player] <= 0 || !*minimapGimpEnabled) {
            if (input.consumeBinaryToggle("MinimapPing")) {
                auto mouse_position = inputs.getVirtualMouse(player)->draw_cursor ?
                    minimap->getRelativeMousePosition(false):
                    SDL_Rect{(int)cursor.x, (int)cursor.y, minimap->getSize().w, minimap->getSize().h};
                messagePlayer(clientnum, MESSAGE_DEBUG, "[Minimap] Clicked %d %d %d %d",
                    mouse_position.x, mouse_position.y, mouse_position.w, mouse_position.h);
                if (mouse_position.w > 0 && mouse_position.h > 0) {
                    const int size = std::max((int)map.width, (int)map.height);
                    const int xdiff = std::max(0, (int)map.height - (int)map.width) / 2;
                    const int ydiff = std::max(0, (int)map.width - (int)map.height) / 2;
                    const int x = (mouse_position.x * size) / mouse_position.w - xdiff;
                    const int y = (mouse_position.y * size) / mouse_position.h - ydiff;
                    if (x >= 0 && y >= 0 && x < map.width && y < map.height) {
                        MinimapPing newPing(ticks, player, x, y);
		                sendMinimapPing(player, newPing.x, newPing.y);

                        // can also issue move commands via minimap
                        FollowerRadialMenu& followerMenu = FollowerMenu[player];
		                if ( !followerMenu.menuToggleClick && followerMenu.selectMoveTo )
		                {
			                if ( followerMenu.optionSelected == ALLY_CMD_MOVETO_SELECT )
			                {
                                if (!players[player]->usingCommand() && players[player]->bControlEnabled) {
				                    createParticleFollowerCommand(newPing.x, newPing.y, 0, FOLLOWER_TARGET_PARTICLE, 0);
				                    followerMenu.optionSelected = ALLY_CMD_MOVETO_CONFIRM;
				                    followerMenu.selectMoveTo = false;
				                    followerMenu.moveToX = static_cast<int>(newPing.x);
				                    followerMenu.moveToY = static_cast<int>(newPing.y);
			                    }
			                }
			            }
			        }
                }
            }
        } else { // if (minimapPingGimpTimer[player] <= 0)
		    --minimapPingGimpTimer[player];
        }
        });

    auto label = frame->addField("label", 64);
    label->setSize(SDL_Rect{16, 0, w - 40, 32});
    label->setHJustify(Field::justify_t::LEFT);
    label->setVJustify(Field::justify_t::CENTER);
    label->setFont(bigfont_outline);
    label->setText(Language::get(5966));

	auto closeGlyph = frame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
		"", "close glyph");
	closeGlyph->disabled = true;
	closeGlyph->ontop = true;

    auto close_button = frame->addButton("close");
    close_button->setSize(SDL_Rect{frame->getSize().w - 30, 4, 26, 26});
	close_button->setColor(makeColor(255, 255, 255, 255));
	close_button->setHighlightColor(makeColor(255, 255, 255, 255));
	close_button->setText("X");
	close_button->setFont(smallfont_outline);
	close_button->setHideGlyphs(true);
	close_button->setHideKeyboardGlyphs(true);
	close_button->setHideSelectors(true);
	close_button->setMenuConfirmControlType(0);
	close_button->setBackground("*#images/ui/Shop/Button_X_00.png");
	close_button->setBackgroundHighlighted("*#images/ui/Shop/Button_XHigh_00.png");
	close_button->setBackgroundActivated("*#images/ui/Shop/Button_XPress_00.png");
	close_button->setTextHighlightColor(makeColor(201, 162, 100, 255));
    close_button->setCallback([](Button& button){
        const int player = button.getOwner();
        players[player]->minimap.mapWindow = nullptr;
        auto parent = static_cast<Frame*>(button.getParent());
        parent->removeSelf();
        if (players[player]->gui_mode == GUI_MODE_NONE) {
            players[player]->shootmode = true;
        }
		Player::soundCancel();
        });
}

static ConsoleCommand ccmd_log_clear("/log_clear", "Clears log history",
    [](int argc, const char** argv){
    list_FreeAll(&messages);
    });

void addMessageToLogWindow(int player, string_t* string) {
    auto& frame = players[player]->messageZone.logWindow;
    if (!frame || !string) {
        return;
    }

    const int w = frame->getSize().w;
    const int h = frame->getSize().h;

    auto subframe = frame->findFrame("subframe"); assert(subframe);
    auto subframe_size = subframe->getActualSize();
	int y = subframe_size.h;
	if ( y != 4 )
	{
		y = subframe_size.h + *cvar_log_lineheight_offset;
	}

    static ConsoleVariable<bool> timestamp_messages("/log_timestamp", true);

    char buf[1024];
    const Uint32 time = string->time / TICKS_PER_SECOND;
    const Uint32 hour = time / 3600;
    const Uint32 min = (time / 60) % 60;
    const Uint32 sec = time % 60;
    const int result = *timestamp_messages ?
        snprintf(buf, sizeof(buf), "[%.2u:%.2u:%.2u] %s",
            hour, min, sec, string->data):
        snprintf(buf, sizeof(buf), "%s", string->data);
    const int size = std::min(std::max(0, (int)sizeof(buf)), result);

    static ConsoleVariable<std::string> font("/log_font",
        "fonts/PixelMaz_monospace.ttf#32#2");
	static ConsoleVariable<std::string> compactfont("/log_font_compact",
		"fonts/pixel_maz.ttf#32#2");

	const bool bCompactWidth = players[player]->bUseCompactGUIWidth();
    auto field = subframe->addField("field", size + 1);
	int text_h = 0;
	int text_w = 0;
	int textHeight = 0;
	if ( bCompactWidth )
	{
		field->setFont(compactfont->c_str());
		field->setTextColor(string->color);
		field->addWordToHighlight(0, makeColorRGB(166, 166, 166));
		field->setText(buf);
		field->setPaddingPerLine(*cvar_log_multiline_pady);
		if ( auto text = field->getTextObject() )
		{
			textHeight = (int)(std::max(*cvar_log_lineheight_min, (int)text->getHeight()) * (int)string->lines + 2);
			text_h = textHeight + *cvar_log_lineheight_offset;
			text_w = (int)text->getWidth();
			field->setSize(SDL_Rect{ 8, y, text_w, textHeight });
		}
	}
	else
	{
		field->setFont(font->c_str());
		field->setTextColor(string->color);
		field->addWordToHighlight(0, makeColorRGB(166, 166, 166));
		field->addWordToHighlight(1, makeColorRGB(166, 166, 166));
		field->addWordToHighlight(2, makeColorRGB(166, 166, 166));
		field->addWordToHighlight(3, makeColorRGB(166, 166, 166));
		field->setText(buf);
		field->setPaddingPerLine(*cvar_log_multiline_pady);
		if ( auto text = field->getTextObject() )
		{
			textHeight = (int)(std::max(*cvar_log_lineheight_min, (int)text->getHeight()) * (int)string->lines + 2);
			text_h = textHeight + *cvar_log_lineheight_offset;
			text_w = (int)text->getWidth();
			field->setSize(SDL_Rect{ 8, y, text_w, textHeight });
		}
	}

    //(void)snprintf(buf, sizeof(buf), "[%.2u:%.2u:%.2u]", hour, min, sec);
    //field->setTooltip(buf);

    const int new_w = std::max(subframe_size.w, text_w + 8);

	y = std::max(y, 0);
    y += textHeight;
    if (subframe_size.y >= subframe_size.h - subframe->getSize().h) {
        // advance scroll because we're already at bottom
        const int limit = new_w > w ?
            y - subframe->getSize().h + 16:
            y - subframe->getSize().h;
        subframe->setActualSize(SDL_Rect{subframe_size.x,
            std::max(0, limit), new_w, y});
    } else {
        // retain scroll position because we're looking at past history
        subframe->setActualSize(SDL_Rect{
            subframe_size.x, subframe_size.y, new_w, y});
    }
}

void openLogWindow(int player) {
	if ( !players[player]->messageZone.logParentFrame )
	{
		return;
	}
    auto& frame = players[player]->messageZone.logWindow;
    if (frame) {
        frame->removeSelf();
        frame = nullptr;
		if ( players[player]->gui_mode == GUI_MODE_NONE ) {
			players[player]->shootmode = true;
		}
		else
		{
			players[player]->GUI.returnToPreviousActiveModule();
		}
		Player::soundCancel();
        return;
    }

	players[player]->GUI.previousModule = players[player]->GUI.activeModule;
	if ( players[player]->shootmode )
	{
		players[player]->openStatusScreen(GUI_MODE_NONE,
			INVENTORY_MODE_ITEM, Player::GUI_t::MODULE_LOG);
	}
	else
	{
		players[player]->openStatusScreen(GUI_MODE_INVENTORY,
			players[player]->inventory_mode, Player::GUI_t::MODULE_LOG); // Reset the GUI to the inventory.
	}

	Player::soundActivate();

    auto& otherWindow = players[player]->minimap.mapWindow;
    if (otherWindow) {
        otherWindow->removeSelf();
        otherWindow = nullptr;
    }
    Frame* parent = players[player]->messageZone.logParentFrame;
    const SDL_Rect size = parent->getSize();
    int w = std::max(Frame::virtualScreenX / 2, size.w - 432);
    int h = std::max(Frame::virtualScreenY / 2, size.h - 256);
	static ConsoleVariable<int> cvar_log_splitscreen_w("/log_splitscreen_wborder", 40);
	static ConsoleVariable<int> cvar_log_splitscreen_h("/log_splitscreen_hborder", 64);
	int yoffset = 32;
	if ( (players[player]->bUseCompactGUIHeight() && players[player]->bUseCompactGUIWidth())
		|| players[player]->bUseCompactGUIWidth() )
	{
		w = size.w - *cvar_log_splitscreen_w;
		if ( !(players[player]->bUseCompactGUIWidth() && !players[player]->bUseCompactGUIHeight()) ) // 2p tall splitscreen
		{
			h = size.h - *cvar_log_splitscreen_h;
		}
	}
	else if ( players[player]->bUseCompactGUIHeight() )
	{
		// 2p wide
		w = size.w - 432;
		h = size.h - 8;
		yoffset = 0;
	}

    frame = parent->addFrame("log_window");
    frame->setOwner(player);
    frame->setSize(SDL_Rect{(size.w - w) / 2, (size.h - h) / 2 - yoffset, w, h});
    frame->setBorderColor(makeColor(51, 33, 26, 255));
    frame->setColor(makeColor(logBgColor->x, logBgColor->y, logBgColor->z, logBgColor->w));
    //frame->setBorder(2);
    frame->setBorder(0);
    frame->setTickCallback([](Widget& widget){
        const int player = widget.getOwner();
        auto frame = static_cast<Frame*>(&widget);
        if (players[player]->shootmode) {
            players[player]->messageZone.logWindow = nullptr;
            frame->removeSelf();
        }

        const int w = frame->getSize().w;
        const int h = frame->getSize().h;

        const bool using_keyboard = Input::inputs[player].getPlayerControlType() ==
            Input::playerControlType_t::PLAYER_CONTROLLED_BY_KEYBOARD;

        const bool pressed = (ticks % TICKS_PER_SECOND) >= TICKS_PER_SECOND / 2;

        auto help_left = frame->findField("help_left"); assert(help_left);
        auto help_center = frame->findField("help_center"); assert(help_center);
        auto help_right = frame->findField("help_right"); assert(help_right);
		auto help_left_div = frame->findField("help_left_div"); assert(help_left_div);
		auto help_center_div = frame->findField("help_center_div"); assert(help_center_div);
		auto help_right_div = frame->findField("help_right_div"); assert(help_right_div);
		help_left->setDisabled(false);
		help_center->setDisabled(false);
		help_right->setDisabled(false);
		help_left_div->setDisabled(false);
		help_center_div->setDisabled(false);
		help_right_div->setDisabled(false);

		auto LogHome = frame->findImage("LogHome"); assert(LogHome); 
		LogHome->disabled = true;
		auto LogEnd = frame->findImage("LogEnd"); assert(LogEnd); 
		LogEnd->disabled = true;
		auto LogPageUp = frame->findImage("LogPageUp"); assert(LogPageUp); 
		LogPageUp->disabled = true;
		auto LogPageDown = frame->findImage("LogPageDown"); assert(LogPageDown); 
		LogPageDown->disabled = true;
		auto LogScrollUp = frame->findImage("LogScrollUp"); assert(LogScrollUp); 
		LogScrollUp->disabled = true;
		auto LogScrollDown = frame->findImage("LogScrollDown"); assert(LogScrollDown); 
		LogScrollDown->disabled = true;

		const bool bCompactWidth = players[player]->bUseCompactGUIWidth();
		const bool twoPrompts = bCompactWidth || (players[player]->bUseCompactGUIHeight() && !players[player]->bUseCompactGUIWidth() && *MainMenu::clipped_splitscreen);
		struct TextAndGlyphs
		{
			Frame::image_t* img1;
			Frame::image_t* img2;
			Field* div;
			Field* text;
		};
		std::vector<TextAndGlyphs> textAndGlyphs;
		if ( twoPrompts )
		{
			help_left->setText(Language::get(4315));
			help_center->setDisabled(true);
			help_center_div->setDisabled(true);
			help_right->setText(Language::get(4316));

			textAndGlyphs.push_back(TextAndGlyphs{ LogPageUp, LogPageDown, help_left_div, help_left});
			textAndGlyphs.push_back(TextAndGlyphs{ LogScrollUp, LogScrollDown, help_right_div, help_right });
		}
		else
		{
			help_left->setText(Language::get(4314));
			help_center->setText(Language::get(4315));
			help_right->setText(Language::get(4316));

			textAndGlyphs.push_back(TextAndGlyphs{ LogHome, LogEnd, help_left_div, help_left });
			textAndGlyphs.push_back(TextAndGlyphs{ LogPageUp, LogPageDown, help_center_div, help_center });
			textAndGlyphs.push_back(TextAndGlyphs{ LogScrollUp, LogScrollDown, help_right_div, help_right });
		}

		for ( auto& entry : textAndGlyphs )
		{
			entry.div->setDisabled(entry.text->isDisabled());

			entry.img1->disabled = entry.text->isDisabled();
			if ( !entry.img1->disabled )
			{
				std::string path = Input::inputs[player].getGlyphPathForBinding(entry.img1->name.c_str(), pressed);
				if ( auto glyph = Image::get(path.c_str()) )
				{
					entry.img1->color = 0xffffffff;
					entry.img1->path = path;
					entry.img1->pos.w = (int)glyph->getWidth();
					entry.img1->pos.h = (int)glyph->getHeight();
					entry.img1->pos.y = (int)(h - 16 - entry.img1->pos.h / 2);
				}
			}

			entry.img2->disabled = entry.text->isDisabled();
			if ( !entry.img2->disabled )
			{
				std::string path = Input::inputs[player].getGlyphPathForBinding(entry.img2->name.c_str(), pressed);
				if ( auto glyph = Image::get(path.c_str()) )
				{
					entry.img2->color = 0xffffffff;
					entry.img2->path = path;
					entry.img2->pos.w = (int)glyph->getWidth();
					entry.img2->pos.h = (int)glyph->getHeight();
					entry.img2->pos.y = (int)(h - 16 - entry.img2->pos.h / 2);
				}
			}
			if ( entry.text->isDisabled() )
			{
				continue;
			}

			if ( entry.text == help_left )
			{
				entry.img1->pos.x = 8;
				SDL_Rect divPos = entry.div->getSize();
				divPos.x = entry.img1->pos.x + entry.img1->pos.w + 4;
				if ( auto textGet = entry.div->getTextObject() )
				{
					divPos.w = textGet->getWidth();
				}
				entry.div->setSize(divPos);

				entry.img2->pos.x = divPos.x + divPos.w + 4;
				SDL_Rect textPos = entry.text->getSize();
				textPos.x = entry.img2->pos.x + entry.img2->pos.w + 8;
				entry.text->setSize(textPos);
			}
			else if ( entry.text == help_center )
			{
				int totalWidth = entry.img1->pos.w + entry.img2->pos.w;
				SDL_Rect divPos = entry.div->getSize();
				if ( auto textGet = entry.div->getTextObject() )
				{
					divPos.w = textGet->getWidth();
				}
				SDL_Rect textPos = entry.text->getSize();
				if ( auto textGet = entry.text->getTextObject() )
				{
					textPos.w = textGet->getWidth();
				}
				totalWidth += 4 + 4 + divPos.w + 8 + textPos.w;
				int startx = w / 2 - (totalWidth / 2);
				if ( startx % 2 == 1 ) { ++startx; } // even alignment

				entry.img1->pos.x = startx;
				divPos.x = entry.img1->pos.x + entry.img1->pos.w + 4;
				entry.div->setSize(divPos);

				entry.img2->pos.x = divPos.x + divPos.w + 4;
				textPos.x = entry.img2->pos.x + entry.img2->pos.w + 8;
				entry.text->setSize(textPos);
			}
			else if ( entry.text == help_right )
			{
				int totalWidth = entry.img1->pos.w + entry.img2->pos.w;
				SDL_Rect divPos = entry.div->getSize();
				if ( auto textGet = entry.div->getTextObject() )
				{
					divPos.w = textGet->getWidth();
				}
				SDL_Rect textPos = entry.text->getSize();
				if ( auto textGet = entry.text->getTextObject() )
				{
					textPos.w = textGet->getWidth();
				}
				totalWidth += 4 + 4 + divPos.w + 8 + textPos.w;
				int startx = w - 8 - totalWidth;
				if ( startx % 2 == 1 ) { --startx; } // even alignment

				entry.img1->pos.x = startx;
				divPos.x = entry.img1->pos.x + entry.img1->pos.w + 4;
				entry.div->setSize(divPos);

				entry.img2->pos.x = divPos.x + divPos.w + 4;
				textPos.x = entry.img2->pos.x + entry.img2->pos.w + 8;
				entry.text->setSize(textPos);
			}
		}

        auto subframe = frame->findFrame("subframe"); assert(subframe);
        auto subframe_size = subframe->getActualSize();
		/*auto fields = subframe->getFields();
		if ( fields.size() > 0 )
		{
			SDL_Rect fieldPos = fields[fields.size() - 1]->getSize();
			if ( fieldPos.y + fieldPos.h > subframe_size.h )
			{
				subframe_size.h += (fieldPos.y + fieldPos.h - subframe_size.h);
				subframe_size.y += (fieldPos.y + fieldPos.h - subframe_size.h);
				subframe->setActualSize(subframe_size);
			}
		}*/

        if (Input::inputs[player].consumeBinaryToggle("LogHome")) {
            Input::inputs[player].consumeBindingsSharedWithBinding("LogHome");
            subframe_size.x = 0;
            subframe_size.y = 0;
            subframe->setActualSize(subframe_size);
        }
        if (Input::inputs[player].consumeBinaryToggle("LogEnd")) {
            Input::inputs[player].consumeBindingsSharedWithBinding("LogEnd");
            const int limit = subframe_size.w > w ?
                subframe_size.h - subframe->getSize().h + 16:
                subframe_size.h - subframe->getSize().h;
            subframe_size.x = 0;
            subframe_size.y = std::max(0, limit);
            subframe->setActualSize(subframe_size);
        }
        if (Input::inputs[player].consumeBinaryToggle("LogPageUp")) {
            Input::inputs[player].consumeBindingsSharedWithBinding("LogPageUp");
            subframe_size.y -= subframe->getSize().h;
            subframe_size.y = std::max(0, subframe_size.y);
            subframe->setActualSize(subframe_size);
        }
        if (Input::inputs[player].consumeBinaryToggle("LogPageDown")) {
            Input::inputs[player].consumeBindingsSharedWithBinding("LogPageDown");
            subframe_size.y += subframe->getSize().h;
            const int limit = subframe_size.w > w ?
                subframe_size.h - subframe->getSize().h + 16:
                subframe_size.h - subframe->getSize().h;
            subframe_size.y = std::min(std::max(0, limit), subframe_size.y);
            subframe->setActualSize(subframe_size);
        }
		if ( Input::inputs[player].consumeBinaryToggle("LogClose") ) {
			Input::inputs[player].consumeBindingsSharedWithBinding("LogClose");
			if ( players[player]->messageZone.logWindow ) {
				Player::soundCancel();
				players[player]->messageZone.logWindow->removeSelf();
				players[player]->messageZone.logWindow = nullptr;
				if ( players[player]->gui_mode == GUI_MODE_NONE ) {
					players[player]->shootmode = true;
				}
				else
				{
					players[player]->GUI.returnToPreviousActiveModule();
				}
			}
		}

		if ( Frame::image_t* closeGlyph = frame->findImage("close glyph") )
		{
			closeGlyph->disabled = true;
			if ( inputs.hasController(player) && !inputs.getVirtualMouse(player)->draw_cursor )
			{
				Button* closeBtn = frame->findButton("close");
                if (closeBtn)
                {
                    SDL_Rect closeBtnPos = closeBtn->getSize();
                    closeBtn->setSize(closeBtnPos);

                    closeGlyph->path = Input::inputs[player].getGlyphPathForBinding("LogClose");
                    if ( auto imgGet = Image::get(closeGlyph->path.c_str()) )
                    {
                        closeGlyph->pos.w = imgGet->getWidth();
                        closeGlyph->pos.h = imgGet->getHeight();
                        closeGlyph->disabled = false;
                    }
                    closeGlyph->pos.x = closeBtn->getSize().x + closeBtn->getSize().w / 2 - closeGlyph->pos.w / 2;
                    if ( closeGlyph->pos.x % 2 == 1 )
                    {
                        ++closeGlyph->pos.x;
                    }
                    closeGlyph->pos.y = closeBtn->getSize().y + closeBtn->getSize().h - 4;
                }
			}
		}
        });

    // frame images
    {
        frame->addImage(
            SDL_Rect{0, 0, 16, 32},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_TL00.png",
            "TL");
        frame->addImage(
            SDL_Rect{16, 0, w - 32, 32},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_T00.png",
            "T");
        frame->addImage(
            SDL_Rect{w - 16, 0, 16, 32},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_TR00.png",
            "TR");
        auto L = frame->addImage(
            SDL_Rect{0, 32, 4, h - 64},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_L00.png",
            "L");
        L->ontop = true;
        auto R = frame->addImage(
            SDL_Rect{w - 4, 32, 4, h - 64},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_R00.png",
            "R");
        R->ontop = true;
        frame->addImage(
            SDL_Rect{0, h - 32, 16, 32},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_BL01.png",
            "BL");
        frame->addImage(
            SDL_Rect{16, h - 32, w - 32, 32},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_B01.png",
            "B");
        frame->addImage(
            SDL_Rect{w - 16, h - 32, 16, 32},
            0xffffffff,
            "*#images/ui/MapAndLog/Hover_BR01.png",
            "BR");
    }

    auto subframe = frame->addFrame("subframe");
    subframe->setScrollWithLeftControls(false);
    subframe->setSize(SDL_Rect{0, 32, w, h - 64});
    subframe->setActualSize(SDL_Rect{0, 0, w, 4});
    subframe->setBorderColor(makeColor(22, 24, 29, 255));
    subframe->setSliderColor(makeColor(44, 48, 58, 255));
    subframe->setColor(makeColor(0, 0, 0, 0));
    subframe->setScrollBarsEnabled(true);
    //subframe->setBorder(2);
    subframe->setBorder(0);

    for (auto node = messages.first; node != nullptr; node = node->next) {
        auto string = (string_t*)node->element;
		if ( string->player == player )
		{
			addMessageToLogWindow(player, string);
		}
    }

    auto label = frame->addField("label", 64);
    label->setSize(SDL_Rect{16, 0, w - 40, 32});
    label->setHJustify(Field::justify_t::LEFT);
    label->setVJustify(Field::justify_t::CENTER);
    label->setFont(bigfont_outline);
    label->setText(Language::get(5967));

	auto closeGlyph = frame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
		"", "close glyph");
	closeGlyph->disabled = true;
	closeGlyph->ontop = true;

    auto close_button = frame->addButton("close");
    close_button->setSize(SDL_Rect{frame->getSize().w - 30, 4, 26, 26});
	close_button->setColor(makeColor(255, 255, 255, 255));
	close_button->setHighlightColor(makeColor(255, 255, 255, 255));
	close_button->setText("X");
	close_button->setFont(smallfont_outline);
	close_button->setHideGlyphs(true);
	close_button->setHideKeyboardGlyphs(true);
	close_button->setHideSelectors(true);
	close_button->setMenuConfirmControlType(0);
	close_button->setBackground("*#images/ui/Shop/Button_X_00.png");
	close_button->setBackgroundHighlighted("*#images/ui/Shop/Button_XHigh_00.png");
	close_button->setBackgroundActivated("*#images/ui/Shop/Button_XPress_00.png");
	close_button->setTextHighlightColor(makeColor(201, 162, 100, 255));
    close_button->setCallback([](Button& button){
        const int player = button.getOwner();
        players[player]->messageZone.logWindow = nullptr;
        auto parent = static_cast<Frame*>(button.getParent());
        parent->removeSelf();
        if (players[player]->gui_mode == GUI_MODE_NONE) {
            players[player]->shootmode = true;
        }
		else
		{
			players[player]->GUI.returnToPreviousActiveModule();
		}
		Player::soundCancel();
        });
	close_button->setDrawCallback([](const Widget& widget, SDL_Rect rect)
	{
		Button* button = (Button*)(&widget);
		const int player = button->getOwner();
		if ( inputs.getVirtualMouse(player)->draw_cursor )
		{
			if ( button->isHighlighted() )
			{
				players[player]->GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_LOG);
				if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_LOG )
				{
					players[player]->GUI.activateModule(Player::GUI_t::MODULE_LOG);
				}
				SDL_Rect pos = button->getAbsoluteSize();
				// make sure to adjust absolute size to camera viewport
				pos.x -= players[player]->camera_virtualx1();
				pos.y -= players[player]->camera_virtualy1();
				players[player]->hud.setCursorDisabled(false);
				players[player]->hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, inputs.getVirtualMouse(player)->draw_cursor);
			}
		}
	});

    auto help_left = frame->addField("help_left", 128);
    help_left->setSize(SDL_Rect{0, h - 32, w, 32});
    help_left->setHJustify(Field::justify_t::LEFT);
    help_left->setVJustify(Field::justify_t::CENTER);
    help_left->setFont(smallfont_outline);
	help_left->setDisabled(true);

	auto help_left_div = frame->addField("help_left_div", 32);
	help_left_div->setSize(SDL_Rect{ 0, h - 32, w, 32 });
	help_left_div->setHJustify(Field::justify_t::LEFT);
	help_left_div->setVJustify(Field::justify_t::CENTER);
	help_left_div->setFont(smallfont_outline);
	help_left_div->setDisabled(true);
	help_left_div->setText("/");

    frame->addImage(SDL_Rect{0,0,0,0}, 0,
		"images/system/white.png", "LogHome");
    frame->addImage(SDL_Rect{0,0,0,0}, 0,
		"images/system/white.png", "LogEnd");

    auto help_center = frame->addField("help_center", 128);
    help_center->setSize(SDL_Rect{0, h - 32, w, 32});
    help_center->setHJustify(Field::justify_t::LEFT);
    help_center->setVJustify(Field::justify_t::CENTER);
    help_center->setFont(smallfont_outline);
	help_center->setDisabled(true);

	auto help_center_div = frame->addField("help_center_div", 32);
	help_center_div->setSize(SDL_Rect{ 0, h - 32, w, 32 });
	help_center_div->setHJustify(Field::justify_t::LEFT);
	help_center_div->setVJustify(Field::justify_t::CENTER);
	help_center_div->setFont(smallfont_outline);
	help_center_div->setDisabled(true);
	help_center_div->setText("/");

    frame->addImage(SDL_Rect{0,0,0,0}, 0,
		"images/system/white.png", "LogPageUp");
    frame->addImage(SDL_Rect{0,0,0,0}, 0,
		"images/system/white.png", "LogPageDown");

    auto help_right = frame->addField("help_right", 128);
    help_right->setSize(SDL_Rect{0, h - 32, w - 4, 32});
    help_right->setHJustify(Field::justify_t::RIGHT);
    help_right->setVJustify(Field::justify_t::CENTER);
    help_right->setFont(smallfont_outline);
	help_right->setDisabled(true);

	auto help_right_div = frame->addField("help_right_div", 32);
	help_right_div->setSize(SDL_Rect{ 0, h - 32, w, 32 });
	help_right_div->setHJustify(Field::justify_t::LEFT);
	help_right_div->setVJustify(Field::justify_t::CENTER);
	help_right_div->setFont(smallfont_outline);
	help_right_div->setDisabled(true);
	help_right_div->setText("/");

    frame->addImage(SDL_Rect{0,0,0,0}, 0,
		"images/system/white.png", "LogScrollUp");
    frame->addImage(SDL_Rect{0,0,0,0}, 0,
		"images/system/white.png", "LogScrollDown");
}

std::map<std::string, std::pair<std::string, std::string>> Player::CharacterSheet_t::mapDisplayNamesDescriptions;
std::string Player::CharacterSheet_t::defaultString = "";
std::map<std::string, std::string> Player::CharacterSheet_t::hoverTextStrings;
void Player::CharacterSheet_t::loadCharacterSheetJSON()
{
	if ( !PHYSFS_getRealDir("/data/charsheet.json") )
	{
		printlog("[JSON]: Error: Could not find file: data/charsheet.json");
	}
	else
	{
		std::string inputPath = PHYSFS_getRealDir("/data/charsheet.json");
		inputPath.append("/data/charsheet.json");

		File* fp = FileIO::open(inputPath.c_str(), "rb");
		if ( !fp )
		{
			printlog("[JSON]: Error: Could not open json file %s", inputPath.c_str());
		}
		else
		{
			char buf[65536];
			int count = fp->read(buf, sizeof(buf[0]), sizeof(buf));
			buf[count] = '\0';
			rapidjson::StringStream is(buf);
			FileIO::close(fp);
			rapidjson::Document d;
			d.ParseStream(is);
			if ( !d.HasMember("version") )
			{
				printlog("[JSON]: Error: No 'version' value in json file, or JSON syntax incorrect! %s", inputPath.c_str());
			}
			else
			{
				if ( d.HasMember("level_strings") )
				{
					mapDisplayNamesDescriptions.clear();
					for ( rapidjson::Value::ConstMemberIterator itr = d["level_strings"].MemberBegin();
						itr != d["level_strings"].MemberEnd(); ++itr )
					{
						std::string name = "";
						std::string desc = "";
						if ( itr->value.HasMember("display_name") )
						{
							name = itr->value["display_name"].GetString();
						}
						if ( itr->value.HasMember("description") )
						{
							desc = itr->value["description"].GetString();
						}
						mapDisplayNamesDescriptions[itr->name.GetString()] = std::make_pair(name, desc);
					}
				}
				if ( d.HasMember("hover_text") )
				{
					hoverTextStrings.clear();
					for ( rapidjson::Value::ConstMemberIterator itr = d["hover_text"].MemberBegin();
						itr != d["hover_text"].MemberEnd(); ++itr )
					{
						if ( itr->value.IsObject() )
						{
							for ( rapidjson::Value::ConstMemberIterator inner_itr = itr->value.MemberBegin();
								inner_itr != itr->value.MemberEnd(); ++inner_itr )
							{
								hoverTextStrings[inner_itr->name.GetString()] = inner_itr->value.GetString();
							}
						}
						else
						{
							hoverTextStrings[itr->name.GetString()] = itr->value.GetString();
						}
					}
				}
			}
		}
	}
}

const int NUM_CHARSHEET_TOOLTIP_BACKING_FRAMES = 9;
const int NUM_CHARSHEET_TOOLTIP_TEXT_FIELDS = 16;
std::map<int, Field*> characterSheetTooltipTextFields[MAXPLAYERS];
std::map<int, Frame*> characterSheetTooltipTextBackingFrames[MAXPLAYERS];

static void charsheet_deselect_fn(Widget& widget) {
	if ( widget.isSelected()
		&& players[widget.getOwner()]->GUI.activeModule != Player::GUI_t::MODULE_CHARACTERSHEET
		&& !inputs.getVirtualMouse(widget.getOwner())->draw_cursor )
	{
		widget.deselect();
	}
};

void Player::CharacterSheet_t::createCharacterSheet()
{
	char name[32];
	snprintf(name, sizeof(name), "player sheet %d", player.playernum);
	if ( !gameUIFrame[player.playernum]->findFrame(name) )
	{
		characterSheetTooltipTextFields[player.playernum].clear();
		characterSheetTooltipTextBackingFrames[player.playernum].clear();

		Frame* sheetFrame = gameUIFrame[player.playernum]->addFrame(name);
		sheetFrame->setHollow(true);
		sheetFrame->setBorder(0);
		sheetFrame->setOwner(player.playernum);
		sheetFrame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
			players[player.playernum]->camera_virtualy1(),
			Frame::virtualScreenX,
			Frame::virtualScreenY });
		this->sheetFrame = sheetFrame;

		const int bgWidth = 208;
		const int leftAlignX = sheetFrame->getSize().w - bgWidth;
		{
			Frame* fullscreenBg = sheetFrame->addFrame("sheet bg fullscreen");
			fullscreenBg->setSize(SDL_Rect{ leftAlignX,
				0, 208, Frame::virtualScreenY });
			// if splitscreen 3/4 - disable the fullscreen background + title text.
			fullscreenBg->addImage(SDL_Rect{ 0, 0, fullscreenBg->getSize().w, 360 },
				0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_Window_01A_Top.png", "bg image");

			const char* titleFont = "fonts/pixel_maz.ttf#32#2";
			auto characterSheetTitleText = fullscreenBg->addField("character sheet title text", 32);
			characterSheetTitleText->setFont(titleFont);
			characterSheetTitleText->setSize(SDL_Rect{ 6, 177, 202, 32 });
			characterSheetTitleText->setText(Language::get(5968));
			characterSheetTitleText->setVJustify(Field::justify_t::CENTER);
			characterSheetTitleText->setHJustify(Field::justify_t::CENTER);
		}

		// log / map buttons
		{
			const char* buttonFont = "fonts/pixel_maz.ttf#32#2";
			SDL_Rect buttonFramePos{ leftAlignX + 9, 6, 196, 82 };
			auto buttonFrame = sheetFrame->addFrame("log map buttons");
			buttonFrame->setSize(buttonFramePos);
			buttonFrame->setDrawCallback([](const Widget& widget, SDL_Rect pos) {
				auto frame = (Frame*)(&widget);
			std::vector<const char*> buttons = {
				"map button",
				"log button"
			};
			for ( auto button : buttons )
			{
				if ( auto b = frame->findButton(button) )
				{
					if ( players[frame->getOwner()]->characterSheet.sheetDisplayType == CHARSHEET_DISPLAY_NORMAL )
					{
						b->setBackgroundHighlighted("*#images/ui/CharSheet/HUD_CharSheet_ButtonHigh_00.png");
						b->setBackground("*#images/ui/CharSheet/HUD_CharSheet_Button_00.png");
						b->setBackgroundActivated("*#images/ui/CharSheet/HUD_CharSheet_ButtonPress_00.png");
					}
					else
					{
						b->setBackgroundHighlighted("*#images/ui/CharSheet/HUD_CharSheet_ButtonHighCompact_00.png");
						b->setBackground("*#images/ui/CharSheet/HUD_CharSheet_ButtonCompact_00.png");
						b->setBackgroundActivated("*#images/ui/CharSheet/HUD_CharSheet_ButtonCompactPress_00.png");
					}
				}
			}
				});

			SDL_Rect buttonPos{ 0, 0, buttonFramePos.w, 40 };
			auto mapButton = buttonFrame->addButton("map button");
			mapButton->setText(Language::get(4069));
			mapButton->setFont(buttonFont);
			mapButton->setBackground("*#images/ui/CharSheet/HUD_CharSheet_Button_00.png");
			mapButton->setSize(buttonPos);
			mapButton->setHideGlyphs(true);
			mapButton->setHideKeyboardGlyphs(true);
			mapButton->setHideSelectors(true);
			mapButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
			mapButton->setColor(makeColor(255, 255, 255, 255));
			mapButton->setHighlightColor(makeColor(255, 255, 255, 255));
			mapButton->setCallback([](Button& button) {
				openMapWindow(button.getOwner());
			if ( players[button.getOwner()]->minimap.mapWindow ) {
				button.deselect();
			}
				});
			mapButton->setTickCallback(charsheet_deselect_fn);

			auto mapSelector = buttonFrame->addFrame("map button selector");
			mapSelector->setSize(buttonPos);
			mapSelector->setHollow(true);
			//mapSelector->setClickable(true);

			buttonPos.y = buttonPos.y + buttonPos.h + 2;
			auto logButton = buttonFrame->addButton("log button");
			logButton->setText(Language::get(4070));
			logButton->setFont(buttonFont);
			logButton->setBackground("*#images/ui/CharSheet/HUD_CharSheet_Button_00.png");
			logButton->setSize(buttonPos);
			logButton->setHideGlyphs(true);
			logButton->setHideKeyboardGlyphs(true);
			logButton->setHideSelectors(true);
			logButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
			logButton->setColor(makeColor(255, 255, 255, 255));
			logButton->setHighlightColor(makeColor(255, 255, 255, 255));
			logButton->setCallback([](Button& button) {
				openLogWindow(button.getOwner());
				});
			logButton->setTickCallback(charsheet_deselect_fn);

			auto logSelector = buttonFrame->addFrame("log button selector");
			logSelector->setSize(buttonPos);
			logSelector->setHollow(true);
			//logSelector->setClickable(true);
		}

		// game timer
		{
			const char* timerFont = "fonts/pixel_maz.ttf#32#2";
			Uint32 timerTextColor = makeColor(188, 154, 114, 255);

			Frame* timerFrame = sheetFrame->addFrame("game timer");
			timerFrame->setSize(SDL_Rect{ leftAlignX + 36, 90, 142, 26 });
			timerFrame->setDrawCallback([](const Widget& widget, SDL_Rect pos) {
				auto frame = (Frame*)(&widget);
			auto timerToggleImg = frame->findImage("timer icon img");
			auto timerSelector = frame->findButton("timer selector");
			if ( timerToggleImg && timerSelector )
			{
				if ( !players[frame->getOwner()]->characterSheet.showGameTimerAlways )
				{
					if ( timerSelector->isCurrentlyPressed() )
					{
						timerToggleImg->path = "images/ui/CharSheet/HUD_Button_Timer_PressOff00.png";
					}
					else if ( timerSelector->isHighlighted() || (!inputs.getVirtualMouse(widget.getOwner())->draw_cursor && timerSelector->isSelected()) )
					{
						timerToggleImg->path = "images/ui/CharSheet/HUD_Button_Timer_SelectOff00.png";
					}
					else
					{
						timerToggleImg->path = "images/ui/CharSheet/HUD_Button_Timer_UnselectOff00.png";
					}
				}
				else
				{
					if ( timerSelector->isCurrentlyPressed() )
					{
						timerToggleImg->path = "images/ui/CharSheet/HUD_Button_Timer_PressOn00.png";
					}
					else if ( timerSelector->isHighlighted() || (!inputs.getVirtualMouse(widget.getOwner())->draw_cursor && timerSelector->isSelected()) )
					{
						timerToggleImg->path = "images/ui/CharSheet/HUD_Button_Timer_SelectOn00.png";
					}
					else
					{
						timerToggleImg->path = "images/ui/CharSheet/HUD_Button_Timer_UnselectOn00.png";
					}
				}
			}
				});
			auto timerToggleImg = timerFrame->addImage(SDL_Rect{ 0, 0, 26, 26 }, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_Button_Timer_SelectOff00.png", "timer icon img");
			auto timerImg = timerFrame->addImage(SDL_Rect{ 30, 0, 112, 26 }, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_Timer_Backing_00.png", "timer bg img");
			auto timerText = timerFrame->addField("timer text", 32);
			timerText->setFont(timerFont);

			auto timerButton = timerFrame->addButton("timer selector");
			timerButton->setSize(SDL_Rect{ 0, 0, timerToggleImg->pos.w + timerImg->pos.w, 26 });
			timerButton->setColor(makeColor(0, 0, 0, 0));
			timerButton->setHighlightColor(makeColor(0, 0, 0, 0));
			timerButton->setHideGlyphs(true);
			timerButton->setHideKeyboardGlyphs(true);
			timerButton->setHideSelectors(true);
			timerButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
			timerButton->setCallback([](Button& button) {
				bool& bShowTimer = players[button.getOwner()]->characterSheet.showGameTimerAlways;
			bShowTimer = !bShowTimer;
			if ( bShowTimer )
			{
				Player::soundActivate();
			}
			else
			{
				Player::soundCancel();
			}
				});
			timerButton->setTickCallback(charsheet_deselect_fn);

			SDL_Rect textPos = timerImg->pos;
			textPos.x += 12;
			timerText->setSize(textPos);
			timerText->setVJustify(Field::justify_t::CENTER);
			timerText->setText("00:92:30:89");
			timerText->setColor(timerTextColor);
		}

		// skills button
		{
			const char* skillsFont = "fonts/pixel_maz.ttf#32#2";
			Frame* skillsButtonFrame = sheetFrame->addFrame("skills button frame");
			skillsButtonFrame->setSize(SDL_Rect{ leftAlignX + 14, 360 - 8 - 42, 186, 42 });
			auto skillsButton = skillsButtonFrame->addButton("skills button");
			skillsButton->setText(Language::get(4074));
			skillsButton->setFont(skillsFont);
			skillsButton->setBackground("*#images/ui/CharSheet/HUD_CharSheet_ButtonWide_00.png");
			skillsButton->setBackgroundActivated("*#images/ui/CharSheet/HUD_CharSheet_ButtonWidePress_00.png");
			skillsButton->setBackgroundHighlighted("*#images/ui/CharSheet/HUD_CharSheet_ButtonWideHigh_00.png");
			skillsButton->setSize(SDL_Rect{ 0, 0, skillsButtonFrame->getSize().w, skillsButtonFrame->getSize().h });
			skillsButton->setHideGlyphs(true);
			skillsButton->setHideKeyboardGlyphs(true);
			skillsButton->setHideSelectors(true);
			skillsButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
			skillsButton->setColor(makeColor(255, 255, 255, 255));
			skillsButton->setHighlightColor(makeColor(255, 255, 255, 255));
			skillsButton->setCallback([](Button& button) {
				players[button.getOwner()]->skillSheet.openSkillSheet();
				});
			skillsButton->setTickCallback(charsheet_deselect_fn);
		}

		// dungeon floor and level descriptor
		{
			const char* dungeonFont = "fonts/pixel_maz.ttf#32#2";
			Uint32 dungeonTextColor = makeColor(188, 154, 114, 255);
			Frame* dungeonFloorFrame = sheetFrame->addFrame("dungeon floor frame");

			dungeonFloorFrame->setSize(SDL_Rect{ leftAlignX + 6, 118, 202, 52 });
			auto dungeonButton = dungeonFloorFrame->addButton("dungeon floor selector");
			dungeonButton->setSize(SDL_Rect{ 6, 6, 190, 44 });
			dungeonButton->setColor(makeColor(0, 0, 0, 0));
			dungeonButton->setHighlightColor(makeColor(0, 0, 0, 0));
			dungeonButton->setHideGlyphs(true);
			dungeonButton->setHideKeyboardGlyphs(true);
			dungeonButton->setHideSelectors(true);
			dungeonButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
			dungeonButton->setTickCallback(charsheet_deselect_fn);

			auto floorNameText = dungeonFloorFrame->addField("dungeon name text", 32);
			floorNameText->setFont(dungeonFont);
			floorNameText->setSize(SDL_Rect{ 10, 0, 182, 26 });
			floorNameText->setText("");
			floorNameText->setVJustify(Field::justify_t::CENTER);
			floorNameText->setHJustify(Field::justify_t::CENTER);
			floorNameText->setColor(dungeonTextColor);

			auto floorLevelText = dungeonFloorFrame->addField("dungeon level text", 32);
			floorLevelText->setFont(dungeonFont);
			floorLevelText->setSize(SDL_Rect{ 10, 26, 182, 26 });
			floorLevelText->setText("");
			floorLevelText->setVJustify(Field::justify_t::CENTER);
			floorLevelText->setHJustify(Field::justify_t::CENTER);
			floorLevelText->setColor(dungeonTextColor);
		}

		Frame* characterFrame = sheetFrame->addFrame("character info");
		const char* infoFont = "fonts/pixel_maz.ttf#32#2";
		characterFrame->setSize(SDL_Rect{ leftAlignX, 206, bgWidth, 116 });
		characterFrame->setHollow(true);
		Uint32 infoTextColor = makeColor(188, 154, 114, 255);
		Uint32 classTextColor = makeColor(74, 66, 207, 255);

		sheetFrame->addImage(SDL_Rect{ characterFrame->getSize().x, characterFrame->getSize().y - 60,
			214, 170 }, 0xFFFFFFFF,
			"*#images/ui/CharSheet/HUD_CharSheet_Window_01A_TopCompact.png", "character info compact img");

		Frame* characterInnerFrame = characterFrame->addFrame("character info inner frame");
		characterInnerFrame->setSize(SDL_Rect{ 6, 0, 202, 104 });
		{
			//characterInnerFrame->addImage(SDL_Rect{ 0, 0, characterInnerFrame->getSize().w, characterInnerFrame->getSize().h }, 0xFFFFFFFF,
			//	"*#images/ui/CharSheet/HUD_CharSheet_Window_01A_TopTmp.png", "character info tmp img");


			SDL_Rect characterTextPos{ 2, 0, 198, 24 };
			auto nameText = characterInnerFrame->addField("character name text", 32);
			nameText->setFont(infoFont);
			nameText->setSize(SDL_Rect{ characterTextPos.x,
				characterTextPos.y,
				characterTextPos.w,
				characterTextPos.h });
			nameText->setText("Slartibartfast");
			nameText->setVJustify(Field::justify_t::CENTER);
			nameText->setHJustify(Field::justify_t::CENTER);
			nameText->setColor(infoTextColor);

			/*characterInnerFrame->addImage(SDL_Rect{ 2, 2, 198, 20 }, makeColor(255, 255, 255, 64),
				"images/system/white.png", "character name frame");*/
				//characterInnerFrame->addFrame("character name selector")->setSize(SDL_Rect{ 2, 2, 198, 20 });

			characterTextPos.x = 8;
			characterTextPos.w = 190;
			characterTextPos.y = 52;
			characterTextPos.h = 26;
			auto levelText = characterInnerFrame->addField("character level text", 32);
			levelText->setFont(infoFont);
			levelText->setSize(SDL_Rect{ characterTextPos.x,
				characterTextPos.y,
				characterTextPos.w,
				characterTextPos.h });
			levelText->setText("");
			levelText->setVJustify(Field::justify_t::CENTER);
			levelText->setColor(infoTextColor);

			/*characterInnerFrame->addImage(SDL_Rect{ 4, 54, 194, 22 }, makeColor(255, 255, 255, 64),
				"images/system/white.png", "character level frame");*/
			auto classButton = characterInnerFrame->addButton("character class selector");
			classButton->setSize(SDL_Rect{ 4, 54, 194, 22 });
			classButton->setColor(makeColor(0, 0, 0, 0));
			classButton->setHighlightColor(makeColor(0, 0, 0, 0));
			classButton->setHideGlyphs(true);
			classButton->setHideKeyboardGlyphs(true);
			classButton->setHideSelectors(true);
			classButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
			classButton->setTickCallback(charsheet_deselect_fn);

			characterTextPos.x = 8;
			characterTextPos.w = 190;
			characterTextPos.y = 52;
			characterTextPos.h = 26;
			auto classText = characterInnerFrame->addField("character class text", 32);
			classText->setFont(infoFont);
			classText->setSize(SDL_Rect{ characterTextPos.x,
				characterTextPos.y,
				characterTextPos.w,
				characterTextPos.h });
			classText->setText("");
			classText->setVJustify(Field::justify_t::CENTER);
			classText->setHJustify(Field::justify_t::LEFT);
			classText->setTextColor(classTextColor);

			characterTextPos.x = 4;
			characterTextPos.w = 194;
			characterTextPos.y = 26;
			characterTextPos.h = 26;
			auto raceText = characterInnerFrame->addField("character race text", 32);
			raceText->setFont(infoFont);
			raceText->setSize(SDL_Rect{ characterTextPos.x,
				characterTextPos.y,
				characterTextPos.w,
				characterTextPos.h });
			raceText->setText("");
			raceText->setVJustify(Field::justify_t::CENTER);
			raceText->setHJustify(Field::justify_t::CENTER);
			raceText->setColor(infoTextColor);

			auto sexImg = characterInnerFrame->addImage(
				SDL_Rect{ characterTextPos.x + characterTextPos.w - 40, characterTextPos.y - 4, 16, 28 }, 0xFFFFFFFF,
				"*#images/ui/CharSheet/HUD_CharSheet_Sex_M_01.png", "character sex img");

			/*characterInnerFrame->addImage(SDL_Rect{ 4, 28, 194, 22 }, makeColor(255, 255, 255, 64),
				"images/system/white.png", "character race frame");*/
			auto raceButton = characterInnerFrame->addButton("character race selector");
			raceButton->setSize(SDL_Rect{ 4, 28, 194, 22 });
			raceButton->setColor(makeColor(0, 0, 0, 0));
			raceButton->setHighlightColor(makeColor(0, 0, 0, 0));
			raceButton->setHideGlyphs(true);
			raceButton->setHideKeyboardGlyphs(true);
			raceButton->setHideSelectors(true);
			raceButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
			raceButton->setTickCallback(charsheet_deselect_fn);

			characterTextPos.x = 4;
			characterTextPos.w = 194;
			characterTextPos.y = 78;
			characterTextPos.h = 26;
			auto goldTitleText = characterInnerFrame->addField("gold text title", 8);
			goldTitleText->setFont(infoFont);
			goldTitleText->setSize(SDL_Rect{ 48, characterTextPos.y, 52, characterTextPos.h });
			goldTitleText->setText(Language::get(5969));
			goldTitleText->setVJustify(Field::justify_t::CENTER);
			goldTitleText->setColor(infoTextColor);

			auto goldText = characterInnerFrame->addField("gold text", 32);
			goldText->setFont(infoFont);
			goldText->setSize(SDL_Rect{ 92, characterTextPos.y, 88, characterTextPos.h });
			goldText->setText("0");
			goldText->setVJustify(Field::justify_t::CENTER);
			goldText->setHJustify(Field::justify_t::CENTER);
			goldText->setColor(infoTextColor);

			auto goldImg = characterInnerFrame->addImage(SDL_Rect{ 24, characterTextPos.y - 4, 20, 28 },
				0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_ButtonMoney_00.png", "gold img");

			/*characterInnerFrame->addImage(SDL_Rect{ 24, 80, 156, 22 }, makeColor(255, 255, 255, 64),
				"images/system/white.png", "character gold frame");*/
			auto goldButton = characterInnerFrame->addButton("character gold selector");
			goldButton->setSize(SDL_Rect{ 22, 80, 158, 22 });
			goldButton->setColor(makeColor(0, 0, 0, 0));
			goldButton->setHighlightColor(makeColor(0, 0, 0, 0));
			goldButton->setHideGlyphs(true);
			goldButton->setHideKeyboardGlyphs(true);
			goldButton->setHideSelectors(true);
			goldButton->setMenuConfirmControlType(0);
			goldButton->setTickCallback(charsheet_deselect_fn);
		}

		{
			Frame* statsFrame = sheetFrame->addFrame("stats");
			const int statsFrameHeight = 182;
			statsFrame->setSize(SDL_Rect{ leftAlignX, 344, bgWidth, statsFrameHeight });
			statsFrame->addImage(SDL_Rect{ 0, 0, statsFrame->getSize().w, statsFrame->getSize().h },
				0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_Window_01B_BotA.png", "stats bg img");

			Frame* statsInnerFrame = statsFrame->addFrame("stats inner frame");
			statsInnerFrame->setSize(SDL_Rect{ 0, 0, statsFrame->getSize().w, statsFrame->getSize().h });

			SDL_Rect iconPos{ 20, 8, 24, 24 };
			const int headingLeftX = iconPos.x + iconPos.w + 4;
			const int baseStatLeftX = headingLeftX + 32;
			const int modifiedStatLeftX = baseStatLeftX + 64;
			SDL_Rect textPos{ headingLeftX, iconPos.y, 40, iconPos.h };
			Uint32 statTextColor = hudColors.characterSheetNeutral;

			const char* statFont = "fonts/pixel_maz.ttf#32#2";
			textPos.y = iconPos.y + 1;
			statsInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_STR_00.png", "str icon");
			{
				auto textBase = statsInnerFrame->addField("str text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(statFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(5300));
				textBase->setColor(statTextColor);
				auto textStat = statsInnerFrame->addField("str text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(statFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("0");
				textStat->setColor(statTextColor);
				auto textStatModified = statsInnerFrame->addField("str text modified", 32);
				textStatModified->setVJustify(Field::justify_t::CENTER);
				textStatModified->setHJustify(Field::justify_t::CENTER);
				textStatModified->setFont(statFont);
				textPos.x = modifiedStatLeftX;
				textStatModified->setSize(textPos);
				textStatModified->setText("");
				textStatModified->setColor(statTextColor);

				auto statButton = statsInnerFrame->addButton("str button");
				statButton->setSize(SDL_Rect{ 12, iconPos.y + 2, statsFrame->getSize().w - 34, iconPos.h - 2 });
				statButton->setColor(makeColor(0, 0, 0, 0));
				statButton->setHighlightColor(makeColor(0, 0, 0, 0));
				statButton->setHideGlyphs(true);
				statButton->setHideKeyboardGlyphs(true);
				statButton->setHideSelectors(true);
				statButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				statButton->setTickCallback(charsheet_deselect_fn);
			}
			const int rowSpacing = 4;
			iconPos.y += iconPos.h + rowSpacing;
			textPos.y = iconPos.y + 1;
			statsInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_DEX_00.png", "dex icon");
			{
				auto textBase = statsInnerFrame->addField("dex text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(statFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(5301));
				textBase->setColor(statTextColor);
				auto textStat = statsInnerFrame->addField("dex text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(statFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("0");
				textStat->setColor(statTextColor);
				auto textStatModified = statsInnerFrame->addField("dex text modified", 32);
				textStatModified->setVJustify(Field::justify_t::CENTER);
				textStatModified->setHJustify(Field::justify_t::CENTER);
				textStatModified->setFont(statFont);
				textPos.x = modifiedStatLeftX;
				textStatModified->setSize(textPos);
				textStatModified->setText("2");
				textStatModified->setColor(statTextColor);

				auto statButton = statsInnerFrame->addButton("dex button");
				statButton->setSize(SDL_Rect{ 12, iconPos.y + 2, statsFrame->getSize().w - 34, iconPos.h - 2 });
				statButton->setColor(makeColor(0, 0, 0, 0));
				statButton->setHighlightColor(makeColor(0, 0, 0, 0));
				statButton->setHideGlyphs(true);
				statButton->setHideKeyboardGlyphs(true);
				statButton->setHideSelectors(true);
				statButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				statButton->setTickCallback(charsheet_deselect_fn);
			}

			iconPos.y += iconPos.h + rowSpacing;
			textPos.y = iconPos.y + 1;
			statsInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_CON_00.png", "con icon");
			{
				auto textBase = statsInnerFrame->addField("con text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(statFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(5302));
				textBase->setColor(statTextColor);
				auto textStat = statsInnerFrame->addField("con text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(statFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("0");
				textStat->setColor(statTextColor);
				auto textStatModified = statsInnerFrame->addField("con text modified", 32);
				textStatModified->setVJustify(Field::justify_t::CENTER);
				textStatModified->setHJustify(Field::justify_t::CENTER);
				textStatModified->setFont(statFont);
				textPos.x = modifiedStatLeftX;
				textStatModified->setSize(textPos);
				textStatModified->setText("");
				textStatModified->setColor(statTextColor);

				auto statButton = statsInnerFrame->addButton("con button");
				statButton->setSize(SDL_Rect{ 12, iconPos.y + 2, statsFrame->getSize().w - 34, iconPos.h - 2 });
				statButton->setColor(makeColor(0, 0, 0, 0));
				statButton->setHighlightColor(makeColor(0, 0, 0, 0));
				statButton->setHideGlyphs(true);
				statButton->setHideKeyboardGlyphs(true);
				statButton->setHideSelectors(true);
				statButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				statButton->setTickCallback(charsheet_deselect_fn);
			}

			iconPos.y += iconPos.h + rowSpacing;
			textPos.y = iconPos.y + 1;
			statsInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_INT_00.png", "int icon");
			{
				auto textBase = statsInnerFrame->addField("int text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(statFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(5303));
				textBase->setColor(statTextColor);
				auto textStat = statsInnerFrame->addField("int text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(statFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("0");
				textStat->setColor(statTextColor);
				auto textStatModified = statsInnerFrame->addField("int text modified", 32);
				textStatModified->setVJustify(Field::justify_t::CENTER);
				textStatModified->setHJustify(Field::justify_t::CENTER);
				textStatModified->setFont(statFont);
				textPos.x = modifiedStatLeftX;
				textStatModified->setSize(textPos);
				textStatModified->setText("");
				textStatModified->setColor(statTextColor);

				auto statButton = statsInnerFrame->addButton("int button");
				statButton->setSize(SDL_Rect{ 12, iconPos.y + 2, statsFrame->getSize().w - 34, iconPos.h - 2 });
				statButton->setColor(makeColor(0, 0, 0, 0));
				statButton->setHighlightColor(makeColor(0, 0, 0, 0));
				statButton->setHideGlyphs(true);
				statButton->setHideKeyboardGlyphs(true);
				statButton->setHideSelectors(true);
				statButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				statButton->setTickCallback(charsheet_deselect_fn);
			}

			iconPos.y += iconPos.h + rowSpacing;
			textPos.y = iconPos.y + 1;
			statsInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_PER_00.png", "per icon");
			{
				auto textBase = statsInnerFrame->addField("per text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(statFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(5304));
				textBase->setColor(statTextColor);
				auto textStat = statsInnerFrame->addField("per text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(statFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("0");
				textStat->setColor(statTextColor);
				auto textStatModified = statsInnerFrame->addField("per text modified", 32);
				textStatModified->setVJustify(Field::justify_t::CENTER);
				textStatModified->setHJustify(Field::justify_t::CENTER);
				textStatModified->setFont(statFont);
				textPos.x = modifiedStatLeftX;
				textStatModified->setSize(textPos);
				textStatModified->setText("");
				textStatModified->setColor(statTextColor);

				auto statButton = statsInnerFrame->addButton("per button");
				statButton->setSize(SDL_Rect{ 12, iconPos.y + 2, statsFrame->getSize().w - 34, iconPos.h - 2 });
				statButton->setColor(makeColor(0, 0, 0, 0));
				statButton->setHighlightColor(makeColor(0, 0, 0, 0));
				statButton->setHideGlyphs(true);
				statButton->setHideKeyboardGlyphs(true);
				statButton->setHideSelectors(true);
				statButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				statButton->setTickCallback(charsheet_deselect_fn);
			}

			iconPos.y += iconPos.h + rowSpacing;
			textPos.y = iconPos.y + 1;
			statsInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_CHA_00.png", "chr icon");
			{
				auto textBase = statsInnerFrame->addField("chr text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(statFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(5305));
				textBase->setColor(statTextColor);
				auto textStat = statsInnerFrame->addField("chr text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(statFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("0");
				textStat->setColor(statTextColor);
				auto textStatModified = statsInnerFrame->addField("chr text modified", 32);
				textStatModified->setVJustify(Field::justify_t::CENTER);
				textStatModified->setHJustify(Field::justify_t::CENTER);
				textStatModified->setFont(statFont);
				textPos.x = modifiedStatLeftX;
				textStatModified->setSize(textPos);
				textStatModified->setText("");
				textStatModified->setColor(statTextColor);

				auto statButton = statsInnerFrame->addButton("chr button");
				statButton->setSize(SDL_Rect{ 12, iconPos.y + 2, statsFrame->getSize().w - 34, iconPos.h - 2 });
				statButton->setColor(makeColor(0, 0, 0, 0));
				statButton->setHighlightColor(makeColor(0, 0, 0, 0));
				statButton->setHideGlyphs(true);
				statButton->setHideKeyboardGlyphs(true);
				statButton->setHideSelectors(true);
				statButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				statButton->setTickCallback(charsheet_deselect_fn);
			}
		}

		{
			Frame* attributesFrame = sheetFrame->addFrame("attributes");
			attributesFrame->setSize(SDL_Rect{ leftAlignX, 550, bgWidth, 182 });

			attributesFrame->addImage(SDL_Rect{ 0, 0, attributesFrame->getSize().w, attributesFrame->getSize().h },
				0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_Window_01B_BotB.png", "attributes bg img");

			Frame* attributesInnerFrame = attributesFrame->addFrame("attributes inner frame");
			attributesInnerFrame->setSize(SDL_Rect{ 0, 0, attributesFrame->getSize().w, attributesFrame->getSize().h });

			SDL_Rect iconPos{ 20, 8, 24, 24 };
			const int headingLeftX = iconPos.x + iconPos.w + 4;
			const int baseStatLeftX = headingLeftX + 48;
			SDL_Rect textPos{ headingLeftX, iconPos.y, 80, iconPos.h };
			Uint32 statTextColor = hudColors.characterSheetNeutral;

			const char* attributeFont = "fonts/pixel_maz.ttf#32#2";
			textPos.y = iconPos.y + 1;
			attributesInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_ATT_00.png", "atk icon");
			{
				auto textBase = attributesInnerFrame->addField("atk text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(attributeFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(6093));
				textBase->setColor(statTextColor);
				auto textStat = attributesInnerFrame->addField("atk text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(attributeFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("14");
				textStat->setColor(statTextColor);

				auto attributeButton = attributesInnerFrame->addButton("atk button");
				attributeButton->setSize(SDL_Rect{ 12, iconPos.y + 2, attributesFrame->getSize().w - 34, iconPos.h - 2 });
				attributeButton->setColor(makeColor(0, 0, 0, 0));
				attributeButton->setHighlightColor(makeColor(0, 0, 0, 0));
				attributeButton->setHideGlyphs(true);
				attributeButton->setHideKeyboardGlyphs(true);
				attributeButton->setHideSelectors(true);
				attributeButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				attributeButton->setTickCallback(charsheet_deselect_fn);
			}

			const int rowSpacing = 4;
			iconPos.y += iconPos.h + rowSpacing;
			textPos.y = iconPos.y + 1;
			attributesInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_AC_00.png", "ac icon");
			{
				auto textBase = attributesInnerFrame->addField("ac text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(attributeFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(6094));
				textBase->setColor(statTextColor);
				auto textStat = attributesInnerFrame->addField("ac text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(attributeFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("3");
				textStat->setColor(statTextColor);

				auto attributeButton = attributesInnerFrame->addButton("ac button");
				attributeButton->setSize(SDL_Rect{ 12, iconPos.y + 2, attributesFrame->getSize().w - 34, iconPos.h - 2 });
				attributeButton->setColor(makeColor(0, 0, 0, 0));
				attributeButton->setHighlightColor(makeColor(0, 0, 0, 0));
				attributeButton->setHideGlyphs(true);
				attributeButton->setHideKeyboardGlyphs(true);
				attributeButton->setHideSelectors(true);
				attributeButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				attributeButton->setTickCallback(charsheet_deselect_fn);
			}

			iconPos.y += iconPos.h + rowSpacing;
			textPos.y = iconPos.y + 1;
			attributesInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_SPWR_00.png", "pwr icon");
			{
				auto textBase = attributesInnerFrame->addField("pwr text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(attributeFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(6095));
				textBase->setColor(statTextColor);
				auto textStat = attributesInnerFrame->addField("pwr text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(attributeFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("115%");
				textStat->setColor(statTextColor);

				auto attributeButton = attributesInnerFrame->addButton("pow button");
				attributeButton->setSize(SDL_Rect{ 12, iconPos.y + 2, attributesFrame->getSize().w - 34, iconPos.h - 2 });
				attributeButton->setColor(makeColor(0, 0, 0, 0));
				attributeButton->setHighlightColor(makeColor(0, 0, 0, 0));
				attributeButton->setHideGlyphs(true);
				attributeButton->setHideKeyboardGlyphs(true);
				attributeButton->setHideSelectors(true);
				attributeButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				attributeButton->setTickCallback(charsheet_deselect_fn);
			}

			iconPos.y += iconPos.h + rowSpacing;
			textPos.y = iconPos.y + 1;
			attributesInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_RES_00.png", "res icon");
			{
				auto textBase = attributesInnerFrame->addField("res text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(attributeFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(6096));
				textBase->setColor(statTextColor);
				auto textStat = attributesInnerFrame->addField("res text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(attributeFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("100%");
				textStat->setColor(statTextColor);

				auto attributeButton = attributesInnerFrame->addButton("res button");
				attributeButton->setSize(SDL_Rect{ 12, iconPos.y + 2, attributesFrame->getSize().w - 34, iconPos.h - 2 });
				attributeButton->setColor(makeColor(0, 0, 0, 0));
				attributeButton->setHighlightColor(makeColor(0, 0, 0, 0));
				attributeButton->setHideGlyphs(true);
				attributeButton->setHideKeyboardGlyphs(true);
				attributeButton->setHideSelectors(true);
				attributeButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				attributeButton->setTickCallback(charsheet_deselect_fn);
			}

			iconPos.y += iconPos.h + rowSpacing;
			textPos.y = iconPos.y + 1;
			attributesInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_REGEN_00.png", "regen icon");
			{
				auto textBase = attributesInnerFrame->addField("regen text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(attributeFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(6097));
				textBase->setColor(statTextColor);

				auto textDiv = attributesInnerFrame->addField("regen text divider", 4);
				textDiv->setVJustify(Field::justify_t::CENTER);
				textDiv->setHJustify(Field::justify_t::CENTER);
				textDiv->setFont(attributeFont);
				textPos.x = baseStatLeftX + 0;
				textDiv->setSize(textPos);
				textDiv->setText(" ");
				textDiv->setColor(statTextColor);

				SDL_Rect hpmpTextPos = textPos;
				const int middleX = (textPos.x + textPos.w / 2);
				auto textRegenHP = attributesInnerFrame->addField("regen text hp", 16);
				textRegenHP->setVJustify(Field::justify_t::CENTER);
				textRegenHP->setHJustify(Field::justify_t::RIGHT);
				textRegenHP->setFont(attributeFont);
				hpmpTextPos.x = middleX - 4 - hpmpTextPos.w;
				textRegenHP->setSize(hpmpTextPos);
				textRegenHP->setText("0.2");
				textRegenHP->setColor(statTextColor);

				auto textRegenMP = attributesInnerFrame->addField("regen text mp", 16);
				textRegenMP->setVJustify(Field::justify_t::CENTER);
				textRegenMP->setHJustify(Field::justify_t::LEFT);
				textRegenMP->setFont(attributeFont);
				hpmpTextPos.x = middleX + 4;
				textRegenMP->setSize(hpmpTextPos);
				textRegenMP->setText("0.1");
				textRegenMP->setColor(statTextColor);

				auto attributeButton = attributesInnerFrame->addButton("rgn button");
				const int fullWidth = attributesFrame->getSize().w - 34 + 12;
				attributeButton->setSize(SDL_Rect{ 12, iconPos.y + 2, attributesFrame->getSize().w - 34 - 50, iconPos.h - 2 });
				attributeButton->setColor(makeColor(0, 0, 0, 0));
				attributeButton->setHighlightColor(makeColor(0, 0, 0, 0));
				attributeButton->setHideGlyphs(true);
				attributeButton->setHideKeyboardGlyphs(true);
				attributeButton->setHideSelectors(true);
				attributeButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				attributeButton->setTickCallback(charsheet_deselect_fn);

				auto attributeButton2 = attributesInnerFrame->addButton("rgn mp button");
				attributeButton2->setSize(SDL_Rect{ attributeButton->getSize().x + attributeButton->getSize().w,
					iconPos.y + 2, fullWidth - (attributeButton->getSize().x + attributeButton->getSize().w), iconPos.h - 2 });
				attributeButton2->setColor(makeColor(0, 0, 0, 0));
				attributeButton2->setHighlightColor(makeColor(0, 0, 0, 0));
				attributeButton2->setHideGlyphs(true);
				attributeButton2->setHideKeyboardGlyphs(true);
				attributeButton2->setHideSelectors(true);
				attributeButton2->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				attributeButton2->setTickCallback(charsheet_deselect_fn);
			}

			iconPos.y += iconPos.h + rowSpacing;
			textPos.y = iconPos.y + 1;
			attributesInnerFrame->addImage(iconPos, 0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_WGT_00.png", "weight icon");
			{
				auto textBase = attributesInnerFrame->addField("weight text title", 8);
				textBase->setVJustify(Field::justify_t::CENTER);
				textBase->setFont(attributeFont);
				textPos.x = headingLeftX;
				textBase->setSize(textPos);
				textBase->setText(Language::get(6098));
				textBase->setColor(statTextColor);
				auto textStat = attributesInnerFrame->addField("weight text stat", 32);
				textStat->setVJustify(Field::justify_t::CENTER);
				textStat->setHJustify(Field::justify_t::CENTER);
				textStat->setFont(attributeFont);
				textPos.x = baseStatLeftX;
				textStat->setSize(textPos);
				textStat->setText("120");
				textStat->setColor(statTextColor);

				auto attributeButton = attributesInnerFrame->addButton("wgt button");
				attributeButton->setSize(SDL_Rect{ 12, iconPos.y + 2, attributesFrame->getSize().w - 34, iconPos.h - 2 });
				attributeButton->setColor(makeColor(0, 0, 0, 0));
				attributeButton->setHighlightColor(makeColor(0, 0, 0, 0));
				attributeButton->setHideGlyphs(true);
				attributeButton->setHideKeyboardGlyphs(true);
				attributeButton->setHideSelectors(true);
				attributeButton->setMenuConfirmControlType(Widget::MENU_CONFIRM_CONTROLLER);
				attributeButton->setTickCallback(charsheet_deselect_fn);
			}
		}

		{
			auto tooltipFrame = sheetFrame->addFrame("sheet tooltip");
			tooltipFrame->setSize(SDL_Rect{ leftAlignX - 200, 0, 200, 200 });
			tooltipFrame->setHollow(true);
			tooltipFrame->setInheritParentFrameOpacity(false);
			tooltipFrame->setDisabled(true);
			Uint32 color = makeColor(255, 255, 255, 255);
			tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TL_00.png", skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
			tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TR_00.png", skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
			tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_T_00.png", skillsheetEffectBackgroundImages[TOP].c_str());
			tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_L_00.png", skillsheetEffectBackgroundImages[MIDDLE_LEFT].c_str());
			tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_R_00.png", skillsheetEffectBackgroundImages[MIDDLE_RIGHT].c_str());
			tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				makeColor(22, 24, 29, 255), "images/system/white.png", skillsheetEffectBackgroundImages[MIDDLE].c_str());
			tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_BL_00.png", skillsheetEffectBackgroundImages[BOTTOM_LEFT].c_str());
			tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_BR_00.png", skillsheetEffectBackgroundImages[BOTTOM_RIGHT].c_str());
			tooltipFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_B_00.png", skillsheetEffectBackgroundImages[BOTTOM].c_str());
			imageSetWidthHeight9x9(tooltipFrame, skillsheetEffectBackgroundImages);
			imageResizeToContainer9x9(tooltipFrame, SDL_Rect{ 0, 0, 200, 200 }, skillsheetEffectBackgroundImages);
			auto txt = tooltipFrame->addField("tooltip text", 1024);
			auto txtRightAlignHint = tooltipFrame->addField("tooltip text right align hint", 128);
			const char* tooltipFont = "fonts/pixel_maz_multiline.ttf#16#2";
			txt->setFont(tooltipFont);
			txt->setColor(makeColor(188, 154, 114, 255));
			txtRightAlignHint->setFont(tooltipFont);
			txtRightAlignHint->setColor(hudColors.characterSheetFaintText);
			auto glyph1 = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "images/system/white.png", "glyph 1");
			glyph1->disabled = true;
			auto glyph2 = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "images/system/white.png", "glyph 2");
			glyph2->disabled = true;
			auto glyph3 = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "images/system/white.png", "glyph 3");
			glyph3->disabled = true;
			auto glyph4 = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "images/system/white.png", "glyph 4");
			glyph4->disabled = true;

			for ( int i = 1; i <= NUM_CHARSHEET_TOOLTIP_TEXT_FIELDS; ++i )
			{
				char txtEntryFieldName[64] = "";
				snprintf(txtEntryFieldName, sizeof(txtEntryFieldName), "txt %d", i);
				auto txtEntry = tooltipFrame->addField(txtEntryFieldName, 1024);
				txtEntry->setFont(tooltipFont);
				txtEntry->setDisabled(true);
				txtEntry->setVJustify(Field::justify_t::CENTER);
				txtEntry->setColor(makeColor(188, 154, 114, 255));
				txtEntry->setOntop(true);

				characterSheetTooltipTextFields[player.playernum][i] = txtEntry;
			}

			auto div = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 1 },
				makeColor(49, 53, 61, 255),
				"images/system/white.png", "tooltip divider 1");
			div->disabled = true;
			div = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 1 },
				makeColor(49, 53, 61, 255),
				"images/system/white.png", "tooltip divider 2");
			div->disabled = true;


			for ( int i = 1; i <= NUM_CHARSHEET_TOOLTIP_BACKING_FRAMES; ++i )
			{
				char backingFrameName[64] = "";
				snprintf(backingFrameName, sizeof(backingFrameName), "txt value backing frame %d", i);
				auto txtValueBackingFrame = tooltipFrame->addFrame(backingFrameName);
				txtValueBackingFrame->setSize(SDL_Rect{ 0, 0, tooltipFrame->getSize().w, tooltipFrame->getSize().h });
				txtValueBackingFrame->setDisabled(true);
				Uint32 color = makeColor(51, 33, 26, 255);
				txtValueBackingFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_TL00.png", skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
				txtValueBackingFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_TR00.png", skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
				txtValueBackingFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_T00.png", skillsheetEffectBackgroundImages[TOP].c_str());
				txtValueBackingFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_L00.png", skillsheetEffectBackgroundImages[MIDDLE_LEFT].c_str());
				txtValueBackingFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_R00.png", skillsheetEffectBackgroundImages[MIDDLE_RIGHT].c_str());
				txtValueBackingFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_M00.png", skillsheetEffectBackgroundImages[MIDDLE].c_str());
				txtValueBackingFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_BL00.png", skillsheetEffectBackgroundImages[BOTTOM_LEFT].c_str());
				txtValueBackingFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_BR00.png", skillsheetEffectBackgroundImages[BOTTOM_RIGHT].c_str());
				txtValueBackingFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_B00.png", skillsheetEffectBackgroundImages[BOTTOM].c_str());
				imageSetWidthHeight9x9(txtValueBackingFrame, skillsheetEffectBackgroundImages);

				characterSheetTooltipTextBackingFrames[player.playernum][i] = txtValueBackingFrame;
			}

			{
				auto raceTooltip = tooltipFrame->addFrame("sheet race tooltip");
				raceTooltip->setSize(SDL_Rect{ 0, 24, 324, 664 });
				raceTooltip->setDisabled(true);
				raceTooltip->setHollow(true);
				const auto font = smallfont_outline;

				auto details_text = raceTooltip->addField("details", 1024);
				details_text->setFont(font);
				details_text->setSize(SDL_Rect{ 0, 0, 242, 300 });
				details_text->setColor(hudColors.characterSheetOffWhiteText);

				auto details_text_right = raceTooltip->addField("details_right", 1024);
				details_text_right->setFont(font);
				details_text_right->setSize(SDL_Rect{ 121, 0, 121, 300 });
				details_text_right->setColor(hudColors.characterSheetOffWhiteText);

				MainMenu::RaceDescriptions::update_details_text(*raceTooltip, stats[player.playernum]);
			}

			{
				auto classTooltip = tooltipFrame->addFrame("sheet class tooltip");
				classTooltip->setDisabled(true);
				classTooltip->setHollow(true);
				auto statGrowths = classTooltip->addFrame("stat growths");
				// stats definitions
				const char* class_stats_text[] = {
					ItemTooltips.getItemStatShortName("STR").c_str(), 
					ItemTooltips.getItemStatShortName("DEX").c_str(),
					ItemTooltips.getItemStatShortName("CON").c_str(),
					ItemTooltips.getItemStatShortName("INT").c_str(),
					ItemTooltips.getItemStatShortName("PER").c_str(),
					ItemTooltips.getItemStatShortName("CHR").c_str()
				};
				constexpr int num_class_stats = sizeof(class_stats_text) / sizeof(class_stats_text[0]);
				constexpr SDL_Rect bottom{ 0, 0, 236, 30 };
				constexpr int column = bottom.w / num_class_stats;

				classTooltip->setSize(SDL_Rect{ 0, 0, bottom.w, bottom.h });
				statGrowths->setSize(bottom);

				for ( int c = 0; c < num_class_stats; ++c ) 
				{
					char buf[16];
					snprintf(buf, sizeof(buf), "%d", c);
					auto class_stat = statGrowths->addField(buf, 16);
					class_stat->setSize(SDL_Rect{
						bottom.x + column * c, bottom.y, column, bottom.h });
					class_stat->setHJustify(Field::justify_t::CENTER);
					class_stat->setVJustify(Field::justify_t::TOP);
					class_stat->setFont(smallfont_outline);
					class_stat->setText(class_stats_text[c]);
					//class_stat->setTickCallback([](Widget& widget) {class_stat_fn(*static_cast<Field*>(&widget), widget.getOwner()); });

					SDL_Rect imgPos = class_stat->getSize();
					imgPos.x += imgPos.w / 2;
					imgPos.w = 14;
					imgPos.x -= imgPos.w / 2;
					imgPos.h = 16;
					imgPos.y -= imgPos.h - 4;

					char buf2[32];
					/*snprintf(buf2, sizeof(buf2), "stat img top %d", c);
					auto class_stat_img_top = statGrowths->addImage(imgPos, 0xFFFFFFFF,
						"*#images/ui/Main Menus/Play/PlayerCreation/ClassSelection/statgrowth_hi2.png", buf2);
					class_stat_img_top->disabled = true;*/
					snprintf(buf2, sizeof(buf2), "stat img bottom %d", c);
					imgPos.y = class_stat->getSize().y + 17;
					auto class_stat_img_bottom = statGrowths->addImage(imgPos, 0xFFFFFFFF,
						"*#images/ui/Main Menus/Play/PlayerCreation/ClassSelection/statgrowth_lo2.png", buf2);
					class_stat_img_bottom->disabled = true;
				}
			}
		}
	}
}

void Player::GUIDropdown_t::activateSelection(const std::string& name, const int option)
{
	auto& dropdown = allDropDowns[name];
	if ( dropdown.options[option].action == "no_action" )
	{
		messagePlayer(player.playernum, MESSAGE_DEBUG, "[Dropdowns]: Warning, no action for %s : option %d", name.c_str(), option);
	}
	else
	{
		if ( dropdown.options[option].action == "gold_drop_10" )
		{
			char dropCommand[32] = "";
			snprintf(dropCommand, sizeof(dropCommand), "/dropgold %d %d", player.playernum, 10);
			consoleCommand(dropCommand);
		}
		else if ( dropdown.options[option].action == "gold_drop_100" )
		{
			char dropCommand[32] = "";
			snprintf(dropCommand, sizeof(dropCommand), "/dropgold %d %d", player.playernum, 100);
			consoleCommand(dropCommand);
		}
		else if ( dropdown.options[option].action == "gold_drop_1000" )
		{
			char dropCommand[32] = "";
			snprintf(dropCommand, sizeof(dropCommand), "/dropgold %d %d", player.playernum, 1000);
			consoleCommand(dropCommand);
		}
		else if ( dropdown.options[option].action == "gold_drop_all" )
		{
			char dropCommand[32] = "";
			snprintf(dropCommand, sizeof(dropCommand), "/dropgold %d %d", player.playernum, std::max(0, stats[player.playernum]->GOLD));
			consoleCommand(dropCommand);
		}
		else if ( dropdown.options[option].action == "view_status_effects" )
		{
			if ( /*StatusEffectQueue[player.playernum].effectQueue.size() > 0*/ true )
			{
				player.GUI.previousModule = players[player.playernum]->GUI.activeModule;
				if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor )
				{
					player.GUI.activateModule(Player::GUI_t::MODULE_STATUS_EFFECTS);
				}
				else
				{
					player.GUI.activateModule(Player::GUI_t::MODULE_NONE);
				}
				StatusEffectQueue[player.playernum].selectedElement = 0;
				player.hud.statusFxFocusedWindowActive = true;
			}
		}
		else if ( dropdown.options[option].action == "view_portrait" )
		{
			if ( playerInventoryFrames[player.playernum].characterPreview )
			{
				player.GUI.previousModule = players[player.playernum]->GUI.activeModule;
				player.GUI.activateModule(Player::GUI_t::MODULE_PORTRAIT);

				SDL_Rect size = playerInventoryFrames[player.playernum].characterPreview->getAbsoluteSize();

				// make sure to adjust absolute size to camera viewport
				const int offsetX = 4;
				const int offsetY = 6;
				size.x += offsetX;
				size.y += offsetY;
				size.w -= offsetX * 2;
				size.h -= offsetY * 2;
				size.x -= player.camera_virtualx1();
				size.y -= player.camera_virtualy1();

				player.hud.updateCursorAnimation(size.x - 1, size.y - 1,
					size.w, size.h, inputs.getVirtualMouse(player.playernum)->draw_cursor);
				player.paperDoll.portraitActiveToEdit = true;
			}
		}
		else if ( dropdown.options[option].action == "inventory_autosort" )
		{
			autosortInventory(player.playernum);
			//quickStackItems();
			//playSound(139, 64);
		}
		messagePlayer(player.playernum, MESSAGE_DEBUG, "[Dropdowns]: Executing action '%s' for [%s] : option %d",
			dropdown.options[option].action.c_str(), name.c_str(), option);
	}
}

bool Player::GUIDropdown_t::getDropDownAlignRight(const std::string& name)
{
	bool invert = false;
	if ( name == "drop_gold" )
	{
		if ( player.characterSheet.panelJustify == Player::PANEL_JUSTIFY_RIGHT 
			&& (player.bUseCompactGUIHeight() || player.bUseCompactGUIWidth()) )
		{
			invert = true;
		}
	}
	else if ( name == "chest_interact" )
	{
		if ( player.inventoryUI.bCompactView )
		{
			if ( player.inventoryUI.inventoryPanelJustify != PanelJustify_t::PANEL_JUSTIFY_RIGHT )
			{
				invert = true;
			}
		}
	}
	else if ( name == "paper_doll" )
	{
		if ( player.inventoryUI.bCompactView )
		{
			if ( player.inventoryUI.paperDollPanelJustify == PanelJustify_t::PANEL_JUSTIFY_RIGHT )
			{
				invert = true;
			}
		}
	}
	else if ( name == "item_interact" || name == "spell_interact" )
	{
		if ( player.inventoryUI.bCompactView )
		{
			Item* item = uidToItem(dropDownItem);
			if ( item && player.paperDoll.isItemOnDoll(*item) )
			{
				if ( player.inventoryUI.paperDollPanelJustify == PanelJustify_t::PANEL_JUSTIFY_RIGHT )
				{
					invert = true;
				}
			}
			else if ( item && itemCategory(item) == SPELL_CAT )
			{
				if ( player.inventoryUI.spellPanel.panelJustify == PanelJustify_t::PANEL_JUSTIFY_RIGHT )
				{
					invert = true;
				}
			}
			else
			{
				// normal inventory items
				if ( player.inventoryUI.inventoryPanelJustify == PanelJustify_t::PANEL_JUSTIFY_RIGHT )
				{
					invert = true;
				}
			}
		}
	}
	return (invert ? !allDropDowns[name].alignRight : allDropDowns[name].alignRight);
}

void Player::CharacterSheet_t::processCharacterSheet()
{
	if ( !sheetFrame )
	{
		createCharacterSheet();
	}

	sheetFrame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
		players[player.playernum]->camera_virtualy1(),
		players[player.playernum]->camera_virtualWidth(),
		players[player.playernum]->camera_virtualHeight() });

	if ( !stats[player.playernum] || !players[player.playernum]->isLocalPlayer() )
	{
		sheetFrame->setDisabled(true);
		queuedElement = SHEET_UNSELECTED;
		return;
	}

	bool bCompactView = false;
	if ( (keystatus[SDLK_u] && enableDebugKeys) || player.bUseCompactGUIHeight() || player.bUseCompactGUIWidth() )
	{
		bCompactView = true;
	}

	bool hideAndExit = false;
	if ( nohud || player.shootmode || !(player.gui_mode == GUI_MODE_INVENTORY || player.gui_mode == GUI_MODE_SHOP) )
	{
		hideAndExit = true;
	}
	else if ( bCompactView && player.hud.compactLayoutMode != Player::HUD_t::COMPACT_LAYOUT_CHARSHEET )
	{
		hideAndExit = true;
	}

	sheetFrame->setDisabled(false);

	if ( bCompactView )
	{
		// justify opposite of inventory
		panelJustify = (player.inventoryUI.inventoryPanelJustify == Player::PANEL_JUSTIFY_LEFT) 
			? Player::PANEL_JUSTIFY_RIGHT : Player::PANEL_JUSTIFY_LEFT;
	}
	else
	{
		panelJustify = Player::PANEL_JUSTIFY_RIGHT;
	}

	if ( player.inventoryUI.slideOutPercent <= .0001 )
	{
		isInteractable = !hideAndExit;
		if ( isInteractable && queuedElement != SHEET_UNSELECTED )
		{
			const bool updateCursor = true;
			const bool usingMouse = false;
			selectElement(queuedElement, usingMouse, updateCursor);
			queuedElement = SHEET_UNSELECTED;
		}
	}
	else
	{
		isInteractable = false;
	}

	// resize elements for splitscreen
	{
		auto characterInfoFrame = sheetFrame->findFrame("character info");
		const int bgWidth = 208;
		const int leftAlignX = sheetFrame->getSize().w - bgWidth + player.inventoryUI.slideOutPercent * player.inventoryUI.slideOutWidth;
		int compactAlignX1 = -player.inventoryUI.slideOutPercent * player.inventoryUI.slideOutWidth;
		int compactAlignX2 = sheetFrame->getSize().w + player.inventoryUI.slideOutPercent * player.inventoryUI.slideOutWidth;
		auto compactImgBg = sheetFrame->findImage("character info compact img");
		Frame* dungeonFloorFrame = sheetFrame->findFrame("dungeon floor frame");
		Frame* buttonFrame = sheetFrame->findFrame("log map buttons");
		Frame* fullscreenBg = sheetFrame->findFrame("sheet bg fullscreen");
		Frame* timerFrame = sheetFrame->findFrame("game timer");
		Frame* skillsButtonFrame = sheetFrame->findFrame("skills button frame");
		Frame* characterInnerFrame = characterInfoFrame->findFrame("character info inner frame");

		auto statsFrame = sheetFrame->findFrame("stats");
		auto attributesFrame = sheetFrame->findFrame("attributes");

		if ( bCompactView )
		{
			// compact view
			sheetDisplayType = CHARSHEET_DISPLAY_COMPACT;

			compactImgBg->disabled = false;
			compactImgBg->pos.x = (panelJustify == PANEL_JUSTIFY_RIGHT ? compactAlignX1 : compactAlignX2 - compactImgBg->pos.w);
			compactImgBg->pos.y = 0;

			SDL_Rect pos = characterInfoFrame->getSize();
			pos.x = (panelJustify == PANEL_JUSTIFY_RIGHT ? compactAlignX1 : compactAlignX2 - pos.w);
			pos.y = compactImgBg->pos.y + 60;
			characterInfoFrame->setSize(pos);

			SDL_Rect dungeonFloorFramePos = dungeonFloorFrame->getSize();
			dungeonFloorFramePos.x = pos.x + (panelJustify == PANEL_JUSTIFY_RIGHT ? 6 : 0);
			dungeonFloorFramePos.y = pos.y - 56;
			dungeonFloorFrame->setSize(dungeonFloorFramePos);

			SDL_Rect characterInnerFramePos = characterInnerFrame->getSize();
			characterInnerFramePos.x = (panelJustify == PANEL_JUSTIFY_RIGHT ? 6 : 0);
			characterInnerFrame->setSize(characterInnerFramePos);

			SDL_Rect buttonFramePos = buttonFrame->getSize();
			buttonFramePos.w = 198;
			buttonFramePos.h = 40;
			buttonFramePos.x = (panelJustify == PANEL_JUSTIFY_RIGHT ? compactAlignX1 + 8 : compactAlignX2 - buttonFramePos.w - 8);
			buttonFramePos.y = compactImgBg->pos.y + compactImgBg->pos.h + 1;
			buttonFrame->setSize(buttonFramePos);

			{
				SDL_Rect buttonPos{ 0, 1, 98, 38 };
				auto mapBtn = buttonFrame->findButton("map button");
				mapBtn->setText(Language::get(4071));
				mapBtn->setSize(buttonPos);
				auto mapSelector = buttonFrame->findFrame("map button selector");
				SDL_Rect mapSelectorPos = buttonPos;
				mapSelectorPos.x += 6;
				mapSelectorPos.w -= 12;
				mapSelectorPos.y += 4;
				mapSelectorPos.h -= 8;
				mapSelector->setSize(mapSelectorPos);

				buttonPos.x = buttonFramePos.w - buttonPos.w;
				auto logBtn = buttonFrame->findButton("log button");
				logBtn->setText(Language::get(4072));
				logBtn->setSize(buttonPos);
				auto logSelector = buttonFrame->findFrame("log button selector");
				SDL_Rect logSelectorPos = buttonPos;
				logSelectorPos.x += 6;
				logSelectorPos.w -= 12;
				logSelectorPos.y += 4;
				logSelectorPos.h -= 10;
				logSelector->setSize(logSelectorPos);
			}

			fullscreenBg->setDisabled(true);

			auto statsPos = statsFrame->getSize();
			statsPos.x = (panelJustify == PANEL_JUSTIFY_RIGHT ? compactAlignX2 - statsPos.w : compactAlignX1);
			statsPos.y = 0;
			statsFrame->setSize(statsPos);

			auto attributesPos = attributesFrame->getSize();
			attributesPos.x = (panelJustify == PANEL_JUSTIFY_RIGHT ? compactAlignX2 - attributesPos.w : compactAlignX1);
			attributesPos.y = statsPos.y + statsPos.h - 4; // 4 pixels above bottom edge of stats pane
			attributesFrame->setSize(attributesPos);
		}
		else
		{
			// standard view
			sheetDisplayType = CHARSHEET_DISPLAY_NORMAL;

			SDL_Rect pos = characterInfoFrame->getSize();
			pos.x = leftAlignX;
			pos.y = 206;
			characterInfoFrame->setSize(pos);

			SDL_Rect dungeonFloorFramePos = dungeonFloorFrame->getSize();
			dungeonFloorFramePos.x = pos.x + 6;
			dungeonFloorFramePos.y = pos.y - 88;
			dungeonFloorFrame->setSize(dungeonFloorFramePos);

			SDL_Rect characterInnerFramePos = characterInnerFrame->getSize();
			characterInnerFramePos.x = (panelJustify == PANEL_JUSTIFY_RIGHT ? 6 : 0);
			characterInnerFrame->setSize(characterInnerFramePos);

			SDL_Rect buttonFramePos = buttonFrame->getSize();
			buttonFramePos.x = leftAlignX + 9;
			buttonFramePos.y = 6;
			buttonFramePos.w = 196;
			buttonFramePos.h = 82;
			buttonFrame->setSize(buttonFramePos);
			{
				SDL_Rect buttonPos{ 0, 0, buttonFramePos.w, 40 };
				auto mapBtn = buttonFrame->findButton("map button");
				mapBtn->setText(Language::get(4069));
				mapBtn->setSize(buttonPos);
				auto mapSelector = buttonFrame->findFrame("map button selector");
				mapSelector->setSize(buttonPos);

				buttonPos.y = buttonPos.y + buttonPos.h + 2;
				auto logBtn = buttonFrame->findButton("log button");
				logBtn->setText(Language::get(4070));
				logBtn->setSize(buttonPos);
				auto logSelector = buttonFrame->findFrame("log button selector");
				logSelector->setSize(buttonPos);
			}

			SDL_Rect timerFramePos = timerFrame->getSize();
			timerFramePos.x = leftAlignX + 36;
			timerFrame->setSize(timerFramePos);

			SDL_Rect skillsButtonFramePos = skillsButtonFrame->getSize();
			skillsButtonFramePos.x = leftAlignX + 14;
			skillsButtonFrame->setSize(skillsButtonFramePos);

			fullscreenBg->setDisabled(false);
			SDL_Rect fullscreenBgPos = fullscreenBg->getSize();
			fullscreenBgPos.x = sheetFrame->getSize().w - fullscreenBgPos.w + player.inventoryUI.slideOutPercent * player.inventoryUI.slideOutWidth;
			fullscreenBg->setSize(fullscreenBgPos);
			compactImgBg->disabled = true;

			Frame::image_t* fullscreenBgImg = fullscreenBg->findImage("bg image");

			auto statsPos = statsFrame->getSize();
			statsPos.x = sheetFrame->getSize().w - statsPos.w + player.inventoryUI.slideOutPercent * player.inventoryUI.slideOutWidth;
			statsPos.y = fullscreenBgImg->pos.y + fullscreenBgImg->pos.h;
			statsFrame->setSize(statsPos);

			auto attributesPos = attributesFrame->getSize();
			attributesPos.x = sheetFrame->getSize().w - attributesPos.w + player.inventoryUI.slideOutPercent * player.inventoryUI.slideOutWidth;
			attributesPos.y = statsPos.y + statsPos.h - 4; // 4 px overlap attributes pane
			attributesFrame->setSize(attributesPos);

		}
	}

	updateCharacterSheetTooltip(SHEET_UNSELECTED, SDL_Rect{ 0, 0, 0, 0 }); // to reset the tooltip from displaying.
	if ( hideAndExit )
	{
		queuedElement = SHEET_UNSELECTED;
		sheetFrame->setDisabled(true);
		return;
	}

	player.GUI.handleCharacterSheetMovement();

	{
		auto characterInfoFrame = sheetFrame->findFrame("character info");
		assert(characterInfoFrame);
		auto characterInnerFrame = characterInfoFrame->findFrame("character info inner frame");
		assert(characterInnerFrame);
		auto statsFrame = sheetFrame->findFrame("stats");
		assert(statsFrame);
		auto statsInnerFrame = statsFrame->findFrame("stats inner frame");
		assert(statsInnerFrame);
		auto attributesFrame = sheetFrame->findFrame("attributes");
		assert(attributesFrame);
		auto attributesInnerFrame = attributesFrame->findFrame("attributes inner frame");
		assert(attributesInnerFrame);
		SheetElements targetElement = SHEET_ENUM_END;
		auto logButton = sheetFrame->findFrame("log map buttons")->findButton("log button");
		auto mapButton = sheetFrame->findFrame("log map buttons")->findButton("map button");
		auto skillsButton = sheetFrame->findFrame("skills button frame")->findButton("skills button");
		Button* strButton = statsInnerFrame->findButton("str button");
		Button* dexButton = statsInnerFrame->findButton("dex button");
		Button* conButton = statsInnerFrame->findButton("con button");
		Button* intButton = statsInnerFrame->findButton("int button");
		Button* perButton = statsInnerFrame->findButton("per button");
		Button* chrButton = statsInnerFrame->findButton("chr button");
		Button* atkButton = attributesInnerFrame->findButton("atk button");
		Button* acButton = attributesInnerFrame->findButton("ac button");
		Button* powButton = attributesInnerFrame->findButton("pow button");
		Button* resButton = attributesInnerFrame->findButton("res button");
		Button* rgnButton = attributesInnerFrame->findButton("rgn button");
		Button* rgnMpButton = attributesInnerFrame->findButton("rgn mp button");
		Button* wgtButton = attributesInnerFrame->findButton("wgt button");

		auto sheetTimer = sheetFrame->findFrame("game timer");
		if ( bCompactView )
		{
			sheetTimer->setDisabled(true);
		}
		else
		{
			sheetTimer->setDisabled(false);
		}

		bool mouseHighlightActive = inputs.getVirtualMouse(player.playernum)->draw_cursor
			&& (!player.GUI.isDropdownActive())
			&& isInteractable;

		if ( player.bUseCompactGUIWidth()
			&& (player.minimap.mapWindow || player.messageZone.logWindow) )
		{
			mouseHighlightActive = false;
		}

		if ( mouseHighlightActive )
		{
			if ( skillsButton->isHighlighted() )
			{
				targetElement = SHEET_SKILL_LIST;
			}
			else if ( logButton->isHighlighted() )
			{
				targetElement = SHEET_OPEN_LOG;
			}
			else if ( mapButton->isHighlighted() )
			{
				targetElement = SHEET_OPEN_MAP;
			}
			else if ( !sheetTimer->isDisabled() && sheetTimer->findButton("timer selector")->isHighlighted() )
			{
				targetElement = SHEET_TIMER;
			}
			else if ( sheetFrame->findFrame("dungeon floor frame")->findButton("dungeon floor selector")->isHighlighted() )
			{
				targetElement = SHEET_DUNGEON_FLOOR;
			}
			else if ( characterInnerFrame->findButton("character class selector")->isHighlighted() )
			{
				targetElement = SHEET_CHAR_CLASS;
			}
			else if ( characterInnerFrame->findButton("character race selector")->isHighlighted() )
			{
				targetElement = SHEET_CHAR_RACE_SEX;
			}
			else if ( characterInnerFrame->findButton("character gold selector")->isHighlighted() )
			{
				targetElement = SHEET_GOLD;
			}
			else if ( strButton->isHighlighted() )
			{
				targetElement = SHEET_STR;
			}
			else if ( dexButton->isHighlighted() )
			{
				targetElement = SHEET_DEX;
			}
			else if ( conButton->isHighlighted() )
			{
				targetElement = SHEET_CON;
			}
			else if ( intButton->isHighlighted() )
			{
				targetElement = SHEET_INT;
			}
			else if ( perButton->isHighlighted() )
			{
				targetElement = SHEET_PER;
			}
			else if ( chrButton->isHighlighted() )
			{
				targetElement = SHEET_CHR;
			}
			else if ( atkButton->isHighlighted() )
			{
				targetElement = SHEET_ATK;
			}
			else if ( acButton->isHighlighted() )
			{
				targetElement = SHEET_AC;
			}
			else if ( powButton->isHighlighted() )
			{
				targetElement = SHEET_POW;
			}
			else if ( resButton->isHighlighted() )
			{
				targetElement = SHEET_RES;
			}
			else if ( rgnButton->isHighlighted() )
			{
				targetElement = SHEET_RGN;
			}
			else if ( rgnMpButton->isHighlighted() )
			{
				targetElement = SHEET_RGN_MP;
			}
			else if ( wgtButton->isHighlighted() )
			{
				targetElement = SHEET_WGT;
			}
		}
		if ( targetElement != SHEET_ENUM_END )
		{
			player.GUI.activateModule(Player::GUI_t::MODULE_CHARACTERSHEET);
			selectElement(targetElement, true, true);
		}
		else
		{
			if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
			{
				if ( player.GUI.activeModule == Player::GUI_t::MODULE_CHARACTERSHEET
					&& !player.GUI.isDropdownActive() && !player.GUI.dropdownMenu.bClosedThisTick )
				{
					// no moused over objects, deactivate the cursor.
					player.GUI.activateModule(Player::GUI_t::MODULE_NONE);
				}
			}
		}
		//messagePlayer(0, "%d", player.GUI.activeModule);
		// players[player.playernum]->GUI.warpControllerToModule(false); - use this for controller input
	}

	updateGameTimer();
	updateStats();
	updateAttributes();
	updateCharacterInfo();
}

std::map<std::string, Player::GUIDropdown_t::DropDown_t> Player::GUIDropdown_t::allDropDowns;

bool Player::GUIDropdown_t::set(const std::string name)
{
	if ( allDropDowns.find(name) == allDropDowns.end() )
	{
		printlog("[Dropdown]: Could not find dropdown name %s", name.c_str());
		return false;
	}

	if ( currentName != name )
	{
		create(name);
	}
	currentName = name;
	return true;
}

void Player::GUIDropdown_t::process()
{
	bClosedThisTick = false;
	if ( dropdownBlockClickFrame )
	{
		dropdownBlockClickFrame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
			players[player.playernum]->camera_virtualy1(),
			players[player.playernum]->camera_virtualWidth(),
			players[player.playernum]->camera_virtualHeight() });
	}
	if ( !dropdownFrame ) { return; }
	
	if ( !bOpen )
	{
		dropdownFrame->setDisabled(true);
		dropDownOptionSelected = -1;
		dropDownItem = 0;
		dropDownX = 0;
		dropDownY = 0;
		dropDownToggleClick = false;
		return;
	}
	else
	{
		dropdownFrame->setDisabled(false);
	}

	auto highlightImageMid = dropdownFrame->findImage("interact selected highlight mid");
	highlightImageMid->disabled = true;
	highlightImageMid->color = hudColors.itemContextMenuOptionSelectedImg;
	auto highlightImageLeft = dropdownFrame->findImage("interact selected highlight left");
	highlightImageLeft->disabled = true;
	highlightImageLeft->color = hudColors.itemContextMenuOptionSelectedImg;
	auto highlightImageRight = dropdownFrame->findImage("interact selected highlight right");
	highlightImageRight->disabled = true;
	highlightImageRight->color = hudColors.itemContextMenuOptionSelectedImg;

	size_t index = 0;
	unsigned int maxWidth = 0;
	if ( auto interactText = dropdownFrame->findField("interact text") )
	{
		interactText->setColor(hudColors.itemContextMenuHeadingText);
		if ( auto textGet = Text::get(interactText->getText(), interactText->getFont(),
			interactText->getTextColor(), interactText->getOutlineColor()) )
		{
			maxWidth = textGet->getWidth();
		}
	}
	int maxHeight = 0;
	const int textPaddingX = 8;

	auto dropDown = allDropDowns[currentName];
	std::vector<ItemContextMenuPrompts> contextOptions;
	Item* item = uidToItem(dropDownItem);
	if ( currentName == "chest_interact" )
	{
		list_t* chest_inventory = nullptr;
		if ( openedChest[player.playernum] )
		{
			if ( multiplayer == CLIENT )
			{
				chest_inventory = &chestInv[player.playernum];
			}
			else if ( openedChest[player.playernum]->children.first && openedChest[player.playernum]->children.first->element )
			{
				chest_inventory = (list_t*)openedChest[player.playernum]->children.first->element;
			}
		}

		if ( chest_inventory )
		{
			for ( node_t* node = chest_inventory->first; node != NULL; node = node->next )
			{
				Item* chestItem = (Item*)node->element;
				if ( !chestItem )
				{
					continue;
				}
				if ( chestItem->uid == dropDownItem )
				{
					item = chestItem;
					break;
				}
			}
		}
	}

	if ( dropDownItem != 0 && !item )
	{
		close();
		return;
	}
	if ( currentName == "item_interact" || currentName == "hotbar_interact" 
		|| currentName == "chest_interact"
		|| currentName == "spell_interact" )
	{
		if ( item )
		{
			dropDown.options.clear();
			contextOptions = getContextMenuOptionsForItem(player.playernum, item);
			if ( currentName == "hotbar_interact" )
			{
				contextOptions.push_back(PROMPT_CLEAR_HOTBAR_SLOT);
				if ( itemCategory(item) == SPELLBOOK )
				{
					for ( auto it = contextOptions.begin(); it != contextOptions.end(); ++it )
					{
						if ( (*it) == PROMPT_INTERACT )
						{
							(*it) = PROMPT_INTERACT_SPELLBOOK_HOTBAR;
						}
					}
				}
			}
			if ( player.inventoryUI.useItemDropdownOnGamepad == Inventory_t::GAMEPAD_DROPDOWN_FULL )
			{
				for ( auto it = contextOptions.begin(); it != contextOptions.end(); )
				{
					if ( (*it) == PROMPT_APPRAISE )
					{
						it = contextOptions.erase(it);
						continue;
					}
					++it;
				}
			}
			else if ( player.inventoryUI.useItemDropdownOnGamepad == Inventory_t::GAMEPAD_DROPDOWN_COMPACT )
			{
				for ( auto it = contextOptions.begin(); it != contextOptions.end(); )
				{
					if ( (*it) == PROMPT_APPRAISE || (*it) == PROMPT_DROP )
					{
						it = contextOptions.erase(it);
						continue;
					}
					++it;
				}
			}
			for ( auto option : contextOptions )
			{
				dropDown.options.push_back(DropdownOption_t(getContextMenuLangEntry(player.playernum, option, *item), "", "", ""));
			}
		}
	}
	if ( dropDown.module != Player::GUI_t::MODULE_NONE )
	{
		if ( dropDown.module != player.GUI.activeModule )
		{
			close();
			return;
		}
	}

	if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor )
	{
		bool pressedDown = Input::inputs[player.playernum].consumeBinaryToggle("InventoryMoveDown");
		pressedDown = Input::inputs[player.playernum].consumeBinaryToggle("InventoryMoveDownAnalog") || pressedDown;

		bool pressedUp = Input::inputs[player.playernum].consumeBinaryToggle("InventoryMoveUp");
		pressedUp = Input::inputs[player.playernum].consumeBinaryToggle("InventoryMoveUpAnalog") || pressedUp;

		if ( pressedDown && player.bControlEnabled && !gamePaused && !player.usingCommand() )
		{
			++dropDownOptionSelected;
			if ( dropDownOptionSelected >= dropDown.options.size() )
			{
				dropDownOptionSelected = 0;
			}
			Player::soundMovement();
		}
		else if ( pressedUp	&& player.bControlEnabled && !gamePaused && !player.usingCommand() )
		{
			--dropDownOptionSelected;
			if ( dropDownOptionSelected < 0 )
			{
				dropDownOptionSelected = dropDown.options.size() - 1;
			}
			Player::soundMovement();
		}
	}

	std::vector<std::tuple<Frame::image_t*, Field*, Frame::image_t*>> optionFrames;
	index = 1;
	for ( auto& option : dropDown.options )
	{
		char glyphname[32] = "";
		snprintf(glyphname, sizeof(glyphname), "glyph %d", (int)index);
		char optionname[32] = "";
		snprintf(optionname, sizeof(optionname), "interact option %d", (int)index);

		auto img = dropdownFrame->findImage(glyphname);
		auto txt = dropdownFrame->findField(optionname);
		optionFrames.push_back(std::make_tuple(img, txt, nullptr));
		txt->setColor(hudColors.itemContextMenuOptionText);
		//txt->setColor(makeColor(148, 82, 3, 255));
		txt->setDisabled(false);
		img->disabled = true;

		if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor )
		{
			if ( dropDownOptionSelected + 1 == index )
			{
				img->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuConfirm");
				if ( auto imgGet = Image::get(img->path.c_str()) )
				{
					img->pos.w = imgGet->getWidth();
					img->pos.h = imgGet->getHeight();
					img->disabled = false;
				}
			}
		}
		/*if ( option.controllerGlyph != "" && inputs.getVirtualMouse(player.playernum)->lastMovementFromController )
		{
			img->path = Input::inputs[player.playernum].getGlyphPathForBinding(option.controllerGlyph.c_str());
			img->disabled = false;
		}
		else if ( option.keyboardGlyph != "" && inputs.getVirtualMouse(player.playernum)->draw_cursor )
		{
			img->path = Input::inputs[player.playernum].getGlyphPathForBinding(option.keyboardGlyph.c_str());
			img->disabled = false;
		}*/

		txt->setText(option.text.c_str());
		if ( auto textGet = Text::get(txt->getText(), txt->getFont(),
			txt->getTextColor(), txt->getOutlineColor()) )
		{
			maxWidth = std::max(textGet->getWidth() + 40, maxWidth);

			SDL_Rect size = txt->getSize();
			size.w = textGet->getWidth();
			if ( img->disabled || true )
			{
				size.x = textPaddingX;
				txt->setHJustify(Field::justify_t::CENTER);
			}
			else
			{
				size.x = img->pos.x + img->pos.w + textPaddingX;
				txt->setHJustify(Field::justify_t::LEFT);
			}
			txt->setSize(size);
		}

		img->pos.x = txt->getSize().x - 8;
		img->pos.y = txt->getSize().y + txt->getSize().h / 2 - img->pos.h / 2;

		maxHeight = std::max(std::max(txt->getSize().y + txt->getSize().h, img->pos.y + img->pos.h), maxHeight);
		++index;
	}

	const int rightClickProtectBuffer = (right_click_protect ? 0 : 10);
	const Sint32 mousex = (inputs.getMouse(player.playernum, Inputs::X) / (float)xres) * (float)Frame::virtualScreenX;
	const Sint32 mousey = (inputs.getMouse(player.playernum, Inputs::Y) / (float)yres) * (float)Frame::virtualScreenY;

	index = 0;
	bool alignRight = getDropDownAlignRight(currentName);
	for ( auto& optionGlyphTextBacking : optionFrames )
	{
		auto img = std::get<0>(optionGlyphTextBacking);
		auto txt = std::get<1>(optionGlyphTextBacking);

		if ( txt->getHJustify() == Field::justify_t::CENTER || true )
		{
			SDL_Rect size = txt->getSize();
			size.w = maxWidth;
			txt->setSize(size);
		}

		if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
		{
			auto ml = dropdownFrame->findImage("interact middle left");
			SDL_Rect absoluteSize = txt->getAbsoluteSize();
			absoluteSize.x -= (4 + ml->pos.w) + (alignRight ? rightClickProtectBuffer : 0);
			absoluteSize.w += ((4 + ml->pos.w) * 2 + rightClickProtectBuffer);
			absoluteSize.y += 4;
			absoluteSize.h -= 4;
			if ( mousex >= absoluteSize.x && mousex < absoluteSize.x + absoluteSize.w
				&& mousey >= absoluteSize.y && mousey < absoluteSize.y + absoluteSize.h )
			{
				dropDownOptionSelected = index;
			}
		}
		++index;
	}

	int textStartX = textPaddingX;
	//if ( optionFrames.size() > 0 )
	//{
	//	auto img = std::get<0>(optionFrames[0]);
	//	textStartX += (img->disabled ? 0 : img->pos.x + img->pos.w);
	//}
	const int frameWidth = maxWidth + textStartX + textPaddingX;

	SDL_Rect frameSize = dropdownFrame->getSize();
	frameSize.x = dropDownX;
	frameSize.y = dropDownY;

	// position the frame elements
	int interimHeight = 0;
	{
		auto tl = dropdownFrame->findImage("interact top left");
		auto tmid = dropdownFrame->findImage("interact top background");
		tmid->pos.w = frameWidth - tl->pos.w * 2;
		auto tr = dropdownFrame->findImage("interact top right");
		tr->pos.x = tmid->pos.x + tmid->pos.w;

		interimHeight = tmid->pos.y + tmid->pos.h;
		frameSize.w = tr->pos.x + tr->pos.w;
	}
	{
		const int middleOffsetY = 13;
		auto ml = dropdownFrame->findImage("interact middle left");
		ml->pos.h = maxHeight - interimHeight - middleOffsetY;
		auto mmid = dropdownFrame->findImage("interact middle background");
		mmid->pos.h = ml->pos.h;
		mmid->pos.w = frameWidth - (ml->pos.w) * 2;
		mmid->color = hudColors.itemContextMenuOptionImg;
		auto mr = dropdownFrame->findImage("interact middle right");
		mr->pos.h = ml->pos.h;
		mr->pos.x = mmid->pos.x + mmid->pos.w;

		interimHeight = mmid->pos.y + mmid->pos.h;
	}
	{
		auto bl = dropdownFrame->findImage("interact bottom left");
		bl->pos.y = interimHeight;
		auto bmid = dropdownFrame->findImage("interact bottom background");
		bmid->pos.y = interimHeight;
		bmid->pos.w = frameWidth - bl->pos.w * 2;
		auto br = dropdownFrame->findImage("interact bottom right");
		br->pos.y = interimHeight;
		br->pos.x = bmid->pos.x + bmid->pos.w;

		frameSize.h = br->pos.y + br->pos.h;
	}

	if ( auto interactText = dropdownFrame->findField("interact text") )
	{
		SDL_Rect size = interactText->getSize();
		size.x = 0;
		size.w = frameSize.w;
		interactText->setSize(size);
	}

	if ( !alignRight )
	{
		frameSize.x -= frameSize.w;
	}
	if ( frameSize.y + frameSize.h > player.camera_virtualy2() )
	{
		frameSize.y -= (frameSize.y + frameSize.h) - player.camera_virtualy2();
	}
	dropdownFrame->setSize(frameSize);

	if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
	{
		SDL_Rect absoluteSize = dropdownFrame->getAbsoluteSize();
		// right click protect uses exact border, else there is 10 px buffer
		absoluteSize.x -= (alignRight ? rightClickProtectBuffer : 0);
		absoluteSize.w += rightClickProtectBuffer;
	if ( !(mousex >= absoluteSize.x && mousex < absoluteSize.x + absoluteSize.w
		&& mousey >= absoluteSize.y && mousey < absoluteSize.y + absoluteSize.h) )
	{
		dropDownOptionSelected = -1;
	}
	}

	if ( dropDownOptionSelected >= 0 && dropDownOptionSelected < dropDown.options.size() )
	{
		auto txt = std::get<1>(optionFrames[dropDownOptionSelected]);
		txt->setColor(hudColors.itemContextMenuOptionSelectedText);
		SDL_Rect size = txt->getSize();
		size.x -= 4;
		size.w += 2 * 4;
		size.y += 3;
		highlightImageMid->pos = size;
		highlightImageMid->pos.x += highlightImageLeft->pos.w;
		highlightImageMid->pos.w -= 2 * highlightImageLeft->pos.w;
		highlightImageMid->pos.h = highlightImageLeft->pos.h;
		highlightImageMid->disabled = false;

		highlightImageLeft->pos.x = highlightImageMid->pos.x - highlightImageLeft->pos.w;
		highlightImageLeft->pos.y = highlightImageMid->pos.y;
		highlightImageLeft->disabled = false;
		highlightImageRight->pos.x = highlightImageMid->pos.x + highlightImageMid->pos.w;
		highlightImageRight->disabled = false;
		highlightImageRight->pos.y = highlightImageMid->pos.y;
	}

	bool activate = false;
	if ( !dropDownToggleClick && !Input::inputs[player.playernum].binary("MenuRightClick") )
	{
		activate = true;
		if ( dropDownOptionSelected >= 0 && dropDownOptionSelected < dropDown.options.size() )
		{
			Player::soundActivate();
		}
	}
	else if ( dropDownToggleClick )
	{
		if ( Input::inputs[player.playernum].consumeBinaryToggle("MenuRightClick") )
		{
			close();
		}
		else if ( Input::inputs[player.playernum].consumeBinaryToggle("MenuConfirm") )
		{
			activate = true;
			if ( dropDownOptionSelected >= 0 && dropDownOptionSelected < dropDown.options.size() )
			{
				Player::soundActivate();
			}
		}
		else if ( Input::inputs[player.playernum].consumeBinaryToggle("MenuCancel") )
		{
			close();
			Player::soundCancel();
		}
	}

	if ( !(player.bControlEnabled && !gamePaused && !player.usingCommand()) )
	{
		close();
	}
	else if ( activate )
	{
		if ( dropDownOptionSelected >= 0 && dropDownOptionSelected < dropDown.options.size() )
		{
			if ( currentName == "item_interact" || currentName == "hotbar_interact" 
				|| currentName == "chest_interact" || currentName == "spell_interact" )
			{
				if ( item && dropDownOptionSelected < contextOptions.size() )
				{
					if ( contextOptions[dropDownOptionSelected] == ItemContextMenuPrompts::PROMPT_DROP 
						&& player.paperDoll.isItemOnDoll(*item) )
					{
						// need to unequip
						player.inventoryUI.activateItemContextMenuOption(item, ItemContextMenuPrompts::PROMPT_UNEQUIP_FOR_DROP);
						player.paperDoll.updateSlots();
						if ( player.paperDoll.isItemOnDoll(*item) )
						{
							// couldn't unequip, no more actions
						}
						else
						{
							// successfully unequipped, let's drop it.
							bool droppedAll = false;
							while ( item && item->count > 1 )
							{
								droppedAll = dropItem(item, player.playernum);
								if ( droppedAll )
								{
									item = nullptr;
								}
							}
							if ( !droppedAll )
							{
								dropItem(item, player.playernum);
							}
						}
					}
					else
					{
						player.inventoryUI.activateItemContextMenuOption(item, contextOptions[dropDownOptionSelected]);
					}
				}
			}
			else
			{
				activateSelection(currentName, dropDownOptionSelected);
			}
		}
		//Close the menu.
		close();
	}
}

void Player::GUIDropdown_t::close()
{
	if ( dropdownFrame )
	{
		dropdownFrame->setHollow(true);
		dropdownFrame->removeSelf();
		dropdownFrame = nullptr;
	}
	if ( dropdownBlockClickFrame )
	{
		dropdownBlockClickFrame->setHollow(true);
		dropdownBlockClickFrame->removeSelf();
		dropdownBlockClickFrame = nullptr;
	}
	dropDownOptionSelected = 0;
	dropDownItem = 0;
	bOpen = false;
	dropDownToggleClick = false;
	currentName = "";
	bClosedThisTick = true;
}


void Player::GUI_t::closeDropdowns()
{
	if ( dropdownMenu.bOpen )
	{
		dropdownMenu.close();
	}
	if ( inputs.getUIInteraction(player.playernum)->itemMenuOpen )
	{
		inputs.getUIInteraction(player.playernum)->itemMenuOpen = false;
		player.inventoryUI.updateItemContextMenu();
	}
}
bool Player::GUI_t::isDropdownActive()
{
	if ( dropdownMenu.bOpen )
	{
		return true;
	}
	if ( inputs.getUIInteraction(player.playernum)->itemMenuOpen )
	{
		return true;
	}
	return false;
}

void Player::GUIDropdown_t::open(const std::string name)
{
	set(name);
	assert(dropdownFrame);
	if ( bOpen )
	{
		return;
	}

	if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor )
	{
		Player::soundActivate();
	}
	bOpen = true;
	bClosedThisTick = false;

	// clear inventory item context menu stuff
	bool& itemMenuOpen = inputs.getUIInteraction(player.playernum)->itemMenuOpen;
	itemMenuOpen = false;

	if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
	{
		dropDownX = (inputs.getMouse(player.playernum, Inputs::X) / (float)xres) * (float)Frame::virtualScreenX + (getDropDownAlignRight(name) ? 8 : -8);
		dropDownY = (inputs.getMouse(player.playernum, Inputs::Y) / (float)yres) * (float)Frame::virtualScreenY;
		if ( auto interactMenuTop = dropdownFrame->findImage("interact top background") )
		{
			// 10px is slot half height, minus the top interact text height
			// mouse will be situated halfway in first menu option
			dropDownY -= (interactMenuTop->pos.h + 10 + 2);
		}
		if ( dropDownX % 2 == 1 )
		{
			++dropDownX; // even pixel adjustment
		}
		if ( dropDownY % 2 == 1 )
		{
			++dropDownY; // even pixel adjustment
		}
	}
	dropDownOptionSelected = 0;
	if ( allDropDowns[name].defaultOption > 0 && allDropDowns[name].options.size() > allDropDowns[name].defaultOption )
	{
		if ( auto txt = dropdownFrame->findField("interact option 1") )
		{
			dropDownY -= txt->getSize().h;
			dropDownOptionSelected = allDropDowns[name].defaultOption;
		}
	}
	if ( auto highlightImageMid = dropdownFrame->findImage("interact selected highlight mid") )
	{
		highlightImageMid->disabled = true;
	}
	if ( auto highlightImageLeft = dropdownFrame->findImage("interact selected highlight left") )
	{
		highlightImageLeft->disabled = true;
	}
	if ( auto highlightImageRight = dropdownFrame->findImage("interact selected highlight right") )
	{
		highlightImageRight->disabled = true;
	}

	//Default reset. Otherwise will break mouse support after using gamepad once to trigger a context menu.
	dropDownToggleClick = false;

	if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
	{
		player.hud.cursor.lastUpdateTick = ticks;
	}
}

void Player::GUIDropdown_t::create(const std::string name)
{
	if ( dropdownFrame )
	{
		dropdownFrame->removeSelf();
		dropdownFrame = nullptr;
	}
	if ( dropdownBlockClickFrame )
	{
		dropdownBlockClickFrame->removeSelf();
		dropdownBlockClickFrame = nullptr;
	}

	auto& dropDown = allDropDowns[name];

	char dropdownBlockClickName[64] = "";
	snprintf(dropdownBlockClickName, sizeof(dropdownBlockClickName), "player dropdown block click %d", player.playernum);
	dropdownBlockClickFrame = gameUIFrame[player.playernum]->addFrame(dropdownBlockClickName);
	dropdownBlockClickFrame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
		players[player.playernum]->camera_virtualy1(),
		players[player.playernum]->camera_virtualWidth(),
		players[player.playernum]->camera_virtualHeight()});
	dropdownBlockClickFrame->setOwner(player.playernum);

	char dropdownName[64] = "";
	snprintf(dropdownName, sizeof(dropdownName), "player dropdown %d", player.playernum);
	dropdownFrame = gameUIFrame[player.playernum]->addFrame(dropdownName);
	const int interactWidth = 106;
	dropdownFrame->setSize(SDL_Rect{ 0, 0, interactWidth + 6 * 2, 100 });
	dropdownFrame->setDisabled(true);
	dropdownFrame->setInheritParentFrameOpacity(false);

	Uint32 color = makeColor( 255, 255, 255, 255);
	const int topBackgroundHeight = 30;
	const int optionHeight = 20;

	dropdownFrame->addImage(SDL_Rect{ 24, 0, 0, 30 },
		color, "*#images/ui/Inventory/tooltips/HoverItemMenu_T03.png", "interact top background");
	dropdownFrame->addImage(SDL_Rect{ 0, 0, 24, 30 },
		color, "*#images/ui/Inventory/tooltips/HoverItemMenu_TL03.png", "interact top left");
	dropdownFrame->addImage(SDL_Rect{ 0, 0, 24, 30 },
		color, "*#images/ui/Inventory/tooltips/HoverItemMenu_TR03.png", "interact top right");

	dropdownFrame->addImage(SDL_Rect{ 24, 30, 0, 12 },
		color, "*#images/ui/Inventory/tooltips/HoverItemMenu_C03.png", "interact middle background");
	auto ml = dropdownFrame->addImage(SDL_Rect{ 0, 30, 24, 12 },
		color, "*#images/ui/Inventory/tooltips/HoverItemMenu_L03.png", "interact middle left");
	ml->tiled = true;
	auto mr = dropdownFrame->addImage(SDL_Rect{ 0, 30, 24, 12 },
		color, "*#images/ui/Inventory/tooltips/HoverItemMenu_R03.png", "interact middle right");
	mr->tiled = true;

	dropdownFrame->addImage(SDL_Rect{ 24, 96, 0, 14 },
		color, "*#images/ui/Inventory/tooltips/HoverItemMenu_B03.png", "interact bottom background");
	dropdownFrame->addImage(SDL_Rect{ 0, 96, 24, 14 },
		color, "*#images/ui/Inventory/tooltips/HoverItemMenu_BL03.png", "interact bottom left");
	dropdownFrame->addImage(SDL_Rect{ 0, 96, 24, 14 },
		color, "*#images/ui/Inventory/tooltips/HoverItemMenu_BR03.png", "interact bottom right");

	auto selectmid = dropdownFrame->addImage(SDL_Rect{ 6, optionHeight - 16, interactWidth, 22 },
		hudColors.itemContextMenuOptionSelectedImg, "*#images/ui/Inventory/tooltips/HoverItemMenu_SelectBack_M03.png", "interact selected highlight mid");
	selectmid->tiled = true;
	dropdownFrame->addImage(SDL_Rect{ 6, optionHeight - 16, 20, 22 },
		hudColors.itemContextMenuOptionSelectedImg, "*#images/ui/Inventory/tooltips/HoverItemMenu_SelectBack_L03.png", "interact selected highlight left");
	dropdownFrame->addImage(SDL_Rect{ 6, optionHeight - 16, 20, 22 },
		hudColors.itemContextMenuOptionSelectedImg, "*#images/ui/Inventory/tooltips/HoverItemMenu_SelectBack_R03.png", "interact selected highlight right");

	const char* interactFont = "fonts/pixel_maz.ttf#32#2";

	auto interactText = dropdownFrame->addField("interact text", 32);
	interactText->setText(dropDown.title.c_str());
	interactText->setSize(SDL_Rect{ 0, 2, 0, topBackgroundHeight });
	interactText->setFont(interactFont);
	interactText->setHJustify(Field::justify_t::CENTER);
	interactText->setVJustify(Field::justify_t::CENTER);
	interactText->setColor(hudColors.itemContextMenuHeadingText);

	const int interactOptionStartX = 4;
	const int interactOptionStartY = 33;
	const int glyphSize = 20;
	const int textWidth = 80;
	const int textHeight = glyphSize + 8;

	Uint32 textColor = hudColors.itemContextMenuOptionText;
	SDL_Rect prevGlyphPos;

	for ( int i = 1; i <= dropDown.options.size(); ++i )
	{
		char glyphname[32] = "";
		snprintf(glyphname, sizeof(glyphname), "glyph %d", i);
		Frame::image_t* interactGlyph = nullptr;
		if ( i == 1 )
		{
			interactGlyph = dropdownFrame->addImage(
				SDL_Rect{ interactOptionStartX + 4, interactOptionStartY + 4, glyphSize, glyphSize },
				0xFFFFFFFF, "", glyphname);
		}
		else if ( i > 1 )
		{
			interactGlyph = dropdownFrame->addImage(
				SDL_Rect{ interactOptionStartX + 4,
				prevGlyphPos.y + prevGlyphPos.h + 4,
				glyphSize, glyphSize },
				0xFFFFFFFF, "", glyphname);
		}

		const int textAlignX = interactGlyph->pos.x + interactGlyph->pos.w + 6;
		int textAlignY = interactGlyph->pos.y - 10;
		if ( i == 1 )
		{
			textAlignY = interactGlyph->pos.y - 8;
		}

		char optionname[32] = "";
		snprintf(optionname, sizeof(optionname), "interact option %d", i);
		interactText = dropdownFrame->addField(optionname, 32);
		interactText->setText("");
		interactText->setSize(SDL_Rect{
			textAlignX,
			textAlignY,
			textWidth, textHeight });
		interactText->setFont(interactFont);
		interactText->setHJustify(Field::justify_t::LEFT);
		interactText->setVJustify(Field::justify_t::CENTER);
		interactText->setColor(textColor);

		prevGlyphPos = interactGlyph->pos;
	}
}

void Player::CharacterSheet_t::selectElement(SheetElements element, bool usingMouse, bool moveCursor)
{
	selectedElement = element;

	Frame* elementFrame = nullptr;
	Frame::image_t* img = nullptr;
	Field* elementField = nullptr;
	Button* elementButton = nullptr;
	bool selectedAButton = false;
	switch ( element )
	{
		case SHEET_OPEN_LOG:
			if ( elementFrame = sheetFrame->findFrame("log map buttons") )
			{
				if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor )
				{
					elementFrame->findButton("log button")->select();
					selectedAButton = true;
				}
				elementFrame = elementFrame->findFrame("log button selector");
				//img = elementFrame->findImage("log button img");
			}
			break;
		case SHEET_OPEN_MAP:
			if ( elementFrame = sheetFrame->findFrame("log map buttons") )
			{
				if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor )
				{
					elementFrame->findButton("map button")->select();
					selectedAButton = true;
				}
				elementFrame = elementFrame->findFrame("map button selector");
				//img = elementFrame->findImage("map button img");
			}
			break;
		case SHEET_SKILL_LIST:
			elementFrame = sheetFrame->findFrame("skills button frame");
			if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor )
			{
				elementFrame->findButton("skills button")->select();
				selectedAButton = true;
			}
			break;
		case SHEET_TIMER:
			elementFrame = sheetFrame->findFrame("game timer");
			if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor )
			{
				elementFrame->findButton("timer selector")->select();
				selectedAButton = true;
			}
			break;
		case SHEET_GOLD:
			if ( elementFrame = sheetFrame->findFrame("character info") )
			{
				if ( elementFrame = elementFrame->findFrame("character info inner frame") )
				{
					elementButton = elementFrame->findButton("character gold selector");
				}
			}
			break;
		case SHEET_DUNGEON_FLOOR:
			if ( elementFrame = sheetFrame->findFrame("dungeon floor frame") )
			{
				elementButton = elementFrame->findButton("dungeon floor selector");
			}
			break;
		case SHEET_CHAR_CLASS:
			if ( elementFrame = sheetFrame->findFrame("character info") )
			{
				if ( elementFrame = elementFrame->findFrame("character info inner frame") )
				{
					elementButton = elementFrame->findButton("character class selector");
				}
			}
			break;
		case SHEET_CHAR_RACE_SEX:
			if ( elementFrame = sheetFrame->findFrame("character info") )
			{
				if ( elementFrame = elementFrame->findFrame("character info inner frame") )
				{
					elementButton = elementFrame->findButton("character race selector");
				}
			}
			break;
		case SHEET_STR:
			if ( elementFrame = sheetFrame->findFrame("stats") )
			{
				if ( elementFrame = elementFrame->findFrame("stats inner frame") )
				{
					elementButton = elementFrame->findButton("str button");
				}
			}
			break;
		case SHEET_DEX:
			if ( elementFrame = sheetFrame->findFrame("stats") )
			{
				if ( elementFrame = elementFrame->findFrame("stats inner frame") )
				{
					elementButton = elementFrame->findButton("dex button");
				}
			}
			break;
		case SHEET_CON:
			if ( elementFrame = sheetFrame->findFrame("stats") )
			{
				if ( elementFrame = elementFrame->findFrame("stats inner frame") )
				{
					elementButton = elementFrame->findButton("con button");
				}
			}
			break;
		case SHEET_INT:
			if ( elementFrame = sheetFrame->findFrame("stats") )
			{
				if ( elementFrame = elementFrame->findFrame("stats inner frame") )
				{
					elementButton = elementFrame->findButton("int button");
				}
			}
			break;
		case SHEET_PER:
			if ( elementFrame = sheetFrame->findFrame("stats") )
			{
				if ( elementFrame = elementFrame->findFrame("stats inner frame") )
				{
					elementButton = elementFrame->findButton("per button");
				}
			}
			break;
		case SHEET_CHR:
			if ( elementFrame = sheetFrame->findFrame("stats") )
			{
				if ( elementFrame = elementFrame->findFrame("stats inner frame") )
				{
					elementButton = elementFrame->findButton("chr button");
				}
			}
			break;
		case SHEET_ATK:
			if ( elementFrame = sheetFrame->findFrame("attributes") )
			{
				if ( elementFrame = elementFrame->findFrame("attributes inner frame") )
				{
					elementButton = elementFrame->findButton("atk button");
				}
			}
			break;
		case SHEET_AC:
			if ( elementFrame = sheetFrame->findFrame("attributes") )
			{
				if ( elementFrame = elementFrame->findFrame("attributes inner frame") )
				{
					elementButton = elementFrame->findButton("ac button");
				}
			}
			break;
		case SHEET_POW:
			if ( elementFrame = sheetFrame->findFrame("attributes") )
			{
				if ( elementFrame = elementFrame->findFrame("attributes inner frame") )
				{
					elementButton = elementFrame->findButton("pow button");
				}
			}
			break;
		case SHEET_RES:
			if ( elementFrame = sheetFrame->findFrame("attributes") )
			{
				if ( elementFrame = elementFrame->findFrame("attributes inner frame") )
				{
					elementButton = elementFrame->findButton("res button");
				}
			}
			break;
		case SHEET_RGN:
			if ( elementFrame = sheetFrame->findFrame("attributes") )
			{
				if ( elementFrame = elementFrame->findFrame("attributes inner frame") )
				{
					elementButton = elementFrame->findButton("rgn button");
				}
			}
			break;
		case SHEET_RGN_MP:
			if ( elementFrame = sheetFrame->findFrame("attributes") )
			{
				if ( elementFrame = elementFrame->findFrame("attributes inner frame") )
				{
					elementButton = elementFrame->findButton("rgn mp button");
				}
			}
			break;
		case SHEET_WGT:
			if ( elementFrame = sheetFrame->findFrame("attributes") )
			{
				if ( elementFrame = elementFrame->findFrame("attributes inner frame") )
				{
					elementButton = elementFrame->findButton("wgt button");
				}
			}
			break;
		default:
			elementFrame = nullptr;
			break;
	}

	SDL_Rect pos{ 0, 0, 0, 0 };
	if ( elementFrame && moveCursor )
	{
		elementFrame->warpMouseToFrame(player.playernum, (Inputs::SET_CONTROLLER));
		pos = elementFrame->getAbsoluteSize();
		if ( img )
		{
			pos.x += img->pos.x;
			pos.y += img->pos.y;
			pos.w = img->pos.w;
			pos.h = img->pos.h;
		}
		if ( elementButton )
		{
			pos = elementButton->getAbsoluteSize();
		}
		if ( elementField )
		{
			pos = elementField->getAbsoluteSize();
		}
		// make sure to adjust absolute size to camera viewport
		pos.x -= player.camera_virtualx1();
		pos.y -= player.camera_virtualy1();
		player.hud.setCursorDisabled(false);
		if ( !isInteractable )
		{
			player.characterSheet.queuedElement = player.characterSheet.selectedElement;
		}
		else
		{
			player.characterSheet.queuedElement = SHEET_UNSELECTED;
			player.hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, usingMouse);
		}
	}
	if ( !selectedAButton && elementFrame && !inputs.getVirtualMouse(player.playernum)->draw_cursor )
	{
		if ( elementButton )
		{
			elementButton->select();
		}
		else
		{
			elementFrame->select();
		}
	}
}

void Player::CharacterSheet_t::updateGameTimer()
{
	auto characterInfoFrame = sheetFrame->findFrame("character info");
	auto timerFrame = sheetFrame->findFrame("game timer");
	auto timerText = timerFrame->findField("timer text");
	char buf[32];

	Uint32 sec = (completionTime / TICKS_PER_SECOND) % 60;
	Uint32 min = ((completionTime / TICKS_PER_SECOND) / 60) % 60;
	Uint32 hour = (((completionTime / TICKS_PER_SECOND) / 60) / 60) % 24;
	Uint32 day = ((completionTime / TICKS_PER_SECOND) / 60) / 60 / 24;
	snprintf(buf, sizeof(buf), "%02d:%02d:%02d:%02d", day, hour, min, sec);
	timerText->setText(buf);

	bool enableTooltips = !player.GUI.isDropdownActive() && !player.GUI.dropdownMenu.bClosedThisTick && inputs.getVirtualMouse(player.playernum)->draw_cursor;

	bool bCompactView = player.bUseCompactGUIHeight();
	if ( bCompactView )
	{
		enableTooltips = false;
	}

	if ( selectedElement == SHEET_TIMER && enableTooltips )
	{
		SDL_Rect tooltipPos = characterInfoFrame->getSize();
		tooltipPos.y = timerFrame->getSize().y;
		Player::PanelJustify_t tooltipJustify = PANEL_JUSTIFY_RIGHT;
		if ( (panelJustify == PANEL_JUSTIFY_LEFT && !bCompactView) || (panelJustify == PANEL_JUSTIFY_RIGHT && bCompactView) )
		{
			tooltipJustify = PANEL_JUSTIFY_LEFT;
			tooltipPos.x += tooltipPos.w;
		}
		updateCharacterSheetTooltip(SHEET_TIMER, tooltipPos, tooltipJustify);
	}
}

std::string& Player::CharacterSheet_t::getHoverTextString(std::string key)
{
	if ( hoverTextStrings.find(key) != hoverTextStrings.end() )
	{
		return hoverTextStrings[key];
	}
	return defaultString;
}

bool getAttackTooltipLines(int playernum, AttackHoverText_t& attackHoverTextInfo, int lineNumber, char titleBuf[128], char valueBuf[128])
{
	std::string skillName = "-";
	Sint32 skillLVL = 0;
	for ( auto& skill : Player::SkillSheet_t::skillSheetData.skillEntries )
	{
		if ( skill.skillId == attackHoverTextInfo.proficiency )
		{
			skillName = skill.name;
			skillLVL = stats[playernum]->getModifiedProficiency(attackHoverTextInfo.proficiency);
			break;
		}
	}

	if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_MELEE_WEAPON )
	{
		switch ( lineNumber )
		{
			case 1:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_avg").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_average_format").c_str(),
					(real_t)attackHoverTextInfo.attackMinRange + ((attackHoverTextInfo.attackMaxRange - attackHoverTextInfo.attackMinRange) / 2.0));
				return true;
			case 2:
				snprintf(titleBuf, 127, Player::CharacterSheet_t::getHoverTextString("attributes_atk_range").c_str(),
					skillName.c_str(), skillLVL);
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_range_format").c_str(), 
					attackHoverTextInfo.attackMinRange, attackHoverTextInfo.attackMaxRange);
				return true;
			case 3:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_attr_bonus_melee").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.mainAttributeBonus);
				return true;
			case 4:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_weapon_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.weaponBonus);
				return true;
			case 5:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_melee_weapon_base").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					BASE_MELEE_DAMAGE);
				return true;
			case 6:
				return false;
			default:
				return false;
		}
	}
	else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_UNARMED )
	{
		switch ( lineNumber )
		{
			case 1:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_avg").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_average_format").c_str(),
					(real_t)attackHoverTextInfo.attackMinRange + ((attackHoverTextInfo.attackMaxRange - attackHoverTextInfo.attackMinRange) / 2.0));
				return true;
			case 2:
				snprintf(titleBuf, 127, Player::CharacterSheet_t::getHoverTextString("attributes_atk_range").c_str(),
					skillName.c_str(), skillLVL);
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_range_format").c_str(),
					attackHoverTextInfo.attackMinRange, attackHoverTextInfo.attackMaxRange);
				return true;
			case 3:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_attr_bonus_melee").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.mainAttributeBonus);
				return true;
			case 4:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_items_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.equipmentAndEffectBonus);
				return true;
			case 5:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_skill_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.proficiencyBonus);
				return true;
			case 6:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_unarmed_weapon_base").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					BASE_PLAYER_UNARMED_DAMAGE);
				return true;
			default:
				return false;
		}
	}
	else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_PICKAXE )
	{
		switch ( lineNumber )
		{
			case 1:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_avg").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_average_format").c_str(),
					(real_t)attackHoverTextInfo.attackMinRange + ((attackHoverTextInfo.attackMaxRange - attackHoverTextInfo.attackMinRange) / 2.0));
				return true;
			case 2:
				snprintf(titleBuf, 127, Player::CharacterSheet_t::getHoverTextString("attributes_atk_range_noskill").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_range_format").c_str(),
					attackHoverTextInfo.attackMinRange, attackHoverTextInfo.attackMaxRange);
				return true;
			case 3:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_attr_bonus_melee").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.mainAttributeBonus);
				return true;
			case 4:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_weapon_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.weaponBonus);
				return true;
			case 5:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_melee_weapon_base").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					BASE_MELEE_DAMAGE);
				return true;
			default:
				return false;
		}
	}
	else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_RANGED )
	{
		switch ( lineNumber )
		{
			case 1:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_avg").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_average_format").c_str(),
					(real_t)attackHoverTextInfo.attackMinRange + ((attackHoverTextInfo.attackMaxRange - attackHoverTextInfo.attackMinRange) / 2.0));
				return true;
			case 2:
				snprintf(titleBuf, 127, Player::CharacterSheet_t::getHoverTextString("attributes_atk_range").c_str(),
					skillName.c_str(), skillLVL);
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_range_format").c_str(),
					attackHoverTextInfo.attackMinRange, attackHoverTextInfo.attackMaxRange);
				return true;
			case 3:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_attr_bonus_ranged").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.mainAttributeBonus);
				return true;
			case 4:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_weapon_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.weaponBonus);
				return true;
			case 5:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_items_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.equipmentAndEffectBonus);
				return true;
			case 6:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_ranged_weapon_base").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					BASE_RANGED_DAMAGE);
				return true;
			default:
				return false;
		}
	}
	else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_THROWN
		|| attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_THROWN_GEM )
	{
		switch ( lineNumber )
		{
			case 1:
				snprintf(titleBuf, 127, Player::CharacterSheet_t::getHoverTextString("attributes_atk_range").c_str(),
					skillName.c_str(), skillLVL);
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_range_format").c_str(),
					attackHoverTextInfo.attackMinRange, attackHoverTextInfo.attackMaxRange);
				return true;
			case 2:
				strcpy(titleBuf, "");
				strcpy(valueBuf, "");
				return true;
			case 3:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_attr_bonus_ranged").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.mainAttributeBonus);
				return true;
			case 4:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_weapon_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.weaponBonus);
				return true;
			case 5:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_skill_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.proficiencyBonus);
				return true;
			case 6:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_thrown_weapon_fully_charged").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					3);
				return true;
			case 7:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_thrown_weapon_base").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					BASE_THROWN_DAMAGE);
				return true;
			default:
				return false;
		}
	}
	else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_THROWN_POTION )
	{
		switch ( lineNumber )
		{
			case 1:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_avg").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_average_format").c_str(),
					(real_t)attackHoverTextInfo.attackMinRange + ((attackHoverTextInfo.attackMaxRange - attackHoverTextInfo.attackMinRange) / 2.0));
				return true;
			case 2:
				snprintf(titleBuf, 127, Player::CharacterSheet_t::getHoverTextString("attributes_atk_range").c_str(),
					skillName.c_str(), skillLVL);
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_range_format").c_str(),
					attackHoverTextInfo.attackMinRange, attackHoverTextInfo.attackMaxRange);
				return true;
			case 3:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_weapon_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.weaponBonus);
				return true;
			case 4:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_skill_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.proficiencyBonus);
				return true;
			case 5:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_thrown_weapon_base").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					BASE_THROWN_DAMAGE);
				return true;
			default:
				return false;
		}
	}
	else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_WHIP )
	{
		switch ( lineNumber )
		{
			case 1:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_avg").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_nobonus_format").c_str(),
					attackHoverTextInfo.totalAttack);
				return true;
			case 2:
				snprintf(titleBuf, 127, Player::CharacterSheet_t::getHoverTextString("attributes_atk_range").c_str(),
					skillName.c_str(), skillLVL);
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_range_format").c_str(),
					attackHoverTextInfo.attackMinRange, attackHoverTextInfo.attackMaxRange);
				return true;
			case 3:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_attr_bonus_whip").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.mainAttributeBonus);
				return true;
			case 4:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_weapon_bonus").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					attackHoverTextInfo.weaponBonus);
				return true;
			case 5:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_entry_melee_weapon_base").c_str());
				snprintf(valueBuf, 127,
					Player::CharacterSheet_t::getHoverTextString("attributes_atk_bonus_format").c_str(),
					BASE_MELEE_DAMAGE);
				return true;
			default:
				return false;
		}
	}
	else
	{
		switch ( lineNumber )
		{
			case 1:
				snprintf(titleBuf, 127, "%s", Player::CharacterSheet_t::getHoverTextString("attributes_atk_avg").c_str());
				snprintf(valueBuf, 127, "-");
				return true;
			case 2:
				strcpy(titleBuf, "");
				strcpy(valueBuf, "");
				return true;
			default:
				return false;
		}
	}
	return false;
}

real_t getDisplayedHPRegen(Entity* my, Stat& myStats, Uint32* outColor, char buf[32])
{
	real_t regen = 0.0;
	if ( outColor )
	{
		*outColor = hudColors.characterSheetNeutral;
	}
	if ( myStats.HP > 0 )
	{
		regen = (static_cast<real_t>(Entity::getHealthRegenInterval(my,
			myStats, true)) / TICKS_PER_SECOND);
		if ( myStats.type == SKELETON )
		{
			if ( !(svFlags & SV_FLAG_HUNGER) )
			{
				regen = HEAL_TIME * 4 / TICKS_PER_SECOND;
			}
		}
		if ( regen < 0 )
		{
			regen = 0.0;
			if ( !(svFlags & SV_FLAG_HUNGER) )
			{
				if ( outColor )
				{
					*outColor = hudColors.characterSheetNeutral;
				}
			}
			else
			{
				if ( outColor )
				{
					*outColor = hudColors.characterSheetRed;
				}
			}
		}
		else if ( regen < HEAL_TIME / TICKS_PER_SECOND )
		{
			if ( outColor )
			{
				*outColor = hudColors.characterSheetGreen;
			}
		}
	}
	else
	{
		regen = HEAL_TIME / TICKS_PER_SECOND;
	}

	if ( regen > 0.01 )
	{
		real_t nominalRegen = HEAL_TIME / TICKS_PER_SECOND;
		regen = nominalRegen / regen;
	}
	if ( buf )
	{
		if ( !(svFlags & SV_FLAG_HUNGER) )
		{
			snprintf(buf, 32, "- ");
		}
		else
		{
			snprintf(buf, 32, "%.f%%", regen * 100.0);
		}
	}
	return regen * 100.0;
}

real_t getDisplayedMPRegen(Entity* my, Stat& myStats, Uint32* outColor, char buf[32])
{
	real_t regen = 0.0;
	bool isNegative = false;
	bool isInsectoid = false;
	if ( /*players[player.playernum]->entity*/ true )
	{
		regen = (static_cast<real_t>(Entity::getManaRegenInterval(my, myStats, true)) / TICKS_PER_SECOND);
		if ( myStats.type == AUTOMATON )
		{
			if ( myStats.HUNGER <= 300 )
			{
				isNegative = true;
				regen /= 6; // degrade faster
			}
			else if ( myStats.HUNGER > 1200 )
			{
				if ( myStats.MP / static_cast<real_t>(std::max(1, myStats.MAXMP)) <= 0.5 )
				{
					regen /= 4; // increase faster at < 50% mana
				}
				else
				{
					regen /= 2; // increase less faster at > 50% mana
				}
			}
			else if ( myStats.HUNGER > 300 )
			{
				// normal manaRegenInterval 300-1200 hunger.
			}
		}

		if ( regen < 0.0 /*stats[player]->playerRace == RACE_INSECTOID && stats[player]->appearance == 0*/ )
		{
			regen = 0.0;
		}

		if ( myStats.type == AUTOMATON )
		{
			if ( myStats.HUNGER <= 300 )
			{
				if ( outColor )
				{
					*outColor = hudColors.characterSheetRed;
				}
			}
			else if ( regen < static_cast<real_t>(getBaseManaRegen(my, myStats)) / TICKS_PER_SECOND )
			{
				if ( outColor )
				{
					*outColor = hudColors.characterSheetGreen;
				}
			}
		}
		else if ( myStats.playerRace == RACE_INSECTOID && myStats.appearance == 0 )
		{
			isInsectoid = true;
			if ( !(svFlags & SV_FLAG_HUNGER) )
			{
				if ( outColor )
				{
					*outColor = hudColors.characterSheetNeutral;
				}
			}
			else
			{
				if ( outColor )
				{
					*outColor = hudColors.characterSheetRed;
				}
			}
		}
		else if ( regen < static_cast<real_t>(getBaseManaRegen(my, myStats)) / TICKS_PER_SECOND )
		{
			if ( outColor )
			{
				*outColor = hudColors.characterSheetGreen;
			}
		}
	}
	else
	{
		regen = MAGIC_REGEN_TIME / TICKS_PER_SECOND;
	}

	if ( isNegative )
	{
		regen *= -1; // negative
	}

	if ( isInsectoid )
	{
		if ( svFlags & SV_FLAG_HUNGER )
		{
			real_t normalRegenTime = (1000.f * 30 * 1.5) / static_cast<float>(TICKS_PER_SECOND); // 30 base, insectoid does 1.5x in getHungerTickRate()
			normalRegenTime /= (std::max(myStats.MAXMP, 1)); // time for 1 mana in seconds
			normalRegenTime *= TICKS_PER_SECOND; // game ticks for 1 mana

			regen = normalRegenTime / (regen * TICKS_PER_SECOND);
		}
		else
		{
			if ( buf )
			{
				snprintf(buf, 32, "-");
			}
			return regen * 100.0;
		}
	}
	else
	{
		if ( regen > 0.01 || regen < -0.01 )
		{
			real_t nominalRegen = MAGIC_REGEN_TIME / TICKS_PER_SECOND;
			regen = nominalRegen / regen;
		}
	}
	if ( buf )
	{
		if ( myStats.type == AUTOMATON )
		{
			snprintf(buf, 32, Player::CharacterSheet_t::getHoverTextString("attributes_rgn_ht_small_format").c_str(), regen * 100.0);
		}
		else
		{
			snprintf(buf, 32, Player::CharacterSheet_t::getHoverTextString("attributes_rgn_small_format").c_str(), regen * 100.0);
		}
	}
	return regen * 100.0;
}

struct CharacterSheetTooltipCache_t
{
	Sint32 baseSTR = 0;
	Sint32 baseDEX = 0;
	Sint32 baseINT = 0;
	Sint32 baseCON = 0;
	Sint32 basePER = 0;
	Sint32 baseCHR = 0;

	Sint32 modifiedSTR = 0;
	Sint32 modifiedDEX = 0;
	Sint32 modifiedINT = 0;
	Sint32 modifiedCON = 0;
	Sint32 modifiedPER = 0;
	Sint32 modifiedCHR = 0;

	Sint32 ac = 0;
	int playerRace = RACE_HUMAN;
	int playerRaceType = NOTHING;
	int type = NOTHING;
	int classnum = -1;
	bool hungerEnabled = false;
	int weapontype = 0;
	Sint32 ATK = -1;
	bool manualUpdate = false;

	struct TextEntries_t
	{
		std::string title = "";
		std::string entry1 = "";
		std::string entry2 = "";
		std::string entry3 = "";
		std::string entry4 = "";
		std::string entry5 = "";
		std::string entry6 = "";
		std::string entry7 = "";
		std::string entry8 = "";
		std::string entry9 = "";
		std::string entry10 = "";
		std::string entry11 = "";
		std::string entry12 = "";
	};
	TextEntries_t textEntries[Player::CharacterSheet_t::SHEET_ENUM_END];
	bool needsUpdate(const int player)
	{
		if ( manualUpdate ) { return true; }
		if ( baseSTR != stats[player]->STR ) { return true; }
		if ( baseDEX != stats[player]->DEX ) { return true; }
		if ( baseCON != stats[player]->CON ) { return true; }
		if ( baseINT != stats[player]->INT ) { return true; }
		if ( basePER != stats[player]->PER ) { return true; }
		if ( baseCHR != stats[player]->CHR ) { return true; }

		if ( modifiedSTR != statGetSTR(stats[player], players[player]->entity) ) { return true; }
		if ( modifiedDEX != statGetDEX(stats[player], players[player]->entity) ) { return true; }
		if ( modifiedCON != statGetCON(stats[player], players[player]->entity) ) { return true; }
		if ( modifiedINT != statGetINT(stats[player], players[player]->entity) ) { return true; }
		if ( modifiedPER != statGetPER(stats[player], players[player]->entity) ) { return true; }
		if ( modifiedCHR != statGetCHR(stats[player], players[player]->entity) ) { return true; }

		if ( playerRace != stats[player]->playerRace ) { return true; }
		if ( hungerEnabled != (svFlags & SV_FLAG_HUNGER) ) { return true; }
		if ( ac != AC(stats[player]) ) { return true; }
		if ( weapontype != getWeaponSkill(stats[player]->weapon) ) { return true; }

		int playerRaceType = getMonsterFromPlayerRace(playerRace);
		int type = stats[player]->type;
		if ( arachnophobia_filter )
		{
			if ( type == SPIDER )
			{
				type = CRAB;
			}
			if ( playerRaceType == SPIDER )
			{
				playerRaceType = CRAB;
			}
		}
		if ( type != this->type ) { return true; }
		if ( playerRaceType != this->playerRaceType ) { return true; }
		if ( client_classes[player] != classnum ) { return true; }
		return false;
	}
	void updateToCharacter(const int player)
	{
		manualUpdate = false;

		baseSTR = stats[player]->STR;
		baseDEX = stats[player]->DEX;
		baseCON = stats[player]->CON;
		baseINT = stats[player]->INT;
		basePER = stats[player]->PER;
		baseCHR = stats[player]->CHR;

		modifiedSTR = statGetSTR(stats[player], players[player]->entity);
		modifiedDEX = statGetDEX(stats[player], players[player]->entity);
		modifiedCON = statGetCON(stats[player], players[player]->entity);
		modifiedINT = statGetINT(stats[player], players[player]->entity);
		modifiedPER = statGetPER(stats[player], players[player]->entity);
		modifiedCHR = statGetCHR(stats[player], players[player]->entity);

		playerRace = stats[player]->playerRace;
		playerRaceType = getMonsterFromPlayerRace(playerRace);
		type = stats[player]->type;
		classnum = client_classes[player];
		if ( arachnophobia_filter )
		{
			if ( type == SPIDER )
			{
				type = CRAB;
			}
			if ( playerRaceType == SPIDER )
			{
				playerRaceType = CRAB;
			}
		}
		hungerEnabled = (svFlags & SV_FLAG_HUNGER);
		ac = AC(stats[player]);
		weapontype = getWeaponSkill(stats[player]->weapon);
	}
};
bool blitCharacterSheetTooltipToSurf = false;
CharacterSheetTooltipCache_t charsheetTooltipCache[MAXPLAYERS];
void Player::CharacterSheet_t::updateCharacterSheetTooltip(SheetElements element, SDL_Rect pos, Player::PanelJustify_t tooltipJustify)
{
	if ( !sheetFrame )
	{
		return;
	}
	auto tooltipFrame = sheetFrame->findFrame("sheet tooltip");
	if ( tooltipFrame->isDisabled() )
	{
		tooltipOpacitySetpoint = 0;
		tooltipOpacityAnimate = 1.0;
	}
	
	if ( static_cast<int>(tooltipFrame->getOpacity()) != tooltipOpacitySetpoint )
	{
		const real_t fpsScale = getFPSScale(144.0);
		if ( tooltipOpacitySetpoint == 0 )
		{
			if ( ticks - tooltipDeselectedTick > 5 )
			{
				real_t factor = 10.0;
				real_t setpointDiff = fpsScale * std::max(.05, (tooltipOpacityAnimate)) / (factor);
				tooltipOpacityAnimate -= setpointDiff;
				tooltipOpacityAnimate = std::max(0.0, tooltipOpacityAnimate);
			}
		}
		else
		{
			real_t setpointDiff = fpsScale * std::max(.05, (1.0 - tooltipOpacityAnimate)) / (1);
			tooltipOpacityAnimate += setpointDiff;
			tooltipOpacityAnimate = std::min(1.0, tooltipOpacityAnimate);
		}
		tooltipFrame->setOpacity(tooltipOpacityAnimate * 100);
	}
	else
	{
		tooltipFrame->setOpacity(tooltipOpacitySetpoint);
	}

	if ( selectedElement == SHEET_UNSELECTED )
	{
		cachedElementTooltip = SHEET_UNSELECTED;
	}
	if ( player.shootmode )
	{
		tooltipOpacitySetpoint = 0;
		tooltipOpacityAnimate = 0.0;
	}
	if ( element == SHEET_ENUM_END || element == SHEET_UNSELECTED
		|| player.GUI.activeModule != Player::GUI_t::MODULE_CHARACTERSHEET )
	{
		//tooltipFrame->setDisabled(true);
		return;
	}

	tooltipOpacitySetpoint = 0;
	tooltipOpacityAnimate = 1.0;
	tooltipFrame->setDisabled(false);
	tooltipFrame->setOpacity(100.0);
	tooltipDeselectedTick = ticks;

	//if ( keystatus[SDLK_g] )
	//{
	//	keystatus[SDLK_g] = 0;
	//	blitCharacterSheetTooltipToSurf = !blitCharacterSheetTooltipToSurf;
	//	messagePlayer(0, MESSAGE_DEBUG, "%d", blitCharacterSheetTooltipToSurf);
	//	if ( !blitCharacterSheetTooltipToSurf )
	//	{
	//		tooltipFrame->setBlitChildren(false);
	//	}
	//	else if ( blitCharacterSheetTooltipToSurf )
	//	{
	//		tooltipFrame->setBlitChildren(true);
	//	}
	//}

	bool redraw = false;
	if ( cachedElementTooltip != selectedElement 
		|| cachedElementTooltip == SHEET_ENUM_END || cachedElementTooltip == SHEET_UNSELECTED
		|| charsheetTooltipCache[player.playernum].needsUpdate(player.playernum) )
	{
		redraw = true;
		cachedElementTooltip = selectedElement;
		charsheetTooltipCache[player.playernum].updateToCharacter(player.playernum);
	}

	if ( !redraw )
	{
		return;
	}


	Uint32 defaultColor = hudColors.characterSheetNeutral;
	auto txt = tooltipFrame->findField("tooltip text");
	txt->setColor(defaultColor);
	auto txtRightAlignHint = tooltipFrame->findField("tooltip text right align hint");
	txtRightAlignHint->setColor(hudColors.characterSheetFaintText);
	txtRightAlignHint->setDisabled(true);

	for ( int i = 1; i <= NUM_CHARSHEET_TOOLTIP_TEXT_FIELDS; ++i )
	{
		char glyphName[32] = "";
		snprintf(glyphName, sizeof(glyphName), "glyph %d", i);
		if ( auto glyph = tooltipFrame->findImage(glyphName) )
		{
			glyph->disabled = true;
		}

		auto entry = characterSheetTooltipTextFields[player.playernum][i]; assert(entry);
		entry->setDisabled(true);
		entry->setHJustify(Frame::justify_t::LEFT);
		entry->setVJustify(Field::justify_t::CENTER);
		entry->setColor(defaultColor);
	}
	auto div = tooltipFrame->findImage("tooltip divider 1");
	div->disabled = true;
	auto div2 = tooltipFrame->findImage("tooltip divider 2");
	div2->disabled = true;

	for ( int i = 1; i <= NUM_CHARSHEET_TOOLTIP_BACKING_FRAMES; ++i )
	{
		auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][i];
		txtValueBackingFrame->setDisabled(true);
	}

	auto raceTooltip = tooltipFrame->findFrame("sheet race tooltip");
	raceTooltip->setDisabled(true);
	auto classTooltip = tooltipFrame->findFrame("sheet class tooltip");
	classTooltip->setDisabled(true);

	if ( !(element >= Player::CharacterSheet_t::SHEET_STR && element <= Player::CharacterSheet_t::SHEET_CHR) )
	{
		auto tooltipTopLeft = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
		tooltipTopLeft->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TL_00.png";
		auto tooltipTop = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP].c_str());
		tooltipTop->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_T_00.png";
		auto tooltipTopRight = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
		tooltipTopRight->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TR_00.png";
		imageSetWidthHeight9x9(tooltipFrame, skillsheetEffectBackgroundImages);
	}

	if ( element >= Player::CharacterSheet_t::SHEET_STR && element <= Player::CharacterSheet_t::SHEET_CHR )
	{
		auto tooltipTopLeft = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
		tooltipTopLeft->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TL_Blue_00.png";
		auto tooltipTop = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP].c_str());
		tooltipTop->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_T_Blue_00.png";
		auto tooltipTopRight = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
		tooltipTopRight->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TR_Blue_00.png";
		imageSetWidthHeight9x9(tooltipFrame, skillsheetEffectBackgroundImages);

		int maxWidth = 260;
		if ( getHoverTextString("stat_max_tooltip_width") != defaultString )
		{
			maxWidth = std::max(0, std::stoi(getHoverTextString("stat_max_tooltip_width")));
		}
		int minWidth = 0;
		if ( getHoverTextString("stat_min_tooltip_width") != defaultString )
		{
			minWidth = std::max(0, std::stoi(getHoverTextString("stat_min_tooltip_width")));
		}
		const int padx = 16;
		const int pady1 = 8;
		const int pady2 = 4;
		const int padxMid = 4;
		const int padyMid = 8;
		SDL_Rect tooltipPos = SDL_Rect{ 400, 0, maxWidth, 100 };

		std::string titleText = "";
		std::string descText = "";
		int value = 0;
		switch ( element )
		{
			case SHEET_STR:
				titleText = getHoverTextString("stat_str_title");
				descText = getHoverTextString("stat_str_desc");
				break;
			case SHEET_DEX:
				titleText = getHoverTextString("stat_dex_title");
				descText = getHoverTextString("stat_dex_desc");
				break;
			case SHEET_CON:
				titleText = getHoverTextString("stat_con_title");
				descText = getHoverTextString("stat_con_desc");
				break;
			case SHEET_INT:
				titleText = getHoverTextString("stat_int_title");
				descText = getHoverTextString("stat_int_desc");
				break;
			case SHEET_PER:
				titleText = getHoverTextString("stat_per_title");
				descText = getHoverTextString("stat_per_desc");
				break;
			case SHEET_CHR:
				titleText = getHoverTextString("stat_chr_title");
				descText = getHoverTextString("stat_chr_desc");
				break;
			default:
				break;
		}

		txt->setText(titleText.c_str());
		SDL_Rect txtPos = SDL_Rect{ padx, pady1 - 2, maxWidth - padx * 2, 80 };
		txt->setSize(txtPos);
		if ( charsheetTooltipCache[player.playernum].textEntries[element].title != txt->getText() )
		{
			txt->reflowTextToFit(0);
			charsheetTooltipCache[player.playernum].textEntries[element].title = txt->getText();
		}
		txt->setColor(hudColors.characterSheetHeadingText);
		Font* actualFont = Font::get(txt->getFont());
		int txtHeight = txt->getNumTextLines() * actualFont->height(true);
		txtPos.h = txtHeight + 4;
		auto txtGet = Text::get(txt->getLongestLine().c_str(), txt->getFont(),
			txt->getTextColor(), txt->getOutlineColor());
		txtPos.w = txtGet->getWidth();
		txtPos.w = std::max(minWidth - padx * 2, txtPos.w);
		txt->setSize(txtPos);

		tooltipPos.w = (txtPos.w + padx * 2);

		unsigned int longestValue = 0;
		std::map<int, std::pair<Field*, SDL_Rect>> valueSizes;

		int currentHeight = txtPos.y + (actualFont->height(true) * 1) + 2;
		const int extraTextHeightForLowerCharacters = 4;
		{
			currentHeight += padyMid;
			auto entry = characterSheetTooltipTextFields[player.playernum][1]; assert(entry);
			entry->setDisabled(false);
			char buf[128] = "";
			snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_base_amount").c_str());
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			auto glyphBacking = tooltipFrame->findImage("glyph 1");
			glyphBacking->disabled = false;
			glyphBacking->path = getHoverTextString("icon_backing_path");
			glyphBacking->pos.x = padx + padxMid + 4;
			glyphBacking->pos.y = currentHeight + 6;
			glyphBacking->pos.w = 44;
			glyphBacking->pos.h = 44;

			auto glyphIcon = tooltipFrame->findImage("glyph 2");
			glyphIcon->disabled = false;
			glyphIcon->path = "";
			switch ( element )
			{
				case SHEET_STR:
					glyphIcon->path = getHoverTextString("icon_str_path");
					break;
				case SHEET_DEX:
					glyphIcon->path = getHoverTextString("icon_dex_path");
					break;
				case SHEET_CON:
					glyphIcon->path = getHoverTextString("icon_con_path");
					break;
				case SHEET_INT:
					glyphIcon->path = getHoverTextString("icon_int_path");
					break;
				case SHEET_PER:
					glyphIcon->path = getHoverTextString("icon_per_path");
					break;
				case SHEET_CHR:
					glyphIcon->path = getHoverTextString("icon_chr_path");
					break;
				default:
					break;
			}
			glyphIcon->pos.w = 24;
			glyphIcon->pos.h = 24;
			glyphIcon->pos.x = glyphBacking->pos.x + glyphBacking->pos.w / 2 - glyphIcon->pos.w / 2;
			glyphIcon->pos.y = glyphBacking->pos.y + glyphBacking->pos.h / 2 - glyphIcon->pos.h / 2;

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx / 2 + glyphBacking->pos.x + glyphBacking->pos.w;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid + glyphBacking->pos.x + glyphBacking->pos.w);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry1 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry1 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][2]; assert(entry);
			entryValue->setDisabled(false);
			int value = 0;
			char valueBuf[128] = "";
			switch ( element )
			{
				case SHEET_STR:
					value = stats[player.playernum]->STR;
					snprintf(valueBuf, sizeof(valueBuf), "%d STR", value);
					break;
				case SHEET_DEX:
					value = stats[player.playernum]->DEX;
					snprintf(valueBuf, sizeof(valueBuf), "%d DEX", value);
					break;
				case SHEET_CON:
					value = stats[player.playernum]->CON;
					snprintf(valueBuf, sizeof(valueBuf), "%d CON", value);
					break;
				case SHEET_INT:
					value = stats[player.playernum]->INT;
					snprintf(valueBuf, sizeof(valueBuf), "%d INT", value);
					break;
				case SHEET_PER:
					value = stats[player.playernum]->PER;
					snprintf(valueBuf, sizeof(valueBuf), "%d PER", value);
					break;
				case SHEET_CHR:
					value = stats[player.playernum]->CHR;
					snprintf(valueBuf, sizeof(valueBuf), "%d CHR", value);
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			entryValue->setText(valueBuf);
			SDL_Rect entryValuePos = entry->getSize();
			entryValue->setSize(entryValuePos);
			entryValue->setHJustify(Frame::justify_t::RIGHT);
			entryValue->setVJustify(Field::justify_t::TOP);

			/*auto txtValueBackingFrame = tooltipFrame->findFrame("txt value backing frame 1");
			SDL_Rect backingFramePos = entryValue->getSize();
			auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
				entryValue->getTextColor(), entryValue->getOutlineColor());
			longestValue = std::max(longestValue, txtValueGet->getWidth());
			backingFramePos.x = backingFramePos.x + backingFramePos.w;
			backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
			valueSizes[1] = std::make_pair(entryValue, backingFramePos);
			txtValueBackingFrame->setDisabled(false);*/
		}
		{
			currentHeight += 0;// padyMid / 2;
			auto entry = characterSheetTooltipTextFields[player.playernum][3]; assert(entry);
			entry->setDisabled(false);
			char buf[128] = "";
			snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_modified_amount").c_str());
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			auto glyphBacking = tooltipFrame->findImage("glyph 1");

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx / 2 + glyphBacking->pos.x + glyphBacking->pos.w;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid + glyphBacking->pos.x + glyphBacking->pos.w);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry3 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry3 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][4]; assert(entry);
			entryValue->setDisabled(false);
			char valueBuf[128] = "";
			int value = 0;
			switch ( element )
			{
				case SHEET_STR:
					value = statGetSTR(stats[player.playernum], players[player.playernum]->entity);
					value -= stats[player.playernum]->STR;
					snprintf(valueBuf, sizeof(valueBuf), "%+d STR", value);
					break;
				case SHEET_DEX:
					value = statGetDEX(stats[player.playernum], players[player.playernum]->entity);
					value -= stats[player.playernum]->DEX;
					snprintf(valueBuf, sizeof(valueBuf), "%+d DEX", value);
					break;
				case SHEET_CON:
					value = statGetCON(stats[player.playernum], players[player.playernum]->entity);
					value -= stats[player.playernum]->CON;
					snprintf(valueBuf, sizeof(valueBuf), "%+d CON", value);
					break;
				case SHEET_INT:
					value = statGetINT(stats[player.playernum], players[player.playernum]->entity);
					value -= stats[player.playernum]->INT;
					snprintf(valueBuf, sizeof(valueBuf), "%+d INT", value);
					break;
				case SHEET_PER:
					value = statGetPER(stats[player.playernum], players[player.playernum]->entity);
					value -= stats[player.playernum]->PER;
					snprintf(valueBuf, sizeof(valueBuf), "%+d PER", value);
					break;
				case SHEET_CHR:
					value = statGetCHR(stats[player.playernum], players[player.playernum]->entity);
					value -= stats[player.playernum]->CHR;
					snprintf(valueBuf, sizeof(valueBuf), "%+d CHR", value);
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			else if ( value > 0 )
			{
				entryValue->setColor(hudColors.characterSheetGreen);
			}
			entryValue->setText(valueBuf);
			SDL_Rect entryValuePos = entry->getSize();
			entryValue->setSize(entryValuePos);
			entryValue->setHJustify(Frame::justify_t::RIGHT);
			entryValue->setVJustify(Field::justify_t::TOP);

			/*auto txtValueBackingFrame = tooltipFrame->findFrame("txt value backing frame 2");
			SDL_Rect backingFramePos = entryValue->getSize();
			auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
				entryValue->getTextColor(), entryValue->getOutlineColor());
			longestValue = std::max(longestValue, txtValueGet->getWidth());
			backingFramePos.x = backingFramePos.x + backingFramePos.w;
			backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
			valueSizes[2] = std::make_pair(entryValue, backingFramePos);
			txtValueBackingFrame->setDisabled(false);*/
		}
		{
			// stat extra number display
			currentHeight += padyMid;
			auto entry = characterSheetTooltipTextFields[player.playernum][5]; assert(entry);
			entry->setDisabled(false);
			char buf[128] = "";
			if ( element == SHEET_STR )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_str_atk_bonus").c_str());
			}
			else if ( element == SHEET_DEX )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_dex_ranged_atk_bonus").c_str());
			}
			else if ( element == SHEET_CON )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_con_ac_bonus").c_str());
			}
			else if ( element == SHEET_PER )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_per_pierce_bonus").c_str());
			}
			else if ( element == SHEET_INT )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_int_pwr_bonus").c_str());
			}
			else if ( element == SHEET_CHR )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_chr_buying_bonus").c_str());
			}
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx + padxMid;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid * 2);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry5 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry5 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][6]; assert(entry);
			entryValue->setDisabled(false);
			char valueBuf[128] = "";
			int value = 0;
			switch ( element )
			{
				case SHEET_STR:
				{
					Sint32 STR = statGetSTR(stats[player.playernum], players[player.playernum]->entity);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_atk_value_format").c_str(), STR);
				}
					break;
				case SHEET_DEX:
				{
					Sint32 DEX = statGetDEX(stats[player.playernum], players[player.playernum]->entity);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_atk_value_format").c_str(), DEX);
				}
					break;
				case SHEET_CON:
				{
					Sint32 CON = statGetCON(stats[player.playernum], players[player.playernum]->entity);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_ac_value_format").c_str(), CON);
				}
					break;
				case SHEET_INT:
				{
					//real_t val = getBonusFromCasterOfSpellElement(players[player.playernum]->entity, stats[player.playernum], nullptr, SPELL_NONE) * 100.0;
					int INT = statGetINT(stats[player.playernum], players[player.playernum]->entity);
					real_t bonus = 0.0;
					if ( INT > 0 )
					{
						bonus += INT / 100.0;
					}
					real_t val = bonus * 100.0;
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_pwr_value_format").c_str(), val);
				}
					break;
				case SHEET_PER:
				{
					real_t val = std::min(std::max(statGetPER(stats[player.playernum], players[player.playernum]->entity) / 2, 0), 50);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_pierce_value_format").c_str(), val);
				}
					break;
				case SHEET_CHR:
				{
					real_t val = 1 / ((50 + stats[player.playernum]->getModifiedProficiency(PRO_TRADING)) / 150.f); // buy value
					real_t normalVal = val;
					//normalVal /= (1.f + statGetCHR(stats[player.playernum], players[player.playernum]->entity) / 20.f);
					normalVal = std::max(1.0, normalVal);

					int stat = stats[player.playernum]->CHR;
					stats[player.playernum]->CHR = 0;
					stats[player.playernum]->CHR -= statGetCHR(stats[player.playernum], players[player.playernum]->entity);
					real_t zeroVal = val;
					//zeroVal /= (1.f + statGetCHR(stats[player.playernum], players[player.playernum]->entity) / 20.f);
					zeroVal = std::max(1.0, zeroVal);
					stats[player.playernum]->CHR = stat;

					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_buying_value_format").c_str(), (zeroVal - normalVal) * 100.0);
				}
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			else if ( value > 0 )
			{
				entryValue->setColor(hudColors.characterSheetGreen);
			}
			entryValue->setText(valueBuf);
			entryValue->setSize(entry->getSize());
			entryValue->setHJustify(Frame::justify_t::LEFT);
			entryValue->setVJustify(Field::justify_t::TOP);

			auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][3];
			SDL_Rect backingFramePos = entryValue->getSize();
			auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
				entryValue->getTextColor(), entryValue->getOutlineColor());
			longestValue = std::max(longestValue, txtValueGet->getWidth());
			backingFramePos.x = backingFramePos.x + backingFramePos.w;
			backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
			valueSizes[3] = std::make_pair(entryValue, backingFramePos);
			txtValueBackingFrame->setDisabled(false);
		}
		if ( element == SHEET_STR || element == SHEET_DEX || element == SHEET_INT || element == SHEET_PER || element == SHEET_CHR )
		{
			// stat extra number display
			currentHeight += padyMid;
			auto entry = characterSheetTooltipTextFields[player.playernum][7]; assert(entry);
			entry->setDisabled(false);
			char buf[128] = "";

			if ( element == SHEET_STR )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_str_movement_bonus").c_str());
			}
			else if ( element == SHEET_DEX )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_dex_thrown_atk_bonus").c_str());
			}
			else if ( element == SHEET_INT )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_int_mp_regen_bonus").c_str());
			}
			else if ( element == SHEET_PER )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_per_light_bonus").c_str());
			}
			else if ( element == SHEET_CHR )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_chr_selling_bonus").c_str());
			}
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx + padxMid;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid * 2);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry7 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry7 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][8]; assert(entry);
			entryValue->setDisabled(false);
			char valueBuf[128] = "";
			int value = 0;
			switch ( element )
			{
				case SHEET_STR:
				{
					Sint32 STR = statGetSTR(stats[player.playernum], players[player.playernum]->entity);
					Sint32 DEX = statGetDEX(stats[player.playernum], players[player.playernum]->entity);
					real_t weightratio1 = player.movement.getWeightRatio(player.movement.getCharacterModifiedWeight(), 0);
					real_t weightratio2 = player.movement.getWeightRatio(player.movement.getCharacterModifiedWeight(), STR);
					real_t speedFactor1 = player.movement.getSpeedFactor(weightratio1, DEX);
					real_t speedFactor2 = player.movement.getSpeedFactor(weightratio2, DEX);
					real_t maxSpeed = player.movement.getMaximumSpeed();

					real_t noSTRPercent = 100.0 * speedFactor1 / std::fmax(.01, maxSpeed);
					real_t currentPercent = 100.0 * speedFactor2 / std::fmax(.01, maxSpeed);
					real_t displayValue = currentPercent - noSTRPercent;
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_movement_value_format").c_str(), displayValue);
				}
					break;
				case SHEET_DEX:
				{
					Sint32 DEX = statGetDEX(stats[player.playernum], players[player.playernum]->entity);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_atk_value_format").c_str(), DEX / 4);
				}
					break;
				case SHEET_CON:
					break;
				case SHEET_INT:
				{
					Sint32 oldINT = stats[player.playernum]->INT;
					stats[player.playernum]->INT += -statGetINT(stats[player.playernum], player.entity);
					real_t regenWithoutINT = getDisplayedMPRegen(player.entity, *stats[player.playernum], nullptr, nullptr);
					stats[player.playernum]->INT = oldINT;

					real_t regenTotal = getDisplayedMPRegen(player.entity, *stats[player.playernum], nullptr, nullptr);
					real_t regenStatSkill = regenTotal - regenWithoutINT;
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_mp_regen_value_format").c_str(), regenStatSkill);
				}
					break;
				case SHEET_PER:
				{
					const int PER = statGetPER(stats[player.playernum], players[player.playernum]->entity);
					const int range_bonus = std::min(std::max(0, PER / 5), 2);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_light_value_format").c_str(), range_bonus);
				}
					break;
				case SHEET_CHR:
				{
					real_t val = (50 + stats[player.playernum]->getModifiedProficiency(PRO_TRADING)) / 150.f; // sell value
					real_t normalVal = val;
					normalVal *= (1.f + statGetCHR(stats[player.playernum], players[player.playernum]->entity) / 20.f);
					normalVal = std::min(1.0, normalVal);

					int stat = stats[player.playernum]->CHR;
					stats[player.playernum]->CHR = 0;
					stats[player.playernum]->CHR -= statGetCHR(stats[player.playernum], players[player.playernum]->entity);
					real_t zeroVal = val;
					zeroVal *= (1.f + statGetCHR(stats[player.playernum], players[player.playernum]->entity) / 20.f);
					zeroVal = std::min(1.0, zeroVal);
					stats[player.playernum]->CHR = stat;

					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_selling_value_format").c_str(), (normalVal - zeroVal) * 100.0);
				}
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			else if ( value > 0 )
			{
				entryValue->setColor(hudColors.characterSheetGreen);
			}
			entryValue->setText(valueBuf);
			entryValue->setSize(entry->getSize());
			entryValue->setHJustify(Frame::justify_t::LEFT);
			entryValue->setVJustify(Field::justify_t::TOP);

			auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][4];
			SDL_Rect backingFramePos = entryValue->getSize();
			auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
				entryValue->getTextColor(), entryValue->getOutlineColor());
			longestValue = std::max(longestValue, txtValueGet->getWidth());
			backingFramePos.x = backingFramePos.x + backingFramePos.w;
			backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
			valueSizes[4] = std::make_pair(entryValue, backingFramePos);
			txtValueBackingFrame->setDisabled(false);
		}
		if ( element == SHEET_PER || element == SHEET_DEX )
		{
			// stat extra number display
			currentHeight += padyMid;
			auto entry = characterSheetTooltipTextFields[player.playernum][9]; assert(entry);
			entry->setDisabled(false);
			char buf[128] = "";
			if ( element == SHEET_DEX )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_dex_movement_bonus").c_str());
			}
			else if ( element == SHEET_PER )
			{
				snprintf(buf, sizeof(buf), "%s", getHoverTextString("stat_per_sneaking_bonus").c_str());
			}
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx + padxMid;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid * 2);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry9 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry9 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][10]; assert(entry);
			entryValue->setDisabled(false);
			char valueBuf[128] = "";
			int value = 0;
			switch ( element )
			{
				case SHEET_STR:
					break;
				case SHEET_DEX:
				{
					Sint32 STR = statGetSTR(stats[player.playernum], players[player.playernum]->entity);
					real_t weightratio = player.movement.getWeightRatio(player.movement.getCharacterModifiedWeight(), STR);
					Sint32 DEX = statGetDEX(stats[player.playernum], players[player.playernum]->entity);
					real_t speedFactor1 = player.movement.getSpeedFactor(weightratio, 0);
					real_t speedFactor2 = player.movement.getSpeedFactor(weightratio, DEX);
					real_t maxSpeed = player.movement.getMaximumSpeed();

					real_t noDEXPercent = 100.0 * speedFactor1 / std::fmax(.01, maxSpeed);
					real_t currentPercent = 100.0 * speedFactor2 / std::fmax(.01, maxSpeed);

					real_t displayValue = currentPercent - noDEXPercent;
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_movement_value_format").c_str(), displayValue);
				}
					break;
				case SHEET_CON:
					break;
				case SHEET_INT:
					break;
				case SHEET_PER:
				{
					const int PER = statGetPER(stats[player.playernum], players[player.playernum]->entity);
					const int range_bonus = std::min(std::max(0, PER / 5), 2);
					const int sneakingBonus = range_bonus + 2;
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("stat_light_value_format").c_str(), sneakingBonus);
				}
				break;
				case SHEET_CHR:
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			else if ( value > 0 )
			{
				entryValue->setColor(hudColors.characterSheetGreen);
			}
			entryValue->setText(valueBuf);
			entryValue->setSize(entry->getSize());
			entryValue->setHJustify(Frame::justify_t::LEFT);
			entryValue->setVJustify(Field::justify_t::TOP);

			auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][5];
			SDL_Rect backingFramePos = entryValue->getSize();
			auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
				entryValue->getTextColor(), entryValue->getOutlineColor());
			longestValue = std::max(longestValue, txtValueGet->getWidth());
			backingFramePos.x = backingFramePos.x + backingFramePos.w;
			backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
			valueSizes[5] = std::make_pair(entryValue, backingFramePos);
			txtValueBackingFrame->setDisabled(false);
		}

		for ( int index = 1; index <= NUM_CHARSHEET_TOOLTIP_BACKING_FRAMES; ++index )
		{
			auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][index];
			if ( txtValueBackingFrame->isDisabled() )
			{
				continue;
			}
			if ( valueSizes.find(index) == valueSizes.end() )
			{
				continue;
			}

			SDL_Rect valuePos = valueSizes[index].second;
			Field* entryValue = valueSizes[index].first;
			SDL_Rect entryValuePos = entryValue->getSize();
			entryValuePos.x = entryValuePos.x + entryValuePos.w;
			entryValuePos.w = (int)longestValue;
			entryValuePos.x -= entryValuePos.w;
			entryValuePos.x -= 8;
			entryValue->setSize(entryValuePos);

			valuePos.w = (int)longestValue + 16;
			valuePos.x -= (valuePos.w);
			valuePos.y -= 3;
			valuePos.h += 4;

			txtValueBackingFrame->setSize(valuePos);

			imageResizeToContainer9x9(txtValueBackingFrame, SDL_Rect{ 0, 0, valuePos.w, valuePos.h }, skillsheetEffectBackgroundImages);
		}

		{
			currentHeight += padyMid;

			div->pos.x = padx;
			div->pos.y = currentHeight;
			div->pos.w = txtPos.w;
			div->disabled = false;

			currentHeight += padyMid;

			auto entry = characterSheetTooltipTextFields[player.playernum][11]; assert(entry);
			entry->setDisabled(false);
			char buf[512] = "";

			std::string descTextFormatted = "\x1E ";
			for ( auto s : descText )
			{
				descTextFormatted += s;
				if ( s == '\n' )
				{
					descTextFormatted += "\x1E ";
				}
			}

			snprintf(buf, sizeof(buf), "%s", descTextFormatted.c_str());
			entry->setText(buf);

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w;
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry11 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry11 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(hudColors.characterSheetOffWhiteText);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);

			currentHeight += padyMid / 4;
			tooltipPos.h = pady1 + currentHeight + pady2;
		}

		tooltipPos.h = pady1 + currentHeight + pady2;
		if ( tooltipJustify == PANEL_JUSTIFY_RIGHT )
		{
			tooltipPos.x = pos.x - tooltipPos.w;
		}
		else
		{
			tooltipPos.x = pos.x;
		}
		tooltipPos.y = pos.y;

		tooltipFrame->setSize(tooltipPos);
		imageResizeToContainer9x9(tooltipFrame, SDL_Rect{ 0, 0, tooltipPos.w, tooltipPos.h },
			skillsheetEffectBackgroundImages);
	}
	else if ( element >= Player::CharacterSheet_t::SHEET_ATK && element <= Player::CharacterSheet_t::SHEET_WGT )
	{
		AttackHoverText_t attackHoverTextInfo;
		Sint32 attackPower = displayAttackPower(player.playernum, attackHoverTextInfo);

//#ifndef NDEBUG
//		if ( keystatus[SDLK_V] )
//		{
//			keystatus[SDLK_V] = 0;
//			messagePlayer(player.playernum, MESSAGE_DEBUG, "Remove this");
//			stats[player.playernum]->playerRace = RACE_AUTOMATON;
//			stats[player.playernum]->appearance = 0;
//		}
//		if ( keystatus[SDLK_B] )
//		{
//			keystatus[SDLK_B] = 0;
//			messagePlayer(player.playernum, MESSAGE_DEBUG, "Remove this");
//			stats[player.playernum]->playerRace = RACE_INSECTOID;
//			stats[player.playernum]->appearance = 0;
//		}
//#endif // !NDEBUG

		bool isAutomatonHTRegen = stats[player.playernum]->type == AUTOMATON;
		bool isInsectoidENRegen = (stats[player.playernum]->playerRace == RACE_INSECTOID && stats[player.playernum]->appearance == 0);

		auto tooltipTopLeft = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
		tooltipTopLeft->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TL_Blue_00.png";
		auto tooltipTop = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP].c_str());
		tooltipTop->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_T_Blue_00.png";
		auto tooltipTopRight = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
		tooltipTopRight->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TR_Blue_00.png";
		imageSetWidthHeight9x9(tooltipFrame, skillsheetEffectBackgroundImages);

		int maxWidth = 260;
		if ( getHoverTextString("attributes_max_tooltip_width") != defaultString )
		{
			maxWidth = std::max(0, std::stoi(getHoverTextString("attributes_max_tooltip_width")));
		}
		int minWidth = 0;
		if ( getHoverTextString("attributes_min_tooltip_width") != defaultString )
		{
			minWidth = std::max(0, std::stoi(getHoverTextString("attributes_min_tooltip_width")));
		}
		const int padx = 16;
		const int pady1 = 8;
		const int pady2 = 4;
		const int padxMid = 4;
		const int padyMid = 8;
		SDL_Rect tooltipPos = SDL_Rect{ 400, 0, maxWidth, 100 };

		std::string titleText = "";
		std::string descText = "";
		int value = 0;
		switch ( element )
		{
			case SHEET_ATK:
			{
				char descBuf[256];
				std::string skillName = "-";
				for ( auto& skill : player.skillSheet.skillSheetData.skillEntries )
				{
					if ( skill.skillId == attackHoverTextInfo.proficiency )
					{
						skillName = skill.name;
						break;
					}
				}
				titleText = getHoverTextString("attributes_atk_title");
				txtRightAlignHint->setText("");
				txtRightAlignHint->setDisabled(false);
				if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_UNARMED )
				{
					txtRightAlignHint->setText(getHoverTextString("attributes_atk_title_unarmed").c_str());
				}
				else if ( stats[player.playernum]->weapon )
				{
					Item* item = stats[player.playernum]->weapon;
					if ( item->type >= WOODEN_SHIELD && item->type < NUMITEMS )
					{
						char itemNameBuf[128];
						if ( itemCategory(item) == MAGICSTAFF )
						{
							snprintf(itemNameBuf, sizeof(itemNameBuf), "%s (%+d)", item->getName(), item->beatitude);
							std::string itemNameStr = itemNameBuf;
							capitalizeString(itemNameStr);
							txtRightAlignHint->setText(itemNameStr.c_str());
						}
						else
						{
							snprintf(itemNameBuf, sizeof(itemNameBuf), "%s %s (%+d)", 
								ItemTooltips.getItemStatusAdjective(item->type, item->status).c_str(), item->getName(), item->beatitude);
							txtRightAlignHint->setText(itemNameBuf);
						}
					}
				}
				if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_MELEE_WEAPON
					|| attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_WHIP )
				{
					snprintf(descBuf, sizeof(descBuf), getHoverTextString("attributes_atk_melee_desc").c_str(), skillName.c_str());
					descText = descBuf;
				}
				else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_UNARMED )
				{
					snprintf(descBuf, sizeof(descBuf), getHoverTextString("attributes_atk_unarmed_desc").c_str(), skillName.c_str());
					descText = descBuf;
				}
				else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_RANGED )
				{
					snprintf(descBuf, sizeof(descBuf), getHoverTextString("attributes_atk_ranged_desc").c_str(), skillName.c_str());
					descText = descBuf;
				}
				else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_THROWN )
				{
					snprintf(descBuf, sizeof(descBuf), getHoverTextString("attributes_atk_thrown_desc").c_str(), skillName.c_str());
					descText = descBuf;
				}
				else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_THROWN_GEM )
				{
					snprintf(descBuf, sizeof(descBuf), getHoverTextString("attributes_atk_gem_desc").c_str(), skillName.c_str());
					descText = descBuf;
				}
				else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_THROWN_POTION )
				{
					snprintf(descBuf, sizeof(descBuf), getHoverTextString("attributes_atk_potion_desc").c_str(), skillName.c_str());
					descText = descBuf;
				}
				else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_PICKAXE )
				{
					snprintf(descBuf, sizeof(descBuf), getHoverTextString("attributes_atk_pickaxe_desc").c_str());
					descText = descBuf;
				}
				else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_MAGICSTAFF )
				{
					snprintf(descBuf, sizeof(descBuf), getHoverTextString("attributes_atk_magicstaff_desc").c_str());
					descText = descBuf;
				}
				else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_TOOL )
				{
					snprintf(descBuf, sizeof(descBuf), getHoverTextString("attributes_atk_tool_desc").c_str());
					descText = descBuf;
				}
				else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_TOOL_TRAP )
				{
					snprintf(descBuf, sizeof(descBuf), getHoverTextString("attributes_atk_tinker_tool_desc").c_str());
					descText = descBuf;
				}
				else
				{
					descText = "";
				}
			}
				break;
			case SHEET_AC:
				titleText = getHoverTextString("attributes_ac_title");
				descText = getHoverTextString("attributes_ac_desc");
				break;
			case SHEET_POW:
				titleText = getHoverTextString("attributes_pwr_title");
				descText = getHoverTextString("attributes_pwr_desc");
				break;
			case SHEET_RES:
				titleText = getHoverTextString("attributes_res_title");
				descText = getHoverTextString("attributes_res_desc");
				break;
			case SHEET_RGN:
				titleText = getHoverTextString("attributes_rgn_hp_title");
				if ( !(svFlags & SV_FLAG_HUNGER) )
				{
					descText = getHoverTextString("attributes_rgn_hp_desc_no_hunger");
				}
				else
				{
					descText = getHoverTextString("attributes_rgn_hp_desc");
				}
				break;
			case SHEET_RGN_MP:
				if ( isAutomatonHTRegen )
				{
					titleText = getHoverTextString("attributes_rgn_ht_title");
					descText = getHoverTextString("attributes_rgn_ht_desc");
				}
				else if ( isInsectoidENRegen )
				{
					titleText = getHoverTextString("attributes_rgn_en_title");
					if ( !(svFlags & SV_FLAG_HUNGER) )
					{
						descText = getHoverTextString("attributes_rgn_en_desc_no_hunger");
					}
					else
					{
						descText = getHoverTextString("attributes_rgn_en_desc");
					}
				}
				else
				{
					titleText = getHoverTextString("attributes_rgn_mp_title");
					descText = getHoverTextString("attributes_rgn_mp_desc");
				}
				break;
			case SHEET_WGT:
				titleText = getHoverTextString("attributes_wgt_title");
				descText = getHoverTextString("attributes_wgt_desc");
				break;
			default:
				break;
		}

		txt->setText(titleText.c_str());
		SDL_Rect txtPos = SDL_Rect{ padx, pady1 - 2, maxWidth - padx * 2, 80 };
		txt->setSize(txtPos);
		if ( charsheetTooltipCache[player.playernum].textEntries[element].title != txt->getText() )
		{
			txt->reflowTextToFit(0);
			charsheetTooltipCache[player.playernum].textEntries[element].title = txt->getText();
		}
		txt->setColor(hudColors.characterSheetHeadingText);
		Font* actualFont = Font::get(txt->getFont());
		int txtHeight = txt->getNumTextLines() * actualFont->height(true);
		txtPos.h = txtHeight + 4;
		auto txtGet = Text::get(txt->getLongestLine().c_str(), txt->getFont(),
			txt->getTextColor(), txt->getOutlineColor());
		txtPos.w = txtGet->getWidth();
		txtPos.w = std::max(minWidth - padx * 2, txtPos.w);
		txt->setSize(txtPos);

		txtRightAlignHint->setSize(txtPos);
		txtRightAlignHint->setHJustify(Field::justify_t::RIGHT);

		tooltipPos.w = (txtPos.w + padx * 2);

		unsigned int longestValue = 0;
		std::map<int, std::pair<Field*, SDL_Rect>> valueSizes;

		int currentHeight = txtPos.y + (actualFont->height(true) * 1) + 2;
		const int extraTextHeightForLowerCharacters = 4;
		int currentTextFieldIndex = 1;
		int currentTextBackingFrameIndex = 1;

		char buf[128] = "";
		char valueBuf[128] = "";

		if ( element == SHEET_ATK && getAttackTooltipLines(player.playernum, attackHoverTextInfo, 1, buf, valueBuf)
			|| element != SHEET_ATK )
		{
			currentHeight += padyMid;
			auto entry = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entry->setDisabled(false);
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_ac_base").c_str());
					bool oldDefending = stats[player.playernum]->defending;
					stats[player.playernum]->defending = false;
					Sint32 armor = AC(stats[player.playernum]);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_ac_nobonus_format").c_str(), armor);
					stats[player.playernum]->defending = oldDefending;
				}
					break;
				case SHEET_POW:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_pwr_base").c_str());
					std::string tag = "MAGIC_SPELLPOWER_TOTAL";
					std::string formatValue = "%d";
					std::string pwrBonus = formatSkillSheetEffects(player.playernum, PRO_MAGIC, tag, formatValue);
					Sint32 pwr = 100 + std::stoi(pwrBonus);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_pwr_nobonus_format").c_str(), pwr);
				}
					break;
				case SHEET_RES:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_res_base").c_str());
					real_t resistance = 100.0 * Entity::getDamageTableMultiplier(player.entity, *stats[player.playernum], DAMAGE_TABLE_MAGIC);
					resistance /= (Entity::getMagicResistance(stats[player.playernum]) + 1);
					resistance = 100.0 - resistance;
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_res_nobonus_format").c_str(), (int)resistance);
				}
					break;
				case SHEET_RGN:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_hp_base").c_str());
					char hpbuf[32] = "";
					getDisplayedHPRegen(players[player.playernum]->entity, *stats[player.playernum], nullptr, hpbuf);
					if ( !(svFlags & SV_FLAG_HUNGER) )
					{
						snprintf(valueBuf, sizeof(valueBuf), "%s", hpbuf);
					}
					else
					{
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_nobonus_format").c_str(), hpbuf);
					}
				}
					break;
				case SHEET_RGN_MP:
				{
					char mpbuf[32] = "";
					real_t regen = getDisplayedMPRegen(players[player.playernum]->entity, *stats[player.playernum], nullptr, mpbuf);
					if ( isAutomatonHTRegen )
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_ht_base").c_str());
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_nobonus_format").c_str(), mpbuf);
					}
					else if ( isInsectoidENRegen )
					{
						if ( !(svFlags & SV_FLAG_HUNGER) )
						{
							snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_en_base").c_str());
							snprintf(valueBuf, sizeof(valueBuf), "%s", mpbuf);
						}
						else
						{
							snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_en_base").c_str());
							snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_en_nobonus_format").c_str(), mpbuf);
						}
					}
					else
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_mp_base").c_str());
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_nobonus_format").c_str(), mpbuf);
					}
				}
					break;
				case SHEET_WGT:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_wgt_base").c_str());
					int weight = player.movement.getCharacterWeight();
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_wgt_nobonus_format").c_str(), weight);
				}
					break;
				default:
					break;
			}
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			auto glyphBacking = tooltipFrame->findImage("glyph 1");
			glyphBacking->disabled = false;
			glyphBacking->path = getHoverTextString("icon_backing_path");
			glyphBacking->pos.x = padx + padxMid + 4;
			glyphBacking->pos.y = currentHeight + 6;
			glyphBacking->pos.w = 44;
			glyphBacking->pos.h = 44;

			auto glyphIcon = tooltipFrame->findImage("glyph 2");
			glyphIcon->disabled = false;
			glyphIcon->path = "";
			switch ( element )
			{
				case SHEET_ATK:
					if ( attackHoverTextInfo.proficiency == -1 )
					{
						glyphIcon->path = getHoverTextString("icon_atk_path");
					}
					else if (attackHoverTextInfo.proficiency >= 0 && attackHoverTextInfo.proficiency < NUMPROFICIENCIES )
					{
						for ( auto& skill : player.skillSheet.skillSheetData.skillEntries )
						{
							if ( skill.skillId == attackHoverTextInfo.proficiency )
							{
								if ( skillCapstoneUnlocked(player.playernum, attackHoverTextInfo.proficiency) )
								{
									glyphIcon->path = skill.skillIconPathLegend;
								}
								else
								{
									glyphIcon->path = skill.skillIconPath;
								}
								break;
							}
						}
						if ( stats[player.playernum]->getModifiedProficiency(attackHoverTextInfo.proficiency) >= SKILL_LEVEL_LEGENDARY )
						{
							glyphBacking->path = actionPromptBackingIconPath100;
						}
						else if ( stats[player.playernum]->getModifiedProficiency(attackHoverTextInfo.proficiency) >= SKILL_LEVEL_EXPERT )
						{
							glyphBacking->path = actionPromptBackingIconPath60;
						}
						else if ( stats[player.playernum]->getModifiedProficiency(attackHoverTextInfo.proficiency) >= SKILL_LEVEL_BASIC )
						{
							glyphBacking->path = actionPromptBackingIconPath20;
						}
						else
						{
							glyphBacking->path = actionPromptBackingIconPath00;
						}
					}
					break;
				case SHEET_AC:
					glyphIcon->path = getHoverTextString("icon_ac_path");
					for ( auto& skill : player.skillSheet.skillSheetData.skillEntries )
					{
						if ( skill.skillId == PRO_SHIELD )
						{
							if ( skillCapstoneUnlocked(player.playernum, PRO_SHIELD) )
							{
								glyphIcon->path = skill.skillIconPathLegend;
							}
							else
							{
								glyphIcon->path = skill.skillIconPath;
							}
							break;
						}
					}
					if ( stats[player.playernum]->getModifiedProficiency(PRO_SHIELD) >= SKILL_LEVEL_LEGENDARY )
					{
						glyphBacking->path = actionPromptBackingIconPath100;
					}
					else if ( stats[player.playernum]->getModifiedProficiency(PRO_SHIELD) >= SKILL_LEVEL_EXPERT )
					{
						glyphBacking->path = actionPromptBackingIconPath60;
					}
					else if ( stats[player.playernum]->getModifiedProficiency(PRO_SHIELD) >= SKILL_LEVEL_BASIC )
					{
						glyphBacking->path = actionPromptBackingIconPath20;
					}
					else
					{
						glyphBacking->path = actionPromptBackingIconPath00;
					}
					break;
				case SHEET_POW:
					glyphIcon->path = getHoverTextString("icon_pwr_path");
					break;
				case SHEET_RES:
					glyphIcon->path = getHoverTextString("icon_res_path");
					break;
				case SHEET_RGN:
					glyphIcon->path = getHoverTextString("icon_rgn_hp_path");
					break;
				case SHEET_RGN_MP:
					if ( isAutomatonHTRegen )
					{
						if ( stats[player.playernum]->HUNGER <= 300 )
						{
							glyphIcon->path = getHoverTextString("icon_rgn_ht_empty_path");
						}
						else if ( stats[player.playernum]->HUNGER > 1200 )
						{
							glyphIcon->path = getHoverTextString("icon_rgn_ht_superheated_path");
						}
						else
						{
							glyphIcon->path = getHoverTextString("icon_rgn_ht_normal_path");
						}
					}
					else
					{
						glyphIcon->path = getHoverTextString("icon_rgn_mp_path");
					}
					break;
				case SHEET_WGT:
					glyphIcon->path = getHoverTextString("icon_wgt_path");
					break;
				default:
					break;
			}
			glyphIcon->pos.w = 24;
			glyphIcon->pos.h = 24;
			glyphIcon->pos.x = glyphBacking->pos.x + glyphBacking->pos.w / 2 - glyphIcon->pos.w / 2;
			glyphIcon->pos.y = glyphBacking->pos.y + glyphBacking->pos.h / 2 - glyphIcon->pos.h / 2;

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx / 2 + glyphBacking->pos.x + glyphBacking->pos.w;
			entryPos.y = currentHeight;
			if ( element == SHEET_ATK )
			{
				if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_THROWN
					|| attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_THROWN_GEM
					|| attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_PICKAXE )
				{
					// fewer lines, add offset to centre the lines with the glyph
					entryPos.y += 8;
				}
				else if ( attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_DEFAULT
					|| attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_TOOL
					|| attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_TOOL_TRAP
					|| attackHoverTextInfo.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_MAGICSTAFF )
				{
					entryPos.y += 16;
				}
			}
			else if ( element == SHEET_RGN_MP && isInsectoidENRegen )
			{
				entryPos.y += 16;
			}
			entryPos.w = txtPos.w - (padxMid + glyphBacking->pos.x + glyphBacking->pos.w);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry1 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry1 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entryValue->setDisabled(false);
			int value = 0;
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
					break;
				case SHEET_POW:
					break;
				case SHEET_RES:
					break;
				case SHEET_RGN:
					break;
				case SHEET_WGT:
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			entryValue->setText(valueBuf);
			SDL_Rect entryValuePos = entry->getSize();
			entryValue->setSize(entryValuePos);
			entryValue->setHJustify(Frame::justify_t::RIGHT);
			entryValue->setVJustify(Field::justify_t::TOP);

			/*auto txtValueBackingFrame = tooltipFrame->findFrame("txt value backing frame 1");
			SDL_Rect backingFramePos = entryValue->getSize();
			auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
				entryValue->getTextColor(), entryValue->getOutlineColor());
			longestValue = std::max(longestValue, txtValueGet->getWidth());
			backingFramePos.x = backingFramePos.x + backingFramePos.w;
			backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
			valueSizes[1] = std::make_pair(entryValue, backingFramePos);
			txtValueBackingFrame->setDisabled(false);*/
			++currentTextBackingFrameIndex;
		}

		if ( element == SHEET_ATK && getAttackTooltipLines(player.playernum, attackHoverTextInfo, 2, buf, valueBuf)
			|| element != SHEET_ATK )
		{
			currentHeight += 0;
			auto entry = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entry->setDisabled(false);
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
				{
					std::string skillName = "";
					int skillLVL = 0;
					for ( auto& skill : player.skillSheet.skillSheetData.skillEntries )
					{
						if ( skill.skillId == PRO_SHIELD )
						{
							skillName = skill.name;
							skillLVL = stats[player.playernum]->getModifiedProficiency(skill.skillId);
							break;
						}
					}
					snprintf(buf, sizeof(buf), getHoverTextString("attributes_ac_defending").c_str(), skillName.c_str(), skillLVL);
					std::string tag = "BLOCK_AC_INCREASE";
					std::string blockBonus = formatSkillSheetEffects(player.playernum, PRO_SHIELD, tag, getHoverTextString("attributes_ac_bonus_format"));
					snprintf(valueBuf, sizeof(valueBuf), "%s", blockBonus.c_str());
				}
					break;
				case SHEET_POW:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_pwr_spellbook").c_str());
					std::string tag = "MAGIC_SPELLPOWER_INT";
					std::string formatValue = "%d";
					std::string pwrBonus = formatSkillSheetEffects(player.playernum, PRO_MAGIC, tag, formatValue);
					Sint32 pwr = std::stoi(pwrBonus) / 2;
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_pwr_bonus_format").c_str(), pwr);
				}
					break;
				case SHEET_RES:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_res_sources").c_str());
					int sources = Entity::getMagicResistance(stats[player.playernum]);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_res_sources_format").c_str(), sources);
				}
					break;
				case SHEET_RGN:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_sources").c_str());
					int sources = Entity::getHealringFromEquipment(players[player.playernum]->entity, *stats[player.playernum], true);
					sources += Entity::getHealringFromEffects(players[player.playernum]->entity, *stats[player.playernum]);
					sources = std::min(sources, 3);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_hp_sources_format").c_str(), sources);
				}
					break;
				case SHEET_RGN_MP:
				{
					if ( isInsectoidENRegen )
					{
						//snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_en_sources").c_str());
						snprintf(buf, sizeof(buf), "");
						snprintf(valueBuf, sizeof(valueBuf), "");
					}
					else
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_sources").c_str());
						int sources = Entity::getManaringFromEquipment(players[player.playernum]->entity, *stats[player.playernum], true);
						sources += Entity::getManaringFromEffects(players[player.playernum]->entity, *stats[player.playernum]);
						sources = std::min(sources, 3);
						if ( isAutomatonHTRegen )
						{
							snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_ht_sources_format").c_str(), sources);
						}
						else
						{
							snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_mp_sources_format").c_str(), sources);
						}
					}
				}
					break;
				case SHEET_WGT:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_wgt_movement_speed").c_str());
					int weight = player.movement.getCharacterModifiedWeight();
					Sint32 STR = statGetSTR(stats[player.playernum], player.entity);
					Sint32 DEX = statGetDEX(stats[player.playernum], player.entity);
					real_t currentSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(weight, STR), DEX);
					real_t maxSpeed = player.movement.getMaximumSpeed();
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_wgt_speed_format").c_str(), 
						100.0 * currentSpeed / std::fmax(.01, maxSpeed));
				}
					break;
				default:
					break;
			}
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			auto glyphBacking = tooltipFrame->findImage("glyph 1");

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx / 2 + glyphBacking->pos.x + glyphBacking->pos.w;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid + glyphBacking->pos.x + glyphBacking->pos.w);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry2 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry2 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);

			if ( strcmp(buf, "") )
			{
				// don't modify height if this is an empty line
				currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			}
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entryValue->setDisabled(false);
			int value = 0;
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
					break;
				case SHEET_POW:
					break;
				case SHEET_RES:
					break;
				case SHEET_RGN:
					break;
				case SHEET_WGT:
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			else if ( value > 0 )
			{
				entryValue->setColor(hudColors.characterSheetGreen);
			}
			entryValue->setText(valueBuf);
			SDL_Rect entryValuePos = entry->getSize();
			entryValue->setSize(entryValuePos);
			entryValue->setHJustify(Frame::justify_t::RIGHT);
			entryValue->setVJustify(Field::justify_t::TOP);

			/*auto txtValueBackingFrame = tooltipFrame->findFrame("txt value backing frame 2");
			SDL_Rect backingFramePos = entryValue->getSize();
			auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
				entryValue->getTextColor(), entryValue->getOutlineColor());
			longestValue = std::max(longestValue, txtValueGet->getWidth());
			backingFramePos.x = backingFramePos.x + backingFramePos.w;
			backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
			valueSizes[2] = std::make_pair(entryValue, backingFramePos);
			txtValueBackingFrame->setDisabled(false);*/
			++currentTextBackingFrameIndex;
		}
		bool hasEntryInfoLines = false;
		if ( element == SHEET_ATK && getAttackTooltipLines(player.playernum, attackHoverTextInfo, 3, buf, valueBuf)
			|| (element != SHEET_ATK 
				&& !(element == SHEET_RGN && !(svFlags & SV_FLAG_HUNGER))
				&& !(element == SHEET_RGN_MP && isInsectoidENRegen && !(svFlags & SV_FLAG_HUNGER))
				))
		{
			// extra number display - line 3
			hasEntryInfoLines = true;
			if ( element == SHEET_ATK || element == SHEET_AC || element == SHEET_POW || element == SHEET_RES || element == SHEET_RGN
				|| element == SHEET_RGN_MP || element == SHEET_WGT )
			{
				if ( element == SHEET_RGN_MP && isInsectoidENRegen )
				{
					currentHeight += 8;
				}

				// add a divider
				div2->pos.x = padx;
				div2->pos.y = currentHeight + 2 + actualFont->height(true);
				div2->pos.w = txtPos.w;
				div2->disabled = false;

				auto entryTotalHeading = characterSheetTooltipTextFields[player.playernum][16]; assert(entryTotalHeading);
				entryTotalHeading->setDisabled(false);
				if ( element == SHEET_ATK )
				{
					entryTotalHeading->setText(getHoverTextString("attributes_atk_total_sum_header").c_str());
				}
				else if ( element == SHEET_AC )
				{
					entryTotalHeading->setText(getHoverTextString("attributes_ac_base_sum_header").c_str());
				}
				else if ( element == SHEET_POW )
				{
					entryTotalHeading->setText(getHoverTextString("attributes_pwr_base_sum_header").c_str());
				}
				else if ( element == SHEET_RES )
				{
					entryTotalHeading->setText(getHoverTextString("attributes_res_base_sum_header").c_str());
				}
				else if ( element == SHEET_RGN )
				{
					entryTotalHeading->setText(getHoverTextString("attributes_rgn_hp_base_sum_header").c_str());
				}
				else if ( element == SHEET_RGN_MP )
				{
					if ( isAutomatonHTRegen )
					{
						entryTotalHeading->setText(getHoverTextString("attributes_rgn_ht_base_sum_header").c_str());
					}
					else if ( isInsectoidENRegen )
					{
						entryTotalHeading->setText(getHoverTextString("attributes_rgn_en_base_sum_header").c_str());
					}
					else
					{
						entryTotalHeading->setText(getHoverTextString("attributes_rgn_mp_base_sum_header").c_str());
					}
				}
				else if ( element == SHEET_WGT )
				{
					entryTotalHeading->setText(getHoverTextString("attributes_wgt_base_sum_header").c_str());
				}
				entryTotalHeading->setColor(hudColors.characterSheetOffWhiteText);
				entryTotalHeading->setHJustify(Field::justify_t::RIGHT);
				SDL_Rect entryPos = entryTotalHeading->getSize();
				entryPos.x = padx + padxMid;
				entryPos.y = currentHeight + 1 - (extraTextHeightForLowerCharacters / 2);
				entryPos.w = txtPos.w - (padxMid * 2);
				entryPos.h = actualFont->height(true) + extraTextHeightForLowerCharacters;
				entryTotalHeading->setSize(entryPos);

				currentHeight += actualFont->height(true) + 2; // extra gap here for 'total' text.
			}
			currentHeight += padyMid;
			auto entry = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entry->setDisabled(false);
			int value = 0;
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_ac_entry_attr_bonus").c_str());
					Sint32 CON = statGetCON(stats[player.playernum], players[player.playernum]->entity);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_ac_bonus_format").c_str(), CON);
				}
					break;
				case SHEET_POW:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_pwr_base_value").c_str());
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_pwr_bonus_format").c_str(), 100);
				}
					break;
				case SHEET_RES:
				{
					Monster type = stats[player.playernum]->type;
					std::string appearance = "";
					bool aestheticOnly = false;
					if ( player.entity )
					{
						if ( player.entity->effectPolymorph == NOTHING && stats[player.playernum]->playerRace > RACE_HUMAN )
						{
							if ( stats[player.playernum]->appearance != 0 )
							{
								aestheticOnly = true;
								appearance = Language::get(4068);
								type = player.entity->getMonsterFromPlayerRace(stats[player.playernum]->playerRace);
							}
						}
					}
					std::string race = getMonsterLocalizedName(type).c_str();
					capitalizeString(race);

					snprintf(buf, sizeof(buf), getHoverTextString("attributes_res_base_value").c_str(), race.c_str());
					Sint32 baseResist = damagetables[stats[player.playernum]->type][DAMAGE_TABLE_MAGIC] * 100;
					baseResist = 100 - baseResist;
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_res_bonus_format").c_str(), baseResist);
				}
					break;
				case SHEET_RGN:
				{
					Monster type = stats[player.playernum]->type;
					bool aestheticOnly = false;
					if ( player.entity )
					{
						if ( player.entity->effectPolymorph == NOTHING && stats[player.playernum]->playerRace > RACE_HUMAN )
						{
							if ( stats[player.playernum]->appearance != 0 )
							{
								aestheticOnly = true;
								type = player.entity->getMonsterFromPlayerRace(stats[player.playernum]->playerRace);
							}
						}
					}
					std::string race = getMonsterLocalizedName(type).c_str();
					capitalizeString(race);

					snprintf(buf, sizeof(buf), getHoverTextString("attributes_rgn_base_value").c_str(), race.c_str());
					real_t regen = 100.0;
					if ( type == SKELETON )
					{
						regen = 25.0;
					}
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_bonus_format").c_str(), regen);
				}
					break;
				case SHEET_RGN_MP:
				{
					if ( isAutomatonHTRegen )
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_ht_base_bonus").c_str());
						real_t baseHTModifier = 100.f;
						if ( stats[player.playernum]->HUNGER <= 300 )
						{
							int baseTime = getBaseManaRegen(player.entity, *stats[player.playernum]);
							real_t scaledInterval = ((60 * baseTime) / (std::max(stats[player.playernum]->MAXMP, 1)));
							baseHTModifier = scaledInterval / TICKS_PER_SECOND;
							baseHTModifier /= -6.0; // degrade faster
							real_t nominalRegen = MAGIC_REGEN_TIME / TICKS_PER_SECOND;
							baseHTModifier = (nominalRegen / baseHTModifier) * 100.0;
						}
						else if ( stats[player.playernum]->HUNGER > 1200 )
						{
							if ( stats[player.playernum]->MP / static_cast<real_t>(std::max(1, stats[player.playernum]->MAXMP)) <= 0.5 )
							{
								baseHTModifier *= 4; // increase faster at < 50% mana
							}
							else
							{
								baseHTModifier *= 2; // increase less faster at > 50% mana
							}
						}
						else
						{
							// normal manaRegenInterval 300-1200 hunger.
						}
						//baseHTModifier /= 100.0;
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_ht_bonus_format").c_str(), baseHTModifier);
					}
					else if ( isInsectoidENRegen )
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_en_base_bonus").c_str());

						real_t normalRegenTime = (1000.f * 30 * 1.5) / static_cast<float>(TICKS_PER_SECOND); // 30 base, insectoid does 1.5x in getHungerTickRate()
						//normalRegenTime = (1000.f * (Entity::getHungerTickRate(stats[player.playernum], true, true)) / static_cast<float>(TICKS_PER_SECOND));
						normalRegenTime /= (std::max(stats[player.playernum]->MAXMP, 1)); // time for 1 mana in seconds
						normalRegenTime *= TICKS_PER_SECOND; // game ticks for 1 mana

						real_t modifiedRegenTime = (1000.f * (Entity::getHungerTickRate(stats[player.playernum], true, false)) / static_cast<float>(TICKS_PER_SECOND));
						modifiedRegenTime /= (std::max(stats[player.playernum]->MAXMP, 1)); // time for 1 mana in seconds
						modifiedRegenTime *= TICKS_PER_SECOND; // game ticks for 1 mana

						real_t displayValue = 100.0 * (normalRegenTime / modifiedRegenTime);

						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_en_bonus_format").c_str(), displayValue);
					}
					else
					{
						Monster type = stats[player.playernum]->type;
						bool aestheticOnly = false;
						if ( player.entity )
						{
							if ( player.entity->effectPolymorph == NOTHING && stats[player.playernum]->playerRace > RACE_HUMAN )
							{
								if ( stats[player.playernum]->appearance != 0 )
								{
									aestheticOnly = true;
									type = player.entity->getMonsterFromPlayerRace(stats[player.playernum]->playerRace);
								}
							}
						}
						std::string race = getMonsterLocalizedName(type).c_str();
						capitalizeString(race);

						snprintf(buf, sizeof(buf), getHoverTextString("attributes_rgn_base_value").c_str(), race.c_str());
						real_t regen = 100.0;
						if ( type == SKELETON )
						{
							regen = 25.0;
						}
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_bonus_format").c_str(), regen);
					}
				}
				break;
				case SHEET_WGT:
				{
					int weight = player.movement.getCharacterModifiedWeight();
					//int equippedWeightTotal = player.movement.getCharacterEquippedWeight();
					//int equippedWeight = player.movement.getCharacterModifiedWeight(&equippedWeightTotal);
					//int goldWeightTotal = stats[player.playernum]->GOLD / 100;
					//int goldWeight = player.movement.getCharacterModifiedWeight(&goldWeightTotal);
					Sint32 STR = statGetSTR(stats[player.playernum], player.entity);
					Sint32 DEX = statGetDEX(stats[player.playernum], player.entity);
					//real_t currentEquippedSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(equippedWeight, STR), DEX);
					real_t currentSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(weight, STR), DEX);
					real_t noWeightSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(0, STR), DEX);
					//real_t goldSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(goldWeight, STR), DEX);
					real_t maxSpeed = player.movement.getMaximumSpeed();

					real_t currentSpeedPercent = 100.0 * currentSpeed / std::fmax(.01, maxSpeed);
					//real_t currentEquippedSpeedPercent = 100.0 * currentEquippedSpeed / std::fmax(.01, maxSpeed);
					real_t noWeightSpeedPercent = 100.0 * noWeightSpeed / std::fmax(.01, maxSpeed);
					//real_t goldSpeedPercent = 100.0 * goldSpeed / std::fmax(.01, maxSpeed);

					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_wgt_attributes_bonus").c_str());
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_wgt_speed_bonus_format").c_str(),
						currentSpeedPercent + (noWeightSpeedPercent - currentSpeedPercent) /*+ (goldSpeedPercent - noWeightSpeedPercent)*/);
				}
					break;
				default:
					break;
			}
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx + padxMid;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid * 2);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry3 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry3 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entryValue->setDisabled(false);
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
					break;
				case SHEET_POW:
					break;
				case SHEET_RES:
					break;
				case SHEET_RGN:
					break;
				case SHEET_WGT:
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			else if ( value > 0 )
			{
				entryValue->setColor(hudColors.characterSheetGreen);
			}
			entryValue->setText(valueBuf);
			entryValue->setSize(entry->getSize());
			entryValue->setHJustify(Frame::justify_t::LEFT);
			entryValue->setVJustify(Field::justify_t::TOP);

			auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][currentTextBackingFrameIndex];
			SDL_Rect backingFramePos = entryValue->getSize();
			auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
				entryValue->getTextColor(), entryValue->getOutlineColor());
			longestValue = std::max(longestValue, txtValueGet->getWidth());
			backingFramePos.x = backingFramePos.x + backingFramePos.w;
			backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
			valueSizes[currentTextBackingFrameIndex] = std::make_pair(entryValue, backingFramePos);
			txtValueBackingFrame->setDisabled(false);
			++currentTextBackingFrameIndex;
		}

		if ( (element == SHEET_ATK && getAttackTooltipLines(player.playernum, attackHoverTextInfo, 4, buf, valueBuf))
			|| (element != SHEET_ATK 
				&& !(element == SHEET_RGN && !(svFlags & SV_FLAG_HUNGER))
				&& !(element == SHEET_RGN_MP && isInsectoidENRegen && !(svFlags & SV_FLAG_HUNGER))
				)
			)
		{
			// extra number display - line 4
			hasEntryInfoLines = true;
			currentHeight += padyMid;
			auto entry = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entry->setDisabled(false);
			int value = 0;
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_ac_entry_items_bonus").c_str());
					Sint32 CON = statGetCON(stats[player.playernum], players[player.playernum]->entity);

					Sint32 oldSkillLVL = stats[player.playernum]->getProficiency(PRO_SHIELD);
					bool oldDefending = stats[player.playernum]->defending;
					stats[player.playernum]->defending = false;
					stats[player.playernum]->setProficiencyUnsafe(PRO_SHIELD, -999);

					Sint32 armor = AC(stats[player.playernum]);
					stats[player.playernum]->defending = oldDefending;
					stats[player.playernum]->setProficiency(PRO_SHIELD, oldSkillLVL);

					Sint32 itemsEffectBonus = armor - CON;
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_ac_bonus_format").c_str(), itemsEffectBonus);
				}
					break;
				case SHEET_POW:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_pwr_entry_attr_bonus").c_str());
					std::string tag = "MAGIC_SPELLPOWER_INT";
					std::string pwrINTBonus = formatSkillSheetEffects(player.playernum, PRO_MAGIC, tag, getHoverTextString("attributes_pwr_bonus_format"));
					snprintf(valueBuf, sizeof(valueBuf), "%s", pwrINTBonus.c_str());
				}
					break;
				case SHEET_RES:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_res_entry_items_bonus").c_str());
					Sint32 baseResist = 100 * damagetables[stats[player.playernum]->type][DAMAGE_TABLE_MAGIC];
					baseResist = 100 - baseResist;
					real_t resistance = 100.0 * Entity::getDamageTableMultiplier(player.entity, *stats[player.playernum], DAMAGE_TABLE_MAGIC);
					resistance /= (Entity::getMagicResistance(stats[player.playernum]) + 1);
					resistance = (100.0 - resistance);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_res_bonus_format").c_str(), (int)resistance - baseResist);
				}
					break;
				case SHEET_RGN:
				{
					Monster type = stats[player.playernum]->type;
					bool aestheticOnly = false;
					if ( player.entity )
					{
						if ( player.entity->effectPolymorph == NOTHING && stats[player.playernum]->playerRace > RACE_HUMAN )
						{
							if ( stats[player.playernum]->appearance != 0 )
							{
								aestheticOnly = true;
								type = player.entity->getMonsterFromPlayerRace(stats[player.playernum]->playerRace);
							}
						}
					}
					real_t baseRegen = 100.0;
					if ( type == SKELETON )
					{
						baseRegen = 25.0;
					}

					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_entry_items_bonus").c_str());
					real_t regen = getDisplayedHPRegen(player.entity, *stats[player.playernum], nullptr, nullptr);
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_bonus_format").c_str(), regen - baseRegen);
				}
					break;
				case SHEET_RGN_MP:
				{
					if ( isAutomatonHTRegen )
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_entry_items_bonus").c_str());
						real_t baseHTModifier = 100.f;
						if ( stats[player.playernum]->HUNGER <= 300 )
						{
							int baseTime = getBaseManaRegen(player.entity, *stats[player.playernum]);
							real_t scaledInterval = ((60 * baseTime) / (std::max(stats[player.playernum]->MAXMP, 1)));
							baseHTModifier = scaledInterval / TICKS_PER_SECOND;
							baseHTModifier /= -6.0; // degrade faster
							real_t nominalRegen = MAGIC_REGEN_TIME / TICKS_PER_SECOND;
							baseHTModifier = (nominalRegen / baseHTModifier) * 100.0;
						}
						else if ( stats[player.playernum]->HUNGER > 1200 )
						{
							if ( stats[player.playernum]->MP / static_cast<real_t>(std::max(1, stats[player.playernum]->MAXMP)) <= 0.5 )
							{
								baseHTModifier *= 4; // increase faster at < 50% mana
							}
							else
							{
								baseHTModifier *= 2; // increase less faster at > 50% mana
							}
						}
						else
						{
							// normal manaRegenInterval 300-1200 hunger.
						}
						real_t regenTotal = getDisplayedMPRegen(player.entity, *stats[player.playernum], nullptr, nullptr);
						real_t displayTotal = (regenTotal - baseHTModifier);
						//displayTotal /= 100.0;
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_ht_bonus_format").c_str(), displayTotal);
					}
					else if ( isInsectoidENRegen )
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_en_entry_items_bonus").c_str());

						real_t normalRegenTime = (1000.f * 30 * 1.5) / static_cast<float>(TICKS_PER_SECOND); // 30 base, insectoid does 1.5x in getHungerTickRate()
						normalRegenTime /= (std::max(stats[player.playernum]->MAXMP, 1)); // time for 1 mana in seconds
						normalRegenTime *= TICKS_PER_SECOND; // game ticks for 1 mana

						real_t modifiedRegenTime = (1000.f * (Entity::getHungerTickRate(stats[player.playernum], true, false)) / static_cast<float>(TICKS_PER_SECOND));
						modifiedRegenTime /= (std::max(stats[player.playernum]->MAXMP, 1)); // time for 1 mana in seconds
						modifiedRegenTime *= TICKS_PER_SECOND; // game ticks for 1 mana

						real_t baseValue = 100.0 * (normalRegenTime / modifiedRegenTime);
						real_t displayedValue = getDisplayedMPRegen(player.entity, *stats[player.playernum], nullptr, nullptr);

						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_en_bonus_format").c_str(), displayedValue - baseValue);
					}
					else
					{
						Monster type = stats[player.playernum]->type;
						bool aestheticOnly = false;
						if ( player.entity )
						{
							if ( player.entity->effectPolymorph == NOTHING && stats[player.playernum]->playerRace > RACE_HUMAN )
							{
								if ( stats[player.playernum]->appearance != 0 )
								{
									aestheticOnly = true;
									type = player.entity->getMonsterFromPlayerRace(stats[player.playernum]->playerRace);
								}
							}
						}
						real_t baseRegen = 100.0;
						if ( type == SKELETON )
						{
							baseRegen = 25.0;
						}

						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_entry_items_bonus").c_str());
						Sint32 oldINT = stats[player.playernum]->INT;
						stats[player.playernum]->INT += -statGetINT(stats[player.playernum], player.entity);
						real_t regenWithoutINT = getDisplayedMPRegen(player.entity, *stats[player.playernum], nullptr, nullptr);
						stats[player.playernum]->INT = oldINT;
						real_t regenTotal = getDisplayedMPRegen(player.entity, *stats[player.playernum], nullptr, nullptr);
						real_t regenStatSkill = regenTotal - regenWithoutINT;

						real_t regenItemsEffects = regenTotal - regenStatSkill - baseRegen;
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_bonus_format").c_str(), regenItemsEffects);
					}
				}
					break;
				case SHEET_WGT:
				{
					int weight = player.movement.getCharacterModifiedWeight();
					int equippedWeightTotal = player.movement.getCharacterEquippedWeight();
					int equippedWeight = player.movement.getCharacterModifiedWeight(&equippedWeightTotal);
					Sint32 STR = statGetSTR(stats[player.playernum], player.entity);
					Sint32 DEX = statGetDEX(stats[player.playernum], player.entity);
					real_t currentEquippedSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(equippedWeight, STR), DEX);
					//real_t currentSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(weight, STR), DEX);
					real_t noWeightSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(0, STR), DEX);
					real_t maxSpeed = player.movement.getMaximumSpeed();

					//real_t currentSpeedPercent = 100.0 * currentSpeed / std::fmax(.01, maxSpeed);
					real_t currentEquippedSpeedPercent = 100.0 * currentEquippedSpeed / std::fmax(.01, maxSpeed);
					real_t noWeightSpeedPercent = 100.0 * noWeightSpeed / std::fmax(.01, maxSpeed);

					real_t displayValue = (currentEquippedSpeedPercent - noWeightSpeedPercent);
					if ( displayValue >= 0.0 )
					{
						displayValue = -.000001; // so there is a negative sign
					}

					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_wgt_equipment_value").c_str());
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_wgt_speed_bonus_format").c_str(),
						displayValue);
				}
					break;
				default:
					break;
			}
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx + padxMid;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid * 2);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry4 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry4 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entryValue->setDisabled(false);
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
					break;
				case SHEET_POW:
					break;
				case SHEET_RES:
					break;
				case SHEET_RGN:
					break;
				case SHEET_WGT:
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			else if ( value > 0 )
			{
				entryValue->setColor(hudColors.characterSheetGreen);
			}
			entryValue->setText(valueBuf);
			entryValue->setSize(entry->getSize());
			entryValue->setHJustify(Frame::justify_t::LEFT);
			entryValue->setVJustify(Field::justify_t::TOP);

			auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][currentTextBackingFrameIndex];
			SDL_Rect backingFramePos = entryValue->getSize();
			auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
				entryValue->getTextColor(), entryValue->getOutlineColor());
			longestValue = std::max(longestValue, txtValueGet->getWidth());
			backingFramePos.x = backingFramePos.x + backingFramePos.w;
			backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
			valueSizes[4] = std::make_pair(entryValue, backingFramePos);
			txtValueBackingFrame->setDisabled(false);
			++currentTextBackingFrameIndex;
		}

		if ( element == SHEET_ATK && getAttackTooltipLines(player.playernum, attackHoverTextInfo, 5, buf, valueBuf)
			|| (element != SHEET_ATK 
				&& element != SHEET_RES 
				&& !(element == SHEET_RGN && !(svFlags & SV_FLAG_HUNGER))
				&& !(element == SHEET_RGN_MP && isInsectoidENRegen && !(svFlags & SV_FLAG_HUNGER))
				) 
			)
		{
			// extra number display - line 5
			hasEntryInfoLines = true;
			currentHeight += padyMid;
			auto entry = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entry->setDisabled(false);
			int value = 0;
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_ac_passive_bonus").c_str());

					Sint32 oldSkillLVL = stats[player.playernum]->getProficiency(PRO_SHIELD);
					bool oldDefending = stats[player.playernum]->defending;
					stats[player.playernum]->defending = false;

					Sint32 armor = AC(stats[player.playernum]);
					stats[player.playernum]->setProficiencyUnsafe(PRO_SHIELD, -999);
					Sint32 armorNoSkill = AC(stats[player.playernum]);
					stats[player.playernum]->setProficiency(PRO_SHIELD, oldSkillLVL);
					stats[player.playernum]->defending = oldDefending;

					Sint32 passiveBonus = armor - armorNoSkill;
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_ac_bonus_format").c_str(), passiveBonus);
				}
					break;
				case SHEET_POW:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_pwr_entry_items_bonus").c_str());
					std::string tag = "MAGIC_SPELLPOWER_EQUIPMENT";
					std::string pwrINTBonus = formatSkillSheetEffects(player.playernum, PRO_MAGIC, tag, getHoverTextString("attributes_pwr_bonus_format"));
					snprintf(valueBuf, sizeof(valueBuf), "%s", pwrINTBonus.c_str());
				}
					break;
				case SHEET_RES:
					break;
				case SHEET_RGN:
				{
					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_plain_display").c_str());
					real_t regen = (static_cast<real_t>(Entity::getHealthRegenInterval(player.entity, *stats[player.playernum], true)) / TICKS_PER_SECOND);
					if ( regen <= 0.0 )
					{
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_hp_per_second_format_zero").c_str(),
							(static_cast<real_t>(HEAL_TIME) / TICKS_PER_SECOND));
					}
					else
					{
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_hp_per_second_format").c_str(),
							regen);
					}
				}
					break;
				case SHEET_RGN_MP:
				{
					if ( isAutomatonHTRegen )
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_ht_boiler_status").c_str());
						if ( stats[player.playernum]->HUNGER <= 300 )
						{
							value = -1;
							snprintf(valueBuf, sizeof(valueBuf), "%s", getHoverTextString("attributes_rgn_ht_boiler_value_low").c_str());
						}
						else if ( stats[player.playernum]->HUNGER > 1200 )
						{
							value = 2;
							snprintf(valueBuf, sizeof(valueBuf), "%s", getHoverTextString("attributes_rgn_ht_boiler_value_superheat").c_str());
						}
						else
						{
							value = 1;
							snprintf(valueBuf, sizeof(valueBuf), "%s", getHoverTextString("attributes_rgn_ht_boiler_value_normal").c_str());
						}
					}
					else if ( isInsectoidENRegen )
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_plain_display").c_str());
						real_t regen = (static_cast<real_t>(Entity::getManaRegenInterval(player.entity, *stats[player.playernum], true)) / TICKS_PER_SECOND);
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_en_per_second_format").c_str(), regen);
					}
					else
					{
						Monster type = stats[player.playernum]->type;
						bool aestheticOnly = false;
						if ( player.entity )
						{
							if ( player.entity->effectPolymorph == NOTHING && stats[player.playernum]->playerRace > RACE_HUMAN )
							{
								if ( stats[player.playernum]->appearance != 0 )
								{
									aestheticOnly = true;
									type = player.entity->getMonsterFromPlayerRace(stats[player.playernum]->playerRace);
								}
							}
						}
						real_t baseRegen = 100.0;
						if ( type == SKELETON )
						{
							baseRegen = 25.0;
						}

						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_entry_statskill_bonus").c_str());
						Sint32 oldINT = stats[player.playernum]->INT;
						stats[player.playernum]->INT += -statGetINT(stats[player.playernum], player.entity);
						real_t regenWithoutINT = getDisplayedMPRegen(player.entity, *stats[player.playernum], nullptr, nullptr);
						stats[player.playernum]->INT = oldINT;

						real_t regenTotal = getDisplayedMPRegen(player.entity, *stats[player.playernum], nullptr, nullptr);
						real_t regenStatSkill = regenTotal - regenWithoutINT;

						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_bonus_format").c_str(), regenStatSkill);
					}
				}
					break;
				case SHEET_WGT:
				{
					int weight = player.movement.getCharacterModifiedWeight();
					int equippedWeightTotal = player.movement.getCharacterEquippedWeight();
					int equippedWeight = player.movement.getCharacterModifiedWeight(&equippedWeightTotal);
					int goldWeightTotal = stats[player.playernum]->getGoldWeight();
					int goldWeight = player.movement.getCharacterModifiedWeight(&goldWeightTotal);
					Sint32 STR = statGetSTR(stats[player.playernum], player.entity);
					Sint32 DEX = statGetDEX(stats[player.playernum], player.entity);
					real_t currentEquippedSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(equippedWeight, STR), DEX);
					real_t currentSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(weight - goldWeight, STR), DEX); // ignore gold
					real_t noWeightSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(0, STR), DEX);
					real_t maxSpeed = player.movement.getMaximumSpeed();

					real_t currentSpeedPercent = 100.0 * currentSpeed / std::fmax(.01, maxSpeed);
					real_t currentEquippedSpeedPercent = 100.0 * currentEquippedSpeed / std::fmax(.01, maxSpeed);
					real_t noWeightSpeedPercent = 100.0 * noWeightSpeed / std::fmax(.01, maxSpeed);

					real_t displayValue = (currentSpeedPercent - noWeightSpeedPercent)
						- (currentEquippedSpeedPercent - noWeightSpeedPercent);
					if ( displayValue >= 0.0 )
					{
						displayValue = -.000001; // so there is a negative sign
					}

					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_wgt_inventory_value").c_str());
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_wgt_speed_bonus_format").c_str(),
						displayValue);
				}
					break;
				default:
					break;
			}
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx + padxMid;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid * 2);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry5 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry5 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entryValue->setDisabled(false);
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
					break;
				case SHEET_POW:
					break;
				case SHEET_RES:
					break;
				case SHEET_RGN:
					break;
				case SHEET_WGT:
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			else if ( value > 0 )
			{
				if ( isAutomatonHTRegen )
				{
					if ( value == 2 ) // supercharge
					{
						entryValue->setColor(hudColors.characterSheetHeadingText);
					}
					else
					{
						entryValue->setColor(hudColors.characterSheetGreen);
					}
				}
				else
				{
					entryValue->setColor(hudColors.characterSheetGreen);
				}
			}
			entryValue->setText(valueBuf);
			entryValue->setSize(entry->getSize());
			entryValue->setHJustify(Frame::justify_t::LEFT);
			entryValue->setVJustify(Field::justify_t::TOP);

			if ( element == SHEET_RGN || (element == SHEET_RGN_MP && (isAutomatonHTRegen || isInsectoidENRegen)) )
			{
				// special rule here to ignore size of this long line
				auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][currentTextBackingFrameIndex];
				SDL_Rect backingFramePos = entryValue->getSize();
				auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
					entryValue->getTextColor(), entryValue->getOutlineColor());
				//longestValue = std::max(longestValue, txtValueGet->getWidth());
				backingFramePos.x = backingFramePos.x + backingFramePos.w;
				backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
				//valueSizes[currentTextBackingFrameIndex] = std::make_pair(entryValue, backingFramePos);
				txtValueBackingFrame->setDisabled(true);

				backingFramePos.w = (int)txtValueGet->getWidth();
				backingFramePos.x -= backingFramePos.w;
				backingFramePos.x -= 8;
				entryValue->setSize(backingFramePos);
				++currentTextBackingFrameIndex;
			}
			else
			{
				auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][currentTextBackingFrameIndex];
				SDL_Rect backingFramePos = entryValue->getSize();
				auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
					entryValue->getTextColor(), entryValue->getOutlineColor());
				longestValue = std::max(longestValue, txtValueGet->getWidth());
				backingFramePos.x = backingFramePos.x + backingFramePos.w;
				backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
				valueSizes[currentTextBackingFrameIndex] = std::make_pair(entryValue, backingFramePos);
				txtValueBackingFrame->setDisabled(false);
				++currentTextBackingFrameIndex;
			}
		}

		if ( element == SHEET_ATK && getAttackTooltipLines(player.playernum, attackHoverTextInfo, 6, buf, valueBuf)
			|| (element == SHEET_RGN_MP && !isInsectoidENRegen) || element == SHEET_WGT )
		{
			// extra number display - line 6
			hasEntryInfoLines = true;
			currentHeight += padyMid;
			auto entry = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entry->setDisabled(false);
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
					break;
				case SHEET_POW:
					break;
				case SHEET_RES:
					break;
				case SHEET_RGN_MP:
				{
					if ( isAutomatonHTRegen )
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_plain_display").c_str());
						real_t regen = (static_cast<real_t>(Entity::getManaRegenInterval(player.entity, *stats[player.playernum], true)) / TICKS_PER_SECOND);
						if ( stats[player.playernum]->HUNGER <= 300 )
						{
							regen /= 6; // degrade faster
							snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_ht_per_second_format").c_str(), -1, regen);
						}
						else if ( stats[player.playernum]->HUNGER > 1200 )
						{
							if ( stats[player.playernum]->MP / static_cast<real_t>(std::max(1, stats[player.playernum]->MAXMP)) <= 0.5 )
							{
								regen /= 4; // increase faster at < 50% mana
							}
							else
							{
								regen /= 2; // increase less faster at > 50% mana
							}
							snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_ht_per_second_format").c_str(), 1, regen);
						}
						else if ( stats[player.playernum]->HUNGER > 300 )
						{
							// normal manaRegenInterval 300-1200 hunger.
							snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_ht_per_second_format").c_str(), 1, regen);
						}
					}
					else
					{
						snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_rgn_plain_display").c_str());
						real_t regen = (static_cast<real_t>(Entity::getManaRegenInterval(player.entity, *stats[player.playernum], true)) / TICKS_PER_SECOND);
						snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_rgn_mp_per_second_format").c_str(), regen);
					}
				}
					break;
				case SHEET_WGT:
				{
					int weight = player.movement.getCharacterModifiedWeight();
					int equippedWeightTotal = player.movement.getCharacterEquippedWeight();
					int equippedWeight = player.movement.getCharacterModifiedWeight(&equippedWeightTotal);
					int goldWeightTotal = stats[player.playernum]->getGoldWeight();
					int goldWeight = player.movement.getCharacterModifiedWeight(&goldWeightTotal);
					Sint32 STR = statGetSTR(stats[player.playernum], player.entity);
					Sint32 DEX = statGetDEX(stats[player.playernum], player.entity);
					//real_t currentEquippedSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(equippedWeight, STR), DEX);
					real_t currentSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(weight, STR), DEX);
					real_t noWeightSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(0, STR), DEX);
					//real_t goldSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(goldWeight, STR), DEX);
					real_t noGoldSpeed = player.movement.getSpeedFactor(player.movement.getWeightRatio(weight - goldWeight, STR), DEX);
					real_t maxSpeed = player.movement.getMaximumSpeed();

					real_t currentSpeedPercent = 100.0 * currentSpeed / std::fmax(.01, maxSpeed);
					//real_t currentEquippedSpeedPercent = 100.0 * currentEquippedSpeed / std::fmax(.01, maxSpeed);
					real_t noWeightSpeedPercent = 100.0 * noWeightSpeed / std::fmax(.01, maxSpeed);
					//real_t goldSpeedPercent = 100.0 * goldSpeed / std::fmax(.01, maxSpeed);
					real_t noGoldSpeedPercent = 100.0 * noGoldSpeed / std::fmax(.01, maxSpeed);

					real_t displayValue = (currentSpeedPercent - noWeightSpeedPercent) 
						- (noGoldSpeedPercent - noWeightSpeedPercent);
					if ( displayValue >= 0.001 )
					{
						// do nothing
					}
					else if ( displayValue >= 0.0 )
					{
						displayValue = -.000001; // so there is a negative sign
					}

					snprintf(buf, sizeof(buf), "%s", getHoverTextString("attributes_wgt_gold_value").c_str());
					snprintf(valueBuf, sizeof(valueBuf), getHoverTextString("attributes_wgt_speed_bonus_format").c_str(),
						displayValue);
				}
					break;
				default:
					break;
			}
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx + padxMid;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid * 2);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry6 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry6 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entryValue->setDisabled(false);
			int value = 0;
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
					break;
				case SHEET_POW:
					break;
				case SHEET_RES:
					break;
				case SHEET_RGN:
					break;
				case SHEET_WGT:
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			else if ( value > 0 )
			{
				entryValue->setColor(hudColors.characterSheetGreen);
			}
			entryValue->setText(valueBuf);
			entryValue->setSize(entry->getSize());
			entryValue->setHJustify(Frame::justify_t::LEFT);
			entryValue->setVJustify(Field::justify_t::TOP);

			if ( element == SHEET_RGN_MP )
			{
				// special rule here to ignore size of this long line
				auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][currentTextBackingFrameIndex];
				SDL_Rect backingFramePos = entryValue->getSize();
				auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
					entryValue->getTextColor(), entryValue->getOutlineColor());
				//longestValue = std::max(longestValue, txtValueGet->getWidth());
				backingFramePos.x = backingFramePos.x + backingFramePos.w;
				backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
				//valueSizes[currentTextBackingFrameIndex] = std::make_pair(entryValue, backingFramePos);
				txtValueBackingFrame->setDisabled(true);

				backingFramePos.w = (int)txtValueGet->getWidth();
				backingFramePos.x -= backingFramePos.w;
				backingFramePos.x -= 8;
				entryValue->setSize(backingFramePos);
				++currentTextBackingFrameIndex;
			}
			else
			{
				auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][currentTextBackingFrameIndex];
				SDL_Rect backingFramePos = entryValue->getSize();
				auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
					entryValue->getTextColor(), entryValue->getOutlineColor());
				longestValue = std::max(longestValue, txtValueGet->getWidth());
				backingFramePos.x = backingFramePos.x + backingFramePos.w;
				backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
				valueSizes[currentTextBackingFrameIndex] = std::make_pair(entryValue, backingFramePos);
				txtValueBackingFrame->setDisabled(false);
				++currentTextBackingFrameIndex;
			}
		}

		if ( element == SHEET_ATK && getAttackTooltipLines(player.playernum, attackHoverTextInfo, 7, buf, valueBuf) )
		{
			// extra number display - line 7
			hasEntryInfoLines = true;
			currentHeight += padyMid;
			auto entry = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entry->setDisabled(false);
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
					break;
				case SHEET_POW:
					break;
				case SHEET_RES:
					break;
				case SHEET_RGN:
					break;
				case SHEET_WGT:
					break;
				default:
					break;
			}
			entry->setText(buf);
			entry->setVJustify(Field::justify_t::TOP);

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx + padxMid;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w - (padxMid * 2);
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry7 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry7 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			entry->setColor(defaultColor);
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);
			tooltipPos.h = pady1 + currentHeight + pady2;

			auto entryValue = characterSheetTooltipTextFields[player.playernum][currentTextFieldIndex]; assert(entry);
			++currentTextFieldIndex;
			entryValue->setDisabled(false);
			int value = 0;
			switch ( element )
			{
				case SHEET_ATK:
					break;
				case SHEET_AC:
					break;
				case SHEET_POW:
					break;
				case SHEET_RES:
					break;
				case SHEET_RGN:
					break;
				case SHEET_WGT:
					break;
				default:
					break;
			}
			entryValue->setColor(hudColors.characterSheetNeutral);
			if ( value < 0 )
			{
				entryValue->setColor(hudColors.characterSheetRed);
			}
			else if ( value > 0 )
			{
				entryValue->setColor(hudColors.characterSheetGreen);
			}
			entryValue->setText(valueBuf);
			entryValue->setSize(entry->getSize());
			entryValue->setHJustify(Frame::justify_t::LEFT);
			entryValue->setVJustify(Field::justify_t::TOP);

			auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][currentTextBackingFrameIndex];
			SDL_Rect backingFramePos = entryValue->getSize();
			auto txtValueGet = Text::get(entryValue->getText(), entryValue->getFont(),
				entryValue->getTextColor(), entryValue->getOutlineColor());
			longestValue = std::max(longestValue, txtValueGet->getWidth());
			backingFramePos.x = backingFramePos.x + backingFramePos.w;
			backingFramePos.h = actualFont->height(true) + extraTextHeightForLowerCharacters - 2;
			valueSizes[currentTextBackingFrameIndex] = std::make_pair(entryValue, backingFramePos);
			txtValueBackingFrame->setDisabled(false);
			++currentTextBackingFrameIndex;
		}

		for ( int index = 1; index <= NUM_CHARSHEET_TOOLTIP_BACKING_FRAMES; ++index )
		{
			auto txtValueBackingFrame = characterSheetTooltipTextBackingFrames[player.playernum][index];
			if ( txtValueBackingFrame->isDisabled() )
			{
				continue;
			}

			if ( valueSizes.find(index) == valueSizes.end() )
			{
				continue;
			}

			SDL_Rect valuePos = valueSizes[index].second;
			Field* entryValue = valueSizes[index].first;
			SDL_Rect entryValuePos = entryValue->getSize();
			entryValuePos.x = entryValuePos.x + entryValuePos.w;
			entryValuePos.w = (int)longestValue;
			entryValuePos.x -= entryValuePos.w;
			entryValuePos.x -= 8;
			entryValue->setSize(entryValuePos);

			valuePos.w = (int)longestValue + 16;
			valuePos.x -= (valuePos.w);
			valuePos.y -= 3;
			valuePos.h += 4;

			txtValueBackingFrame->setSize(valuePos);

			imageResizeToContainer9x9(txtValueBackingFrame, SDL_Rect{ 0, 0, valuePos.w, valuePos.h }, skillsheetEffectBackgroundImages);
		}

		if ( !hasEntryInfoLines )
		{
			currentHeight += padyMid * 2;
		}

		{
			currentHeight += padyMid;

			div->pos.x = padx;
			div->pos.y = currentHeight;
			div->pos.w = txtPos.w;
			div->disabled = false;

			currentHeight += padyMid;

			auto entry = characterSheetTooltipTextFields[player.playernum][15]; assert(entry);
			entry->setDisabled(false);
			char buf[512] = "";

			std::string descTextFormatted = "\x1E ";
			for ( auto s : descText )
			{
				descTextFormatted += s;
				if ( s == '\n' )
				{
					descTextFormatted += "\x1E ";
				}
			}

			snprintf(buf, sizeof(buf), "%s", descTextFormatted.c_str());
			entry->setText(buf);

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx;
			entryPos.y = currentHeight;
			entryPos.w = txtPos.w;
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry8 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry8 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
			entry->setSize(entryPos);
			if ( element == SHEET_RGN && !(svFlags & SV_FLAG_HUNGER) )
			{
				entry->setColor(hudColors.itemContextMenuHeadingText);
			}
			else if ( element == SHEET_RGN_MP && isInsectoidENRegen && !(svFlags & SV_FLAG_HUNGER) )
			{
				entry->setColor(hudColors.itemContextMenuHeadingText);
			}
			else
			{
				entry->setColor(hudColors.characterSheetOffWhiteText);
			}
			currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);

			currentHeight += padyMid / 4;
			tooltipPos.h = pady1 + currentHeight + pady2;
		}

		tooltipPos.h = pady1 + currentHeight + pady2;
		if ( tooltipJustify == PANEL_JUSTIFY_RIGHT )
		{
			tooltipPos.x = pos.x - tooltipPos.w;
		}
		else
		{
			tooltipPos.x = pos.x;
		}
		tooltipPos.y = pos.y;
		tooltipFrame->setSize(tooltipPos);
		if ( tooltipPos.y + tooltipPos.h > sheetFrame->getSize().h )
		{
			// keep on-screen
			tooltipPos.y -= ((tooltipPos.y + tooltipPos.h) - sheetFrame->getSize().h);
			tooltipFrame->setSize(tooltipPos);
		}
		imageResizeToContainer9x9(tooltipFrame, SDL_Rect{ 0, 0, tooltipPos.w, tooltipPos.h },
			skillsheetEffectBackgroundImages);
	}
	else if ( element == Player::CharacterSheet_t::SHEET_DUNGEON_FLOOR )
	{
		const int maxWidth = 260;
		const int padx = 16;
		const int pady1 = 8;
		const int pady2 = 4;
		const int padxMid = 4;
		const int padyMid = 4;
		SDL_Rect tooltipPos = SDL_Rect{ 400, 0, maxWidth, 100 };
		
		std::string descriptionText = mapDisplayNamesDescriptions[map.name].second.c_str();
		std::string mapDetailsText = "";
		auto mapDetails = Player::Minimap_t::mapDetails;
		for ( auto& detail : mapDetails )
		{
			if ( mapDetailsText != "" )
			{
				mapDetailsText += '\n';
			}
			mapDetailsText += "\x1E ";
			mapDetailsText += detail.second;
		}

		if ( strcmp(descriptionText.c_str(), txt->getText()) )
		{
			txt->setText(descriptionText.c_str());
		}
		SDL_Rect txtPos = SDL_Rect{ padx, pady1, maxWidth - padx * 2, 80 };
		txt->setSize(txtPos);
		if ( charsheetTooltipCache[player.playernum].textEntries[element].title != txt->getText() )
		{
			txt->reflowTextToFit(0);
			charsheetTooltipCache[player.playernum].textEntries[element].title = txt->getText();
		}
		Font* actualFont = Font::get(txt->getFont());
		int txtHeight = txt->getNumTextLines() * actualFont->height(true);
		txtPos.h = txtHeight + 4;
		auto txtGet = Text::get(txt->getLongestLine().c_str(), txt->getFont(),
			txt->getTextColor(), txt->getOutlineColor());
		txtPos.w = txtGet->getWidth();
		txt->setSize(txtPos);

		tooltipPos.w = txtGet->getWidth() + padx * 2;

		int currentHeight = txtPos.y + txtPos.h - 4;

		if ( Player::Minimap_t::mapDetails.size() > 0 )
		{
			currentHeight += padyMid;
			auto entry = tooltipFrame->findField("txt 1"); assert(entry);
			entry->setDisabled(false);
			if ( strcmp(mapDetailsText.c_str(), entry->getText()) )
			{
				entry->setText(mapDetailsText.c_str());
			}

			SDL_Rect entryPos = entry->getSize();
			entryPos.x = padx + padxMid;
			entryPos.y = currentHeight;
			entryPos.w = tooltipPos.w - (2 * (entryPos.x));
			entry->setSize(entryPos);
			if ( charsheetTooltipCache[player.playernum].textEntries[element].entry1 != entry->getText() )
			{
				entry->reflowTextToFit(0);
				charsheetTooltipCache[player.playernum].textEntries[element].entry1 = entry->getText();
			}
			entryPos.h = actualFont->height(true) * entry->getNumTextLines() + 4;
			entry->setSize(entryPos);
			entry->setColor(makeColor(255, 0, 255, 255));
			currentHeight = std::max(entryPos.y + entryPos.h, 0);
		}

		if ( Player::Minimap_t::mapDetails.size() > 0 )
		{
			tooltipPos.h = pady1 + currentHeight + pady2;
		}
		else
		{
			tooltipPos.h = pady1 + txtPos.h + pady2;
		}
		if ( tooltipJustify == PANEL_JUSTIFY_RIGHT )
		{
			tooltipPos.x = pos.x - tooltipPos.w;
		}
		else
		{
			tooltipPos.x = pos.x;
		}
		tooltipPos.y = pos.y;

		tooltipFrame->setSize(tooltipPos);
		imageResizeToContainer9x9(tooltipFrame, SDL_Rect{ 0, 0, tooltipPos.w, tooltipPos.h },
			skillsheetEffectBackgroundImages);
	}
	else if ( element == Player::CharacterSheet_t::SHEET_GOLD )
	{
		const int maxWidth = 200;
		const int padx = 16;
		const int pady1 = 8;
		const int pady2 = 8;
		const int padyMid = 4;
		const int padxMid = 4;
		SDL_Rect tooltipPos = SDL_Rect{ 400, 0, maxWidth, 100 };
		bool usingMouse = !inputs.getVirtualMouse(player.playernum)->lastMovementFromController;
		if ( strcmp(getHoverTextString("gold_mouse").c_str(), txt->getText()) )
		{
			txt->setText(getHoverTextString("gold_mouse").c_str());
		}

		SDL_Rect txtPos = SDL_Rect{ padx, pady1, maxWidth - padx * 2, 80 };
		txt->setSize(txtPos);
		if ( charsheetTooltipCache[player.playernum].textEntries[element].title != txt->getText() )
		{
			txt->reflowTextToFit(0);
			charsheetTooltipCache[player.playernum].textEntries[element].title = txt->getText();
		}
		Font* actualFont = Font::get(txt->getFont());
		int txtHeight = txt->getNumTextLines() * actualFont->height(true);
		txtPos.h = txtHeight + padyMid;
		auto txtGet = Text::get(txt->getLongestLine().c_str(), txt->getFont(),
			txt->getTextColor(), txt->getOutlineColor());
		txtPos.w = txtGet->getWidth();
		txt->setSize(txtPos);
		
		tooltipPos.w = txtPos.w + padx * 2;
		tooltipPos.h = pady1 + txtPos.h + pady2;

		if ( tooltipJustify == PANEL_JUSTIFY_RIGHT )
		{
			tooltipPos.x = pos.x - tooltipPos.w;
		}
		else
		{
			tooltipPos.x = pos.x;
		}
		tooltipPos.y = pos.y;

		tooltipFrame->setSize(tooltipPos);
		imageResizeToContainer9x9(tooltipFrame, SDL_Rect{ 0, 0, tooltipPos.w, tooltipPos.h },
			skillsheetEffectBackgroundImages);
	}
	else if ( element == Player::CharacterSheet_t::SHEET_CHAR_RACE_SEX )
	{
		auto tooltipTopLeft = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
		tooltipTopLeft->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TL_Blue_00.png";
		auto tooltipTop = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP].c_str());
		tooltipTop->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_T_Blue_00.png";
		auto tooltipTopRight = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
		tooltipTopRight->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TR_Blue_00.png";
		imageSetWidthHeight9x9(tooltipFrame, skillsheetEffectBackgroundImages);

		int maxWidth = 260;
		int minWidth = 0;

		const int padx = 16;
		const int pady1 = 8;
		const int pady2 = 4;
		const int padxMid = 4;
		const int padyMid = 8;
		SDL_Rect tooltipPos = SDL_Rect{ 400, 0, maxWidth, 100 };

		Monster race = HUMAN;
		if ( stats[player.playernum]->appearance == 0 && stats[player.playernum]->playerRace != RACE_HUMAN )
		{
			race = getMonsterFromPlayerRace(stats[player.playernum]->playerRace);
		}
		Monster modifiedRace = stats[player.playernum]->type;
		if ( arachnophobia_filter )
		{
			if ( modifiedRace == SPIDER )
			{
				modifiedRace = CRAB;
			}
			if ( race == SPIDER )
			{
				race = CRAB;
			}
		}

		char titleBuf[64];
		std::string titleText = getHoverTextString("race_title_normal");
		if ( players[player.playernum]->entity )
		{
			if ( players[player.playernum]->entity->effectShapeshift != NOTHING )
			{
				titleText = getHoverTextString("race_title_shapeshift");
			}
			else if ( race != modifiedRace )
			{
				titleText = getHoverTextString("race_title_polymorph");
			}
		}

		txt->setText(titleText.c_str());
		SDL_Rect txtPos = SDL_Rect{ padx, pady1 - 2, maxWidth - padx * 2, 80 };
		txt->setSize(txtPos);
		if ( charsheetTooltipCache[player.playernum].textEntries[element].title != txt->getText() )
		{
			txt->reflowTextToFit(0);
			charsheetTooltipCache[player.playernum].textEntries[element].title = txt->getText();
		}
		txt->setColor(hudColors.characterSheetHeadingText);
		Font* actualFont = Font::get(txt->getFont());
		int txtHeight = txt->getNumTextLines() * actualFont->height(true);
		txtPos.h = txtHeight + 4;
		auto txtGet = Text::get(txt->getLongestLine().c_str(), txt->getFont(),
			txt->getTextColor(), txt->getOutlineColor());
		txtPos.w = txtGet->getWidth();
		txtPos.w = std::max(minWidth - padx * 2, txtPos.w);
		txt->setSize(txtPos);

		tooltipPos.w = (txtPos.w + padx * 2);

		unsigned int longestValue = 0;
		std::map<int, std::pair<Field*, SDL_Rect>> valueSizes;

		int currentHeight = txtPos.y + (actualFont->height(true) * 1) + 2;
		const int extraTextHeightForLowerCharacters = 4;
		currentHeight += padyMid;
		
		if ( raceTooltip )
		{
			raceTooltip->setDisabled(false);
			MainMenu::RaceDescriptions::update_details_text(*raceTooltip, stats[player.playernum]);

			SDL_Rect raceTooltipPos = raceTooltip->getSize();
			raceTooltipPos.x = txtPos.x + padxMid;
			raceTooltipPos.y = currentHeight;
			raceTooltipPos.w = 272;
			int heightOffset = 0;
			if ( auto details_text = raceTooltip->findField("details") )
			{
				SDL_Rect pos = details_text->getSize();
				if ( auto actualFont = Font::get(details_text->getFont()) )
				{
					const int numlines = details_text->getNumTextLines();
					const int pad = details_text->getPaddingPerLine();
					const int actualHeight = actualFont->height(true);
					pos.h = 0;
					for ( int line = 0; line < numlines; ++line )
					{
						pos.h += actualHeight + pad;// +details_text->getIndividualLinePadding(line);
						heightOffset += details_text->getIndividualLinePadding(line);
					}
				}
				raceTooltipPos.h = pos.h + pos.y + extraTextHeightForLowerCharacters;
				details_text->setSize(pos);
			}
			if ( auto details_text_right = raceTooltip->findField("details_right") )
			{
				SDL_Rect pos = details_text_right->getSize();
				if ( auto actualFont = Font::get(details_text_right->getFont()) )
				{
					const int numlines = details_text_right->getNumTextLines();
					const int pad = details_text_right->getPaddingPerLine();
					const int actualHeight = actualFont->height(true);
					pos.h = 0;
					for ( int line = 0; line < numlines; ++line )
					{
						pos.h += actualHeight + pad;// +details_text_right->getIndividualLinePadding(line);
					}
				}

				details_text_right->setSize(pos);
			}
			raceTooltip->setSize(raceTooltipPos);
			tooltipPos.w = raceTooltipPos.w + padxMid * 2;
			currentHeight = std::max(raceTooltipPos.y + raceTooltipPos.h - extraTextHeightForLowerCharacters + heightOffset, 0);
		}

		tooltipPos.h = pady1 + currentHeight + pady2;
		if ( tooltipJustify == PANEL_JUSTIFY_RIGHT )
		{
			tooltipPos.x = pos.x - tooltipPos.w;
		}
		else
		{
			tooltipPos.x = pos.x;
		}
		tooltipPos.y = pos.y;
		if ( tooltipPos.y + tooltipPos.h > sheetFrame->getSize().h )
		{
			// keep on-screen
			tooltipPos.y -= ((tooltipPos.y + tooltipPos.h) - sheetFrame->getSize().h);
			tooltipFrame->setSize(tooltipPos);
		}
		tooltipFrame->setSize(tooltipPos);
		imageResizeToContainer9x9(tooltipFrame, SDL_Rect{ 0, 0, tooltipPos.w, tooltipPos.h },
			skillsheetEffectBackgroundImages);
	}
	else if ( element == Player::CharacterSheet_t::SHEET_CHAR_CLASS )
	{
		auto tooltipTopLeft = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
		tooltipTopLeft->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TL_Blue_00.png";
		auto tooltipTop = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP].c_str());
		tooltipTop->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_T_Blue_00.png";
		auto tooltipTopRight = tooltipFrame->findImage(skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
		tooltipTopRight->path = "*#images/ui/CharSheet/HUD_CharSheet_Tooltip_TR_Blue_00.png";
		imageSetWidthHeight9x9(tooltipFrame, skillsheetEffectBackgroundImages);

		int maxWidth = 260;
		int minWidth = 0;
		if ( getHoverTextString("stat_growth_min_tooltip_width") != defaultString )
		{
			minWidth = std::max(0, std::stoi(getHoverTextString("stat_growth_min_tooltip_width")));
		}
		if ( getHoverTextString("stat_growth_max_tooltip_width") != defaultString )
		{
			maxWidth = std::max(0, std::stoi(getHoverTextString("stat_growth_max_tooltip_width")));
		}

		const int padx = 16;
		const int pady1 = 8;
		const int pady2 = 4;
		const int padxMid = 4;
		const int padyMid = 8;
		SDL_Rect tooltipPos = SDL_Rect{ 400, 0, maxWidth, 100 };

		Monster race = HUMAN;
		if ( stats[player.playernum]->appearance == 0 && stats[player.playernum]->playerRace != RACE_HUMAN )
		{
			race = getMonsterFromPlayerRace(stats[player.playernum]->playerRace);
		}
		Monster modifiedRace = stats[player.playernum]->type;
		if ( arachnophobia_filter )
		{
			if ( modifiedRace == SPIDER )
			{
				modifiedRace = CRAB;
			}
			if ( race == SPIDER )
			{
				race = CRAB;
			}
		}

		char titleBuf[64];
		if ( player.entity && player.entity->effectShapeshift != 0 )
		{
			txt->setText(getHoverTextString("class_title_shapeshift").c_str());
		}
		else
		{
			txt->setText(getHoverTextString("class_title").c_str());
		}
		SDL_Rect txtPos = SDL_Rect{ padx, pady1 - 2, maxWidth - padx * 2, 80 };
		txt->setSize(txtPos);
		if ( charsheetTooltipCache[player.playernum].textEntries[element].title != txt->getText() )
		{
			txt->reflowTextToFit(0);
			charsheetTooltipCache[player.playernum].textEntries[element].title = txt->getText();
		}
		txt->setColor(hudColors.characterSheetHeadingText);
		Font* actualFont = Font::get(txt->getFont());
		int txtHeight = txt->getNumTextLines() * actualFont->height(true);
		txtPos.h = txtHeight + 4;
		auto txtGet = Text::get(txt->getLongestLine().c_str(), txt->getFont(),
			txt->getTextColor(), txt->getOutlineColor());
		txtPos.w = txtGet->getWidth();
		txtPos.w = std::max(minWidth - padx * 2, txtPos.w);
		txt->setSize(txtPos);

		tooltipPos.w = (txtPos.w + padx * 2);

		std::map<int, std::pair<Field*, SDL_Rect>> valueSizes;

		int currentHeight = txtPos.y + (actualFont->height(true) * 1) + 2;
		const int extraTextHeightForLowerCharacters = 4;
		currentHeight += padyMid;

		if ( classTooltip )
		{
			classTooltip->setDisabled(false);
			auto statGrowths = classTooltip->findFrame("stat growths");
			if ( player.entity )
			{
				MainMenu::ClassDescriptions::update_stat_growths(*statGrowths, client_classes[player.playernum], player.entity->effectShapeshift);
			}
			else
			{
				MainMenu::ClassDescriptions::update_stat_growths(*statGrowths, client_classes[player.playernum], 0);
			}

			SDL_Rect classTooltipPos = classTooltip->getSize();
			classTooltipPos.w = statGrowths->getSize().w;
			classTooltipPos.h = statGrowths->getSize().h;
			classTooltipPos.x = tooltipPos.w / 2 - classTooltipPos.w / 2;
			classTooltipPos.y = currentHeight;
			classTooltip->setSize(classTooltipPos);

			currentHeight += classTooltipPos.h;

			std::string descText = "";
			descText = getHoverTextString("stat_growth_info");
			
			{
				currentHeight += padyMid;

				div->pos.x = padx;
				div->pos.y = currentHeight;
				div->pos.w = txtPos.w;
				div->disabled = false;

				currentHeight += padyMid;

				auto entry = characterSheetTooltipTextFields[player.playernum][1]; assert(entry);
				entry->setDisabled(false);
				char buf[512] = "";

				std::string descTextFormatted = "\x1E ";
				for ( auto s : descText )
				{
					descTextFormatted += s;
					if ( s == '\n' )
					{
						descTextFormatted += "\x1E ";
					}
				}

				snprintf(buf, sizeof(buf), "%s", descTextFormatted.c_str());
				entry->setText(buf);

				SDL_Rect entryPos = entry->getSize();
				entryPos.x = padx;
				entryPos.y = currentHeight;
				entryPos.w = txtPos.w;
				entry->setSize(entryPos);
				if ( charsheetTooltipCache[player.playernum].textEntries[element].entry1 != entry->getText() )
				{
					entry->reflowTextToFit(0);
					charsheetTooltipCache[player.playernum].textEntries[element].entry1 = entry->getText();
				}
				entryPos.h = actualFont->height(true) * entry->getNumTextLines() + extraTextHeightForLowerCharacters;
				entry->setSize(entryPos);
				entry->setColor(hudColors.characterSheetOffWhiteText);
				currentHeight = std::max(entryPos.y + entryPos.h - extraTextHeightForLowerCharacters, 0);

				currentHeight += padyMid / 4;
				tooltipPos.h = pady1 + currentHeight + pady2;
			}
		}

		tooltipPos.h = pady1 + currentHeight + pady2;
		if ( tooltipJustify == PANEL_JUSTIFY_RIGHT )
		{
			tooltipPos.x = pos.x - tooltipPos.w;
		}
		else
		{
			tooltipPos.x = pos.x;
		}
		tooltipPos.y = pos.y;
		if ( tooltipPos.y + tooltipPos.h > sheetFrame->getSize().h )
		{
			// keep on-screen
			tooltipPos.y -= ((tooltipPos.y + tooltipPos.h) - sheetFrame->getSize().h);
			tooltipFrame->setSize(tooltipPos);
		}
		tooltipFrame->setSize(tooltipPos);
		imageResizeToContainer9x9(tooltipFrame, SDL_Rect{ 0, 0, tooltipPos.w, tooltipPos.h },
			skillsheetEffectBackgroundImages);
	}
	else if ( element == Player::CharacterSheet_t::SHEET_TIMER )
	{
		const int maxWidth = 240;
		const int padx = 16;
		const int pady1 = 8;
		const int pady2 = 8;
		const int padyMid = 4;
		const int padxMid = 4;
		SDL_Rect tooltipPos = SDL_Rect{ 400, 0, maxWidth, 100 };
		bool usingMouse = !inputs.getVirtualMouse(player.playernum)->lastMovementFromController;

		if ( player.characterSheet.showGameTimerAlways )
		{
			std::string tooltiptxt = getHoverTextString("game_timer_mouse") + getHoverTextString("game_timer_unpin");
			if ( strcmp(tooltiptxt.c_str(), txt->getText()) )
			{
				txt->setText(tooltiptxt.c_str());
			}
		}
		else
		{
			std::string tooltiptxt = getHoverTextString("game_timer_mouse") + getHoverTextString("game_timer_pin");
			if ( strcmp(tooltiptxt.c_str(), txt->getText()) )
			{
				txt->setText(tooltiptxt.c_str());
			}
		}

		int currentHeight = padyMid;

		SDL_Rect txtPos = SDL_Rect{ padx, pady1, maxWidth - padx * 2, 80 };
		txt->setSize(txtPos);
		if ( charsheetTooltipCache[player.playernum].textEntries[element].title != txt->getText() )
		{
			txt->reflowTextToFit(0);
			charsheetTooltipCache[player.playernum].textEntries[element].title = txt->getText();
		}
		Font* actualFont = Font::get(txt->getFont());
		int txtHeight = txt->getNumTextLines() * actualFont->height(true);
		txtPos.h = txtHeight + padyMid;
		auto txtGet = Text::get(txt->getLongestLine().c_str(), txt->getFont(),
			txt->getTextColor(), txt->getOutlineColor());
		txtPos.w = txtGet->getWidth();
		txt->setSize(txtPos);
		
		currentHeight = std::max(currentHeight, txtPos.h);

		tooltipPos.w = txtPos.w + padx * 2;
		tooltipPos.h = pady1 + currentHeight + pady2;
		if ( tooltipJustify == PANEL_JUSTIFY_RIGHT )
		{
			tooltipPos.x = pos.x - tooltipPos.w;
		}
		else
		{
			tooltipPos.x = pos.x;
		}
		tooltipPos.y = pos.y;

		tooltipFrame->setSize(tooltipPos);
		imageResizeToContainer9x9(tooltipFrame, SDL_Rect{ 0, 0, tooltipPos.w, tooltipPos.h },
			skillsheetEffectBackgroundImages);
	}
}

void Player::CharacterSheet_t::updateCharacterInfo()
{
	auto characterInfoFrame = sheetFrame->findFrame("character info");
	assert(characterInfoFrame);
	auto characterInnerFrame = characterInfoFrame->findFrame("character info inner frame");
	assert(characterInnerFrame);

	bool enableTooltips = !player.GUI.isDropdownActive() && !player.GUI.dropdownMenu.bClosedThisTick;
	if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor
		&& inputs.hasController(player.playernum)
		&& !Input::inputs[player.playernum].binary("MenuConfirm") )
	{
		enableTooltips = false;
	}

	bool bCompactView = player.bUseCompactGUIHeight();

	char buf[32] = "";
	if ( auto name = characterInnerFrame->findField("character name text") )
	{
		if ( strcmp(stats[player.playernum]->name, name->getText()) )
		{
			name->setText(stats[player.playernum]->name);
		}
	}
	Field* className = characterInnerFrame->findField("character class text");
	int classNameWidth = 0;
	if ( className )
	{
		std::string classname = playerClassLangEntry(client_classes[player.playernum], player.playernum);
		if ( !classname.empty() )
		{
			capitalizeString(classname);
			if ( strcmp(classname.c_str(), className->getText()) )
			{
				className->setText(classname.c_str());
			}
		}
		if ( client_classes[player.playernum] >= CLASS_CONJURER && client_classes[player.playernum] <= CLASS_BREWER )
		{
			className->setTextColor(hudColors.characterDLC1ClassText);
		}
		else if ( client_classes[player.playernum] >= CLASS_MACHINIST && client_classes[player.playernum] <= CLASS_HUNTER )
		{
			className->setTextColor(hudColors.characterDLC2ClassText);
		}
		else
		{
			className->setTextColor(hudColors.characterBaseClassText);
		}
		if ( auto textGet = Text::get(className->getText(), className->getFont(),
			className->getTextColor(), className->getOutlineColor()) )
		{
			classNameWidth = textGet->getWidth();
		}
	}
	Field* charLevel = characterInnerFrame->findField("character level text");
	int charLevelWidth = 0;
	if ( charLevel )
	{
		snprintf(buf, sizeof(buf), Language::get(4051), stats[player.playernum]->LVL);
		if ( strcmp(buf, charLevel->getText()) )
		{
			charLevel->setText(buf);
		}
		if ( auto textGet = Text::get(charLevel->getText(), charLevel->getFont(),
			charLevel->getTextColor(), charLevel->getOutlineColor()) )
		{
			charLevelWidth = textGet->getWidth();
		}
	}
	if ( className && charLevel )
	{
		SDL_Rect classNamePos = className->getSize();
		SDL_Rect charLevelPos = charLevel->getSize();
		const int padding = 24;
		const int startX = 8;
		const int fieldWidth = 190;
		const int totalWidth = charLevelWidth + padding / 2 + classNameWidth;
		charLevelPos.x = startX + fieldWidth / 2 - totalWidth / 2;
		charLevelPos.w = charLevelWidth;
		classNamePos.x = charLevelPos.x + charLevelPos.w + padding / 2 - 4; // -4 centres it nicely somehow, not sure why
		classNamePos.w = classNameWidth;
		charLevel->setSize(charLevelPos);
		className->setSize(classNamePos);
		//messagePlayer(0, "%d | %d", charLevelPos.x - startX, 198 - (classNamePos.x + classNamePos.w));

		if ( selectedElement == SHEET_CHAR_CLASS && enableTooltips )
		{
			SDL_Rect tooltipPos = characterInfoFrame->getSize();
			tooltipPos.y -= 4;
			//tooltipPos.y += raceText->getSize().y;
			Player::PanelJustify_t tooltipJustify = PANEL_JUSTIFY_RIGHT;
			if ( (panelJustify == PANEL_JUSTIFY_LEFT && !bCompactView) || (panelJustify == PANEL_JUSTIFY_RIGHT && bCompactView) )
			{
				tooltipJustify = PANEL_JUSTIFY_LEFT;
				tooltipPos.x += tooltipPos.w;
			}
			if ( bCompactView )
			{
				tooltipPos.y = 0;
				tooltipPos.x += (tooltipJustify == PANEL_JUSTIFY_LEFT) ? 6 : -6;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}
	if ( auto raceText = characterInnerFrame->findField("character race text") )
	{
		Monster type = stats[player.playernum]->type;
		std::string appearance = "";
		bool aestheticOnly = false;
		if ( player.entity )
		{
			if ( player.entity->effectPolymorph == NOTHING && stats[player.playernum]->playerRace > RACE_HUMAN )
			{
				if ( stats[player.playernum]->appearance != 0 )
				{
					aestheticOnly = true;
					appearance = Language::get(4068);
					type = player.entity->getMonsterFromPlayerRace(stats[player.playernum]->playerRace);
				}
			}
		}
		std::string race = getMonsterLocalizedName(type).c_str();
		capitalizeString(race);
		if ( type == HUMAN )
		{
			appearance = Language::get(20 + stats[player.playernum]->appearance % NUMAPPEARANCES);
			capitalizeString(appearance);
		}
		bool centerIconAndText = false;
		if ( appearance != "" )
		{
			if ( aestheticOnly )
			{
				snprintf(buf, sizeof(buf), "%s %s", appearance.c_str(), race.c_str()); // 'guised skeleton'
			}
			else
			{
				snprintf(buf, sizeof(buf), "%s %s", race.c_str(), appearance.c_str()); // 'human gloomforge'
			}
			centerIconAndText = true;
		}
		else
		{
			snprintf(buf, sizeof(buf), "%s", race.c_str());
		}

		if ( strcmp(buf, raceText->getText()) )
		{
			raceText->setText(buf);
		}
		int width = 0;
		if ( auto textGet = Text::get(raceText->getText(), raceText->getFont(),
			raceText->getTextColor(), raceText->getOutlineColor()) )
		{
			width = textGet->getWidth();
		}

		if ( auto sexImg = characterInnerFrame->findImage("character sex img") )
		{
			int offsetx = 0;
			if ( stats[player.playernum]->sex == sex_t::MALE )
			{
				if ( type == AUTOMATON )
				{
					sexImg->path = "*#images/ui/CharSheet/HUD_CharSheet_Sex_AutomatonM_02.png";
				}
				else
				{
					sexImg->path = "*#images/ui/CharSheet/HUD_CharSheet_Sex_M_02.png";
					static ConsoleVariable<int> cvar_sexoffset("/sexoffsetx", -1);
					offsetx = *cvar_sexoffset;
				}
			}
			else if ( stats[player.playernum]->sex == sex_t::FEMALE )
			{
				if ( type == AUTOMATON )
				{
					sexImg->path = "*#images/ui/CharSheet/HUD_CharSheet_Sex_AutomatonF_02.png";
				}
				else
				{
					sexImg->path = "*#images/ui/CharSheet/HUD_CharSheet_Sex_F_02.png";
				}
			}
			if ( auto imgGet = Image::get(sexImg->path.c_str()) )
			{
				sexImg->pos.w = (int)imgGet->getWidth();
				sexImg->pos.h = (int)imgGet->getHeight();
			}

			SDL_Rect raceTextPos = raceText->getSize();
			raceTextPos.x = 4;
			if ( centerIconAndText )
			{
				raceTextPos.x = 4 + (((sexImg->pos.w + 4)) / 2) + offsetx;
			}
			if ( raceTextPos.x % 2 == 1 )
			{
				--raceTextPos.x;
			}
			raceText->setSize(raceTextPos);

			sexImg->pos.x = 16;
			if ( centerIconAndText )
			{
				sexImg->pos.x = raceText->getSize().x + raceText->getSize().w / 2 - width / 2;
				sexImg->pos.x -= (sexImg->pos.w + 4) + (offsetx * 2);
			}
			if ( sexImg->pos.x % 2 == 1 )
			{
				--sexImg->pos.x;
			}
			sexImg->pos.y = raceText->getSize().y + raceText->getSize().h / 2 - sexImg->pos.h / 2;
		}

		if ( selectedElement == SHEET_CHAR_RACE_SEX && enableTooltips )
		{
			SDL_Rect tooltipPos = characterInfoFrame->getSize();
			tooltipPos.y -= 4;
			//tooltipPos.y += raceText->getSize().y;
			Player::PanelJustify_t tooltipJustify = PANEL_JUSTIFY_RIGHT;
			if ( (panelJustify == PANEL_JUSTIFY_LEFT && !bCompactView) || (panelJustify == PANEL_JUSTIFY_RIGHT && bCompactView) )
			{
				tooltipJustify = PANEL_JUSTIFY_LEFT;
				tooltipPos.x += tooltipPos.w;
			}
			if ( bCompactView )
			{
				tooltipPos.y = 0;
				tooltipPos.x += (tooltipJustify == PANEL_JUSTIFY_LEFT) ? 6 : -6;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}
	if ( auto floorFrame = sheetFrame->findFrame("dungeon floor frame") )
	{
		if ( auto floorLevelText = floorFrame->findField("dungeon level text") )
		{
			snprintf(buf, sizeof(buf), Language::get(4052), currentlevel);
			if ( strcmp(buf, floorLevelText->getText()) )
			{
				floorLevelText->setText(buf);
				charsheetTooltipCache[player.playernum].manualUpdate = true;
			}
		}
		if ( auto floorNameText = floorFrame->findField("dungeon name text") )
		{
			if ( mapDisplayNamesDescriptions.find(map.name) != mapDisplayNamesDescriptions.end() )
			{
				if ( strcmp(mapDisplayNamesDescriptions[map.name].first.c_str(), floorNameText->getText()) )
				{
					floorNameText->setText(mapDisplayNamesDescriptions[map.name].first.c_str());
					charsheetTooltipCache[player.playernum].manualUpdate = true;
				}

				if ( selectedElement == SHEET_DUNGEON_FLOOR && enableTooltips )
				{
					SDL_Rect tooltipPos = characterInfoFrame->getSize();
					tooltipPos.y = floorFrame->getSize().y;
					Player::PanelJustify_t tooltipJustify = PANEL_JUSTIFY_RIGHT;
					if ( (panelJustify == PANEL_JUSTIFY_LEFT && !bCompactView) || (panelJustify == PANEL_JUSTIFY_RIGHT && bCompactView) )
					{
						tooltipJustify = PANEL_JUSTIFY_LEFT;
						tooltipPos.x += tooltipPos.w;
					}
					if ( bCompactView )
					{
						tooltipPos.y = 0;
						tooltipPos.x += (tooltipJustify == PANEL_JUSTIFY_LEFT) ? 6 : -6;
					}
					updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
				}
			}
			else
			{
				floorNameText->setText(map.name);
			}
		}
	}

	if ( auto gold = characterInnerFrame->findField("gold text") )
	{
		snprintf(buf, sizeof(buf), "%d", stats[player.playernum]->GOLD);
		gold->setText(buf);
		if ( selectedElement == SHEET_GOLD )
		{
			if ( Input::inputs[player.playernum].binary("MenuRightClick")
				&& player.bControlEnabled && !gamePaused
				&& !player.usingCommand()
				&& player.GUI.activeModule == Player::GUI_t::MODULE_CHARACTERSHEET
				&& !player.GUI.isDropdownActive() )
			{
				player.GUI.dropdownMenu.open("drop_gold");
			}
			else if ( (!inputs.getVirtualMouse(player.playernum)->draw_cursor
					&& inputs.hasController(player.playernum)
					&& Input::inputs[player.playernum].binaryToggle("MenuConfirm")
				)
				&& player.GUI.activeModule == Player::GUI_t::MODULE_CHARACTERSHEET
				&& !player.GUI.isDropdownActive()
				&& !player.usingCommand()
				&& player.bControlEnabled && !gamePaused )
			{
				Input::inputs[player.playernum].consumeBinaryToggle("MenuConfirm");
				player.GUI.dropdownMenu.open("drop_gold");
				player.GUI.dropdownMenu.dropDownToggleClick = true;
				SDL_Rect dropdownPos = characterInfoFrame->getSize();
				dropdownPos.y += gold->getSize().y + gold->getSize().h / 2;
				if ( auto interactMenuTop = player.GUI.dropdownMenu.dropdownFrame->findImage("interact top background") )
				{
					// 10px is slot half height, move by 1.5 slots, minus the top interact text height
					dropdownPos.y -= (interactMenuTop->pos.h + (3 * 10) + 4);
				}
				if ( !player.GUI.dropdownMenu.getDropDownAlignRight("drop_gold") )
				{
					player.GUI.dropdownMenu.dropDownX = dropdownPos.x;
				}
				else
				{
					player.GUI.dropdownMenu.dropDownX = dropdownPos.x + dropdownPos.w;
				}
				player.GUI.dropdownMenu.dropDownX += player.camera_virtualx1();
				player.GUI.dropdownMenu.dropDownY = dropdownPos.y + player.camera_virtualy1();
			}
			if ( enableTooltips && !inputs.getVirtualMouse(player.playernum)->lastMovementFromController )
			{
				SDL_Rect tooltipPos = characterInfoFrame->getSize();
				tooltipPos.y += gold->getSize().y;
				tooltipPos.y -= 6;
				Player::PanelJustify_t tooltipJustify = PANEL_JUSTIFY_RIGHT;
				if ( (panelJustify == PANEL_JUSTIFY_LEFT && !bCompactView) || (panelJustify == PANEL_JUSTIFY_RIGHT && bCompactView) )
				{
					tooltipJustify = PANEL_JUSTIFY_LEFT;
					tooltipPos.x += tooltipPos.w;
				}
				if ( bCompactView )
				{
					tooltipPos.x += (tooltipJustify == PANEL_JUSTIFY_LEFT) ? 6 : -6;
				}
				updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
			}
		}
	}
}

void Player::CharacterSheet_t::updateStats()
{
	auto characterInfoFrame = sheetFrame->findFrame("character info");
	assert(characterInfoFrame);
	auto characterInnerFrame = characterInfoFrame->findFrame("character info inner frame");
	assert(characterInnerFrame);
	auto statsFrame = sheetFrame->findFrame("stats");
	assert(statsFrame);

	auto statsPos = statsFrame->getSize();
	//statsPos.x = sheetFrame->getSize().w - statsPos.w;
	statsFrame->setSize(statsPos);

	auto statsInnerFrame = statsFrame->findFrame("stats inner frame");
	assert(statsInnerFrame);

	const int rightAlignPosX = 0;
	const int leftAlignPosX = 10;
	auto statsInnerPos = statsInnerFrame->getSize();
	statsInnerPos.x = rightAlignPosX;
	/*if ( keystatus[SDLK_I] && enableDebugKeys )
	{
		statsInnerPos.x = leftAlignPosX;
	}*/
	statsInnerFrame->setSize(statsInnerPos);
	Button* strButton = statsInnerFrame->findButton("str button");
	Button* dexButton = statsInnerFrame->findButton("dex button");
	Button* conButton = statsInnerFrame->findButton("con button");
	Button* intButton = statsInnerFrame->findButton("int button");
	Button* perButton = statsInnerFrame->findButton("per button");
	Button* chrButton = statsInnerFrame->findButton("chr button");

	bool bCompactView = player.bUseCompactGUIHeight();

	bool enableTooltips = !player.GUI.isDropdownActive() && !player.GUI.dropdownMenu.bClosedThisTick;
	if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor 
		&& inputs.hasController(player.playernum)
		&& !Input::inputs[player.playernum].binary("MenuConfirm") )
	{
		enableTooltips = false;
	}
	char buf[32] = "";
	if ( auto field = statsInnerFrame->findField("str text stat") )
	{
		snprintf(buf, sizeof(buf), "%d", stats[player.playernum]->STR);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);

		Sint32 modifiedStat = statGetSTR(stats[player.playernum], players[player.playernum]->entity);
		if ( auto modifiedField = statsInnerFrame->findField("str text modified") )
		{
			modifiedField->setColor(hudColors.characterSheetNeutral);
			modifiedField->setDisabled(true);
			snprintf(buf, sizeof(buf), "%d", modifiedStat);
			if ( strcmp(buf, modifiedField->getText()) )
			{
				modifiedField->setText(buf);
				charsheetTooltipCache[player.playernum].manualUpdate = true;
			}
			if ( modifiedStat > stats[player.playernum]->STR )
			{
				modifiedField->setColor(hudColors.characterSheetGreen);
				modifiedField->setDisabled(false);
			}
			else if ( modifiedStat < stats[player.playernum]->STR )
			{
				modifiedField->setColor(hudColors.characterSheetRed);
				modifiedField->setDisabled(false);
			}
		}
		if ( selectedElement == SHEET_STR && enableTooltips )
		{
			SDL_Rect tooltipPos = statsFrame->getSize();
			tooltipPos.y += statsInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}
	if ( auto field = statsInnerFrame->findField("dex text stat") )
	{
		snprintf(buf, sizeof(buf), "%d", stats[player.playernum]->DEX);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);

		Sint32 modifiedStat = statGetDEX(stats[player.playernum], players[player.playernum]->entity);
		if ( auto modifiedField = statsInnerFrame->findField("dex text modified") )
		{
			modifiedField->setColor(hudColors.characterSheetNeutral);
			modifiedField->setDisabled(true);
			snprintf(buf, sizeof(buf), "%d", modifiedStat);
			if ( strcmp(buf, modifiedField->getText()) )
			{
				modifiedField->setText(buf);
				charsheetTooltipCache[player.playernum].manualUpdate = true;
			}
			if ( modifiedStat > stats[player.playernum]->DEX )
			{
				modifiedField->setColor(hudColors.characterSheetGreen);
				modifiedField->setDisabled(false);
			}
			else if ( modifiedStat < stats[player.playernum]->DEX )
			{
				modifiedField->setColor(hudColors.characterSheetRed);
				modifiedField->setDisabled(false);
			}
		}
		if ( selectedElement == SHEET_DEX && enableTooltips )
		{
			SDL_Rect tooltipPos = statsFrame->getSize();
			tooltipPos.y += statsInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}
	if ( auto field = statsInnerFrame->findField("con text stat") )
	{
		snprintf(buf, sizeof(buf), "%d", stats[player.playernum]->CON);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);

		Sint32 modifiedStat = statGetCON(stats[player.playernum], players[player.playernum]->entity);
		if ( auto modifiedField = statsInnerFrame->findField("con text modified") )
		{
			modifiedField->setColor(hudColors.characterSheetNeutral);
			modifiedField->setDisabled(true);
			snprintf(buf, sizeof(buf), "%d", modifiedStat);
			if ( strcmp(buf, modifiedField->getText()) )
			{
				modifiedField->setText(buf);
				charsheetTooltipCache[player.playernum].manualUpdate = true;
			}
			if ( modifiedStat > stats[player.playernum]->CON )
			{
				modifiedField->setColor(hudColors.characterSheetGreen);
				modifiedField->setDisabled(false);
			}
			else if ( modifiedStat < stats[player.playernum]->CON )
			{
				modifiedField->setColor(hudColors.characterSheetRed);
				modifiedField->setDisabled(false);
			}
		}
		if ( selectedElement == SHEET_CON && enableTooltips )
		{
			SDL_Rect tooltipPos = statsFrame->getSize();
			tooltipPos.y += statsInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}
	if ( auto field = statsInnerFrame->findField("int text stat") )
	{
		snprintf(buf, sizeof(buf), "%d", stats[player.playernum]->INT);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);

		Sint32 modifiedStat = statGetINT(stats[player.playernum], players[player.playernum]->entity);
		if ( auto modifiedField = statsInnerFrame->findField("int text modified") )
		{
			modifiedField->setColor(hudColors.characterSheetNeutral);
			modifiedField->setDisabled(true);
			snprintf(buf, sizeof(buf), "%d", modifiedStat);
			if ( strcmp(buf, modifiedField->getText()) )
			{
				modifiedField->setText(buf);
				charsheetTooltipCache[player.playernum].manualUpdate = true;
			}
			if ( modifiedStat > stats[player.playernum]->INT )
			{
				modifiedField->setColor(hudColors.characterSheetGreen);
				modifiedField->setDisabled(false);
			}
			else if ( modifiedStat < stats[player.playernum]->INT )
			{
				modifiedField->setColor(hudColors.characterSheetRed);
				modifiedField->setDisabled(false);
			}
		}
		if ( selectedElement == SHEET_INT && enableTooltips )
		{
			SDL_Rect tooltipPos = statsFrame->getSize();
			tooltipPos.y += statsInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}
	if ( auto field = statsInnerFrame->findField("per text stat") )
	{
		snprintf(buf, sizeof(buf), "%d", stats[player.playernum]->PER);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);

		Sint32 modifiedStat = statGetPER(stats[player.playernum], players[player.playernum]->entity);
		if ( auto modifiedField = statsInnerFrame->findField("per text modified") )
		{
			modifiedField->setColor(hudColors.characterSheetNeutral);
			modifiedField->setDisabled(true);
			snprintf(buf, sizeof(buf), "%d", modifiedStat);
			if ( strcmp(buf, modifiedField->getText()) )
			{
				modifiedField->setText(buf);
				charsheetTooltipCache[player.playernum].manualUpdate = true;
			}
			if ( modifiedStat > stats[player.playernum]->PER )
			{
				modifiedField->setColor(hudColors.characterSheetGreen);
				modifiedField->setDisabled(false);
			}
			else if ( modifiedStat < stats[player.playernum]->PER )
			{
				modifiedField->setColor(hudColors.characterSheetRed);
				modifiedField->setDisabled(false);
			}
		}
		if ( selectedElement == SHEET_PER && enableTooltips )
		{
			SDL_Rect tooltipPos = statsFrame->getSize();
			tooltipPos.y += statsInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}
	if ( auto field = statsInnerFrame->findField("chr text stat") )
	{
		snprintf(buf, sizeof(buf), "%d", stats[player.playernum]->CHR);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);

		Sint32 modifiedStat = statGetCHR(stats[player.playernum], players[player.playernum]->entity);
		if ( auto modifiedField = statsInnerFrame->findField("chr text modified") )
		{
			modifiedField->setColor(hudColors.characterSheetNeutral);
			modifiedField->setDisabled(true);
			snprintf(buf, sizeof(buf), "%d", modifiedStat);
			if ( strcmp(buf, modifiedField->getText()) )
			{
				modifiedField->setText(buf);
				charsheetTooltipCache[player.playernum].manualUpdate = true;
			}
			if ( modifiedStat > stats[player.playernum]->CHR )
			{
				modifiedField->setColor(hudColors.characterSheetGreen);
				modifiedField->setDisabled(false);
			}
			else if ( modifiedStat < stats[player.playernum]->CHR )
			{
				modifiedField->setColor(hudColors.characterSheetRed);
				modifiedField->setDisabled(false);
			}
		}
		if ( selectedElement == SHEET_CHR && enableTooltips )
		{
			SDL_Rect tooltipPos = statsFrame->getSize();
			tooltipPos.y += statsInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}
}

void Player::CharacterSheet_t::updateAttributes()
{
	auto attributesFrame = sheetFrame->findFrame("attributes");
	assert(attributesFrame);

	auto attributesPos = attributesFrame->getSize();
	//attributesPos.x = sheetFrame->getSize().w - attributesPos.w;
	attributesFrame->setSize(attributesPos);

	auto attributesInnerFrame = attributesFrame->findFrame("attributes inner frame");
	assert(attributesInnerFrame);

	const int rightAlignPosX = 0;
	const int leftAlignPosX = 10;
	auto attributesInnerPos = attributesInnerFrame->getSize();
	attributesInnerPos.x = rightAlignPosX;
	/*if ( keystatus[SDLK_I] )
	{
		attributesInnerPos.x = leftAlignPosX;
	}*/
	attributesInnerFrame->setSize(attributesInnerPos);

	bool bCompactView = player.bUseCompactGUIHeight();

	bool enableTooltips = !player.GUI.isDropdownActive() && !player.GUI.dropdownMenu.bClosedThisTick;
	if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor
		&& inputs.hasController(player.playernum)
		&& !Input::inputs[player.playernum].binary("MenuConfirm") )
	{
		enableTooltips = false;
	}

	char buf[32] = "";

	if ( auto field = attributesInnerFrame->findField("atk text stat") )
	{
		AttackHoverText_t atkHoverText;
		Sint32 displayedATK = displayAttackPower(player.playernum, atkHoverText);
		if ( atkHoverText.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_MAGICSTAFF
			|| atkHoverText.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_TOOL
			|| atkHoverText.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_TOOL_TRAP
			|| atkHoverText.hoverType == AttackHoverText_t::ATK_HOVER_TYPE_DEFAULT )
		{
			snprintf(buf, sizeof(buf), "-");
		}
		else
		{
			snprintf(buf, sizeof(buf), "%d", displayedATK);
		}
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);

		if ( selectedElement == SHEET_ATK && enableTooltips )
		{
			SDL_Rect tooltipPos = attributesFrame->getSize();
			tooltipPos.y += attributesInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}

	if ( auto field = attributesInnerFrame->findField("ac text stat") )
	{
		snprintf(buf, sizeof(buf), "%d", AC(stats[player.playernum]));
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);

		if ( selectedElement == SHEET_AC && enableTooltips )
		{
			SDL_Rect tooltipPos = attributesFrame->getSize();
			tooltipPos.y += attributesInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}

	if ( auto field = attributesInnerFrame->findField("pwr text stat") )
	{
		real_t spellPower = (getBonusFromCasterOfSpellElement(player.entity, stats[player.playernum], nullptr, SPELL_NONE) * 100.0) + 100.0;
		snprintf(buf, sizeof(buf), "%.f%%", spellPower);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);

		if ( selectedElement == SHEET_POW && enableTooltips )
		{
			SDL_Rect tooltipPos = attributesFrame->getSize();
			tooltipPos.y += attributesInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}

	if ( auto field = attributesInnerFrame->findField("res text stat") )
	{
		real_t resistance = 100.0 * Entity::getDamageTableMultiplier(player.entity, *stats[player.playernum], DAMAGE_TABLE_MAGIC);
		resistance /= (Entity::getMagicResistance(stats[player.playernum]) + 1);
		resistance = -(resistance - 100.0);
		snprintf(buf, sizeof(buf), "%d%%", (int)resistance);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);
		if ( resistance > 0.01 )
		{
			field->setColor(hudColors.characterSheetGreen);
		}
		else if ( resistance < -0.01 )
		{
			field->setColor(hudColors.characterSheetRed);
		}

		if ( selectedElement == SHEET_RES && enableTooltips )
		{
			SDL_Rect tooltipPos = attributesFrame->getSize();
			tooltipPos.y += attributesInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}

	if ( auto field = attributesInnerFrame->findField("regen text hp") )
	{
		field->setColor(hudColors.characterSheetNeutral);
		Uint32 color = hudColors.characterSheetNeutral;
		getDisplayedHPRegen(players[player.playernum]->entity, *stats[player.playernum], &color, buf);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(color);

		if ( selectedElement == SHEET_RGN && enableTooltips )
		{
			SDL_Rect tooltipPos = attributesFrame->getSize();
			tooltipPos.y += attributesInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}

	if ( auto field = attributesInnerFrame->findField("regen text mp") )
	{
		field->setColor(hudColors.characterSheetNeutral);
		Uint32 color = hudColors.characterSheetNeutral;
		getDisplayedMPRegen(players[player.playernum]->entity, *stats[player.playernum], &color, buf);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(color);

		if ( selectedElement == SHEET_RGN_MP && enableTooltips )
		{
			SDL_Rect tooltipPos = attributesFrame->getSize();
			tooltipPos.y += attributesInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}


	if ( auto field = attributesInnerFrame->findField("weight text stat") )
	{
		Sint32 weight = 0;
		for ( node_t* node = stats[player.playernum]->inventory.first; node != NULL; node = node->next )
		{
			Item* item = (Item*)node->element;
			if ( item )
			{
				weight += item->getWeight();
			}
		}
		weight += stats[player.playernum]->getGoldWeight();
		snprintf(buf, sizeof(buf), "%d", weight);
		if ( strcmp(buf, field->getText()) )
		{
			field->setText(buf);
			charsheetTooltipCache[player.playernum].manualUpdate = true;
		}
		field->setColor(hudColors.characterSheetNeutral);

		if ( selectedElement == SHEET_WGT && enableTooltips )
		{
			SDL_Rect tooltipPos = attributesFrame->getSize();
			tooltipPos.y += attributesInnerFrame->getSize().y;
			Player::PanelJustify_t tooltipJustify = panelJustify;
			if ( panelJustify == PANEL_JUSTIFY_LEFT )
			{
				tooltipPos.x += tooltipPos.w;
			}
			updateCharacterSheetTooltip(selectedElement, tooltipPos, tooltipJustify);
		}
	}
}

void Player::Hotbar_t::processHotbar()
{
#ifndef NINTENDO
	if ( inputs.hasController(player.playernum) )
	{
		useHotbarFaceMenu = playerSettings[multiplayer ? 0 : player.playernum].gamepad_facehotbar;
	}
	else if ( inputs.bPlayerUsingKeyboardControl(player.playernum) )
	{
		useHotbarFaceMenu = false;
	}
#else
	useHotbarFaceMenu = playerSettings[multiplayer ? 0 : player.playernum].gamepad_facehotbar;
#endif // NINTENDO

	if ( !hotbarFrame )
	{
		char name[32];
		snprintf(name, sizeof(name), "player hotbar %d", player.playernum);
		hotbarFrame = player.hud.hudFrame->addFrame(name);
		hotbarFrame->setHollow(true);
		hotbarFrame->setBorder(0);
		hotbarFrame->setOwner(player.playernum);
		hotbarFrame->setInheritParentFrameOpacity(false);
		createHotbar(player.playernum);
	}
	hotbarFrame->setSize(SDL_Rect{ 0, 0,
		players[player.playernum]->camera_virtualWidth(),
		players[player.playernum]->camera_virtualHeight() });

	if ( gamePaused || nohud || !players[player.playernum]->isLocalPlayer() )
	{
		// hide
		hotbarFrame->setDisabled(true);
		return;
	}
	else
	{
		hotbarFrame->setDisabled(false);
	}

	updateHotbar();
}

void Player::Inventory_t::Appraisal_t::updateAppraisalAnim()
{
	/*if ( current_item == 0 )
	{
		animAppraisal = 0.0;
		return;
	}*/
	real_t fpsScale = getFPSScale(60.0);
	real_t scale = PI / 40;
	animAppraisal += fpsScale * (scale);
	if ( animAppraisal >= 4 * PI )
	{
		animAppraisal -= 4 * PI;
	}

	if ( itemNotifyUpdatedThisTick == 0 )
	{
		itemNotifyUpdatedThisTick = ticks;
		itemNotifyAnimState = 0;
	}
	if ( (itemNotifyUpdatedThisTick != ticks) && (ticks - itemNotifyUpdatedThisTick) % (TICKS_PER_SECOND / 5) == 0 )
	{
		if ( itemNotifyUpdatedThisTick != ticks )
		{
			++itemNotifyAnimState;
			itemNotifyUpdatedThisTick = ticks;
		}
		if ( itemNotifyAnimState > 2 )
		{
			itemNotifyAnimState = 0;
		}
	}
}

void drawClockwiseSquareMesh(const char* texture, float lerp, SDL_Rect rect, Uint32 color) {
    auto image = Image::get(texture);
    image->drawClockwise(lerp, nullptr, rect,
        SDL_Rect{0, 0, Frame::virtualScreenX, Frame::virtualScreenY}, color);
}

void drawUnidentifiedItemEffectHotbarCallback(const Widget& widget, SDL_Rect rect)
{
	const int player = widget.getOwner();
	auto& appraisal = players[player]->inventoryUI.appraisal;
	if ( appraisal.animStartTick == ticks )
	{
		return;
	}
    
	const Frame* parent = static_cast<const Frame*>(widget.getParent());
	{
		SDL_Rect drawRect = rect;
		drawRect.x += 4;
		drawRect.y += 4;
		drawRect.w -= 6;
		drawRect.h -= 6;
        drawRect.x += drawRect.w / 2;
        drawRect.y += drawRect.h / 2;
		real_t opacity = 192;
		if ( parent && parent->getOpacity() < 100.0 )
		{
			opacity *= parent->getOpacity() / 100.0;
		}
        const auto& appraisal = players[player]->inventoryUI.appraisal;
        drawClockwiseSquareMesh("images/ui/HUD/hotbar/Appraisal_Icon_OutlineHotbar.png",
            (appraisal.timermax - appraisal.timer) / (float)appraisal.timermax,
            drawRect, makeColor(255, 255, 255, opacity));
	}

	auto drawMesh = [](real_t x, real_t y, real_t size, SDL_Rect rect, Uint32 color) {
		auto image = Image::get("images/ui/Inventory/Appraisal_Icon.png");
		const real_t sx = rect.w * size;
		const real_t sy = rect.h * size;
        image->drawColor(nullptr, SDL_Rect{(int)x, (int)y, (int)sx, (int)sy},
            SDL_Rect{0, 0, Frame::virtualScreenX, Frame::virtualScreenY}, color);
	};
	{
		const int imgSize = 26;
		SDL_Rect drawRect = rect;
		drawRect.x += 4 + (rect.w - 6) / 2 - imgSize / 2;
		drawRect.y += 4 + (rect.h - 6) / 2 - imgSize / 2;
		int offsetSize = 7;
		int offsetx = offsetSize * cos(std::min(4 * PI, appraisal.animAppraisal));
		int offsety = offsetSize * sin(std::min(4 * PI, appraisal.animAppraisal));

		drawRect.w = imgSize;
		drawRect.h = imgSize;

		real_t opacity = 92 + 160 * fabs(sin(std::min(2 * PI, appraisal.animAppraisal) / 2));
		if ( parent && parent->getOpacity() < 100.0 )
		{
			opacity *= parent->getOpacity() / 100.0;
		}
		drawMesh(drawRect.x + offsetx, drawRect.y + offsety,
			(real_t)1.0, drawRect, makeColor(255, 255, 255, opacity));
	}
}

void drawUnidentifiedItemEffectCallback(const Widget& widget, SDL_Rect rect)
{
	const int player = widget.getOwner();
	auto& appraisal = players[player]->inventoryUI.appraisal;
	if ( appraisal.animStartTick == ticks )
	{
		return;
	}

	const Frame* parent = static_cast<const Frame*>(widget.getParent());
	{
		SDL_Rect drawRect = rect;
		drawRect.x += 2;
		drawRect.y += 2;
		drawRect.w -= 2;
		drawRect.h -= 2;
        drawRect.x += drawRect.w / 2;
        drawRect.y += drawRect.h / 2;
		real_t opacity = 192;
		if ( parent && parent->getOpacity() < 100.0 )
		{
			opacity *= parent->getOpacity() / 100.0;
		}
		drawClockwiseSquareMesh("images/ui/Inventory/Appraisal_Icon_Outline.png",
            (appraisal.timermax - appraisal.timer) / (float)appraisal.timermax,
            drawRect, makeColor(255, 255, 255, opacity));
	}
    
    auto drawMesh = [](real_t x, real_t y, real_t size, SDL_Rect rect, Uint32 color) {
        auto image = Image::get("images/ui/Inventory/Appraisal_Icon.png");
        const real_t sx = rect.w * size;
        const real_t sy = rect.h * size;
        image->drawColor(nullptr, SDL_Rect{(int)x, (int)y, (int)sx, (int)sy},
            SDL_Rect{0, 0, Frame::virtualScreenX, Frame::virtualScreenY}, color);
    };
	{
		const int imgSize = 26;
		SDL_Rect drawRect = rect;
		drawRect.x += 4 + (rect.w - 6) / 2 - imgSize / 2;
		drawRect.y += 4 + (rect.h - 6) / 2 - imgSize / 2;
		int offsetSize = 7;
		int offsetx = offsetSize * cos(std::min(4 * PI, appraisal.animAppraisal));
		int offsety = offsetSize * sin(std::min(4 * PI, appraisal.animAppraisal));

		drawRect.w = imgSize;
		drawRect.h = imgSize;

		real_t opacity = 92 + 160 * fabs(sin(std::min(2 * PI, appraisal.animAppraisal) / 2));
		if ( parent && parent->getOpacity() < 100.0 )
		{
			opacity *= parent->getOpacity() / 100.0;
		}
		drawMesh(drawRect.x + offsetx, drawRect.y + offsety, 
			(real_t)1.0, drawRect, makeColor(255, 255, 255, opacity));
	}
}

void createPlayerInventorySlotFrameElements(Frame* slotFrame)
{
	const SDL_Rect slotSize = SDL_Rect{ 0, 0, slotFrame->getSize().w, slotFrame->getSize().h };
	SDL_Rect coloredBackgroundPos = SDL_Rect{ slotSize.x + 2, slotSize.y + 2, slotSize.w - 2, slotSize.h - 2 };

	auto beatitudeFrame = slotFrame->addFrame("beatitude status frame"); // covers unidentified status as well
	beatitudeFrame->setSize(slotSize);
	beatitudeFrame->setHollow(true);
	beatitudeFrame->setDisabled(true);
	beatitudeFrame->addImage(coloredBackgroundPos, 0xFFFFFFFF, "images/system/white.png", "beatitude status bg");

	auto brokenStatusFrame = slotFrame->addFrame("broken status frame");
	brokenStatusFrame->setSize(slotSize);
	brokenStatusFrame->setHollow(true);
	brokenStatusFrame->setDisabled(true);
	brokenStatusFrame->addImage(coloredBackgroundPos, makeColor( 160, 160, 160, 64), "images/system/white.png", "broken status bg");

	auto itemSpriteFrame = slotFrame->addFrame("item sprite frame");

	// cut off the slot 2px borders
	SDL_Rect itemSpriteBorder = { slotSize.x + 2, slotSize.y + 2, slotFrame->getSize().w - 2, slotFrame->getSize().h - 2 };
	const int itemSpriteSize = players[slotFrame->getOwner()]->inventoryUI.getItemSpriteSize();
	const int alignOffset = (itemSpriteBorder.w - itemSpriteSize) / 2; // align the item sprite within the box by this offset to center
	itemSpriteBorder.x += alignOffset;
	itemSpriteBorder.y += alignOffset;
	itemSpriteBorder.w = itemSpriteSize;
	itemSpriteBorder.h = itemSpriteSize;

	itemSpriteFrame->setSize(SDL_Rect{ itemSpriteBorder.x, itemSpriteBorder.y, 
		itemSpriteBorder.w, itemSpriteBorder.h });
	itemSpriteFrame->setHollow(true);
	itemSpriteFrame->setDisabled(true);
	SDL_Rect imgPos{ 0, 0, itemSpriteFrame->getSize().w, itemSpriteFrame->getSize().h };
	auto img = itemSpriteFrame->addImage(imgPos, 0xFFFFFFFF, "images/system/white.png", "item sprite img");
	img->outline = false;
	img->outlineColor = 0;
	auto iconLabelBgImg = itemSpriteFrame->addImage(SDL_Rect{ 0, 0, 16, 16 }, 0xFFFFFFFF,
		"images/ui/Inventory/Icon_Label_Backing_00.png", "icon label bg img");
	iconLabelBgImg->disabled = true;

	auto iconLabelImg = itemSpriteFrame->addImage(SDL_Rect{ 0, 0, 16, 16 }, 0xFFFFFFFF,
		"", "icon label img");
	iconLabelImg->disabled = true;

	auto unusableFrame = slotFrame->addFrame("unusable item frame");
	unusableFrame->setSize(slotSize);
	unusableFrame->setHollow(true);
	unusableFrame->setDisabled(true);
	unusableFrame->addImage(coloredBackgroundPos, makeColor( 64, 64, 64, 144), "images/system/white.png", "unusable item bg");

	auto appraisalFrame = slotFrame->addFrame("appraisal frame");
	appraisalFrame->setSize(slotSize);
	appraisalFrame->setHollow(true);
	appraisalFrame->setDisabled(true);
	appraisalFrame->addImage(SDL_Rect{ 4, 4, 6, 14 }, 0xFFFFFFFF,
		"images/ui/Inventory/tooltips/ExclamationAnim00.png", "new notif img");

	static const char* qtyfont = "fonts/pixel_maz.ttf#32#2";
	auto quantityFrame = slotFrame->addFrame("quantity frame");
	quantityFrame->setSize(slotSize);
	quantityFrame->setHollow(true);
	Field* qtyText = quantityFrame->addField("quantity text", 32);
	qtyText->setFont(qtyfont);
	qtyText->setColor(0xffffffff);
	qtyText->setHJustify(Field::justify_t::BOTTOM);
	qtyText->setVJustify(Field::justify_t::RIGHT);
	qtyText->setText("10");
	qtyText->setSize(SDL_Rect{ 0, 6, quantityFrame->getSize().w, quantityFrame->getSize().h });

	auto equippedIconFrame = slotFrame->addFrame("equipped icon frame");
	equippedIconFrame->setSize(slotSize);
	equippedIconFrame->setHollow(true);
	SDL_Rect equippedImgPos = { 2, slotSize.h - 18, 18, 18 };
	equippedIconFrame->addImage(equippedImgPos, 0xFFFFFFFF, "images/system/Equipped.png", "equipped icon img");

	auto brokenIconFrame = slotFrame->addFrame("broken icon frame");
	brokenIconFrame->setSize(slotSize);
	brokenIconFrame->setHollow(true);
	brokenIconFrame->addImage(equippedImgPos, 0xFFFFFFFF, "images/system/Broken.png", "broken icon img");
}

void resetInventorySlotFrames(const int player)
{
	//for ( int x = 0; x < players[player]->inventoryUI.getSizeX(); ++x )
	//{
	//	for ( int y = Player::Inventory_t::PaperDollRows::DOLL_ROW_1; y < players[player]->inventoryUI.DEFAULT_INVENTORY_SIZEY + players[player]->inventoryUI.getPlayerBackpackBonusSizeY(); ++y )
	//	{
	//		if ( auto slotFrame = players[player]->inventoryUI.getInventorySlotFrame(x, y) )
	//		{
	//			slotFrame->setDisabled(true);
	//		}
	//	}
	//}

	if ( players[player]->inventoryUI.frame )
	{
		for ( auto& pair : players[player]->inventoryUI.slotFrames )
		{
			if ( pair.second ) { pair.second->setDisabled(true); }
		}
	}

	//for ( int x = 0; x < Player::Inventory_t::MAX_SPELLS_X; ++x )
	//{
	//	for ( int y = 0; y < Player::Inventory_t::MAX_SPELLS_Y; ++y )
	//	{
	//		if ( auto slotFrame = players[player]->inventoryUI.getSpellSlotFrame(x, y) )
	//		{
	//			slotFrame->setDisabled(true);
	//		}
	//	}
	//}

	if ( players[player]->inventoryUI.spellFrame )
	{
		for ( auto& pair : players[player]->inventoryUI.spellSlotFrames )
		{
			if ( pair.second ) { pair.second->setDisabled(true); }
		}
	}

	//for ( int x = 0; x < Player::Inventory_t::MAX_CHEST_X; ++x )
	//{
	//	for ( int y = 0; y < Player::Inventory_t::MAX_CHEST_Y; ++y )
	//	{
	//		if ( auto slotFrame = players[player]->inventoryUI.getChestSlotFrame(x, y) )
	//		{
	//			slotFrame->setDisabled(true);
	//		}
	//	}
	//}

	if ( players[player]->inventoryUI.chestFrame )
	{
		for ( auto& pair : players[player]->inventoryUI.chestSlotFrames )
		{
			if ( pair.second ) { pair.second->setDisabled(true); }
		}
	}

	//for ( int x = 0; x < Player::ShopGUI_t::MAX_SHOP_X; ++x )
	//{
	//	for ( int y = 0; y < Player::ShopGUI_t::MAX_SHOP_Y; ++y )
	//	{
	//		if ( auto slotFrame = players[player]->shopGUI.getShopSlotFrame(x, y) )
	//		{
	//			slotFrame->setDisabled(true);
	//		}
	//	}
	//}

	if ( players[player]->shopGUI.shopFrame )
	{
		for ( auto& pair : players[player]->shopGUI.shopSlotFrames )
		{
			if ( pair.second ) { pair.second->setDisabled(true); }
		}
	}
}

bool getSlotFrameXYFromMousePos(const int player, int& outx, int& outy, bool spells)
{
	if ( !gui )
	{
		return false;
	}

	if ( players[player]->inventoryUI.chestFrame && !spells
		&& !players[player]->inventoryUI.chestFrame->isDisabled() )
	{
		for ( int x = 0; x < Player::Inventory_t::MAX_CHEST_X; ++x )
		{
			for ( int y = 0; y < Player::Inventory_t::MAX_CHEST_Y; ++y )
			{
				auto slotFrame = players[player]->inventoryUI.getChestSlotFrame(x, y);
				if ( !slotFrame )
				{
					continue;
				}

				if ( !players[player]->inventoryUI.chestGUI.isSlotVisible(x, y) )
				{
					continue;
				}

				if ( slotFrame->capturesMouseInRealtimeCoords() )
				{
					outx = x;
					outy = y;
					return true;
				}
			}
		}
	}
	if ( players[player]->inventoryUI.frame && !spells 
		&& players[player]->inventory_mode == INVENTORY_MODE_ITEM )
	{
		for ( int x = 0; x < players[player]->inventoryUI.getSizeX(); ++x )
		{
			for ( int y = Player::Inventory_t::DOLL_ROW_1; y < players[player]->inventoryUI.getSizeY(); ++y )
			{
				auto slotFrame = players[player]->inventoryUI.getInventorySlotFrame(x, y);
				if ( !slotFrame )
				{
					continue;
				}

				if ( slotFrame->capturesMouseInRealtimeCoords() )
				{
					outx = x;
					outy = y;
					return true;
				}
			}
		}
	}
	if ( players[player]->inventoryUI.spellFrame && spells 
		&& players[player]->inventory_mode == INVENTORY_MODE_SPELL )
	{
		for ( int x = 0; x < Player::Inventory_t::MAX_SPELLS_X; ++x )
		{
			for ( int y = 0; y < Player::Inventory_t::MAX_SPELLS_Y; ++y )
			{
				auto slotFrame = players[player]->inventoryUI.getSpellSlotFrame(x, y);
				if ( !slotFrame )
				{
					continue;
				}

				if ( !players[player]->inventoryUI.spellPanel.isSlotVisible(x, y) )
				{
					continue;
				}

				if ( slotFrame->capturesMouseInRealtimeCoords() )
				{
					outx = x;
					outy = y;
					return true;
				}
			}
		}
	}
	return false;
}

enum SlotFrameIndices : size_t {
	SLOTFRAME_BEATITUDE_FRAME = 0,
	SLOTFRAME_BEATITUDE_IMG = 0,
	SLOTFRAME_BROKEN_STATUS_FRAME = 1,
	SLOTFRAME_BROKEN_STATUS_IMG = 0,
	SLOTFRAME_ITEMSPRITE_FRAME = 2,
	SLOTFRAME_ITEMSPRITE_IMG = 0,
	SLOTFRAME_ITEMSPRITE_LABELBG_IMG = 1,
	SLOTFRAME_ITEMSPRITE_LABEL_IMG = 2,
	SLOTFRAME_UNUSABLE_ITEM_FRAME = 3,
	SLOTFRAME_UNUSABLE_IMG = 0,
	SLOTFRAME_APPRAISAL_FRAME = 4,
	SLOTFRAME_APPRAISAL_NOTIF_IMG = 0,
	SLOTFRAME_QTY_FRAME = 5,
	SLOTFRAME_QTY_TEXT = 0,
	SLOTFRAME_EQUIPPED_FRAME = 6,
	SLOTFRAME_EQUIPPED_IMG = 0,
	SLOTFRAME_BROKEN_ICON_FRAME = 7,
	SLOTFRAME_BROKEN_ICON_IMG = 0
};
void updateSlotFrameFromItem(Frame* slotFrame, void* itemPtr, bool forceUnusable)
{
	if ( !itemPtr || !slotFrame )
	{
		return;
	}

	Item* item = (Item*)itemPtr;

	int player = slotFrame->getOwner();

	bool hiddenItemInGUI = false;
	if ( item->itemSpecialShopConsumable )
	{
		if ( stats[player]->getModifiedProficiency(PRO_TRADING) + statGetCHR(stats[player], players[player]->entity) < (((int)item->itemRequireTradingSkillInShop) * SHOP_CONSUMABLE_SKILL_REQ_PER_POINT) )
		{
			hiddenItemInGUI = true;
		}
	}

	slotFrame->setDisabled(false);

	auto& frames = slotFrame->getFrames();

	auto spriteImageFrame = frames[SLOTFRAME_ITEMSPRITE_FRAME]; // slotFrame->findFrame("item sprite frame");
	auto spriteImage = spriteImageFrame->getImages()[SLOTFRAME_ITEMSPRITE_IMG]; // [spriteImageFrame->findImage("item sprite img");

	if ( hiddenItemInGUI )
	{
		spriteImage->path = ("*#images/system/unknownitem.png");
	}
	else
	{
		spriteImage->path = getItemSpritePath(player, *item);
	}
	bool disableBackgrounds = false;
	if ( !strcmp(slotFrame->getName(), "dragging inventory item") ) // dragging item, no need for colors
	{
		disableBackgrounds = true;
	}

	int* slotType = nullptr;
	if ( slotFrame->getUserData() )
	{
		slotType = (int*)slotFrame->getUserData();
		if ( *slotType == GAMEUI_FRAMEDATA_ANIMATING_ITEM 
			|| *slotType == GAMEUI_FRAMEDATA_ALCHEMY_RECIPE_SLOT )
		{
			disableBackgrounds = true;
		}
	}

	bool isHotbarIcon = false;
	bool alchemyResultIcon = &GenericGUI[player].alchemyGUI.alchemyResultPotion == item;
	if ( spriteImage->path != "" )
	{
		spriteImageFrame->setDisabled(false);
		if ( inputs.getUIInteraction(player)->selectedItem == item )
		{
			if ( !strcmp(slotFrame->getName(), "hotbar slot item") ) // hotbar slots
			{
				// fade this icon
				spriteImage->color = makeColor( 255, 255, 255, 128);
				disableBackgrounds = true;
				isHotbarIcon = true;
			}
		}
		else if ( !strcmp(slotFrame->getName(), "hotbar slot item") ) // hotbar slots
		{
			isHotbarIcon = true;
			auto& hotbar_t = players[player]->hotbar;
			bool tryDimHotbarSlot = false;
			if ( hotbar_t.useHotbarFaceMenu && hotbar_t.faceMenuButtonHeld != Player::Hotbar_t::GROUP_NONE )
			{
				tryDimHotbarSlot = true;
			}
			spriteImage->color = 0xFFFFFFFF;
			if ( tryDimHotbarSlot )
			{
				std::string hotbarSlotParentStr = slotFrame->getParent()->getName();
				if ( hotbarSlotParentStr.find("hotbar slot ") != std::string::npos )
				{
					int num = stoi(hotbarSlotParentStr.substr(strlen("hotbar slot ")));
					if ( hotbar_t.faceMenuButtonHeld != hotbar_t.getFaceMenuGroupForSlot(num) )
					{
						// fade this icon
						spriteImage->color = makeColor( 255, 255, 255, 128);
					}
				}
			}
		}
		else
		{
			spriteImage->color = 0xFFFFFFFF;
		}
		if ( auto iconLabelImg = spriteImageFrame->getImages()[SLOTFRAME_ITEMSPRITE_LABEL_IMG]/*spriteImageFrame->findImage("icon label img")*/ )
		{
			iconLabelImg->path = ItemTooltips.getIconLabel(*item);
			iconLabelImg->disabled = true;
			const int size = 16;
			const int padx = spriteImageFrame->getSize().w / 2 - size / 2;
			iconLabelImg->pos = SDL_Rect{ spriteImageFrame->getSize().w - size - 1,
				1 /*spriteImageFrame->getSize().h - size*/, size, size };
			if ( iconLabelImg->path != "" )
			{
				iconLabelImg->disabled = (!item->identified || hiddenItemInGUI);
			}
			iconLabelImg->color = spriteImage->color;
			if ( auto iconLabelBgImg = spriteImageFrame->getImages()[SLOTFRAME_ITEMSPRITE_LABELBG_IMG]/*spriteImageFrame->findImage("icon label bg img")*/ )
			{
				iconLabelBgImg->pos.w = 24;
				iconLabelBgImg->pos.h = iconLabelBgImg->pos.w;
				iconLabelBgImg->pos.x = spriteImageFrame->getSize().w - iconLabelBgImg->pos.w - 1;
				iconLabelBgImg->pos.y = 1;
				iconLabelBgImg->disabled = iconLabelImg->disabled || disableBackgrounds;
				iconLabelBgImg->color = makeColor(255, 255, 255, 255);
			}
		}
		if ( slotFrame->getUserData() )
		{
			if ( *slotType == GAMEUI_FRAMEDATA_ALCHEMY_ITEM || *slotType == GAMEUI_FRAMEDATA_ALCHEMY_RECIPE_SLOT )
			{
				SDL_Color color;
				getColor(spriteImage->color, &color.r, &color.g, &color.b, &color.a);
				color.a /= 2;
				spriteImage->color = makeColor(color.r, color.g, color.b, color.a);
			}
		}
	}

	if ( auto qtyFrame = frames[SLOTFRAME_QTY_FRAME]/*slotFrame->findFrame("quantity frame")*/ )
	{
		qtyFrame->setDisabled(true);
		bool drawQty = (item->count > 1) ? true : false;
		if ( !drawQty && GenericGUI[player].isNodeTinkeringCraftableItem(item->node) )
		{
			drawQty = true;
		}
		else if ( slotType && *slotType == GAMEUI_FRAMEDATA_ALCHEMY_RECIPE_ENTRY )
		{
			drawQty = true;
		}
		Uint32 qtyColor = 0xFFFFFFFF;
		bool stackable = false;
		Item*& selectedItem = inputs.getUIInteraction(player)->selectedItem;
		if ( selectedItem && !isHotbarIcon && !alchemyResultIcon 
			&& !(slotType 
				&& (*slotType == GAMEUI_FRAMEDATA_ANIMATING_ITEM 
					|| *slotType == GAMEUI_FRAMEDATA_ALCHEMY_RECIPE_SLOT
					|| *slotType == GAMEUI_FRAMEDATA_ALCHEMY_RECIPE_ENTRY)) )
		{
			if ( item != selectedItem 
				&& !itemIsEquipped(selectedItem, player)
				&& !itemIsEquipped(item, player) )
			{
				int selectedItemQty;
				int destItemQty;
				auto result = getItemStackingBehavior(player, selectedItem, item, selectedItemQty, destItemQty);
				if ( result.resultType == ITEM_ADDED_ENTIRELY_TO_DESTINATION_STACK
					|| result.resultType == ITEM_ADDED_PARTIALLY_TO_DESTINATION_STACK )
				{
					drawQty = true;
					qtyColor = hudColors.characterSheetGreen;
					stackable = true;
				}
			}
		}
		if ( drawQty )
		{
			qtyFrame->setDisabled(false);
			if ( auto qtyText = qtyFrame->getFields()[SLOTFRAME_QTY_TEXT]/*qtyFrame->findField("quantity text")*/ )
			{
				char qtybuf[32] = "";
				if ( stackable )
				{
					if ( item->count == 1 )
					{
						snprintf(qtybuf, sizeof(qtybuf), "+");
					}
					else if ( item->count > 1 )
					{
						snprintf(qtybuf, sizeof(qtybuf), "%d+", item->count);
					}
				}
				else
				{
					snprintf(qtybuf, sizeof(qtybuf), "%d", item->count);
				}
				if ( strcmp(qtyText->getText(), qtybuf) )
				{
					qtyText->setText(qtybuf);
				}
				qtyText->setColor(qtyColor);
			}
		}
	}
	
	if ( auto beatitudeFrame = frames[SLOTFRAME_BEATITUDE_FRAME]/*slotFrame->findFrame("beatitude status frame")*/ )
	{
		beatitudeFrame->setDisabled(true);
		//spriteImage->outline = false;
		if ( !disableBackgrounds )
		{
			if ( auto beatitudeImg = beatitudeFrame->getImages()[SLOTFRAME_BEATITUDE_IMG]/*beatitudeFrame->findImage("beatitude status bg")*/ )
			{
				if ( !item->identified )
				{
					//beatitudeImg->color = makeColor( 128, 128, 0, 125);
					if ( !(slotFrame->getUserData() && *slotType == GAMEUI_FRAMEDATA_SHOP_ITEM) )
					{
						beatitudeFrame->setDisabled(false);
					}
					//spriteImage->outlineColor = makeColor(210, 183, 76, 255);
					//spriteImage->outline = true;
				}
				else if ( item->beatitude < 0 )
				{
					//beatitudeImg->color = makeColor( 128, 0, 0, 125);
					beatitudeFrame->setDisabled(false);
					//spriteImage->outlineColor = hudColors.characterSheetRed;
					//spriteImage->outline = true;
				}
				else if ( item->beatitude > 0 )
				{
					/*if ( colorblind )
					{
						beatitudeImg->color = makeColor( 100, 245, 255, 65);
					}
					else
					{
						beatitudeImg->color = makeColor( 0, 255, 0, 65);
					}*/
					//spriteImage->outlineColor = hudColors.characterSheetHeadingText;
					//spriteImage->outline = true;
					beatitudeFrame->setDisabled(false);
				}
				/*if ( !spriteImage->outline )
				{
					spriteImage->outlineColor = 0;
				}
				else
				{
					spriteImage->outlineColor = makeColor(0, 0, 0, 255);
				}*/
				if ( !beatitudeFrame->isDisabled() )
				{
					//beatitudeImg->color = uint32ColorWhite;
					if ( isHotbarIcon || (slotFrame->getUserData() && *slotType == GAMEUI_FRAMEDATA_WORLDTOOLTIP_ITEM) )
					{
						if ( !item->identified )
						{
							static const char* unidentifyHotbarPath = "*#images/ui/HUD/hotbar/HUD_Quickbar_Slot_Box_Overlay_App01.png";
							if ( strcmp(unidentifyHotbarPath, beatitudeImg->path.c_str()) )
							{
								beatitudeImg->path = unidentifyHotbarPath;
							}
						}
						else if ( item->beatitude > 0 )
						{
							static const char* blessHotbarPath = "*#images/ui/HUD/hotbar/HUD_Quickbar_Slot_Box_Overlay_Bless01.png";
							if ( strcmp(blessHotbarPath, beatitudeImg->path.c_str()) )
							{
								beatitudeImg->path = blessHotbarPath;
							}
						}
						else if ( item->beatitude < 0 )
						{
							static const char* curseHotbarPath = "*#images/ui/HUD/hotbar/HUD_Quickbar_Slot_Box_Overlay_Curse01.png";
							if ( strcmp(curseHotbarPath, beatitudeImg->path.c_str()) )
							{
								beatitudeImg->path = curseHotbarPath;
							}
						}
					}
					else
					{
						if ( !item->identified )
						{
							static const char* unidentifyPath = "*#images/ui/Inventory/HUD_Inventory_Item_App00B.png";
							if ( strcmp(unidentifyPath, beatitudeImg->path.c_str()) )
							{
								beatitudeImg->path = unidentifyPath;
							}
						}
						else if ( item->beatitude > 0 )
						{
							static const char* blessPath = "*#images/ui/Inventory/HUD_Inventory_Item_Bless00B.png";
							if ( strcmp(blessPath, beatitudeImg->path.c_str()) )
							{
								beatitudeImg->path = blessPath;
							}
						}
						else if ( item->beatitude < 0 )
						{
							static const char* cursePath = "*#images/ui/Inventory/HUD_Inventory_Item_Curse00B.png";
							if ( strcmp(cursePath, beatitudeImg->path.c_str()) )
							{
								beatitudeImg->path = cursePath;
							}
						}
					}
				}
			}
		}
	}

	if ( auto brokenStatusFrame = frames[SLOTFRAME_BROKEN_STATUS_FRAME]/*slotFrame->findFrame("broken status frame")*/ )
	{
		brokenStatusFrame->setDisabled(true);
		if ( !disableBackgrounds )
		{
			if ( item->status == BROKEN )
			{
				if ( players[player]->shopGUI.bOpen 
					&& isItemSellableToShop(player, item)
					&& !(slotFrame->getUserData() && *slotType == GAMEUI_FRAMEDATA_SHOP_ITEM) )
				{
					// don't grey out this item
				}
				else
				{
					brokenStatusFrame->setDisabled(false);
					auto brokenStatusImg = brokenStatusFrame->getImages()[SLOTFRAME_BROKEN_STATUS_IMG];/*brokenStatusFrame->findImage("broken status bg");*/
					if ( isHotbarIcon || (slotFrame->getUserData() && *slotType == GAMEUI_FRAMEDATA_WORLDTOOLTIP_ITEM) )
					{
						brokenStatusImg->path = "*#images/ui/HUD/hotbar/HUD_Quickbar_Slot_Box_Overlay_01.png";
					}
					else
					{
						brokenStatusImg->path = "images/system/white.png";
					}
				}
			}
		}
	}

	if ( auto unusableFrame = frames[SLOTFRAME_UNUSABLE_ITEM_FRAME]/*slotFrame->findFrame("unusable item frame")*/ )
	{
		bool greyedOut = forceUnusable || hiddenItemInGUI;
		unusableFrame->setDisabled(true);

		if ( (slotFrame->getUserData() && *slotType == GAMEUI_FRAMEDATA_WORLDTOOLTIP_ITEM) )
		{
			// no grey out
		}
		else if ( !disableBackgrounds )
		{
			if ( players[player] && players[player]->entity && players[player]->entity->effectShapeshift != NOTHING )
			{
				// shape shifted, disable some items
				if ( !item->usableWhileShapeshifted(stats[player]) )
				{
					greyedOut = true;
				}
			}
			if ( !greyedOut && client_classes[player] == CLASS_SHAMAN
				&& item->type == SPELL_ITEM && !(playerUnlockedShamanSpell(player, item)) )
			{
				greyedOut = true;
			}

			if ( greyedOut )
			{
				unusableFrame->setDisabled(false);
			}
		}
	}

	bool equipped = false;
	bool broken = false;
	if ( itemCategory(item) != SPELL_CAT )
	{
		if ( itemIsEquipped(item, player) )
		{
			equipped = true;
		}
		else if ( item->status == BROKEN )
		{
			broken = true;
		}
		else if ( alchemyResultIcon && stats[player]->weapon 
			&& itemCategory(stats[player]->weapon) == POTION
			&& stats[player]->weapon->identified && item->identified )
		{
			int selectedItemQty;
			int destItemQty;
			auto result = getItemStackingBehavior(player, item, stats[player]->weapon, selectedItemQty, destItemQty);
			if ( result.resultType == ITEM_ADDED_ENTIRELY_TO_DESTINATION_STACK
				|| result.resultType == ITEM_ADDED_PARTIALLY_TO_DESTINATION_STACK )
			{
				equipped = true;
			}
		}
	}
	else
	{
		spell_t* spell = getSpellFromItem(player, item);
		if ( players[player]->magic.selectedSpell() == spell
			&& (players[player]->magic.selected_spell_last_appearance == item->appearance || players[player]->magic.selected_spell_last_appearance == -1) )
		{
			equipped = true;
		}
	}

	if ( auto equippedIconFrame = frames[SLOTFRAME_EQUIPPED_FRAME]/*slotFrame->findFrame("equipped icon frame")*/ )
	{
		equippedIconFrame->setDisabled(true);
		if ( equipped && (!disableBackgrounds || (slotType && (*slotType == GAMEUI_FRAMEDATA_ANIMATING_ITEM))) )
		{
			equippedIconFrame->setDisabled(false);
		}
	}
	if ( auto brokenIconFrame = frames[SLOTFRAME_BROKEN_ICON_FRAME]/*slotFrame->findFrame("broken icon frame")*/ )
	{
		brokenIconFrame->setDisabled(true);
		if ( broken && (!disableBackgrounds || (slotType && (*slotType == GAMEUI_FRAMEDATA_ALCHEMY_RECIPE_SLOT))) )
		{
			brokenIconFrame->setDisabled(false);
		}
	}

	if ( auto appraisalFrame = frames[SLOTFRAME_APPRAISAL_FRAME]/*slotFrame->findFrame("appraisal frame")*/ )
	{
		appraisalFrame->setDisabled(true);
		appraisalFrame->setDrawCallback(nullptr);
		if ( !item->identified )
		{
			appraisalFrame->setDisabled(false);
		}
		else if ( item->notifyIcon )
		{
			appraisalFrame->setDisabled(false);
		}
		if ( !disableBackgrounds && players[player]->inventoryUI.appraisal.current_item > 0
			&& slotFrame->getOpacity() > 0.999
			&& !item->identified && item->node && item->node->list == &stats[player]->inventory
			&& item->uid == players[player]->inventoryUI.appraisal.current_item )
		{
			if ( isHotbarIcon )
			{
				appraisalFrame->setDisabled(false);
				appraisalFrame->setDrawCallback([](const Widget& widget, SDL_Rect rect) {
					drawUnidentifiedItemEffectHotbarCallback(widget, rect);
				});
			}
			else
			{
				appraisalFrame->setDisabled(false);
				appraisalFrame->setDrawCallback([](const Widget& widget, SDL_Rect rect) {
					drawUnidentifiedItemEffectCallback(widget, rect);
				});
			}
		}
		if ( !appraisalFrame->isDisabled() )
		{
			auto img = appraisalFrame->getImages()[SLOTFRAME_APPRAISAL_NOTIF_IMG];/*appraisalFrame->findImage("new notif img");*/
			img->disabled = true;
			if ( !item->identified )
			{
				img->disabled = false;
				img->path = "images/ui/Inventory/tooltips/Unidentified_Icon.png";
				img->pos.x = 28;
				img->pos.y = 4;
				img->pos.w = 10;
				img->pos.h = 14;
				if ( isHotbarIcon || (slotFrame->getUserData() && *slotType == GAMEUI_FRAMEDATA_WORLDTOOLTIP_ITEM) )
				{
					img->pos.x = 30;
					img->pos.y = 6;
				}
			}
			else if ( item->notifyIcon )
			{
				img->pos.x = 4;
				img->pos.y = 4;
				img->pos.w = 6;
				img->pos.h = 14;
				if ( isHotbarIcon && !players[player]->hotbar.useHotbarFaceMenu )
				{
					img->pos.x = 10;
					img->pos.y = 2;

					// to push to right of "10" text if we label that
					/*if ( players[player]->hotbar.slots()[NUM_HOTBAR_SLOTS - 1].item == item->uid )
					{
						if ( slotFrame && slotFrame->getParent() && !strcmp(slotFrame->getParent()->getName(), "hotbar slot 9") )
						{
							img->pos.x += 6;
						}
					}*/
				}
				img->disabled = false;
				switch ( players[player]->inventoryUI.appraisal.itemNotifyAnimState )
				{
					case 0:
						img->path = "images/ui/Inventory/tooltips/ExclamationAnim00.png";
						break;
					case 1:
						img->path = "images/ui/Inventory/tooltips/ExclamationAnim01.png";
						break;
					case 2:
						img->path = "images/ui/Inventory/tooltips/ExclamationAnim02.png";
						break;
					default:
						img->path = "images/ui/Inventory/tooltips/ExclamationAnim00.png";
						break;
				}
			}
		}
	}
}

void createInventoryTooltipFrame(const int player)
{
	if ( !gui )
	{
		return;
	}

	//const std::string headerFont = "fonts/pixelmix.ttf#14#2";
	//const std::string bodyFont = "fonts/pixelmix.ttf#12#2";
	const std::string headerFont = "fonts/pixel_maz_multiline.ttf#16#2";
	const std::string bodyFont = "fonts/pixel_maz_multiline.ttf#16#2";

	if ( !players[player]->inventoryUI.tooltipContainerFrame )
	{
		char name[32];
		snprintf(name, sizeof(name), "player tooltip container %d", player);
		players[player]->inventoryUI.tooltipContainerFrame = gameUIFrame[player]->addFrame(name);
		players[player]->inventoryUI.tooltipContainerFrame->setSize(
			SDL_Rect{ players[player]->camera_virtualx1(),
			players[player]->camera_virtualy1(), 
			players[player]->camera_virtualWidth(),
			players[player]->camera_virtualHeight() });
		players[player]->inventoryUI.tooltipContainerFrame->setHollow(true);
		players[player]->inventoryUI.tooltipContainerFrame->setDisabled(false);
		players[player]->inventoryUI.tooltipContainerFrame->setInheritParentFrameOpacity(false);
	}
	if ( !players[player]->inventoryUI.titleOnlyTooltipFrame )
	{
		char name[32];
		snprintf(name, sizeof(name), "player title only tooltip %d", player);
		players[player]->inventoryUI.titleOnlyTooltipFrame = players[player]->inventoryUI.tooltipContainerFrame->addFrame(name);
		auto tooltipFrame = players[player]->inventoryUI.titleOnlyTooltipFrame;
		tooltipFrame->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipFrame->setHollow(true);
		tooltipFrame->setDisabled(true);
		tooltipFrame->setInheritParentFrameOpacity(false);

		auto tooltipTextField = tooltipFrame->addField("title only header", 1024);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(headerFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::CENTER);
		tooltipTextField->setVJustify(Field::justify_t::TOP);
		tooltipTextField->setTextColor(hudColors.characterSheetGreen);
		tooltipTextField->setPaddingPerLine(-2);

		Uint32 color = makeColor(255, 255, 255, 255);
		tooltipFrame->addImage(SDL_Rect{ 0, 0, tooltipFrame->getSize().w, 28 },
			color, "*#images/ui/Inventory/tooltips/Hover_T00_TitleOnly.png", "tooltip top background");
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 16, 28 },
			color, "*#images/ui/Inventory/tooltips/Hover_TL00_TitleOnly.png", "tooltip top left");
		tooltipFrame->addImage(SDL_Rect{ 0, 0, 16, 28 },
			color, "*#images/ui/Inventory/tooltips/Hover_TR00_TitleOnly.png", "tooltip top right");
	}
	if ( !players[player]->inventoryUI.tooltipFrame )
	{
		char name[32];
		snprintf(name, sizeof(name), "player tooltip %d", player);
		players[player]->inventoryUI.tooltipFrame = players[player]->inventoryUI.tooltipContainerFrame->addFrame(name);
		auto tooltipFrame = players[player]->inventoryUI.tooltipFrame;
		tooltipFrame->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipFrame->setHollow(true);
		tooltipFrame->setDisabled(true);
		tooltipFrame->setInheritParentFrameOpacity(false);
	}
	else
	{
		return;
	}

	auto tooltipFrame = players[player]->inventoryUI.tooltipFrame;

	Uint32 color = makeColor( 255, 255, 255, 255);
	tooltipFrame->addImage(SDL_Rect{ 0, 0, tooltipFrame->getSize().w, 28 },
		color, "*#images/ui/Inventory/tooltips/Hover_T00.png", "tooltip top background");
	tooltipFrame->addImage(SDL_Rect{ 0, 0, 16, 28 },
		color, "*#images/ui/Inventory/tooltips/Hover_TL00.png", "tooltip top left");
	tooltipFrame->addImage(SDL_Rect{ 0, 0, 16, 28 },
		color, "*#images/ui/Inventory/tooltips/Hover_TR00.png", "tooltip top right");

	tooltipFrame->addImage(SDL_Rect{ 0, 0, tooltipFrame->getSize().w, 52 },
		color, "*#images/ui/Inventory/tooltips/Hover_C00.png", "tooltip middle background");
	tooltipFrame->addImage(SDL_Rect{ 0, 0, 16, 52 },
		color, "*#images/ui/Inventory/tooltips/Hover_L00.png", "tooltip middle left");
	tooltipFrame->addImage(SDL_Rect{ 0, 0, 16, 52 },
		color, "*#images/ui/Inventory/tooltips/Hover_R00.png", "tooltip middle right");

	tooltipFrame->addImage(SDL_Rect{ 0, 0, tooltipFrame->getSize().w, 26 },
		color, "*#images/ui/Inventory/tooltips/Hover_B00.png", "tooltip bottom background");
	tooltipFrame->addImage(SDL_Rect{ 0, 0, 16, 26 },
		color, "*#images/ui/Inventory/tooltips/Hover_BL01.png", "tooltip bottom left");
	tooltipFrame->addImage(SDL_Rect{ 0, 0, 16, 26 },
		color, "*#images/ui/Inventory/tooltips/Hover_BR01.png", "tooltip bottom right");

	auto tooltipTextField = tooltipFrame->addField("inventory mouse tooltip header", 1024);
	tooltipTextField->setText("Nothing");
	tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
	tooltipTextField->setFont(headerFont.c_str());
	tooltipTextField->setHJustify(Field::justify_t::LEFT);
	tooltipTextField->setVJustify(Field::justify_t::CENTER);
	tooltipTextField->setColor(makeColor( 67, 195, 157, 255));

	// temporary debug stuff
	{
		Frame::image_t* tmp = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "images/system/white.png", "inventory mouse tooltip min");
		tmp->color = makeColor( 255, 0, 0, 255);
		tmp->disabled = true;
		tmp = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
			0xFFFFFFFF, "images/system/white.png", "inventory mouse tooltip max");
		tmp->color = makeColor( 0, 255, 0, 255);
		tmp->disabled = true;
		tmp = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
			0xFFFFFFFF, "images/system/white.png", "inventory mouse tooltip header max");
		tmp->color = makeColor( 0, 255, 255, 255);
		tmp->disabled = true;
		tmp = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
			0xFFFFFFFF, "images/system/white.png", "inventory mouse tooltip header bg");
		tmp->color = makeColor( 255, 255, 255, 255);
		tmp->disabled = true;
		tmp = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
			0xFFFFFFFF, "images/system/white.png", "inventory mouse tooltip header bg new");
		tmp->color = makeColor( 255, 255, 0, 255);
		tmp->disabled = true;

		tmp = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
			makeColor(255, 255, 255, 0), "images/ui/Inventory/tooltips/TooltipGradientTop.png", "inventory mouse tooltip fade top");
		tmp->disabled = true;
		tmp->ontop = true;
		tmp = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
			makeColor(255, 255, 255, 0), "images/ui/Inventory/tooltips/TooltipGradientBottom.png", "inventory mouse tooltip fade bottom");
		tmp->disabled = true;
		tmp->ontop = true;
	}

	if ( auto attrFrame = tooltipFrame->addFrame("inventory mouse tooltip attributes frame") )
	{
		attrFrame->setHollow(true);
		attrFrame->setSize(SDL_Rect{ 0, 0, 0, 0 });

		auto spellImageBg = attrFrame->addImage(SDL_Rect{ 0, 0, 48, 48 },
			0xFFFFFFFF, "*#images/ui/Inventory/tooltips/SpellBorder_00.png", "inventory mouse tooltip spell image bg");
		spellImageBg->disabled = true;
		//spellImageBg->color = makeColor( 125, 125, 125, 228);
		auto spellImage = attrFrame->addImage(SDL_Rect{ 0, 0, 36, 36 },
			0xFFFFFFFF, "images/system/white.png", "inventory mouse tooltip spell image");
		spellImage->disabled = true;

		attrFrame->addImage(SDL_Rect{ 0, 0, 24, 24 },
			0xFFFFFFFF, "*#images/ui/Inventory/tooltips/HUD_Tooltip_Icon_Damage_00.png", "inventory mouse tooltip primary image");
		tooltipTextField = attrFrame->addField("inventory mouse tooltip primary value", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip primary value highlight", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip primary value positive text", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip primary value negative text", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip primary value slot name", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::RIGHT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setColor(0xFFFFFFFF);

		attrFrame->addImage(SDL_Rect{ 0, 0, 24, 24 },
			0xFFFFFFFF, "images/system/con32.png", "inventory mouse tooltip secondary image");
		tooltipTextField = attrFrame->addField("inventory mouse tooltip secondary value", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip secondary value highlight", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip secondary value positive text", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip secondary value negative text", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		attrFrame->addImage(SDL_Rect{ 0, 0, 24, 24 },
			0xFFFFFFFF, "images/system/con32.png", "inventory mouse tooltip third image");
		tooltipTextField = attrFrame->addField("inventory mouse tooltip third value", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip third value highlight", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip third value positive text", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip third value negative text", 256);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = attrFrame->addField("inventory mouse tooltip attributes text", 1024);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::TOP);
		tooltipTextField->setColor(makeColor( 188, 154, 114, 255));
	}
	if ( auto descFrame = tooltipFrame->addFrame("inventory mouse tooltip description frame") )
	{
		descFrame->setHollow(true);
		descFrame->setSize(SDL_Rect{ 0, 0, 0, 0 });

		descFrame->addImage(SDL_Rect{ 0, 0, 0, 1 },
			makeColor( 49, 53, 61, 255),
			"images/system/white.png", "inventory mouse tooltip description divider");

		tooltipTextField = descFrame->addField("inventory mouse tooltip description", 1024);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::TOP);
		//tooltipTextField->setColor(makeColor( 188, 154, 114, 255));
		//tooltipTextField->setColor(0xFFFFFFFF);
		tooltipTextField->setTextColor(makeColor( 67, 195, 157, 255));

		tooltipTextField = descFrame->addField("inventory mouse tooltip description positive text", 1024);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::TOP);
		//tooltipTextField->setColor(makeColor( 1, 151, 246, 255));
		tooltipTextField->setColor(0xFFFFFFFF);
		tooltipTextField->setTextColor(makeColor( 188, 154, 114, 255));

		tooltipTextField = descFrame->addField("inventory mouse tooltip description negative text", 1024);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::TOP);
		tooltipTextField->setColor(0xFFFFFFFF);
		tooltipTextField->setTextColor(makeColor( 215, 38, 61, 255));
	}
	if ( auto valueFrame = tooltipFrame->addFrame("inventory mouse tooltip value frame") )
	{
		valueFrame->setHollow(true);
		valueFrame->setSize(SDL_Rect{ 0, 0, 0, 0 });

		valueFrame->addImage(SDL_Rect{ 0, 0, 0, 0 },
			makeColor( 49, 53, 61, 255), 
			"images/system/white.png", "inventory mouse tooltip value background");

		valueFrame->addImage(SDL_Rect{ 0, 0, 0, 1 },
			makeColor( 49, 53, 61, 255),
			"images/system/white.png", "inventory mouse tooltip value divider");

		tooltipTextField = valueFrame->addField("inventory mouse tooltip identified value", 64);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setColor(makeColor( 188, 154, 114, 255));

		valueFrame->addImage(SDL_Rect{ 0, 0, 16, 16 },
			0xFFFFFFFF, 
			"*#images/ui/Inventory/tooltips/HUD_Tooltip_Icon_Money_00.png",
			"inventory mouse tooltip gold image");

		tooltipTextField = valueFrame->addField("inventory mouse tooltip gold value", 64);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setColor(makeColor( 188, 154, 114, 255));

		valueFrame->addImage(SDL_Rect{ 0, 0, 16, 16 },
			0xFFFFFFFF, 
			"*#images/ui/Inventory/tooltips/HUD_Tooltip_Icon_WGT_00.png",
			"inventory mouse tooltip weight image");

		tooltipTextField = valueFrame->addField("inventory mouse tooltip weight value", 64);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::LEFT);
		tooltipTextField->setVJustify(Field::justify_t::CENTER);
		tooltipTextField->setColor(makeColor( 188, 154, 114, 255));
	}
	if ( auto promptFrame = tooltipFrame->addFrame("inventory mouse tooltip prompt frame") )
	{
		promptFrame->setHollow(true);
		promptFrame->setSize(SDL_Rect{ 0, 0, 0, 0 });

		tooltipTextField = promptFrame->addField("inventory mouse tooltip prompt", 1024);
		tooltipTextField->setText("Nothing");
		tooltipTextField->setSize(SDL_Rect{ 0, 0, 0, 0 });
		tooltipTextField->setFont(bodyFont.c_str());
		tooltipTextField->setHJustify(Field::justify_t::RIGHT);
		tooltipTextField->setVJustify(Field::justify_t::TOP);
		tooltipTextField->setColor(makeColor( 148, 82, 3, 255));

	}
	auto tooltipPromptImg = tooltipFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "inventory mouse tooltip prompt img");
	tooltipPromptImg->disabled = true;

	char name[32];
	snprintf(name, sizeof(name), "player interact %d", player);
	if ( auto interactFrame = gameUIFrame[player]->addFrame(name) )
	{
		players[player]->inventoryUI.interactFrame = interactFrame;
		const int interactWidth = 106;
		interactFrame->setSize(SDL_Rect{ 0, 0, interactWidth + 6 * 2, 100 });
		interactFrame->setDisabled(true);
		interactFrame->setInheritParentFrameOpacity(false);

		Uint32 color = makeColor( 255, 255, 255, 255);
		const int topBackgroundHeight = 30;
		const int optionHeight = 20;

		interactFrame->addImage(SDL_Rect{ 24, 0, 0, 30 },
			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_T03.png", "interact top background");
		interactFrame->addImage(SDL_Rect{ 0, 0, 24, 30 },
			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_TL03.png", "interact top left");
		interactFrame->addImage(SDL_Rect{ 0, 0, 24, 30 },
			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_TR03.png", "interact top right");

		interactFrame->addImage(SDL_Rect{ 24, 30, 0, 12 },
			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_C03.png", "interact middle background");
		auto ml = interactFrame->addImage(SDL_Rect{ 0, 30, 24, 12 },
			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_L03.png", "interact middle left");
		ml->tiled = true;
		auto mr = interactFrame->addImage(SDL_Rect{ 0, 30, 24, 12 },
			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_R03.png", "interact middle right");
		mr->tiled = true;

		interactFrame->addImage(SDL_Rect{ 24, 96, 0, 14 },
			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_B03.png", "interact bottom background");
		interactFrame->addImage(SDL_Rect{ 0, 96, 24, 14 },
			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_BL03.png", "interact bottom left");
		interactFrame->addImage(SDL_Rect{ 0, 96, 24, 14 },
			color, "*#images/ui/Inventory/tooltips/HoverItemMenu_BR03.png", "interact bottom right");

		auto selectmid = interactFrame->addImage(SDL_Rect{ 6, optionHeight - 16, interactWidth, 22 },
			hudColors.itemContextMenuOptionSelectedImg, "*#images/ui/Inventory/tooltips/HoverItemMenu_SelectBack_M03.png", "interact selected highlight mid");
		selectmid->tiled = true;
		interactFrame->addImage(SDL_Rect{ 6, optionHeight - 16, 20, 22 },
			hudColors.itemContextMenuOptionSelectedImg, "*#images/ui/Inventory/tooltips/HoverItemMenu_SelectBack_L03.png", "interact selected highlight left");
		interactFrame->addImage(SDL_Rect{ 6, optionHeight - 16, 20, 22 },
			hudColors.itemContextMenuOptionSelectedImg, "*#images/ui/Inventory/tooltips/HoverItemMenu_SelectBack_R03.png", "interact selected highlight right");


		const char* interactFont = "fonts/pixel_maz.ttf#32#2";

		auto interactText = interactFrame->addField("interact text", 32);
		interactText->setText(Language::get(4040));
		interactText->setSize(SDL_Rect{ 0, 2, 0, topBackgroundHeight });
		interactText->setFont(interactFont);
		interactText->setHJustify(Field::justify_t::CENTER);
		interactText->setVJustify(Field::justify_t::CENTER);
		interactText->setColor(hudColors.itemContextMenuHeadingText);

		const int interactOptionStartX = 4;
		const int interactOptionStartY = 33;
		const int glyphSize = 20;

		auto interactGlyph1 = interactFrame->addImage(
			SDL_Rect{ interactOptionStartX + 4, interactOptionStartY + 4, glyphSize, glyphSize },
			0xFFFFFFFF, "", "glyph 1");

		const int textAlignX = interactGlyph1->pos.x + interactGlyph1->pos.w + 6;
		int textAlignY = interactGlyph1->pos.y - 8;
		const int textWidth = 80;
		const int textHeight = glyphSize + 8;

		Uint32 textColor = hudColors.itemContextMenuOptionText;
		
		interactText = interactFrame->addField("interact option 1", 32);
		interactText->setText("");
		interactText->setSize(SDL_Rect{ 
			textAlignX,
			textAlignY,
			textWidth, textHeight });
		interactText->setFont(interactFont);
		interactText->setHJustify(Field::justify_t::LEFT);
		interactText->setVJustify(Field::justify_t::CENTER);
		interactText->setColor(textColor);

		auto interactGlyph2 = interactFrame->addImage(
			SDL_Rect{  interactOptionStartX + 4, 
				interactGlyph1->pos.y + interactGlyph1->pos.h + 4, 
				glyphSize, glyphSize },
			0xFFFFFFFF, "", "glyph 2");

		textAlignY = interactGlyph2->pos.y - 10;
		interactText = interactFrame->addField("interact option 2", 32);
		interactText->setText("");
		interactText->setSize(SDL_Rect{
			textAlignX,
			textAlignY,
			textWidth, textHeight });
		interactText->setFont(interactFont);
		interactText->setHJustify(Field::justify_t::LEFT);
		interactText->setVJustify(Field::justify_t::CENTER);
		interactText->setColor(textColor);

		auto interactGlyph3 = interactFrame->addImage(
			SDL_Rect{ interactOptionStartX + 4,
			interactGlyph2->pos.y + interactGlyph2->pos.h + 4,
			glyphSize, glyphSize },
			0xFFFFFFFF, "", "glyph 3");

		textAlignY = interactGlyph3->pos.y - 10;
		interactText = interactFrame->addField("interact option 3", 32);
		interactText->setText("");
		interactText->setSize(SDL_Rect{
			textAlignX,
			textAlignY,
			textWidth, textHeight });
		interactText->setFont(interactFont);
		interactText->setHJustify(Field::justify_t::LEFT);
		interactText->setVJustify(Field::justify_t::CENTER);
		interactText->setColor(textColor);

		auto interactGlyph4 = interactFrame->addImage(
			SDL_Rect{ interactOptionStartX + 4,
			interactGlyph3->pos.y + interactGlyph3->pos.h + 4,
			glyphSize, glyphSize },
			0xFFFFFFFF, "", "glyph 4");

		textAlignY = interactGlyph4->pos.y - 10;
		interactText = interactFrame->addField("interact option 4", 32);
		interactText->setText("");
		interactText->setSize(SDL_Rect{
			textAlignX,
			textAlignY,
			textWidth, textHeight });
		interactText->setFont(interactFont);
		interactText->setHJustify(Field::justify_t::LEFT);
		interactText->setVJustify(Field::justify_t::CENTER);
		interactText->setColor(textColor);

		auto interactGlyph5 = interactFrame->addImage(
			SDL_Rect{ interactOptionStartX + 4,
			interactGlyph4->pos.y + interactGlyph4->pos.h + 4,
			glyphSize, glyphSize },
			0xFFFFFFFF, "", "glyph 5");

		textAlignY = interactGlyph5->pos.y - 10;
		interactText = interactFrame->addField("interact option 5", 32);
		interactText->setText("");
		interactText->setSize(SDL_Rect{
			textAlignX,
			textAlignY,
			textWidth, textHeight });
		interactText->setFont(interactFont);
		interactText->setHJustify(Field::justify_t::LEFT);
		interactText->setVJustify(Field::justify_t::CENTER);
		interactText->setColor(textColor);
	}

	snprintf(name, sizeof(name), "player item prompt %d", player);
	if ( auto promptFrame = players[player]->inventoryUI.tooltipContainerFrame->addFrame(name) )
	{
		players[player]->inventoryUI.tooltipPromptFrame = promptFrame;
		const int interactWidth = 0;
		SDL_Rect promptSize{ 0, 0, interactWidth + 6 * 2, 100 };
		promptFrame->setDisabled(true);
		promptFrame->setInheritParentFrameOpacity(false);

		Uint32 color = makeColor( 255, 255, 255, 192);

		auto middleCenter = promptFrame->addImage(SDL_Rect{ 6, 2, interactWidth, 76 },
			color, "*#images/ui/Inventory/tooltips/Hover_C00.png", "interact middle background");
		auto middleTop = promptFrame->addImage(SDL_Rect{ 6, 0, interactWidth, 2 },
			color, "*#images/ui/Inventory/tooltips/HoverExt_C00.png", "interact middle top background");
		auto middleBottom = promptFrame->addImage(SDL_Rect{ 6, 0, interactWidth, 2 },
			color, "*#images/ui/Inventory/tooltips/HoverExt_C00.png", "interact middle bottom background");
		auto middleLeft = promptFrame->addImage(SDL_Rect{ 0, 0, 6, 76 },
			color, "*#images/ui/Inventory/tooltips/HoverExt_L00.png", "interact middle left");
		auto middleRight = promptFrame->addImage(SDL_Rect{ interactWidth + 6, 0, 6, 76 },
			color, "*#images/ui/Inventory/tooltips/HoverExt_R00.png", "interact middle right");

		auto bottomCenter = promptFrame->addImage(SDL_Rect{ 4, 76, interactWidth + 4, 4 },
			color, "*#images/ui/Inventory/tooltips/HoverExt_B00.png", "interact bottom background");
		auto bottomLeft = promptFrame->addImage(SDL_Rect{ 0, 76, 4, 4 },
			color, "*#images/ui/Inventory/tooltips/HoverExt_BL00.png", "interact bottom left");
		auto bottomRight = promptFrame->addImage(SDL_Rect{ interactWidth + 4 * 2, 76, 4, 4 },
			color, "*#images/ui/Inventory/tooltips/HoverExt_BR00.png", "interact bottom right");

		const int interactOptionStartX = 60;
		const int interactOptionStartY = 4;
		const int glyphSizeH = 24;
		const int glyphSizeW = 22;

		auto interactGlyph1 = promptFrame->addImage(
			SDL_Rect{ interactOptionStartX, interactOptionStartY, glyphSizeW, glyphSizeH },
			0xFFFFFFFF, "", "glyph 1");

		auto interactGlyph2 = promptFrame->addImage(
			SDL_Rect{ interactGlyph1->pos.x - (glyphSizeW / 2),
			interactGlyph1->pos.y + glyphSizeH,
			glyphSizeW, glyphSizeH },
			0xFFFFFFFF, "", "glyph 2");

		auto interactGlyph3 = promptFrame->addImage(
			SDL_Rect{ interactGlyph1->pos.x + (glyphSizeW + glyphSizeW / 4), interactGlyph1->pos.y, glyphSizeW, glyphSizeH },
			0xFFFFFFFF, "", "glyph 3");

		auto interactGlyph4 = promptFrame->addImage(
			SDL_Rect{ interactGlyph3->pos.x - (glyphSizeW / 2), interactGlyph2->pos.y,
			glyphSizeW, glyphSizeH },
			0xFFFFFFFF, "", "glyph 4");

		auto grabIcon = promptFrame->addImage(
			SDL_Rect{ 0, 0, 0, 0 },
			0xFFFFFFFF, "*#images/ui/Inventory/tooltips/Inventory_Grab.png", "grab icon");
		grabIcon->disabled = true;
		auto dropIcon = promptFrame->addImage(
			SDL_Rect{ 0, 0, 0, 0 },
			0xFFFFFFFF, "*#images/ui/Inventory/tooltips/Inventory_Drop.png", "drop icon");
		dropIcon->disabled = true;

		const int textWidth = 200;
		const int textHeight = glyphSizeH + 8;

		Uint32 promptTextColor = makeColor( 188, 154, 114, 255);
		const char * promptFont = "fonts/pixel_maz.ttf#32#2";
		int textAlignY = interactGlyph1->pos.y - 4;
		int textAlignXRightJustify = interactGlyph1->pos.x - 6 - textWidth;
		auto promptText = promptFrame->addField("txt 1", 32);
		promptText->setText(Language::get(4050));
		promptText->setSize(SDL_Rect{
			textAlignXRightJustify,
			textAlignY,
			textWidth, textHeight });
		promptText->setFont(promptFont);
		promptText->setHJustify(Field::justify_t::RIGHT);
		promptText->setVJustify(Field::justify_t::CENTER);
		promptText->setColor(promptTextColor);

		textAlignXRightJustify = interactGlyph2->pos.x - 6 - textWidth;
		textAlignY = interactGlyph2->pos.y - 4;
		promptText = promptFrame->addField("txt 2", 32);
		promptText->setText(Language::get(4040));
		promptText->setSize(SDL_Rect{
			textAlignXRightJustify,
			textAlignY,
			textWidth, textHeight });
		promptText->setFont(promptFont);
		promptText->setHJustify(Field::justify_t::RIGHT);
		promptText->setVJustify(Field::justify_t::CENTER);
		promptText->setColor(promptTextColor);

		int textAlignXLeftJustify = interactGlyph3->pos.x + interactGlyph3->pos.w + 6;
		textAlignY = interactGlyph3->pos.y - 4;
		promptText = promptFrame->addField("txt 3", 32);
		promptText->setText(Language::get(5956));
		promptText->setSize(SDL_Rect{
			textAlignXLeftJustify,
			textAlignY,
			textWidth, textHeight });
		promptText->setFont(promptFont);
		promptText->setHJustify(Field::justify_t::LEFT);
		promptText->setVJustify(Field::justify_t::CENTER);
		promptText->setColor(promptTextColor);

		textAlignXLeftJustify = interactGlyph4->pos.x + interactGlyph4->pos.w + 6;
		textAlignY = interactGlyph4->pos.y - 4;
		promptText = promptFrame->addField("txt 4", 32);
		promptText->setText(Language::get(5957));
		promptText->setSize(SDL_Rect{
			textAlignXLeftJustify,
			textAlignY,
			textWidth, textHeight });
		promptText->setFont(promptFont);
		promptText->setHJustify(Field::justify_t::LEFT);
		promptText->setVJustify(Field::justify_t::CENTER);
		promptText->setColor(promptTextColor);

		bottomCenter->pos.y = interactGlyph4->pos.y + interactGlyph4->pos.h + 2;
		bottomLeft->pos.y = bottomCenter->pos.y;
		bottomRight->pos.y = bottomCenter->pos.y;

		promptSize.h = bottomCenter->pos.y + bottomCenter->pos.h;

		promptFrame->setSize(promptSize);
		middleCenter->pos.h = bottomCenter->pos.y - 4;
		middleLeft->pos.h = bottomCenter->pos.y;
		middleRight->pos.h = bottomCenter->pos.y;
		middleBottom->pos.y = bottomCenter->pos.y - 2;
	}
}

view_t playerPortraitView[MAXPLAYERS];

void drawCharacterPreview(const int player, SDL_Rect pos, int fov, real_t offsetyaw, bool dark)
{
    if (player < 0 || player >= MAXPLAYERS) {
        return;
    }
    view_t& view = playerPortraitView[player];
	auto ofov = ::fov;
	::fov = fov;

	//TempTexture* minimapTexture = new TempTexture();
	auto playerEntity = Player::getPlayerInteractEntity(player);

	if ( playerEntity )
	{
        GL_CHECK_ERR(glClear(GL_DEPTH_BUFFER_BIT));

		static ConsoleVariable<bool> cvar_char_portrait_static_angle("/char_portrait_static_angle", true);
		view.x = playerEntity->x / 16.0 + (.92 * cos(offsetyaw
			+ (*cvar_char_portrait_static_angle ? playerEntity->yaw : 0)));
		view.y = playerEntity->y / 16.0 + (.92 * sin(offsetyaw
			+ (*cvar_char_portrait_static_angle ? playerEntity->yaw : 0)));
		view.z = playerEntity->z * 2;
		view.ang = (offsetyaw - PI
			+ (*cvar_char_portrait_static_angle ? playerEntity->yaw : 0)); //5 * PI / 4;
		view.vang = PI / 20;

		view.winx = pos.x;
		// winy modification required due to new frame scaling method d49b1a5f34667432f2a2bd754c0abca3a09227c8
		view.winy = pos.y + (yres - Frame::virtualScreenY); 
		//view.winx = x1 + 8;
		//view.winy = y1 + 8;

		view.winw = pos.w;
		view.winh = pos.h;
		glBeginCamera(&view, false);
		bool b = playerEntity->flags[BRIGHT];
        if (!dark) { playerEntity->flags[BRIGHT] = true; }
		if ( !playerEntity->flags[INVISIBLE] )
		{
			glDrawVoxel(&view, playerEntity, REALCOLORS);
		}
		playerEntity->flags[BRIGHT] = b;
		int c = 0;
		if ( multiplayer != CLIENT )
		{
			for ( node_t* node = playerEntity->children.first; node != nullptr; node = node->next )
			{
				if ( playerEntity->behavior == &actPlayer )
				{
					if ( c == 0 )
					{
						c++;
						continue;
					}
				}
				Entity* entity = (Entity*)node->element;
				if ( !entity->flags[INVISIBLE] )
				{
					bool b = entity->flags[BRIGHT];
                    if (!dark) { entity->flags[BRIGHT] = true; }
					glDrawVoxel(&view, entity, REALCOLORS);
					entity->flags[BRIGHT] = b;
				}
				c++;
			}
			for ( node_t* node = map.entities->first; node != NULL; node = node->next )
			{
				Entity* entity = (Entity*)node->element;
				if ( (Sint32)entity->getUID() == -4 ) // torch sprites
				{
					if ( (entity->skill[1] - 1) != player )
					{
						continue;
					}
                    bool b = entity->flags[BRIGHT];
                    if (!dark) { entity->flags[BRIGHT] = true; }
					glDrawSprite(&view, entity, REALCOLORS);
                    entity->flags[BRIGHT] = b;
				}
			}
		}
		else
		{
			for ( node_t* node = map.entities->first; node != NULL; node = node->next )
			{
				Entity* entity = (Entity*)node->element;
				if ( playerEntity->behavior == &actPlayer )
				{
					if ( (entity->behavior == &actPlayerLimb && entity->skill[2] == player && !entity->flags[INVISIBLE]) || (Sint32)entity->getUID() == -4 )
					{
						if ( (Sint32)entity->getUID() == -4 ) // torch sprites
						{
							if ( (entity->skill[1] - 1) != player )
							{
								continue;
							}
							bool b = entity->flags[BRIGHT];
							if (!dark) { entity->flags[BRIGHT] = true; }
							glDrawSprite(&view, entity, REALCOLORS);
							entity->flags[BRIGHT] = b;
						}
						else
						{
							bool b = entity->flags[BRIGHT];
							if (!dark) { entity->flags[BRIGHT] = true; }
							glDrawVoxel(&view, entity, REALCOLORS);
							entity->flags[BRIGHT] = b;
						}
					}
				}
				else if ( playerEntity->behavior == &actDeathGhost )
				{
					if ( entity->behavior == &actDeathGhostLimb && entity->skill[2] == player && !entity->flags[INVISIBLE] )
					{
						bool b = entity->flags[BRIGHT];
						if ( !dark ) { entity->flags[BRIGHT] = true; }
						glDrawVoxel(&view, entity, REALCOLORS);
						entity->flags[BRIGHT] = b;
					}
				}
			}
		}
        if (drawingGui) {
            // blending gets disabled after objects are drawn, so re-enable it.
            GL_CHECK_ERR(glEnable(GL_BLEND));
        }
        glEndCamera(&view, false);
	}
	::fov = ofov;
}

Player::SkillSheet_t::SkillSheetData_t Player::SkillSheet_t::skillSheetData;
void Player::SkillSheet_t::loadSkillSheetJSON()
{
	if ( !PHYSFS_getRealDir("/data/skillsheet_entries.json") )
	{
		printlog("[JSON]: Error: Could not find file: data/skillsheet_entries.json");
	}
	else
	{
		std::string inputPath = PHYSFS_getRealDir("/data/skillsheet_entries.json");
		inputPath.append("/data/skillsheet_entries.json");

		File* fp = FileIO::open(inputPath.c_str(), "rb");
		if ( !fp )
		{
			printlog("[JSON]: Error: Could not open json file %s", inputPath.c_str());
		}
		else
		{
			char buf[65536];
			int count = fp->read(buf, sizeof(buf[0]), sizeof(buf));
			buf[count] = '\0';
			rapidjson::StringStream is(buf);
			FileIO::close(fp);
			rapidjson::Document d;
			d.ParseStream(is);
			if ( !d.HasMember("version") )
			{
				printlog("[JSON]: Error: No 'version' value in json file, or JSON syntax incorrect! %s", inputPath.c_str());
			}
			else
			{
				if ( d.HasMember("skills") )
				{
					auto& allEntries = skillSheetData.skillEntries;
					allEntries.clear();
					for ( rapidjson::Value::ConstValueIterator itr = d["skills"].Begin();
						itr != d["skills"].End(); ++itr )
					{
						allEntries.push_back(SkillSheetData_t::SkillEntry_t());
						auto& entry = allEntries[allEntries.size() - 1];
						if ( (*itr).HasMember("name") )
						{
							entry.name = (*itr)["name"].GetString();
						}
						if ( (*itr).HasMember("id") )
						{
							entry.skillId = (*itr)["id"].GetInt();
						}
						if ( (*itr).HasMember("sfx") )
						{
							entry.skillSfx = (*itr)["sfx"].GetInt();
						}
						if ( (*itr).HasMember("icon_base_path") )
						{
							entry.skillIconPath = (*itr)["icon_base_path"].GetString();
						}
						if ( (*itr).HasMember("icon_legend_path") )
						{
							entry.skillIconPathLegend = (*itr)["icon_legend_path"].GetString();
						}
						if ( (*itr).HasMember("icon_base_path_32px") )
						{
							entry.skillIconPath32px = (*itr)["icon_base_path_32px"].GetString();
						}
						if ( (*itr).HasMember("icon_legend_path_32px") )
						{
							entry.skillIconPathLegend32px = (*itr)["icon_legend_path_32px"].GetString();
						}
						if ( (*itr).HasMember("icon_stat_path") )
						{
							entry.statIconPath = (*itr)["icon_stat_path"].GetString();
						}
						if ( (*itr).HasMember("description") )
						{
							entry.description = (*itr)["description"].GetString();
						}
						if ( (*itr).HasMember("legend_text") )
						{
							entry.legendaryDescription = (*itr)["legend_text"].GetString();
						}
						if ( (*itr).HasMember("effects") )
						{
							for ( rapidjson::Value::ConstValueIterator eff_itr = (*itr)["effects"].Begin(); eff_itr != (*itr)["effects"].End(); ++eff_itr )
							{
								entry.effects.push_back(SkillSheetData_t::SkillEntry_t::SkillEffect_t());
								auto& effect = entry.effects[entry.effects.size() - 1];
								effect.tag = (*eff_itr)["tag"].GetString();
								effect.title = (*eff_itr)["title"].GetString();
								effect.rawValue = (*eff_itr)["value"].GetString();
								effect.valueCustomWidthOffset = 0;
								if ( (*eff_itr).HasMember("custom_value_width_offset") )
								{
									effect.valueCustomWidthOffset = (*eff_itr)["custom_value_width_offset"].GetInt();
								}
								if ( (*eff_itr).HasMember("auto_resize_value") )
								{
									effect.bAllowAutoResizeValue = (*eff_itr)["auto_resize_value"].GetBool();
								}
								else
								{
									effect.bAllowAutoResizeValue = false;
								}
								if ( (*eff_itr).HasMember("realtime_update") )
								{
									effect.bAllowRealtimeUpdate = (*eff_itr)["realtime_update"].GetBool();
								}
								else
								{
									effect.bAllowRealtimeUpdate = false;
								}
							}
						}
						if ( (*itr).HasMember("effects_position") )
						{
							for ( rapidjson::Value::ConstMemberIterator effPos_itr = (*itr)["effects_position"].MemberBegin(); 
								effPos_itr != (*itr)["effects_position"].MemberEnd(); ++effPos_itr )
							{
								std::string memberName = effPos_itr->name.GetString();
								if ( memberName == "effect_start_offset_x" )
								{
									entry.effectStartOffsetX = effPos_itr->value.GetInt();
								}
								else if ( memberName == "effect_background_offset_x" )
								{
									entry.effectBackgroundOffsetX = effPos_itr->value.GetInt();
								}
								else if ( memberName == "effect_background_width" )
								{
									entry.effectBackgroundWidth = effPos_itr->value.GetInt();
								}
							}
						}
					}
				}
				if ( d.HasMember("window_scaling") )
				{
					if ( d["window_scaling"].HasMember("standard_scale_modifier_x") )
					{
						windowHeightScaleX = d["window_scaling"]["standard_scale_modifier_x"].GetDouble();
					}
					if ( d["window_scaling"].HasMember("standard_scale_modifier_y") )
					{
						windowHeightScaleY = d["window_scaling"]["standard_scale_modifier_y"].GetDouble();
					}
					if ( d["window_scaling"].HasMember("compact_scale_modifier_x") )
					{
						windowCompactHeightScaleX = d["window_scaling"]["compact_scale_modifier_x"].GetDouble();
					}
					if ( d["window_scaling"].HasMember("compact_scale_modifier_y") )
					{
						windowCompactHeightScaleY = d["window_scaling"]["compact_scale_modifier_y"].GetDouble();
					}
				}
				if ( d.HasMember("skill_select_images") )
				{
					if ( d["skill_select_images"].HasMember("highlight_left") )
					{
						skillSheetData.highlightSkillImg = d["skill_select_images"]["highlight_left"].GetString();
					}
					if ( d["skill_select_images"].HasMember("selected_left") )
					{
						skillSheetData.selectSkillImg = d["skill_select_images"]["selected_left"].GetString();
					}
					if ( d["skill_select_images"].HasMember("highlight_right") )
					{
						skillSheetData.highlightSkillImg_Right = d["skill_select_images"]["highlight_right"].GetString();
					}
					if ( d["skill_select_images"].HasMember("selected_right") )
					{
						skillSheetData.selectSkillImg_Right = d["skill_select_images"]["selected_right"].GetString();
					}
				}
				if ( d.HasMember("skill_background_icons") )
				{
					if ( d["skill_background_icons"].HasMember("default") )
					{
						skillSheetData.iconBgPathDefault = d["skill_background_icons"]["default"].GetString();
					}
					if ( d["skill_background_icons"].HasMember("default_selected") )
					{
						skillSheetData.iconBgSelectedPathDefault = d["skill_background_icons"]["default_selected"].GetString();
					}
					if ( d["skill_background_icons"].HasMember("novice") )
					{
						skillSheetData.iconBgPathNovice = d["skill_background_icons"]["novice"].GetString();
					}
					if ( d["skill_background_icons"].HasMember("novice_selected") )
					{
						skillSheetData.iconBgSelectedPathNovice = d["skill_background_icons"]["novice_selected"].GetString();
					}
					if ( d["skill_background_icons"].HasMember("expert") )
					{
						skillSheetData.iconBgPathExpert = d["skill_background_icons"]["expert"].GetString();
					}
					if ( d["skill_background_icons"].HasMember("expert_selected") )
					{
						skillSheetData.iconBgSelectedPathExpert = d["skill_background_icons"]["expert_selected"].GetString();
					}
					if ( d["skill_background_icons"].HasMember("legend") )
					{
						skillSheetData.iconBgPathLegend = d["skill_background_icons"]["legend"].GetString();
					}
					if ( d["skill_background_icons"].HasMember("legend_selected") )
					{
						skillSheetData.iconBgSelectedPathLegend = d["skill_background_icons"]["legend_selected"].GetString();
					}
				}
				if ( d.HasMember("alchemy_potion_names_to_filter") )
				{
					skillSheetData.potionNamesToFilter.clear();
					if ( d["alchemy_potion_names_to_filter"].IsString() )
					{
						skillSheetData.potionNamesToFilter.push_back(d["alchemy_potion_names_to_filter"].GetString());
					}
					else if ( d["alchemy_potion_names_to_filter"].IsArray() )
					{
						for ( rapidjson::Value::ConstValueIterator pot_itr = d["alchemy_potion_names_to_filter"].Begin(); 
							pot_itr != d["alchemy_potion_names_to_filter"].End(); ++pot_itr )
						{
							skillSheetData.potionNamesToFilter.push_back(pot_itr->GetString());
						}
					}
				}
				if ( d.HasMember("colors") )
				{
					if ( d["colors"].HasMember("default") )
					{
						skillSheetData.defaultTextColor = makeColor(
							d["colors"]["default"]["r"].GetInt(),
							d["colors"]["default"]["g"].GetInt(),
							d["colors"]["default"]["b"].GetInt(),
							d["colors"]["default"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("novice") )
					{
						skillSheetData.noviceTextColor = makeColor(
							d["colors"]["novice"]["r"].GetInt(),
							d["colors"]["novice"]["g"].GetInt(),
							d["colors"]["novice"]["b"].GetInt(),
							d["colors"]["novice"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("expert") )
					{
						skillSheetData.expertTextColor = makeColor(
							d["colors"]["expert"]["r"].GetInt(),
							d["colors"]["expert"]["g"].GetInt(),
							d["colors"]["expert"]["b"].GetInt(),
							d["colors"]["expert"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("legend") )
					{
						skillSheetData.legendTextColor = makeColor(
							d["colors"]["legend"]["r"].GetInt(),
							d["colors"]["legend"]["g"].GetInt(),
							d["colors"]["legend"]["b"].GetInt(),
							d["colors"]["legend"]["a"].GetInt());
					}
				}
				printlog("[JSON]: Successfully read json file %s", inputPath.c_str());
			}
		}
	}

	if ( !PHYSFS_getRealDir("/data/skillsheet_leadership_entries.json") )
	{
		printlog("[JSON]: Error: Could not find file: data/skillsheet_leadership_entries.json");
	}
	else
	{
		std::string inputPath = PHYSFS_getRealDir("/data/skillsheet_leadership_entries.json");
		inputPath.append("/data/skillsheet_leadership_entries.json");

		File* fp = FileIO::open(inputPath.c_str(), "rb");
		if ( !fp )
		{
			printlog("[JSON]: Error: Could not open json file %s", inputPath.c_str());
		}
		else
		{
			char buf[65536];
			int count = fp->read(buf, sizeof(buf[0]), sizeof(buf));
			buf[count] = '\0';
			rapidjson::StringStream is(buf);
			FileIO::close(fp);

			rapidjson::Document d;
			d.ParseStream(is);
			if ( !d.HasMember("version") )
			{
				printlog("[JSON]: Error: No 'version' value in json file, or JSON syntax incorrect! %s", inputPath.c_str());
			}
			else
			{
				if ( d.HasMember("leadership_allies_base") )
				{
					auto& allyTable = skillSheetData.leadershipAllyTableBase;
					allyTable.clear();
					for ( rapidjson::Value::ConstMemberIterator itr = d["leadership_allies_base"].MemberBegin();
						itr != d["leadership_allies_base"].MemberEnd(); ++itr )
					{
						std::string monsterName = itr->name.GetString();
						int monsterType = -1;
						for ( int i = 0; i < NUMMONSTERS; ++i )
						{
							if ( monsterName.compare(monstertypename[i]) == 0 )
							{
								monsterType = i;
								break;
							}
						}
						if ( monsterType < 0 ) { continue; }
						if ( itr->value.IsArray() )
						{
							for ( rapidjson::Value::ConstValueIterator ally_itr = itr->value.Begin();
								ally_itr != itr->value.End(); ++ally_itr )
							{
								std::string allyName = ally_itr->GetString();
								int allyType = -1;
								for ( int i = 0; i < NUMMONSTERS; ++i )
								{
									if ( allyName.compare(monstertypename[i]) == 0 )
									{
										allyType = i;
										break;
									}
								}
								if ( allyType >= 0 )
								{
									allyTable[(Monster)monsterType].push_back((Monster)allyType);
								}
							}
						}
					}
				}
				if ( d.HasMember("leadership_allies_legendary") )
				{
					auto& allyTable = skillSheetData.leadershipAllyTableLegendary;
					allyTable.clear();
					for ( rapidjson::Value::ConstMemberIterator itr = d["leadership_allies_legendary"].MemberBegin();
						itr != d["leadership_allies_legendary"].MemberEnd(); ++itr )
					{
						std::string monsterName = itr->name.GetString();
						int monsterType = -1;
						for ( int i = 0; i < NUMMONSTERS; ++i )
						{
							if ( monsterName.compare(monstertypename[i]) == 0 )
							{
								monsterType = i;
								break;
							}
						}
						if ( monsterType < 0 ) { continue; }
						if ( itr->value.IsArray() )
						{
							for ( rapidjson::Value::ConstValueIterator ally_itr = itr->value.Begin();
								ally_itr != itr->value.End(); ++ally_itr )
							{
								std::string allyName = ally_itr->GetString();
								int allyType = -1;
								for ( int i = 0; i < NUMMONSTERS; ++i )
								{
									if ( allyName.compare(monstertypename[i]) == 0 )
									{
										allyType = i;
										break;
									}
								}
								if ( allyType >= 0 )
								{
									allyTable[(Monster)monsterType].push_back((Monster)allyType);
								}
							}
						}
					}
				}
				if ( d.HasMember("leadership_allies_unique_recruits") )
				{
					auto& allyTable = skillSheetData.leadershipAllyTableSpecialRecruitment;
					allyTable.clear();
					for ( rapidjson::Value::ConstMemberIterator itr = d["leadership_allies_unique_recruits"].MemberBegin();
						itr != d["leadership_allies_unique_recruits"].MemberEnd(); ++itr )
					{
						std::string monsterName = itr->name.GetString();
						int monsterType = -1;
						for ( int i = 0; i < NUMMONSTERS; ++i )
						{
							if ( monsterName.compare(monstertypename[i]) == 0 )
							{
								monsterType = i;
								break;
							}
						}
						if ( monsterType < 0 ) { continue; }
						if ( itr->value.IsArray() )
						{
							for ( rapidjson::Value::ConstValueIterator ally_itr = itr->value.Begin();
								ally_itr != itr->value.End(); ++ally_itr )
							{
								for ( rapidjson::Value::ConstMemberIterator entry_itr = ally_itr->MemberBegin();
									entry_itr != ally_itr->MemberEnd(); ++entry_itr )
								{
									std::string allyName = entry_itr->name.GetString();
									int allyType = -1;
									for ( int i = 0; i < NUMMONSTERS; ++i )
									{
										if ( allyName.compare(monstertypename[i]) == 0 )
										{
											allyType = i;
											break;
										}
									}
									if ( allyType >= 0 )
									{
										allyTable[(Monster)monsterType].push_back(std::make_pair((Monster)allyType, entry_itr->value.GetString()));
									}
								}
							}
						}
					}
				}
				printlog("[JSON]: Successfully read json file %s", inputPath.c_str());
			}
		}
	}
}

void loadHUDSettingsJSON()
{
	if ( !PHYSFS_getRealDir("/data/HUD_settings.json") )
	{
		printlog("[JSON]: Error: Could not find file: data/HUD_settings.json");
	}
	else
	{
		std::string inputPath = PHYSFS_getRealDir("/data/HUD_settings.json");
		inputPath.append("/data/HUD_settings.json");

		File* fp = FileIO::open(inputPath.c_str(), "rb");
		if ( !fp )
		{
			printlog("[JSON]: Error: Could not open json file %s", inputPath.c_str());
		}
		else
		{
			char buf[65536];
			int count = fp->read(buf, sizeof(buf[0]), sizeof(buf));
			buf[count] = '\0';
			rapidjson::StringStream is(buf);
			FileIO::close(fp);

			rapidjson::Document d;
			d.ParseStream(is);
			if ( !d.HasMember("version") )
			{
				printlog("[JSON]: Error: No 'version' value in json file, or JSON syntax incorrect! %s", inputPath.c_str());
			}
			else
			{
				if ( d.HasMember("selected_cursor_opacity") )
				{
					selectedCursorOpacity = d["selected_cursor_opacity"].GetInt();
				}
				if ( d.HasMember("selected_old_cursor_opacity") )
				{
					oldSelectedCursorOpacity = d["selected_old_cursor_opacity"].GetInt();
				}
				if ( d.HasMember("hotbar") )
				{
					if ( d["hotbar"].HasMember("hotbar_slot_opacity") )
					{
						hotbarSlotOpacity = d["hotbar"]["hotbar_slot_opacity"].GetInt();
					}
					if ( d["hotbar"].HasMember("hotbar_selected_slot_opacity") )
					{
						hotbarSelectedSlotOpacity = d["hotbar"]["hotbar_selected_slot_opacity"].GetInt();
					}
					if ( d["hotbar"].HasMember("hotbar_compact_x_offset") )
					{
						hotbarCompactOffsetX = d["hotbar"]["hotbar_compact_x_offset"].GetInt();
					}
					if ( d["hotbar"].HasMember("hotbar_compact_slot_overlap") )
					{
						hotbarCompactSlotOverlapPercent = d["hotbar"]["hotbar_compact_slot_overlap"].GetDouble();
					}
					if ( d["hotbar"].HasMember("hotbar_compact_inactive_slot_movement_x") )
					{
						hotbarCompactInactiveSlotMovementX = d["hotbar"]["hotbar_compact_inactive_slot_movement_x"].GetInt();
					}
					if ( d["hotbar"].HasMember("hotbar_compact_expanded_x_offset") )
					{
						hotbarCompactExpandedOffsetX = d["hotbar"]["hotbar_compact_expanded_x_offset"].GetInt();
					}
					if ( d["hotbar"].HasMember("hotbar_y_offset") )
					{
						hotbarOffsetY = d["hotbar"]["hotbar_y_offset"].GetInt();
					}
					if ( d["hotbar"].HasMember("hotbar_compact_y_offset") )
					{
						hotbarCompactOffsetY = d["hotbar"]["hotbar_compact_y_offset"].GetInt();
					}
				}
				if ( d.HasMember("xpbar") )
				{
					if ( d["xpbar"].HasMember("xpbar_width_offset") )
					{
						xpbarOffsetWidth = d["xpbar"]["xpbar_width_offset"].GetInt();
					}
					if ( d["xpbar"].HasMember("xpbar_compact_width_offset") )
					{
						xpbarCompactOffsetWidth = d["xpbar"]["xpbar_compact_width_offset"].GetInt();
					}
					if ( d["xpbar"].HasMember("xpbar_y_offset") )
					{
						xpbarOffsetY = d["xpbar"]["xpbar_y_offset"].GetInt();
					}
					if ( d["xpbar"].HasMember("xpbar_compact_y_offset") )
					{
						xpbarCompactOffsetY = d["xpbar"]["xpbar_compact_y_offset"].GetInt();
					}
				}
				if ( d.HasMember("hpmpbar") )
				{
					if ( d["hpmpbar"].HasMember("hpmpbar_width_offset") )
					{
						hpmpbarOffsetWidth = d["hpmpbar"]["hpmpbar_width_offset"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_x_offset") )
					{
						hpmpbarOffsetX = d["hpmpbar"]["hpmpbar_x_offset"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_y_offset") )
					{
						hpmpbarOffsetY = d["hpmpbar"]["hpmpbar_y_offset"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_width_offset") )
					{
						hpmpbarCompactOffsetWidth = d["hpmpbar"]["hpmpbar_compact_width_offset"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_x_offset") )
					{
						hpmpbarCompactOffsetX = d["hpmpbar"]["hpmpbar_compact_x_offset"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_y_offset") )
					{
						hpmpbarCompactOffsetY = d["hpmpbar"]["hpmpbar_compact_y_offset"].GetInt();
					}

					if ( d["hpmpbar"].HasMember("hpmpbar_max_amount_threshold") )
					{
						hpmpbarMaxWidthAmount = d["hpmpbar"]["hpmpbar_max_amount_threshold"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_interval_to_increase_width") )
					{
						hpmpbarIntervalToIncreaseWidth 
							= d["hpmpbar"]["hpmpbar_interval_to_increase_width"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_base_percent") )
					{
						hpmpbarBasePercentSize = d["hpmpbar"]["hpmpbar_base_percent"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_interval_start_value") )
					{
						hpmpbarIntervalStartValue = d["hpmpbar"]["hpmpbar_interval_start_value"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_width_increase_percent_on_interval") )
					{
						hpmpbarWidthIncreasePercentOnInterval = 
							d["hpmpbar"]["hpmpbar_width_increase_percent_on_interval"].GetDouble();
					}

					if ( d["hpmpbar"].HasMember("hpmpbar_compact_max_amount_threshold") )
					{
						hpmpbarCompactMaxWidthAmount = d["hpmpbar"]["hpmpbar_compact_max_amount_threshold"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_interval_to_increase_width") )
					{
						hpmpbarCompactIntervalToIncreaseWidth = 
							d["hpmpbar"]["hpmpbar_compact_interval_to_increase_width"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_base_percent") )
					{
						hpmpbarCompactBasePercentSize = d["hpmpbar"]["hpmpbar_compact_base_percent"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_interval_start_value") )
					{
						hpmpbarCompactIntervalStartValue = d["hpmpbar"]["hpmpbar_compact_interval_start_value"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_width_increase_percent_on_interval") )
					{
						hpmpbarCompactWidthIncreasePercentOnInterval = 
							d["hpmpbar"]["hpmpbar_compact_width_increase_percent_on_interval"].GetDouble();
					}
				}
				if ( d.HasMember("allybars") )
				{
					for ( auto ally_itr = d["allybars"].MemberBegin(); ally_itr != d["allybars"].MemberEnd(); ++ally_itr )
					{
						std::string type = ally_itr->name.GetString();
						if ( type == "followers" )
						{
							if ( ally_itr->value.HasMember("entry_height") )
							{
								AllyStatusBarSettings_t::FollowerBars_t::entrySettings.entryHeight = ally_itr->value["entry_height"].GetInt();
							}
							if ( ally_itr->value.HasMember("entry_compact_height") )
							{
								AllyStatusBarSettings_t::FollowerBars_t::entrySettings.entryCompactHeight = ally_itr->value["entry_compact_height"].GetInt();
							}
							if ( ally_itr->value.HasMember("infinite_scroll") )
							{
								Player::HUD_t::FollowerDisplay_t::infiniteScrolling = ally_itr->value["infinite_scroll"].GetBool();
							}
							if ( ally_itr->value.HasMember("max_finite_bars") )
							{
								Player::HUD_t::FollowerDisplay_t::numFiniteBars = ally_itr->value["max_finite_bars"].GetInt();
							}
							if ( ally_itr->value.HasMember("max_fullsize_bars") )
							{
								Player::HUD_t::FollowerDisplay_t::numInfiniteFullsizeBars = ally_itr->value["max_fullsize_bars"].GetInt();
							}
							if ( ally_itr->value.HasMember("max_compact_bars") )
							{
								Player::HUD_t::FollowerDisplay_t::numInfiniteCompactBars = ally_itr->value["max_compact_bars"].GetInt();
							}
							if ( ally_itr->value.HasMember("splitscreen_max_fullsize_bars") )
							{
								Player::HUD_t::FollowerDisplay_t::numInfiniteSplitscreenFullsizeBars = ally_itr->value["splitscreen_max_fullsize_bars"].GetInt();
							}
							if ( ally_itr->value.HasMember("splitscreen_max_compact_bars") )
							{
								Player::HUD_t::FollowerDisplay_t::numInfiniteSplitscreenCompactBars = ally_itr->value["splitscreen_max_compact_bars"].GetInt();
							}
							if ( ally_itr->value.HasMember("max_fullsize_name_len") )
							{
								AllyStatusBarSettings_t::FollowerBars_t::entrySettings.maxNameLengthFullsize = ally_itr->value["max_fullsize_name_len"].GetInt();
							}
							if ( ally_itr->value.HasMember("max_compact_name_len") )
							{
								AllyStatusBarSettings_t::FollowerBars_t::entrySettings.maxNameLengthCompact = ally_itr->value["max_compact_name_len"].GetInt();
							}
							if ( ally_itr->value.HasMember("max_splitscreen_fullsize_name_len") )
							{
								AllyStatusBarSettings_t::FollowerBars_t::entrySettings.maxNameLengthSplitscreenFullsize = ally_itr->value["max_splitscreen_fullsize_name_len"].GetInt();
							}
							if ( ally_itr->value.HasMember("max_splitscreen_compact_name_len") )
							{
								AllyStatusBarSettings_t::FollowerBars_t::entrySettings.maxNameLengthSplitscreenCompact = ally_itr->value["max_splitscreen_compact_name_len"].GetInt();
							}
							if ( ally_itr->value.HasMember("base_y_pos") )
							{
								AllyStatusBarSettings_t::FollowerBars_t::entrySettings.baseY = ally_itr->value["base_y_pos"].GetInt();
							}
							if ( ally_itr->value.HasMember("base_y_pos_splitscreen") )
							{
								AllyStatusBarSettings_t::FollowerBars_t::entrySettings.baseYSplitscreen = ally_itr->value["base_y_pos_splitscreen"].GetInt();
							}
							if ( ally_itr->value.HasMember("hp") )
							{
								for ( auto val_itr = ally_itr->value["hp"].MemberBegin();
									val_itr != ally_itr->value["hp"].MemberEnd(); ++val_itr )
								{
									std::string key = val_itr->name.GetString();
									auto& bar = AllyStatusBarSettings_t::FollowerBars_t::hpBar;
									if ( key == "bar_pixel_width" )
									{
										bar.barPixelWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_pixel_width" )
									{
										bar.barCompactPixelWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_splitscreen_pixel_width_offset" )
									{
										bar.barSplitscreenPixelWidthOffset = val_itr->value.GetInt();
									}
									else if ( key == "bar_max_amount_threshold" )
									{
										bar.barMaxWidthAmount = val_itr->value.GetInt();
									}
									else if ( key == "bar_interval_to_increase_width" )
									{
										bar.barIntervalToIncreaseWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_interval_start_value" )
									{
										bar.barIntervalStartValue = val_itr->value.GetInt();
									}
									else if ( key == "bar_width_increase_percent_on_interval" )
									{
										bar.barWidthIncreasePercentOnInterval = val_itr->value.GetDouble();
									}
									else if ( key == "bar_base_percent" )
									{
										bar.barBasePercentSize = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_max_amount_threshold" )
									{
										bar.barCompactMaxWidthAmount = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_interval_to_increase_width" )
									{
										bar.barCompactIntervalToIncreaseWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_interval_start_value" )
									{
										bar.barCompactIntervalStartValue = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_width_increase_percent_on_interval" )
									{
										bar.barCompactWidthIncreasePercentOnInterval = val_itr->value.GetDouble();
									}
									else if ( key == "bar_compact_base_percent" )
									{
										bar.barCompactBasePercentSize = val_itr->value.GetInt();
									}
								}
							}
							if ( ally_itr->value.HasMember("mp") )
							{
								for ( auto val_itr = ally_itr->value["mp"].MemberBegin();
									val_itr != ally_itr->value["mp"].MemberEnd(); ++val_itr )
								{
									std::string key = val_itr->name.GetString();
									auto& bar = AllyStatusBarSettings_t::FollowerBars_t::mpBar;
									if ( key == "bar_pixel_width" )
									{
										bar.barPixelWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_pixel_width" )
									{
										bar.barCompactPixelWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_max_amount_threshold" )
									{
										bar.barMaxWidthAmount = val_itr->value.GetInt();
									}
									else if ( key == "bar_interval_to_increase_width" )
									{
										bar.barIntervalToIncreaseWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_interval_start_value" )
									{
										bar.barIntervalStartValue = val_itr->value.GetInt();
									}
									else if ( key == "bar_width_increase_percent_on_interval" )
									{
										bar.barWidthIncreasePercentOnInterval = val_itr->value.GetDouble();
									}
									else if ( key == "bar_base_percent" )
									{
										bar.barBasePercentSize = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_max_amount_threshold" )
									{
										bar.barCompactMaxWidthAmount = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_interval_to_increase_width" )
									{
										bar.barCompactIntervalToIncreaseWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_interval_start_value" )
									{
										bar.barCompactIntervalStartValue = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_width_increase_percent_on_interval" )
									{
										bar.barCompactWidthIncreasePercentOnInterval = val_itr->value.GetDouble();
									}
									else if ( key == "bar_compact_base_percent" )
									{
										bar.barCompactBasePercentSize = val_itr->value.GetInt();
									}
								}
							}
						}
						else if ( type == "players" )
						{
							if ( ally_itr->value.HasMember("entry_height") )
							{
								AllyStatusBarSettings_t::PlayerBars_t::entrySettings.entryHeight = ally_itr->value["entry_height"].GetInt();
							}
							if ( ally_itr->value.HasMember("entry_compact_height") )
							{
								AllyStatusBarSettings_t::PlayerBars_t::entrySettings.entryCompactHeight = ally_itr->value["entry_compact_height"].GetInt();
							}
							if ( ally_itr->value.HasMember("max_fullsize_name_len") )
							{
								AllyStatusBarSettings_t::PlayerBars_t::entrySettings.maxNameLengthFullsize = ally_itr->value["max_fullsize_name_len"].GetInt();
							}
							if ( ally_itr->value.HasMember("max_compact_name_len") )
							{
								AllyStatusBarSettings_t::PlayerBars_t::entrySettings.maxNameLengthCompact = ally_itr->value["max_compact_name_len"].GetInt();
							}
							if ( ally_itr->value.HasMember("max_splitscreen_fullsize_name_len") )
							{
								AllyStatusBarSettings_t::PlayerBars_t::entrySettings.maxNameLengthSplitscreenFullsize = ally_itr->value["max_splitscreen_fullsize_name_len"].GetInt();
							}
							if ( ally_itr->value.HasMember("max_splitscreen_compact_name_len") )
							{
								AllyStatusBarSettings_t::PlayerBars_t::entrySettings.maxNameLengthSplitscreenCompact = ally_itr->value["max_splitscreen_compact_name_len"].GetInt();
							}
							if ( ally_itr->value.HasMember("base_y_pos") )
							{
								AllyStatusBarSettings_t::PlayerBars_t::entrySettings.baseY = ally_itr->value["base_y_pos"].GetInt();
							}
							if ( ally_itr->value.HasMember("base_y_pos_splitscreen") )
							{
								AllyStatusBarSettings_t::PlayerBars_t::entrySettings.baseYSplitscreen = ally_itr->value["base_y_pos_splitscreen"].GetInt();
							}
							if ( ally_itr->value.HasMember("hp") )
							{
								for ( auto val_itr = ally_itr->value["hp"].MemberBegin();
									val_itr != ally_itr->value["hp"].MemberEnd(); ++val_itr )
								{
									std::string key = val_itr->name.GetString();
									auto& bar = AllyStatusBarSettings_t::PlayerBars_t::hpBar;
									if ( key == "bar_pixel_width" )
									{
										bar.barPixelWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_pixel_width" )
									{
										bar.barCompactPixelWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_max_amount_threshold" )
									{
										bar.barMaxWidthAmount = val_itr->value.GetInt();
									}
									else if ( key == "bar_interval_to_increase_width" )
									{
										bar.barIntervalToIncreaseWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_interval_start_value" )
									{
										bar.barIntervalStartValue = val_itr->value.GetInt();
									}
									else if ( key == "bar_width_increase_percent_on_interval" )
									{
										bar.barWidthIncreasePercentOnInterval = val_itr->value.GetDouble();
									}
									else if ( key == "bar_base_percent" )
									{
										bar.barBasePercentSize = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_max_amount_threshold" )
									{
										bar.barCompactMaxWidthAmount = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_interval_to_increase_width" )
									{
										bar.barCompactIntervalToIncreaseWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_interval_start_value" )
									{
										bar.barCompactIntervalStartValue = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_width_increase_percent_on_interval" )
									{
										bar.barCompactWidthIncreasePercentOnInterval = val_itr->value.GetDouble();
									}
									else if ( key == "bar_compact_base_percent" )
									{
										bar.barCompactBasePercentSize = val_itr->value.GetInt();
									}
								}
							}
							if ( ally_itr->value.HasMember("mp") )
							{
								for ( auto val_itr = ally_itr->value["mp"].MemberBegin();
									val_itr != ally_itr->value["mp"].MemberEnd(); ++val_itr )
								{
									std::string key = val_itr->name.GetString();
									auto& bar = AllyStatusBarSettings_t::PlayerBars_t::mpBar;
									if ( key == "bar_pixel_width" )
									{
										bar.barPixelWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_pixel_width" )
									{
										bar.barCompactPixelWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_max_amount_threshold" )
									{
										bar.barMaxWidthAmount = val_itr->value.GetInt();
									}
									else if ( key == "bar_interval_to_increase_width" )
									{
										bar.barIntervalToIncreaseWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_interval_start_value" )
									{
										bar.barIntervalStartValue = val_itr->value.GetInt();
									}
									else if ( key == "bar_width_increase_percent_on_interval" )
									{
										bar.barWidthIncreasePercentOnInterval = val_itr->value.GetDouble();
									}
									else if ( key == "bar_base_percent" )
									{
										bar.barBasePercentSize = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_max_amount_threshold" )
									{
										bar.barCompactMaxWidthAmount = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_interval_to_increase_width" )
									{
										bar.barCompactIntervalToIncreaseWidth = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_interval_start_value" )
									{
										bar.barCompactIntervalStartValue = val_itr->value.GetInt();
									}
									else if ( key == "bar_compact_width_increase_percent_on_interval" )
									{
										bar.barCompactWidthIncreasePercentOnInterval = val_itr->value.GetDouble();
									}
									else if ( key == "bar_compact_base_percent" )
									{
										bar.barCompactBasePercentSize = val_itr->value.GetInt();
									}
								}
							}
						}
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_max_amount_threshold") )
					{
						hpmpbarMaxWidthAmount = d["hpmpbar"]["hpmpbar_max_amount_threshold"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_interval_to_increase_width") )
					{
						hpmpbarIntervalToIncreaseWidth
							= d["hpmpbar"]["hpmpbar_interval_to_increase_width"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_base_percent") )
					{
						hpmpbarBasePercentSize = d["hpmpbar"]["hpmpbar_base_percent"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_interval_start_value") )
					{
						hpmpbarIntervalStartValue = d["hpmpbar"]["hpmpbar_interval_start_value"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_width_increase_percent_on_interval") )
					{
						hpmpbarWidthIncreasePercentOnInterval =
							d["hpmpbar"]["hpmpbar_width_increase_percent_on_interval"].GetDouble();
					}

					if ( d["hpmpbar"].HasMember("hpmpbar_compact_max_amount_threshold") )
					{
						hpmpbarCompactMaxWidthAmount = d["hpmpbar"]["hpmpbar_compact_max_amount_threshold"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_interval_to_increase_width") )
					{
						hpmpbarCompactIntervalToIncreaseWidth =
							d["hpmpbar"]["hpmpbar_compact_interval_to_increase_width"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_base_percent") )
					{
						hpmpbarCompactBasePercentSize = d["hpmpbar"]["hpmpbar_compact_base_percent"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_interval_start_value") )
					{
						hpmpbarCompactIntervalStartValue = d["hpmpbar"]["hpmpbar_compact_interval_start_value"].GetInt();
					}
					if ( d["hpmpbar"].HasMember("hpmpbar_compact_width_increase_percent_on_interval") )
					{
						hpmpbarCompactWidthIncreasePercentOnInterval =
							d["hpmpbar"]["hpmpbar_compact_width_increase_percent_on_interval"].GetDouble();
					}
				}
				if ( d.HasMember("action_prompts") )
				{
					if ( d["action_prompts"].HasMember("x_offset") )
					{
						Player::HUD_t::actionPromptOffsetX = d["action_prompts"]["x_offset"].GetInt();
					}
					if ( d["action_prompts"].HasMember("x_offset_ghost_prompts") )
					{
						Player::HUD_t::actionPromptOffsetXGhostPrompts = d["action_prompts"]["x_offset_ghost_prompts"].GetInt();
					}
					if ( d["action_prompts"].HasMember("y_offset") )
					{
						Player::HUD_t::actionPromptOffsetY = d["action_prompts"]["y_offset"].GetInt();
					}
					if ( d["action_prompts"].HasMember("icon_size") )
					{
						Player::HUD_t::actionPromptIconSize = d["action_prompts"]["icon_size"].GetInt();
					}
					if ( d["action_prompts"].HasMember("icon_backing_size") )
					{
						Player::HUD_t::actionPromptBackingSize = d["action_prompts"]["icon_backing_size"].GetInt();
					}
					if ( d["action_prompts"].HasMember("icon_opacity") )
					{
						Player::HUD_t::actionPromptIconOpacity = d["action_prompts"]["icon_opacity"].GetInt();
					}
					if ( d["action_prompts"].HasMember("icon_backing_opacity") )
					{
						Player::HUD_t::actionPromptIconBackingOpacity = d["action_prompts"]["icon_backing_opacity"].GetInt();
					}
					if ( d["action_prompts"].HasMember("prompt_img_00") )
					{
						actionPromptBackingIconPath00 = d["action_prompts"]["prompt_img_00"].GetString();
					}
					if ( d["action_prompts"].HasMember("prompt_img_20") )
					{
						actionPromptBackingIconPath20 = d["action_prompts"]["prompt_img_20"].GetString();
					}
					if ( d["action_prompts"].HasMember("prompt_img_60") )
					{
						actionPromptBackingIconPath60 = d["action_prompts"]["prompt_img_60"].GetString();
					}
					if ( d["action_prompts"].HasMember("prompt_img_100") )
					{
						actionPromptBackingIconPath100 = d["action_prompts"]["prompt_img_100"].GetString();
					}
				}
				if ( d.HasMember("world_items") )
				{
					if ( d["world_items"].HasMember("scale_modifier") )
					{
						Player::WorldUI_t::WorldTooltipItem_t::WorldItemSettings_t::scaleMod = d["world_items"]["scale_modifier"].GetDouble();
					}
					if ( d["world_items"].HasMember("tooltip_opacity") )
					{
						Player::WorldUI_t::WorldTooltipItem_t::WorldItemSettings_t::opacity = d["world_items"]["tooltip_opacity"].GetDouble();
					}
				}
				if ( d.HasMember("minimap") )
				{
					if ( d["minimap"].HasMember("minimap_full_default_size") )
					{
						Player::Minimap_t::fullSize = d["minimap"]["minimap_full_default_size"].GetInt();
					}
					if ( d["minimap"].HasMember("minimap_compact_default_size") )
					{
						Player::Minimap_t::compactSize = d["minimap"]["minimap_compact_default_size"].GetInt();
					}
					if ( d["minimap"].HasMember("minimap_compact_2p_vertical_size") )
					{
						Player::Minimap_t::compact2pVerticalSize = d["minimap"]["minimap_compact_2p_vertical_size"].GetInt();
					}

					if ( d["minimap"].HasMember("minimap_full_big_scale") )
					{
						Player::Minimap_t::fullBigScale = d["minimap"]["minimap_full_big_scale"].GetDouble();
					}
					if ( d["minimap"].HasMember("minimap_compact_big_scale") )
					{
						Player::Minimap_t::compactBigScale = d["minimap"]["minimap_compact_big_scale"].GetDouble();
					}
					if ( d["minimap"].HasMember("minimap_compact_2p_vertical_big_scale") )
					{
						Player::Minimap_t::compact2pVerticalBigScale = d["minimap"]["minimap_compact_2p_vertical_big_scale"].GetDouble();
					}
				}
				if ( d.HasMember("levelup_anim_curve") )
				{
					LevelUpAnimBreakpoints.clear();
					for ( auto it = d["levelup_anim_curve"].Begin(); it != d["levelup_anim_curve"].End(); ++it )
					{
						LevelUpAnimBreakpoints.push_back(it->GetInt());
					}
				}
				if ( d.HasMember("dmg_number_anim_curve") )
				{
					EnemyHPDamageBarHandler::damageGibAnimCurves.clear();
					for ( auto it = d["dmg_number_anim_curve"].MemberBegin(); it != d["dmg_number_anim_curve"].MemberEnd(); ++it )
					{
						std::string name = it->name.GetString();
						if ( name == "default" )
						{
							for ( auto it2 = it->value.Begin(); it2 != it->value.End(); ++it2 )
							{
								EnemyHPDamageBarHandler::damageGibAnimCurves[DMG_DEFAULT].push_back(it2->GetInt());
							}
						}
					}
				}
				if ( d.HasMember("damage_indicators") )
				{
					damageIndicatorSettings.settings.clear();
					if ( d["damage_indicators"].HasMember("delete_after_ticks") )
					{
						damageIndicatorSettings.deleteAfterTicks = d["damage_indicators"]["delete_after_ticks"].GetUint();
					}
					if ( d["damage_indicators"].HasMember("fade_after_ticks") )
					{
						damageIndicatorSettings.fadeAfterTicks = d["damage_indicators"]["fade_after_ticks"].GetUint();
					}
					if ( d["damage_indicators"].HasMember("fade_speed") )
					{
						damageIndicatorSettings.fadeSpeed = d["damage_indicators"]["fade_speed"].GetDouble();
					}
					if ( d["damage_indicators"].HasMember("animation_on_damage") )
					{
						int index = 0;
						for ( auto it = d["damage_indicators"]["animation_on_damage"].Begin(); it != d["damage_indicators"]["animation_on_damage"].End(); ++it )
						{
							damageIndicatorSettings.indicatorDamageFramePaths[index] = it->GetString();
							++index;
							if ( index >= 4 )
							{
								break;
							}
						}
					}
					if ( d["damage_indicators"].HasMember("animation_on_blocking") )
					{
						int index = 0;
						for ( auto it = d["damage_indicators"]["animation_on_blocking"].Begin(); it != d["damage_indicators"]["animation_on_blocking"].End(); ++it )
						{
							damageIndicatorSettings.indicatorBlockedFramePaths[index] = it->GetString();
							++index;
							if ( index >= 4 )
							{
								break;
							}
						}
					}
					if ( d["damage_indicators"].HasMember("layout_default") )
					{
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_DEFAULT] =
							DamageIndicatorSettings_t::Layout_t();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_DEFAULT].image_size
							= d["damage_indicators"]["layout_default"]["image_size"].GetInt();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_DEFAULT].radius_x
							= d["damage_indicators"]["layout_default"]["radius_x"].GetInt();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_DEFAULT].radius_y
							= d["damage_indicators"]["layout_default"]["radius_y"].GetInt();
					}
					if ( d["damage_indicators"].HasMember("layout_2p_tall") )
					{
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_2P_TALL] =
							DamageIndicatorSettings_t::Layout_t();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_2P_TALL].image_size
							= d["damage_indicators"]["layout_2p_tall"]["image_size"].GetInt();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_2P_TALL].radius_x
							= d["damage_indicators"]["layout_2p_tall"]["radius_x"].GetInt();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_2P_TALL].radius_y
							= d["damage_indicators"]["layout_2p_tall"]["radius_y"].GetInt();
					}
					if ( d["damage_indicators"].HasMember("layout_2p_wide") )
					{
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_2P_WIDE] =
							DamageIndicatorSettings_t::Layout_t();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_2P_WIDE].image_size
							= d["damage_indicators"]["layout_2p_wide"]["image_size"].GetInt();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_2P_WIDE].radius_x
							= d["damage_indicators"]["layout_2p_wide"]["radius_x"].GetInt();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_2P_WIDE].radius_y
							= d["damage_indicators"]["layout_2p_wide"]["radius_y"].GetInt();
					}
					if ( d["damage_indicators"].HasMember("layout_4p") )
					{
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_4P] =
							DamageIndicatorSettings_t::Layout_t();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_4P].image_size
							= d["damage_indicators"]["layout_4p"]["image_size"].GetInt();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_4P].radius_x
							= d["damage_indicators"]["layout_4p"]["radius_x"].GetInt();
						damageIndicatorSettings.settings[DamageIndicatorSettings_t::LAYOUT_4P].radius_y
							= d["damage_indicators"]["layout_4p"]["radius_y"].GetInt();
					}
				}
				if ( d.HasMember("messages") )
				{
					messageZoneSettings.settings.clear();
					std::vector<std::pair<const char*, MessageZoneSettings_t::HotbarTypes_t>> hotbarTypeStrings = {
						{"classic_hotbar", MessageZoneSettings_t::HOTBAR_CLASSIC },
						{"modern_hotbar_keyboard", MessageZoneSettings_t::HOTBAR_MODERN_KEYBOARD },
						{"modern_hotbar_gamepad", MessageZoneSettings_t::HOTBAR_MODERN_GAMEPAD }
					};

					for ( auto pair : hotbarTypeStrings )
					{
						if ( d["messages"].HasMember(pair.first) )
						{
							for ( rapidjson::Value::ConstMemberIterator itr = d["messages"][pair.first].MemberBegin();
								itr != d["messages"][pair.first].MemberEnd(); ++itr )
							{
								std::string alignmentStr = itr->name.GetString();
								auto alignment = Player::MessageZone_t::ALIGN_LEFT_BOTTOM;
								if ( alignmentStr == "left_top" )
								{
									alignment = Player::MessageZone_t::ALIGN_LEFT_TOP;
								}
								else if ( alignmentStr == "left_bottom" )
								{
									alignment = Player::MessageZone_t::ALIGN_LEFT_BOTTOM;
								}
								else if ( alignmentStr == "center_bottom" )
								{
									alignment = Player::MessageZone_t::ALIGN_CENTER_BOTTOM;
								}
								else
								{
									continue;
								}

								auto& setting = messageZoneSettings.addSetting(pair.second, alignment);
								for ( rapidjson::Value::ConstMemberIterator itr2 = itr->value.MemberBegin();
									itr2 != itr->value.MemberEnd(); ++itr2 )
								{
									std::string layoutStr = itr2->name.GetString();
									auto layout = MessageZoneSettings_t::MessageSettings_t::LAYOUT_DEFAULT;
									if ( layoutStr == "default" )
									{
										layout = MessageZoneSettings_t::MessageSettings_t::LAYOUT_DEFAULT;
									}
									else if ( layoutStr == "compact_height" )
									{
										layout = MessageZoneSettings_t::MessageSettings_t::LAYOUT_COMPACT;
									}
									else
									{
										continue;
									}
									setting.layouts[layout].layoutType = layout;
									setting.layouts[layout].offsetY = itr2->value["y_offset"].GetInt();
									setting.layouts[layout].maxMessages = itr2->value["max_messages"].GetInt();
								}
							}
						}
					}
				}
				if ( d.HasMember("world_dialogue") )
				{
					if ( d["world_dialogue"].HasMember("types") )
					{
						for ( rapidjson::Value::ConstMemberIterator itr = d["world_dialogue"]["types"].MemberBegin();
							itr != d["world_dialogue"]["types"].MemberEnd(); ++itr )
						{
							std::string type = itr->name.GetString();
							auto dialogueType = Player::WorldUI_t::WorldTooltipDialogue_t::DIALOGUE_NONE;
							if ( type == "default" )
							{
								dialogueType = Player::WorldUI_t::WorldTooltipDialogue_t::DIALOGUE_NONE;
							}
							else if ( type == "grave" )
							{
								dialogueType = Player::WorldUI_t::WorldTooltipDialogue_t::DIALOGUE_GRAVE;
							}
							else if ( type == "signpost" )
							{
								dialogueType = Player::WorldUI_t::WorldTooltipDialogue_t::DIALOGUE_SIGNPOST;
							}
							else if ( type == "human_npc" )
							{
								dialogueType = Player::WorldUI_t::WorldTooltipDialogue_t::DIALOGUE_NPC;
							}
							else if ( type == "follower_cmd" )
							{
								dialogueType = Player::WorldUI_t::WorldTooltipDialogue_t::DIALOGUE_FOLLOWER_CMD;
							}
							else if ( type == "broadcast" )
							{
								dialogueType = Player::WorldUI_t::WorldTooltipDialogue_t::DIALOGUE_BROADCAST;
							}
							else if ( type == "attack" )
							{
								dialogueType = Player::WorldUI_t::WorldTooltipDialogue_t::DIALOGUE_ATTACK;
							}
							else
							{
								continue;
							}

							auto& settings = Player::WorldUI_t::WorldTooltipDialogue_t::WorldDialogueSettings_t::settings[dialogueType];
							if ( itr->value.HasMember("z_offset") )
							{
								settings.offsetZ = itr->value["z_offset"].GetDouble();
							}
							if ( itr->value.HasMember("text_delay") )
							{
								settings.textDelay = itr->value["text_delay"].GetInt();
							}
							if ( itr->value.HasMember("follow_entity") )
							{
								settings.followEntity = itr->value["follow_entity"].GetBool();
							}
							if ( itr->value.HasMember("fade_dist") )
							{
								settings.fadeDist = itr->value["fade_dist"].GetDouble();
							}
							if ( itr->value.HasMember("base_ticks_to_display") )
							{
								settings.baseTicksToDisplay = itr->value["base_ticks_to_display"].GetUint();
							}
							if ( itr->value.HasMember("extra_ticks_per_line") )
							{
								settings.extraTicksPerLine = itr->value["extra_ticks_per_line"].GetUint();
							}
							if ( itr->value.HasMember("max_width") )
							{
								settings.maxWidth = itr->value["max_width"].GetInt();
							}
							if ( itr->value.HasMember("padx") )
							{
								settings.padx = itr->value["padx"].GetInt();
							}
							if ( itr->value.HasMember("pady") )
							{
								settings.pady = itr->value["pady"].GetInt();
							}
							if ( itr->value.HasMember("pad_after_first_line") )
							{
								settings.padAfterFirstLine = itr->value["pad_after_first_line"].GetInt();
							}
							if ( itr->value.HasMember("scale_modifier") )
							{
								settings.scaleMod = itr->value["scale_modifier"].GetDouble();
							}
						}
					}
				}
				if ( d.HasMember("enemy_hp_bars") )
				{
					if ( d["enemy_hp_bars"].HasMember("world_height_offsets") )
					{
						enemyBarSettings.heightOffsets.clear();
						for ( rapidjson::Value::ConstMemberIterator itr = d["enemy_hp_bars"]["world_height_offsets"].MemberBegin();
							itr != d["enemy_hp_bars"]["world_height_offsets"].MemberEnd(); ++itr )
						{
							enemyBarSettings.heightOffsets[itr->name.GetString()] = itr->value.GetFloat();
						}
					}
					if ( d["enemy_hp_bars"].HasMember("screen_depth_distance_offset") )
					{
						enemyBarSettings.screenDistanceOffsets.clear();
						for ( rapidjson::Value::ConstMemberIterator itr = d["enemy_hp_bars"]["screen_depth_distance_offset"].MemberBegin();
							itr != d["enemy_hp_bars"]["screen_depth_distance_offset"].MemberEnd(); ++itr )
						{
							enemyBarSettings.screenDistanceOffsets[itr->name.GetString()] = itr->value.GetFloat();
						}
					}
					if ( d["enemy_hp_bars"].HasMember("monster_bar_width_to_hp_intervals") )
					{
						EnemyHPDamageBarHandler::widthHealthBreakpointsMonsters.clear();
						for ( rapidjson::Value::ConstValueIterator itr = d["enemy_hp_bars"]["monster_bar_width_to_hp_intervals"].Begin();
							itr != d["enemy_hp_bars"]["monster_bar_width_to_hp_intervals"].End(); ++itr )
						{
							// you need to FindMember() if getting objects from an array...
							auto widthPercentMember = itr->FindMember("width_percent");
							auto hpThresholdMember = itr->FindMember("hp_threshold");
							if ( !widthPercentMember->value.IsInt() || !hpThresholdMember->value.IsInt() )
							{
								printlog("[JSON]: Error: Enemy bar HP or width was not int!");
								continue;
							}
							real_t widthPercent = widthPercentMember->value.GetInt();
							widthPercent /= 100.0;
							int hpThreshold = hpThresholdMember->value.GetInt();
							EnemyHPDamageBarHandler::widthHealthBreakpointsMonsters.push_back(
								std::make_pair(widthPercent, hpThreshold));
						}
					}
					if ( d["enemy_hp_bars"].HasMember("furniture_bar_width_to_hp_intervals") )
					{
						EnemyHPDamageBarHandler::widthHealthBreakpointsFurniture.clear();
						for ( rapidjson::Value::ConstValueIterator itr = d["enemy_hp_bars"]["furniture_bar_width_to_hp_intervals"].Begin();
							itr != d["enemy_hp_bars"]["furniture_bar_width_to_hp_intervals"].End(); ++itr )
						{
							// you need to FindMember() if getting objects from an array...
							auto widthPercentMember = itr->FindMember("width_percent");
							auto hpThresholdMember = itr->FindMember("hp_threshold");
							if ( !widthPercentMember->value.IsInt() || !hpThresholdMember->value.IsInt() )
							{
								printlog("[JSON]: Error: Enemy bar HP or width was not int!");
								continue;
							}
							real_t widthPercent = widthPercentMember->value.GetInt();
							widthPercent /= 100.0;
							int hpThreshold = hpThresholdMember->value.GetInt();
							EnemyHPDamageBarHandler::widthHealthBreakpointsFurniture.push_back(
								std::make_pair(widthPercent, hpThreshold));
						}
					}
					if ( d["enemy_hp_bars"].HasMember("monster_bar_lifetime_ticks") )
					{
						EnemyHPDamageBarHandler::maxTickLifetime = d["enemy_hp_bars"]["monster_bar_lifetime_ticks"].GetInt();
					}
					if ( d["enemy_hp_bars"].HasMember("furniture_bar_lifetime_ticks") )
					{
						EnemyHPDamageBarHandler::maxTickFurnitureLifetime = d["enemy_hp_bars"]["furniture_bar_lifetime_ticks"].GetInt();
					}
					if ( d["enemy_hp_bars"].HasMember("quick_fade_delay_ticks") )
					{
						EnemyHPDamageBarHandler::shortDistanceHPBarFadeTicks = d["enemy_hp_bars"]["quick_fade_delay_ticks"].GetInt();
					}
					if ( d["enemy_hp_bars"].HasMember("quick_fade_distance_from_player_multiplier") )
					{
						if ( d["enemy_hp_bars"]["quick_fade_distance_from_player_multiplier"].IsDouble() )
						{
							EnemyHPDamageBarHandler::shortDistanceHPBarFadeDistance = d["enemy_hp_bars"]["quick_fade_distance_from_player_multiplier"].GetDouble();
						}
						else
						{
							EnemyHPDamageBarHandler::shortDistanceHPBarFadeDistance = d["enemy_hp_bars"]["quick_fade_distance_from_player_multiplier"].GetInt();
						}
					}
				}
				if ( d.HasMember("colors") )
				{
					if ( d["colors"].HasMember("itemmenu_heading_text") )
					{
						hudColors.itemContextMenuHeadingText = makeColor(
							d["colors"]["itemmenu_heading_text"]["r"].GetInt(),
							d["colors"]["itemmenu_heading_text"]["g"].GetInt(),
							d["colors"]["itemmenu_heading_text"]["b"].GetInt(),
							d["colors"]["itemmenu_heading_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("itemmenu_option_text") )
					{
						hudColors.itemContextMenuOptionText = makeColor(
							d["colors"]["itemmenu_option_text"]["r"].GetInt(),
							d["colors"]["itemmenu_option_text"]["g"].GetInt(),
							d["colors"]["itemmenu_option_text"]["b"].GetInt(),
							d["colors"]["itemmenu_option_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("itemmenu_selected_text") )
					{
						hudColors.itemContextMenuOptionSelectedText = makeColor(
							d["colors"]["itemmenu_selected_text"]["r"].GetInt(),
							d["colors"]["itemmenu_selected_text"]["g"].GetInt(),
							d["colors"]["itemmenu_selected_text"]["b"].GetInt(),
							d["colors"]["itemmenu_selected_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("itemmenu_selected_img") )
					{
						hudColors.itemContextMenuOptionSelectedImg = makeColor(
							d["colors"]["itemmenu_selected_img"]["r"].GetInt(),
							d["colors"]["itemmenu_selected_img"]["g"].GetInt(),
							d["colors"]["itemmenu_selected_img"]["b"].GetInt(),
							d["colors"]["itemmenu_selected_img"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("itemmenu_option_img") )
					{
						hudColors.itemContextMenuOptionImg = makeColor(
							d["colors"]["itemmenu_option_img"]["r"].GetInt(),
							d["colors"]["itemmenu_option_img"]["g"].GetInt(),
							d["colors"]["itemmenu_option_img"]["b"].GetInt(),
							d["colors"]["itemmenu_option_img"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_neutral_text") )
					{
						hudColors.characterSheetNeutral = makeColor(
							d["colors"]["charsheet_neutral_text"]["r"].GetInt(),
							d["colors"]["charsheet_neutral_text"]["g"].GetInt(),
							d["colors"]["charsheet_neutral_text"]["b"].GetInt(),
							d["colors"]["charsheet_neutral_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_neutral_light_text") )
					{
						hudColors.characterSheetLightNeutral = makeColor(
							d["colors"]["charsheet_neutral_light_text"]["r"].GetInt(),
							d["colors"]["charsheet_neutral_light_text"]["g"].GetInt(),
							d["colors"]["charsheet_neutral_light_text"]["b"].GetInt(),
							d["colors"]["charsheet_neutral_light_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_neutral_lighter1_text") )
					{
						hudColors.characterSheetLighter1Neutral = makeColor(
							d["colors"]["charsheet_neutral_lighter1_text"]["r"].GetInt(),
							d["colors"]["charsheet_neutral_lighter1_text"]["g"].GetInt(),
							d["colors"]["charsheet_neutral_lighter1_text"]["b"].GetInt(),
							d["colors"]["charsheet_neutral_lighter1_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_neutral_darker1_text") )
					{
						hudColors.characterSheetDarker1Neutral = makeColor(
							d["colors"]["charsheet_neutral_darker1_text"]["r"].GetInt(),
							d["colors"]["charsheet_neutral_darker1_text"]["g"].GetInt(),
							d["colors"]["charsheet_neutral_darker1_text"]["b"].GetInt(),
							d["colors"]["charsheet_neutral_darker1_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_positive_text") )
					{
						hudColors.characterSheetGreen = makeColor(
							d["colors"]["charsheet_positive_text"]["r"].GetInt(),
							d["colors"]["charsheet_positive_text"]["g"].GetInt(),
							d["colors"]["charsheet_positive_text"]["b"].GetInt(),
							d["colors"]["charsheet_positive_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_negative_text") )
					{
						hudColors.characterSheetRed = makeColor(
							d["colors"]["charsheet_negative_text"]["r"].GetInt(),
							d["colors"]["charsheet_negative_text"]["g"].GetInt(),
							d["colors"]["charsheet_negative_text"]["b"].GetInt(),
							d["colors"]["charsheet_negative_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_faint_text") )
					{
						hudColors.characterSheetFaintText = makeColor(
							d["colors"]["charsheet_faint_text"]["r"].GetInt(),
							d["colors"]["charsheet_faint_text"]["g"].GetInt(),
							d["colors"]["charsheet_faint_text"]["b"].GetInt(),
							d["colors"]["charsheet_faint_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_off_white_text") )
					{
						hudColors.characterSheetOffWhiteText = makeColor(
							d["colors"]["charsheet_off_white_text"]["r"].GetInt(),
							d["colors"]["charsheet_off_white_text"]["g"].GetInt(),
							d["colors"]["charsheet_off_white_text"]["b"].GetInt(),
							d["colors"]["charsheet_off_white_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_heading_text") )
					{
						hudColors.characterSheetHeadingText = makeColor(
							d["colors"]["charsheet_heading_text"]["r"].GetInt(),
							d["colors"]["charsheet_heading_text"]["g"].GetInt(),
							d["colors"]["charsheet_heading_text"]["b"].GetInt(),
							d["colors"]["charsheet_heading_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_highlight_text") )
					{
						hudColors.characterSheetHighlightText = makeColor(
							d["colors"]["charsheet_highlight_text"]["r"].GetInt(),
							d["colors"]["charsheet_highlight_text"]["g"].GetInt(),
							d["colors"]["charsheet_highlight_text"]["b"].GetInt(),
							d["colors"]["charsheet_highlight_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_base_class_text") )
					{
						hudColors.characterBaseClassText = makeColor(
							d["colors"]["charsheet_base_class_text"]["r"].GetInt(),
							d["colors"]["charsheet_base_class_text"]["g"].GetInt(),
							d["colors"]["charsheet_base_class_text"]["b"].GetInt(),
							d["colors"]["charsheet_base_class_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_dlc1_text") )
					{
						hudColors.characterDLC1ClassText = makeColor(
							d["colors"]["charsheet_dlc1_text"]["r"].GetInt(),
							d["colors"]["charsheet_dlc1_text"]["g"].GetInt(),
							d["colors"]["charsheet_dlc1_text"]["b"].GetInt(),
							d["colors"]["charsheet_dlc1_text"]["a"].GetInt());
					}
					if ( d["colors"].HasMember("charsheet_dlc2_text") )
					{
						hudColors.characterDLC2ClassText = makeColor(
							d["colors"]["charsheet_dlc2_text"]["r"].GetInt(),
							d["colors"]["charsheet_dlc2_text"]["g"].GetInt(),
							d["colors"]["charsheet_dlc2_text"]["b"].GetInt(),
							d["colors"]["charsheet_dlc2_text"]["a"].GetInt());
					}
				}
				if ( d.HasMember("dropdowns") )
				{
					Player::GUIDropdown_t::allDropDowns.clear();
					for ( rapidjson::Value::ConstMemberIterator itr = d["dropdowns"].MemberBegin();
						itr != d["dropdowns"].MemberEnd(); ++itr )
					{
						auto& dropdown = Player::GUIDropdown_t::allDropDowns[itr->name.GetString()];
						dropdown.internalName = itr->name.GetString();
						if ( itr->value.HasMember("title") )
						{
							dropdown.title = itr->value["title"].GetString();
						}
						else
						{
							dropdown.title = Language::get(4040); // "interact"
						}
						if ( itr->value.HasMember("align_right") )
						{
							dropdown.alignRight = itr->value["align_right"].GetBool();
						}
						if ( itr->value.HasMember("gui_module") )
						{
							std::string moduleName = itr->value["gui_module"].GetString();
							if ( moduleName == "character_sheet" )
							{
								dropdown.module = Player::GUI_t::MODULE_CHARACTERSHEET;
							}
							else if ( moduleName == "inventory" )
							{
								dropdown.module = Player::GUI_t::MODULE_INVENTORY;
							}
							else if ( moduleName == "chest" )
							{
								dropdown.module = Player::GUI_t::MODULE_CHEST;
							}
							else if ( moduleName == "spells" )
							{
								dropdown.module = Player::GUI_t::MODULE_SPELLS;
							}
							else if ( moduleName == "hotbar" )
							{
								dropdown.module = Player::GUI_t::MODULE_HOTBAR;
							}
							else
							{
								dropdown.module = Player::GUI_t::MODULE_NONE;
							}
						}
						if ( itr->value.HasMember("default_option") )
						{
							dropdown.defaultOption = itr->value["default_option"].GetInt();
						}
						else
						{
							dropdown.defaultOption = 0;
						}
						for ( rapidjson::Value::ConstValueIterator options_itr = itr->value["options"].Begin();
							options_itr != itr->value["options"].End(); ++options_itr )
						{
							std::string text = "";
							std::string controller_glyph = "";
							std::string keyboard_glyph = "";
							std::string action = "no_action";
							if ( options_itr->HasMember("text") )
							{
								text = (*options_itr)["text"].GetString();
							}
							if ( options_itr->HasMember("controller_glyph") )
							{
								controller_glyph = (*options_itr)["controller_glyph"].GetString();
							}
							if ( options_itr->HasMember("keyboard_glyph") )
							{
								keyboard_glyph = (*options_itr)["keyboard_glyph"].GetString();
							}
							if ( options_itr->HasMember("action") )
							{
								action = (*options_itr)["action"].GetString();
							}
							dropdown.options.push_back(Player::GUIDropdown_t::DropdownOption_t(text, keyboard_glyph, controller_glyph, action));
						}
					}
				}
				if ( d.HasMember("ping_status") )
				{
					PingNetworkStatus_t::bEnabled = d["ping_status"]["enabled"].GetBool();

					PingNetworkStatus_t::pingLimitGreen = d["ping_status"]["limit_green"].GetInt();
					PingNetworkStatus_t::pingLimitYellow = d["ping_status"]["limit_yellow"].GetInt();
					PingNetworkStatus_t::pingLimitOrange = d["ping_status"]["limit_orange"].GetInt();

					PingNetworkStatus_t::pingHUDDisplayGreen = d["ping_status"]["show_green_always"].GetBool();
					PingNetworkStatus_t::pingHUDDisplayYellow = d["ping_status"]["show_yellow_always"].GetBool();
					PingNetworkStatus_t::pingHUDDisplayOrange = d["ping_status"]["show_orange_always"].GetBool();
					PingNetworkStatus_t::pingHUDDisplayRed = d["ping_status"]["show_red_always"].GetBool();
					PingNetworkStatus_t::pingHUDShowOKBriefly = d["ping_status"]["show_green_yellow_briefly"].GetBool();
					PingNetworkStatus_t::pingHUDShowNumericValue = d["ping_status"]["show_numeric_on_hud"].GetBool();
				}
				printlog("[JSON]: Successfully read json file %s", inputPath.c_str());
			}
		}
	}
}

const int kSpellListHeight = 294;
const int kSpellListGridY = 2;
void createPlayerSpellList(const int player)
{
	if ( !gui )
	{
		return;
	}

	if ( players[player]->inventoryUI.spellFrame || !players[player]->inventoryUI.frame )
	{
		return;
	}

	Frame* frame = players[player]->inventoryUI.frame->addFrame("player spells");
	players[player]->inventoryUI.spellFrame = frame;
	frame->setSize(SDL_Rect{ 0,
		0,
		210,
		kSpellListHeight });
	frame->setHollow(true);
	frame->setBorder(0);
	frame->setOwner(player);
	frame->setInheritParentFrameOpacity(false);

	SDL_Rect basePos{ 0, 0, 210, kSpellListHeight };
	const int inventorySlotSize = players[player]->inventoryUI.getSlotSize();

	players[player]->inventoryUI.spellSlotFrames.clear();

	const int baseSlotOffsetX = 18;
	const int baseSlotOffsetY = 36;
	const int baseGridOffsetY = kSpellListGridY;

	SDL_Rect invSlotsPos{ basePos.x + 4, basePos.y + 4, basePos.w, 242 };
	{
		int numGrids = (players[player]->inventoryUI.MAX_SPELLS_Y / players[player]->inventoryUI.spellPanel.kNumSpellsToDisplayVertical) + 1;

		const auto spellSlotsFrame = frame->addFrame("spell slots");
		spellSlotsFrame->setSize(invSlotsPos);
		spellSlotsFrame->setActualSize(SDL_Rect{ 0, 0, basePos.w, 242 * numGrids });
		spellSlotsFrame->setHollow(true);
		spellSlotsFrame->setAllowScrollBinds(false);

		auto gridImg = spellSlotsFrame->addImage(SDL_Rect{ baseSlotOffsetX, baseGridOffsetY, 162, 242 * numGrids },
			0xFFFFFFFF, "*images/ui/Inventory/HUD_Magic_ScrollGrid.png", "grid img");
		gridImg->tiled = true;

		SDL_Rect currentSlotPos{ baseSlotOffsetX, baseSlotOffsetY, inventorySlotSize, inventorySlotSize };
		const int maxSpellsX = Player::Inventory_t::MAX_SPELLS_X;
		const int maxSpellsY = Player::Inventory_t::MAX_SPELLS_Y;

		for ( int x = 0; x < maxSpellsX; ++x )
		{
			currentSlotPos.x = baseSlotOffsetX + (x * inventorySlotSize);
			for ( int y = 0; y < maxSpellsY; ++y )
			{
				currentSlotPos.y = baseSlotOffsetY + (y * inventorySlotSize);

				char slotname[32] = "";
				snprintf(slotname, sizeof(slotname), "spell %d %d", x, y);

				auto slotFrame = spellSlotsFrame->addFrame(slotname);
				players[player]->inventoryUI.spellSlotFrames[x + y * 100] = slotFrame;
				SDL_Rect slotPos{ currentSlotPos.x, currentSlotPos.y, inventorySlotSize, inventorySlotSize };
				slotFrame->setSize(slotPos);

				createPlayerInventorySlotFrameElements(slotFrame);
			}
		}
	}

	{
		auto bgFrame = frame->addFrame("spell base");
		bgFrame->setSize(basePos);
		bgFrame->setHollow(true);
		const auto bgSize = bgFrame->getSize();
		auto bg = bgFrame->addImage(SDL_Rect{ 0, 0, 210, kSpellListHeight },
			makeColor(255, 255, 255, 255),
			"*#images/ui/Inventory/HUD_Magic_Base.png", "spell base img");
		playerInventoryFrames[player].spellBaseImg = bg;

		auto slider = bgFrame->addSlider("spell slider");
		slider->setBorder(16);
		slider->setMinValue(0);
		slider->setMaxValue(100);
		slider->setValue(0);
		SDL_Rect sliderPos{ basePos.w - 26, 50, 20, 192 };
		slider->setRailSize(sliderPos);
		slider->setHandleSize(SDL_Rect{ 0, 0, 20, 28 });
		slider->setOrientation(Slider::SLIDER_VERTICAL);
		//slider->setCallback(callback);
		slider->setColor(makeColor(255, 255, 255, 255));
		slider->setHighlightColor(makeColor(255, 255, 255, 255));
		slider->setHandleImage("*#images/ui/Sliders/HUD_Magic_Slider_Emerald_01.png");
		slider->setRailImage("*#images/ui/Sliders/HUD_Slider_Blank.png");
		slider->setHideGlyphs(true);
		slider->setHideKeyboardGlyphs(true);
		slider->setHideSelectors(true);
		slider->setMenuConfirmControlType(0);

		auto sliderCapTop = bgFrame->addImage(SDL_Rect{ sliderPos.x + 2, sliderPos.y, 16, 16 },
			makeColor(255, 255, 255, 255),
			"*#images/ui/Sliders/HUD_Magic_Slider_SettingTop_01.png", "spell slider top");
		sliderCapTop->ontop = true;
		auto sliderCapBot = bgFrame->addImage(SDL_Rect{ sliderPos.x + 2, sliderPos.y + sliderPos.h - 16, 16, 16 },
			makeColor(255, 255, 255, 255),
			"*#images/ui/Sliders/HUD_Magic_Slider_SettingBot_01.png", "spell slider bot");
		sliderCapBot->ontop = true;

		const char* font = "fonts/pixel_maz.ttf#32#2";
		auto titleText = bgFrame->addField("title txt", 64);
		titleText->setFont(font);
		titleText->setText(Language::get(5958));
		titleText->setHJustify(Field::justify_t::CENTER);
		titleText->setVJustify(Field::justify_t::TOP);
		titleText->setSize(SDL_Rect{ 56, 12, 96, 24 });
		titleText->setColor(makeColor(236, 175, 28, 255));

		auto closeBtn = bgFrame->addButton("close spell button");
		SDL_Rect closeBtnPos;
		closeBtnPos.x = 180;
		closeBtnPos.y = 6;
		closeBtnPos.w = 26;
		closeBtnPos.h = 26;
		closeBtn->setSize(closeBtnPos);
		closeBtn->setColor(makeColor(255, 255, 255, 255));
		closeBtn->setHighlightColor(makeColor(255, 255, 255, 255));
		closeBtn->setTextHighlightColor(makeColor(201, 162, 100, 255));
		closeBtn->setText("X");
		closeBtn->setFont(font);
		closeBtn->setHideGlyphs(true);
		closeBtn->setHideKeyboardGlyphs(true);
		closeBtn->setHideSelectors(true);
		closeBtn->setMenuConfirmControlType(0);
		closeBtn->setBackground("*#images/ui/Inventory/chests/Button_X_00.png");
		closeBtn->setBackgroundHighlighted("*#images/ui/Inventory/chests/Button_XHigh_00.png");
		closeBtn->setBackgroundActivated("*#images/ui/Inventory/chests/Button_XPress_00.png");
		closeBtn->setCallback([](Button& button) {
			if ( players[button.getOwner()]->inventory_mode == INVENTORY_MODE_SPELL )
			{
				players[button.getOwner()]->inventoryUI.cycleInventoryTab();
			}
			players[button.getOwner()]->inventoryUI.spellPanel.closeSpellPanel();
		});
		closeBtn->setTickCallback([](Widget& widget) {
			if ( widget.isSelected() )
			{
				if ( !inputs.getVirtualMouse(widget.getOwner())->draw_cursor )
				{
					widget.deselect();
				}
			}
		});

		auto skillBg = bgFrame->addImage(SDL_Rect{ 6, 6, 32, 32 },
			makeColor(255, 255, 255, 255),
			"*#images/ui/Inventory/HUD_Magic_Casting_BG_01.png", "spell skill bg");

		auto skillIcon = bgFrame->addImage(SDL_Rect{ skillBg->pos.x + 4, skillBg->pos.y + 4, 24, 24 },
			makeColor(255, 255, 255, 255),
			"", "spell skill icon");

		auto closeGlyph = bgFrame->addImage(SDL_Rect{ 0, 0, 24, 24 },
			makeColor(255, 255, 255, 255),
			"", "close spell glyph");
		closeGlyph->disabled = true;
	}
}

void closeChestGUIAction(const int player)
{
	players[player]->hud.compactLayoutMode = Player::HUD_t::COMPACT_LAYOUT_INVENTORY;
	//players[player]->inventory_mode = INVENTORY_MODE_ITEM;
	if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_INVENTORY )
	{
		players[player]->GUI.activateModule(Player::GUI_t::MODULE_INVENTORY);
		if ( !inputs.getVirtualMouse(player)->draw_cursor )
		{
			players[player]->GUI.warpControllerToModule(false);
		}
	}
	if ( openedChest[player] )
	{
		openedChest[player]->closeChest();
	}
	else
	{
		players[player]->inventoryUI.chestGUI.closeChest();
	}
}

bool takeAllChestGUIAction(const int player)
{
	if ( !openedChest[player] )
	{
		return false;
	}

	list_t* chest_inventory = nullptr;
	if ( multiplayer == CLIENT )
	{
		chest_inventory = &chestInv[player];
	}
	else if ( openedChest[player]->children.first && openedChest[player]->children.first->element )
	{
		chest_inventory = (list_t*)openedChest[player]->children.first->element;
	}
	if ( !chest_inventory )
	{
		// no chest inventory available
		return false;
	}

	std::vector<std::pair<int, Item*>> chestSlotOrder;
	for ( node_t* node = chest_inventory->first; node != nullptr; node = node->next )
	{
		Item* item2 = static_cast<Item*>(node->element);
		if ( item2 )
		{
			int key = item2->x + item2->y * 100;
			chestSlotOrder.push_back(std::make_pair(key, item2));
		}
	}
	int numItems = (int)chestSlotOrder.size();
	std::sort(chestSlotOrder.begin(), chestSlotOrder.end()); // sort ascending by position, left to right, then down
	int pickedUpItems = 0;
	for ( auto& keyValue : chestSlotOrder )
	{
		Item* item = keyValue.second;
		bool tryAddToInventory = true;
		int loops = 0;
		while ( tryAddToInventory )
		{
			++loops;
			if ( item->count <= 0 )
			{
				break;
			}
			int oldItemQty = 0;
			int destItemQty = 0;
			bool oldIdentify = item->identified;
			if ( skillCapstoneUnlocked(player, PRO_APPRAISAL) )
			{
				item->identified = true;
			}
			auto result = getItemStackingBehavior(player, item, nullptr, oldItemQty, destItemQty);
			item->identified = oldIdentify;
			int amountToPlace = item->count - oldItemQty;
			assert(amountToPlace > 0);
			if ( amountToPlace <= 0 )
			{
				break;
			}
			switch ( result.resultType )
			{
				case ITEM_ADDED_PARTIALLY_TO_DESTINATION_STACK:
				{
					if ( Item* inventoryItem = takeItemFromChest(player, item, amountToPlace, result.itemToStackInto, false, false) )
					{
						// need to do another place operation.
					}
					else
					{
						tryAddToInventory = false;
					}
					if ( loops == 1 )
					{
						++pickedUpItems;
					}
					break;
				}
				case ITEM_ADDED_ENTIRELY_TO_DESTINATION_STACK:
				{
					// operation success, can finish here.
					Item* inventoryItem = takeItemFromChest(player, item, amountToPlace, result.itemToStackInto, false, false);
					tryAddToInventory = false;
					if ( loops == 1 )
					{
						++pickedUpItems;
					}
					break;
				}
				case ITEM_ADDED_WITHOUT_NEEDING_STACK:
				{
					// check for inventory space
					if ( !players[player]->inventoryUI.bItemInventoryHasFreeSlot() )
					{
						// no space
						tryAddToInventory = false;
						break;
					}
					Item* inventoryItem = takeItemFromChest(player, item, amountToPlace, nullptr, true, false);
					if ( oldItemQty > 0 )
					{
						// more work to do (unusually large stacks exceeding normal limits)
					}
					else
					{
						tryAddToInventory = false;
					}
					if ( loops == 1 )
					{
						++pickedUpItems;
					}
					break;
				}
				default:
					// error out
					tryAddToInventory = false;
					break;
			}
		}
	}

	if ( pickedUpItems > 0 )
	{
		messagePlayer(player, MESSAGE_INVENTORY, Language::get(4099), pickedUpItems);
		playSound(35 + local_rng.rand() % 3, 64);
	}
	else if ( pickedUpItems == 0 && numItems > 0 )
	{
		messagePlayer(player, MESSAGE_INVENTORY, Language::get(4100));
		playSoundPlayer(player, 90, 64);
	}

	return true;
}

const int chestBaseImgBorderWidth = 16;
const int chestBaseImgBorderTopHeight = 20;
PlayerInventoryFrames_t playerInventoryFrames[MAXPLAYERS];

void createChestGUI(const int player)
{
	if ( !gui )
	{
		return;
	}

	if ( players[player]->inventoryUI.chestFrame || !players[player]->inventoryUI.frame )
	{
		return;
	}

	Frame* frame = players[player]->inventoryUI.frame->addFrame("chest");
	players[player]->inventoryUI.chestFrame = frame;

	frame->setSize(SDL_Rect{ 0,
		0,
		194,
		250 });
	frame->setHollow(true);
	frame->setBorder(0);
	frame->setOwner(player);
	frame->setInheritParentFrameOpacity(false);

	SDL_Rect basePos{ 0, 0, 194, 130 };
	{
		auto bgFrame = frame->addFrame("chest base");
		playerInventoryFrames[player].chestBgFrame = bgFrame;
		bgFrame->setSize(basePos);
		bgFrame->setHollow(false);
		const auto bgSize = bgFrame->getSize();
		auto bg = bgFrame->addImage(SDL_Rect{ 6, 0, 182, 172 },
			makeColor( 255, 255, 255, 255),
			"*#images/ui/Inventory/chests/Chest_Main_00.png", "chest base img");
		playerInventoryFrames[player].chestBaseImg = bg;
		auto bg2 = bgFrame->addImage(SDL_Rect{ 0, 0, 194, 66 },
			makeColor( 255, 255, 255, 255),
			"*#images/ui/Inventory/chests/Chest_Top_00.png", "chest lid img");
		//bg->disabled = false;

		//auto slider = bgFrame->addSlider("chest slider");
		//slider->setBorder(24);
		//slider->setMinValue(0);
		//slider->setMaxValue(100);
		//slider->setValue(0);
		//SDL_Rect sliderPos{ basePos.w - 38, 8, 30, 234 };
		//slider->setRailSize(sliderPos);
		//slider->setHandleSize(SDL_Rect{ 0, 0, 34, 34 });
		//slider->setOrientation(Slider::SLIDER_VERTICAL);
		////slider->setCallback(callback);
		//slider->setColor(makeColor(255, 255, 255, 255));
		//slider->setHighlightColor(makeColor(255, 255, 255, 255));
		//slider->setHandleImage("*#images/ui/Main Menus/Settings/Settings_Slider_Boulder00.png");
		//slider->setRailImage("*#images/ui/Main Menus/Settings/Settings_Slider_Backing00.png");
		//slider->setHideGlyphs(true);
		//slider->setHideKeyboardGlyphs(true);
		//slider->setHideSelectors(true);
		//slider->setMenuConfirmControlType(0);

		const char* font = "fonts/pixel_maz.ttf#32#2";
		auto titleText = bgFrame->addField("title txt", 64);
		titleText->setFont(font);
		titleText->setText(Language::get(5959));
		titleText->setHJustify(Field::justify_t::CENTER);
		titleText->setVJustify(Field::justify_t::CENTER);
		titleText->setSize(SDL_Rect{ basePos.x + 4, 0, 162, 32 });
		titleText->setColor(makeColor(188, 154, 114, 255));

		auto closeBtn = bgFrame->addButton("close chest button");
		SDL_Rect closeBtnPos = titleText->getSize();
		closeBtnPos.x = closeBtnPos.x + closeBtnPos.w - 98;
		closeBtnPos.w = 26;
		closeBtnPos.h = 26;
		closeBtn->setSize(closeBtnPos);
		closeBtn->setColor(makeColor(255, 255, 255, 255));
		closeBtn->setHighlightColor(makeColor(255, 255, 255, 255));
		closeBtn->setText("X");
		closeBtn->setFont(font);
		closeBtn->setHideGlyphs(true);
		closeBtn->setHideKeyboardGlyphs(true);
		closeBtn->setHideSelectors(true);
		closeBtn->setMenuConfirmControlType(0);
		closeBtn->setBackground("*#images/ui/Inventory/chests/Button_X_00.png");
		closeBtn->setBackgroundHighlighted("*#images/ui/Inventory/chests/Button_XHigh_00.png");
		closeBtn->setBackgroundActivated("*#images/ui/Inventory/chests/Button_XPress_00.png");
		closeBtn->setTextHighlightColor(makeColor(201, 162, 100, 255));
		closeBtn->setCallback([](Button& button) {
			closeChestGUIAction(button.getOwner());
		});

		auto grabAllBtn = bgFrame->addButton("grab all button");
		SDL_Rect grabBtnPos = titleText->getSize();
		grabBtnPos.x = closeBtnPos.x + closeBtnPos.w - 86;
		grabBtnPos.w = 86;
		grabBtnPos.h = 26;
		grabAllBtn->setSize(grabBtnPos);
		grabAllBtn->setColor(makeColor(255, 255, 255, 255));
		grabAllBtn->setHighlightColor(makeColor(255, 255, 255, 255));
		grabAllBtn->setText(Language::get(5960));
		grabAllBtn->setFont(font);
		grabAllBtn->setHideGlyphs(true);
		grabAllBtn->setHideKeyboardGlyphs(true);
		grabAllBtn->setHideSelectors(true);
		grabAllBtn->setMenuConfirmControlType(0);
		grabAllBtn->setBackground("*#images/ui/Inventory/chests/Button_TakeAll_00.png");
		grabAllBtn->setBackgroundHighlighted("*#images/ui/Inventory/chests/Button_TakeAllHigh_00.png");
		grabAllBtn->setBackgroundActivated("*#images/ui/Inventory/chests/Button_TakeAllPress_00.png");
		grabAllBtn->setTextHighlightColor(makeColor(201, 162, 100, 255));
		grabAllBtn->setCallback([](Button& button) {
			takeAllChestGUIAction(button.getOwner());
			Player::soundActivate();
		});

		std::string promptFont = "fonts/pixel_maz.ttf#32#2";
		const int promptWidth = 60;
		const int promptHeight = 27;
		auto promptBack = bgFrame->addField("prompt back txt", 16);
		promptBack->setSize(SDL_Rect{ 0, 0, promptWidth, promptHeight });
		promptBack->setFont(promptFont.c_str());
		promptBack->setHJustify(Field::justify_t::RIGHT);
		promptBack->setVJustify(Field::justify_t::CENTER);
		promptBack->setText(Language::get(4053));
		//promptBack->setOntop(true);
		promptBack->setColor(makeColor(201, 162, 100, 255));

		auto promptBackImg = bgFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
			"", "prompt back img");
		promptBackImg->disabled = true;

		auto promptGrabAll = bgFrame->addField("prompt grab txt", 16);
		promptGrabAll->setSize(SDL_Rect{ 0, 0, promptWidth, promptHeight });
		promptGrabAll->setFont(promptFont.c_str());
		promptGrabAll->setHJustify(Field::justify_t::RIGHT);
		promptGrabAll->setVJustify(Field::justify_t::CENTER);
		promptGrabAll->setText(Language::get(4091));
		//promptBack->setOntop(true);
		promptGrabAll->setColor(makeColor(201, 162, 100, 255));

		auto promptGrabImg = bgFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
			"", "prompt grab img");
		promptBackImg->disabled = true;
	}

	const int inventorySlotSize = players[player]->inventoryUI.getSlotSize();

	players[player]->inventoryUI.chestSlotFrames.clear();

	const int baseSlotOffsetX = 0;
	const int baseSlotOffsetY = 0;

	const int gridHeight = 120 + 2; // 120px is grid img, plus 2px to tile the image for bottom border.
	SDL_Rect invSlotsPos{ basePos.x + chestBaseImgBorderWidth, basePos.y + 4 + chestBaseImgBorderTopHeight, basePos.w, gridHeight };
	{
		int numGrids = (players[player]->inventoryUI.MAX_CHEST_Y / players[player]->inventoryUI.chestGUI.kNumItemsToDisplayVertical) + 1;

		const auto chestSlotsFrame = frame->addFrame("chest slots");
		chestSlotsFrame->setSize(invSlotsPos);
		chestSlotsFrame->setActualSize(SDL_Rect{ 0, 0, basePos.w, gridHeight * numGrids });
		chestSlotsFrame->setHollow(true);
		chestSlotsFrame->setAllowScrollBinds(false);
		playerInventoryFrames[player].chestFrameSlots = chestSlotsFrame;

		auto gridImg = chestSlotsFrame->addImage(SDL_Rect{ baseSlotOffsetX, baseSlotOffsetY, 162, gridHeight * numGrids },
			makeColor(255, 255, 255, 32), "*#images/ui/Inventory/HUD_Chest4x3_ScrollGrid.png", "grid img");
		gridImg->tiled = true;

		SDL_Rect currentSlotPos{ baseSlotOffsetX, baseSlotOffsetY, inventorySlotSize, inventorySlotSize };
		const int maxChestX = Player::Inventory_t::MAX_CHEST_X;
		const int maxChestY = Player::Inventory_t::MAX_CHEST_Y;

		for ( int x = 0; x < maxChestX; ++x )
		{
			currentSlotPos.x = baseSlotOffsetX + (x * inventorySlotSize);
			for ( int y = 0; y < maxChestY; ++y )
			{
				currentSlotPos.y = baseSlotOffsetY + (y * inventorySlotSize);

				char slotname[32] = "";
				snprintf(slotname, sizeof(slotname), "chest %d %d", x, y);

				auto slotFrame = chestSlotsFrame->addFrame(slotname);
				players[player]->inventoryUI.chestSlotFrames[x + y * 100] = slotFrame;
				SDL_Rect slotPos{ currentSlotPos.x, currentSlotPos.y, inventorySlotSize, inventorySlotSize };
				slotFrame->setSize(slotPos);

				createPlayerInventorySlotFrameElements(slotFrame);
			}
		}
	}
}

const int Player::ShopGUI_t::MAX_SHOP_X = 5;
const int Player::ShopGUI_t::MAX_SHOP_Y = 5;

void closeShopGUIAction(const int player)
{
	players[player]->hud.compactLayoutMode = Player::HUD_t::COMPACT_LAYOUT_INVENTORY;
	if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_INVENTORY )
	{
		players[player]->GUI.activateModule(Player::GUI_t::MODULE_INVENTORY);
		if ( !inputs.getVirtualMouse(player)->draw_cursor )
		{
			players[player]->GUI.warpControllerToModule(false);
		}
	}
	if ( uidToEntity(shopkeeper[player]) )
	{
		closeShop(player);
	}
	else
	{
		players[player]->shopGUI.closeShop();
	}
}

void toggleShopBuybackView(const int player)
{
	players[player]->shopGUI.buybackView = !players[player]->shopGUI.buybackView;
}

void createShopGUI(const int player)
{
	if ( !gui )
	{
		return;
	}

	auto& shopGUI = players[player]->shopGUI;

	if ( shopGUI.shopFrame || !players[player]->inventoryUI.frame )
	{
		return;
	}

	SDL_Rect basePos{ 0, 0, 520, 334 };

	Frame* frame = players[player]->inventoryUI.frame->addFrame("shop");
	shopGUI.shopFrame = frame;
	frame->setSize(SDL_Rect{ players[player]->camera_virtualx1(),
		players[player]->camera_virtualy1(),
		basePos.w,
		basePos.h });
	frame->setHollow(true);
	frame->setBorder(0);
	frame->setOwner(player);
	frame->setInheritParentFrameOpacity(false);

	{
		auto bgFrame = frame->addFrame("shop base");
		bgFrame->setSize(basePos);
		bgFrame->setHollow(false);
		const auto bgSize = bgFrame->getSize();
		auto bg = bgFrame->addImage(SDL_Rect{ 0, 0, basePos.w, basePos.h },
			makeColor(255, 255, 255, 255),
			"*#images/ui/Shop/Shop_Window_03C.png", "shop base img");
		auto bgGrid = bgFrame->addImage(SDL_Rect{ 12, 18, 206, 214 },
			makeColor(255, 255, 255, 64),
			"*#images/ui/Shop/Shop_ItemSlots_Areas03.png", "shop grid img");

		const char* font = "fonts/pixel_maz_multiline.ttf#16#2";
		Uint32 titleColor = makeColor(219, 157, 20, 255);
		Uint32 titleOutline = makeColor(29, 16, 11, 255);
		auto titleText = bgFrame->addField("shop name", 64);
		titleText->setFont(font);
		titleText->setText("");
		titleText->setHJustify(Field::justify_t::CENTER);
		titleText->setVJustify(Field::justify_t::TOP);
		titleText->setSize(SDL_Rect{ 228, 29, 184, 24 });
		titleText->setTextColor(titleColor);
		titleText->setOutlineColor(titleOutline);

		const char* shoptypefont = "fonts/pixelmix.ttf#16#2";
		auto shopTypeText = bgFrame->addField("shop type", 64);
		shopTypeText->setFont(shoptypefont);
		shopTypeText->setText("");
		shopTypeText->setHJustify(Field::justify_t::CENTER);
		shopTypeText->setVJustify(Field::justify_t::TOP);
		shopTypeText->setSize(SDL_Rect{ 228, 48, 184, 82 });
		shopTypeText->setTextColor(titleColor);
		shopTypeText->setOutlineColor(titleOutline);

		auto shopkeeperImg = bgFrame->addImage(SDL_Rect{ basePos.w - 14 - 80, 14, 80, 80 }, 0xFFFFFFFF,
			"*#images/ui/Shop/shopkeeper.png", "shopkeeper img");

		auto closeBtn = bgFrame->addButton("close shop button");
		SDL_Rect closeBtnPos{ basePos.w - 34, 8, 26, 26 };
		closeBtn->setSize(closeBtnPos);
		closeBtn->setColor(makeColor(255, 255, 255, 255));
		closeBtn->setHighlightColor(makeColor(255, 255, 255, 255));
		closeBtn->setText("X");
		closeBtn->setFont(font);
		closeBtn->setHideGlyphs(true);
		closeBtn->setHideKeyboardGlyphs(true);
		closeBtn->setHideSelectors(true);
		closeBtn->setMenuConfirmControlType(0);
		closeBtn->setBackground("*#images/ui/Shop/Button_X_00.png");
		closeBtn->setBackgroundHighlighted("*#images/ui/Shop/Button_XHigh_00.png");
		closeBtn->setBackgroundActivated("*#images/ui/Shop/Button_XPress_00.png");
		closeBtn->setTextHighlightColor(makeColor(201, 162, 100, 255));
		closeBtn->setCallback([](Button& button) {
			closeShopGUIAction(button.getOwner());
			Player::soundCancel();
		});

		auto discountFrame = bgFrame->addFrame("discount frame");
		discountFrame->setHollow(true);
		discountFrame->setBorder(0);
		discountFrame->setSize(SDL_Rect{ bgFrame->getSize().w - 112, bgFrame->getSize().h - 124, 98, 24 });
		discountFrame->setDisabled(false);

		auto chatWindow = bgFrame->addFrame("chatter");
		auto tl = chatWindow->addImage(SDL_Rect{ 0, 0, 34, 34 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_TLWings00.png", "top left img");
		auto tm = chatWindow->addImage(SDL_Rect{ 0, 0, 2, 6 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_WingsT_00.png", "top img");
		auto tr = chatWindow->addImage(SDL_Rect{ 0, 0, 14, 28 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_TR00.png", "top right img");

		auto ml = chatWindow->addImage(SDL_Rect{ 0, 0, 6, 0 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_WingsL_00.png", "middle left img");
		auto mm1 = chatWindow->addImage(SDL_Rect{ 0, 0, 2, 2 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_CenterColor_00.png", "middle 1 img");
		auto mm2 = chatWindow->addImage(SDL_Rect{ 0, 0, 2, 2 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_CenterColor_00.png", "middle 2 img");
		auto mr = chatWindow->addImage(SDL_Rect{ 0, 0, 6, 0 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_WingsR_00.png", "middle right img");

		auto bl = chatWindow->addImage(SDL_Rect{ 0, 0, 28, 14 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_BL00.png", "bottom left img");
		auto bm = chatWindow->addImage(SDL_Rect{ 0, 0, 2, 6 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_WingsB_00.png", "bottom img");
		auto br = chatWindow->addImage(SDL_Rect{ 0, 0, 14, 14 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_BR00.png", "bottom right img");

		auto pointer = chatWindow->addImage(SDL_Rect{ 0, 0, 20, 22 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Textbox_SpeakerPointer_TR01.png", "pointer img");

		auto bodyFont = "fonts/pixel_maz_multiline.ttf#16#2";
		auto chatText = chatWindow->addField("chat body", 1024);
		chatText->setFont(bodyFont);
		chatText->setText("");
		chatText->setHJustify(Field::justify_t::TOP);
		chatText->setVJustify(Field::justify_t::LEFT);
		chatText->setSize(SDL_Rect{ 0, 0, 0, 0 });
		//chatText->setColor(makeColor(29, 16, 11, 255));
		chatText->setTextColor(makeColor(29, 16, 11, 255));
		chatText->setOutlineColor(makeColor(0, 0, 0, 1));

		{
			auto valueFont = "fonts/pixel_maz.ttf#32#2";

			auto discountLabelText = bgFrame->addField("discount label", 32);
			discountLabelText->setFont(valueFont);
			discountLabelText->setText(Language::get(4122));
			discountLabelText->setHJustify(Field::justify_t::RIGHT);
			discountLabelText->setVJustify(Field::justify_t::TOP);
			discountLabelText->setSize(SDL_Rect{ bgFrame->getSize().w - 106 - 180 - 12, bgFrame->getSize().h - 92 - 30, 180, 24 });
			discountLabelText->setTextColor(makeColor(201, 162, 100, 255));
			discountLabelText->setOutlineColor(makeColor(29, 16, 11, 255));

			auto discountImg = discountFrame->addImage(SDL_Rect{ 0, 0, 98, 24 }, 0xFFFFFFFF,
				"*#images/ui/Shop/Shop_DiscountLabel_00.png", "discount img");

			auto discountValue = discountFrame->addField("discount", 32);
			discountValue->setFont(valueFont);
			discountValue->setText("");
			discountValue->setHJustify(Field::justify_t::RIGHT);
			discountValue->setVJustify(Field::justify_t::TOP);
			discountValue->setSize(SDL_Rect{ 14, 2, 80, 24 });
			discountValue->setColor(makeColor(201, 162, 100, 255));

			auto currentGoldText = bgFrame->addField("current gold", 32);
			currentGoldText->setFont(valueFont);
			currentGoldText->setText("");
			currentGoldText->setHJustify(Field::justify_t::RIGHT);
			currentGoldText->setVJustify(Field::justify_t::TOP);
			currentGoldText->setSize(SDL_Rect{ bgFrame->getSize().w - 80 - 18, bgFrame->getSize().h - 92, 80, 24 });
			currentGoldText->setColor(makeColor(201, 162, 100, 255));

			auto currentGoldLabelText = bgFrame->addField("current gold label", 32);
			currentGoldLabelText->setFont(valueFont);
			currentGoldLabelText->setText(Language::get(4119));
			currentGoldLabelText->setHJustify(Field::justify_t::RIGHT);
			currentGoldLabelText->setVJustify(Field::justify_t::TOP);
			currentGoldLabelText->setSize(SDL_Rect{ bgFrame->getSize().w - 106 - 100 - 12, bgFrame->getSize().h - 92, 100, 24 });
			currentGoldLabelText->setTextColor(makeColor(201, 162, 100, 255));
			currentGoldLabelText->setOutlineColor(makeColor(29, 16, 11, 255));

			auto changeGoldText = bgFrame->addField("change gold", 32);
			changeGoldText->setFont(valueFont);
			changeGoldText->setText("");
			changeGoldText->setHJustify(Field::justify_t::RIGHT);
			changeGoldText->setVJustify(Field::justify_t::TOP);
			changeGoldText->setSize(SDL_Rect{ bgFrame->getSize().w - 80 - 18, bgFrame->getSize().h - 92, 80, 24 });
			changeGoldText->setColor(makeColor(233, 220, 70, 255));
			changeGoldText->setOntop(true);
		}

		{
			auto promptFont = "fonts/pixel_maz.ttf#32#2";
			auto buybackText = bgFrame->addField("buyback txt", 32);
			buybackText->setFont(promptFont);
			buybackText->setText(Language::get(4120));
			buybackText->setHJustify(Field::justify_t::LEFT);
			buybackText->setVJustify(Field::justify_t::TOP);
			buybackText->setSize(SDL_Rect{ bgFrame->getSize().w - 178, bgFrame->getSize().h - 58, 178, 24 });
			buybackText->setTextColor(makeColor(201, 162, 100, 255));
			//buybackText->setOutlineColor(makeColor(29, 16, 11, 255));
			buybackText->setOutlineColor(makeColor(0, 0, 0, 255));

			auto buybackGlyph = bgFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
				"", "buyback glyph");
			buybackGlyph->disabled = true;

			auto buybackBtn = bgFrame->addButton("buyback button");
			buybackBtn->setSize(SDL_Rect{ bgFrame->getSize().w - 208, bgFrame->getSize().h - 50, 194, 26 });
			buybackBtn->setFont(promptFont);
			buybackBtn->setText(Language::get(4120));
			buybackBtn->setColor(makeColor(255, 255, 255, 255));
			buybackBtn->setHighlightColor(makeColor(255, 255, 255, 255));
			buybackBtn->setHideGlyphs(true);
			buybackBtn->setHideKeyboardGlyphs(true);
			buybackBtn->setHideSelectors(true);
			buybackBtn->setMenuConfirmControlType(0);
			buybackBtn->setBackground("*#images/ui/Shop/Shop_Buyback_Button_00.png");
			buybackBtn->setBackgroundHighlighted("*#images/ui/Shop/Shop_Buyback_ButtonHigh_00.png");
			buybackBtn->setBackgroundActivated("*#images/ui/Shop/Shop_Buyback_ButtonPress_00.png");
			buybackBtn->setTextHighlightColor(makeColor(201, 162, 100, 255));
			buybackBtn->setCallback([](Button& button) {
				toggleShopBuybackView(button.getOwner());
				Player::soundActivate();
			});

			auto closeText = bgFrame->addField("close shop prompt", 32);
			closeText->setFont(promptFont);
			closeText->setText(Language::get(4121));
			closeText->setHJustify(Field::justify_t::LEFT);
			closeText->setVJustify(Field::justify_t::TOP);
			closeText->setSize(SDL_Rect{ bgFrame->getSize().w - 178, bgFrame->getSize().h - 36, 178, 24 });
			closeText->setTextColor(makeColor(201, 162, 100, 255));
			//closeText->setOutlineColor(makeColor(29, 16, 11, 255));
			closeText->setOutlineColor(makeColor(0, 0, 0, 255));

			auto closeGlyph = bgFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
				"", "close shop glyph");
			closeGlyph->disabled = true;
			//closeText->setColor(makeColor(233, 220, 70, 255));
		}
	}

	const int inventorySlotSize = players[player]->inventoryUI.getSlotSize();

	shopGUI.shopSlotFrames.clear();

	const int baseSlotOffsetX = 0;
	const int baseSlotOffsetY = 0;

	SDL_Rect invSlotsPos{ 12, 16, 208, 216 };
	{
		const auto shopSlotsFrame = frame->addFrame("shop slots");
		shopSlotsFrame->setSize(invSlotsPos);
		shopSlotsFrame->setHollow(true);

		/*auto gridImg = chestSlotsFrame->addImage(SDL_Rect{ baseSlotOffsetX, baseSlotOffsetY, 162, gridHeight * numGrids },
			makeColor(255, 255, 255, 32), "*#images/ui/Inventory/HUD_Chest4x3_ScrollGrid.png", "grid img");
		gridImg->tiled = true;*/

		SDL_Rect currentSlotPos{ baseSlotOffsetX, baseSlotOffsetY, inventorySlotSize, inventorySlotSize };
		const int maxShopX = Player::ShopGUI_t::MAX_SHOP_X;
		const int maxShopY = Player::ShopGUI_t::MAX_SHOP_Y;

		int accumulateSlotOffsetX = 0;
		for ( int x = 0; x < maxShopX; ++x )
		{
			currentSlotPos.x = baseSlotOffsetX + (x * inventorySlotSize) + accumulateSlotOffsetX;
			for ( int y = 0; y < maxShopY; ++y )
			{
				currentSlotPos.y = baseSlotOffsetY + (y * (inventorySlotSize + 4));

				char slotname[32] = "";
				snprintf(slotname, sizeof(slotname), "shop %d %d", x, y);

				auto slotFrame = shopSlotsFrame->addFrame(slotname);
				shopGUI.shopSlotFrames[x + y * 100] = slotFrame;
				SDL_Rect slotPos{ currentSlotPos.x, currentSlotPos.y, inventorySlotSize, inventorySlotSize };
				slotFrame->setSize(slotPos);

				createPlayerInventorySlotFrameElements(slotFrame);
			}

			if ( x == 0 || x == 3 )
			{
				accumulateSlotOffsetX += 4;
			}
		}
	}

	{
		auto buyTooltipFrame = frame->addFrame("buy tooltip frame");
		buyTooltipFrame->setHollow(true);
		buyTooltipFrame->setBorder(0);
		buyTooltipFrame->setSize(SDL_Rect{ 4, basePos.h - 66, 310, 66 });
		buyTooltipFrame->setDisabled(true);

		auto itemTooltipImg = buyTooltipFrame->addImage(SDL_Rect{ 0, 0, 310, 66 }, 0xFFFFFFFF,
			"*#images/ui/Shop/Shop_Tooltip_2Row_00.png", "tooltip img");

		auto itemGoldImg = buyTooltipFrame->addImage(SDL_Rect{ 0, 0, 20, 28 }, 0xFFFFFFFF,
			"*#images/ui/Inventory/tooltips/HUD_Tooltip_Icon_Money_00.png", "gold img");

		auto itemBgImg = buyTooltipFrame->addImage(SDL_Rect{ 0, 0, 54, 54 }, 0xFFFFFFFF,
			"*images/ui/Shop/Shop_Buy_BGSurround03.png", "item bg img");

		auto orbImg = buyTooltipFrame->addImage(SDL_Rect{ 210 - 8, 38, 16, 16 }, 0xFFFFFFFF,
			"", "orb img");
		orbImg->disabled = true;

		auto slotFrame = buyTooltipFrame->addFrame("item slot frame");
		SDL_Rect slotPos{ 0, 0, players[player]->inventoryUI.getSlotSize(), players[player]->inventoryUI.getSlotSize() };
		slotFrame->setSize(slotPos);
		slotFrame->setDisabled(true);
		createPlayerInventorySlotFrameElements(slotFrame);

		auto itemFont = "fonts/pixel_maz_multiline.ttf#16#2";
		auto itemNameText = buyTooltipFrame->addField("item display name", 1024);
		itemNameText->setFont(itemFont);
		itemNameText->setText("");
		itemNameText->setHJustify(Field::justify_t::LEFT);
		itemNameText->setVJustify(Field::justify_t::TOP);
		itemNameText->setSize(SDL_Rect{ 0, 0, 0, 0 });
		itemNameText->setColor(hudColors.characterSheetLightNeutral);
		auto itemValueText = buyTooltipFrame->addField("item display value", 1024);
		itemValueText->setFont(itemFont);
		itemValueText->setText("");
		itemValueText->setHJustify(Field::justify_t::LEFT);
		itemValueText->setVJustify(Field::justify_t::TOP);
		itemValueText->setSize(SDL_Rect{ 0, 0, 0, 0 });
		itemValueText->setColor(makeColor(201, 162, 100, 255));

		auto buyPromptText = buyTooltipFrame->addField("buy prompt txt", 128);
		buyPromptText->setFont(itemFont);
		buyPromptText->setText("");
		buyPromptText->setHJustify(Field::justify_t::LEFT);
		buyPromptText->setVJustify(Field::justify_t::TOP);
		buyPromptText->setSize(SDL_Rect{ 0, 0, 0, 0 });
		buyPromptText->setColor(makeColor(255, 255, 255, 255));
		auto buyPromptFrame = buyTooltipFrame->addFrame("buy prompt frame");
		buyPromptFrame->setHollow(true);
		buyPromptFrame->setBorder(0);
		buyPromptFrame->setSize(SDL_Rect{ 0, 0, 0, 0 });
		buyPromptFrame->setDisabled(true);
		auto buyPromptGlyph = buyPromptFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
			"", "buy prompt glyph");
	}

	if ( auto buttomEdgeCoverFrame = frame->addFrame("shop bottom edge frame") )
	{
		buttomEdgeCoverFrame->setSize(SDL_Rect{ 0, basePos.h - 10, basePos.w, 10 });
		buttomEdgeCoverFrame->setHollow(true);
		buttomEdgeCoverFrame->setBorder(0);
		auto bottomEdgeCover = buttomEdgeCoverFrame->addImage(SDL_Rect{ 0, 0, basePos.w, 10 },
			makeColor(255, 255, 255, 255),
			"*#images/ui/Shop/Shop_BottomEdgeCover_00.png", "shop bottom edge img");
	}
}

void createPlayerInventory(const int player)
{
	char name[32];
	snprintf(name, sizeof(name), "player inventory %d", player);
	Frame* frame = gameUIFrame[player]->addFrame(name);
	players[player]->inventoryUI.frame = frame;
	frame->setSize(SDL_Rect{ players[player]->camera_virtualx1(),
		players[player]->camera_virtualy1(),
		players[player]->camera_virtualWidth(),
		players[player]->camera_virtualHeight() });
	frame->setHollow(true);
	frame->setBorder(0);
	frame->setOwner(player);
	frame->setInheritParentFrameOpacity(false);

	createChestGUI(player);
	createShopGUI(player);

	SDL_Rect basePos{ 0, 0, 210, 448 };
	{
		auto bgFrame = frame->addFrame("inventory base");
		playerInventoryFrames[player].inventoryBaseImagesFrame = bgFrame;
		bgFrame->setSize(basePos);
		bgFrame->setHollow(true);
		const auto bgSize = bgFrame->getSize();
		auto defaultInvImg = bgFrame->addImage(SDL_Rect{ 0, 0, bgSize.w, 448 },
			makeColor( 255, 255, 255, 255),
			"*#images/ui/Inventory/HUD_Inventory_Base_02.png", "inventory base img");
		defaultInvImg->disabled = true;
		playerInventoryFrames[player].defaultInvImg = defaultInvImg;

		auto compactBase = bgFrame->addImage(SDL_Rect{ 0, 0, 210, 250 },
			makeColor( 255, 255, 255, 255),
			"*#images/ui/Inventory/HUD_Inventory_BaseCompact_02.png", "inventory base compact img");
		compactBase->disabled = true;
		playerInventoryFrames[player].compactInvImg = compactBase;

		auto compactCharacterView = bgFrame->addImage(SDL_Rect{ 0, 0, 210, 214 },
			makeColor( 255, 255, 255, 255),
			"*#images/ui/Inventory/HUD_Inventory_CharacterCompact_02.png", "inventory character compact img");
		compactCharacterView->disabled = true;
		playerInventoryFrames[player].compactCharImg = compactCharacterView;
	}

	{
		auto backpackFrame = frame->addFrame("inventory backpack");
		playerInventoryFrames[player].backpackFrame = backpackFrame;
		backpackFrame->setSize(SDL_Rect{ 0, 202 + 242 - 2, 226, 102 });
		auto backpackImg = backpackFrame->addImage(SDL_Rect{ 0, 0, 226, 102 },
			makeColor( 255, 255, 255, 255),
			"*#images/ui/Inventory/HUD_Inventory_Base_Bag_00a.png", "inventory backpack img");
	}

	const int inventorySlotSize = players[player]->inventoryUI.getSlotSize();

	players[player]->inventoryUI.slotFrames.clear();

	const int baseSlotOffsetX = 4;
	const int baseSlotOffsetY = 0;
	SDL_Rect invSlotsPos{ 0, 202, basePos.w, 242 };
	{
		const auto invSlotsFrame = frame->addFrame("inventory slots");
		playerInventoryFrames[player].invSlotsFrame = invSlotsFrame;
		invSlotsFrame->setSize(invSlotsPos);

		SDL_Rect currentSlotPos{ baseSlotOffsetX, baseSlotOffsetY, inventorySlotSize, inventorySlotSize };

		for ( int x = 0; x < players[player]->inventoryUI.getSizeX(); ++x )
		{
			currentSlotPos.x = baseSlotOffsetX + (x * inventorySlotSize);
			for ( int y = 0; y < players[player]->inventoryUI.DEFAULT_INVENTORY_SIZEY; ++y )
			{
				currentSlotPos.y = baseSlotOffsetY + (y * inventorySlotSize);

				char slotname[32] = "";
				snprintf(slotname, sizeof(slotname), "slot %d %d", x, y);

				auto slotFrame = invSlotsFrame->addFrame(slotname);
				players[player]->inventoryUI.slotFrames[x + y * 100] = slotFrame;
				SDL_Rect slotPos{ currentSlotPos.x, currentSlotPos.y, inventorySlotSize, inventorySlotSize };
				slotFrame->setSize(slotPos);
				//slotFrame->setDisabled(true);

				createPlayerInventorySlotFrameElements(slotFrame);
			}
		}
		//invSlotsFrame->setBlitChildren(true);
	}

	SDL_Rect backpackSlotsPos{ 0, 202 + 242, basePos.w, 242 };
	{
		const auto backPackSlotsFrame = frame->addFrame("backpack slots");
		playerInventoryFrames[player].backpackSlotsFrame = backPackSlotsFrame;
		backPackSlotsFrame->setSize(backpackSlotsPos);
		const int backpackBaseSlotOffsetY = 8;
		int lowestY = 0;

		SDL_Rect currentSlotPos{ baseSlotOffsetX, backpackBaseSlotOffsetY, inventorySlotSize, inventorySlotSize };

		for ( int x = 0; x < players[player]->inventoryUI.getSizeX(); ++x )
		{
			currentSlotPos.x = baseSlotOffsetX + (x * inventorySlotSize);
			if ( x == 0 ) { currentSlotPos.x -= 4; } // backpack has unique first/last column entries
			if ( x == players[player]->inventoryUI.getSizeX() - 1 ) { currentSlotPos.x += 4; }

			for ( int y = players[player]->inventoryUI.DEFAULT_INVENTORY_SIZEY;
				y < players[player]->inventoryUI.DEFAULT_INVENTORY_SIZEY + players[player]->inventoryUI.getPlayerBackpackBonusSizeY(); ++y )
			{
				currentSlotPos.y = backpackBaseSlotOffsetY + ((y - players[player]->inventoryUI.DEFAULT_INVENTORY_SIZEY) * inventorySlotSize);

				char slotname[32] = "";
				snprintf(slotname, sizeof(slotname), "slot %d %d", x, y);

				auto slotFrame = backPackSlotsFrame->addFrame(slotname);
				players[player]->inventoryUI.slotFrames[x + y * 100] = slotFrame;
				SDL_Rect slotPos{ currentSlotPos.x, currentSlotPos.y, inventorySlotSize, inventorySlotSize };
				slotFrame->setSize(slotPos);
				lowestY = std::max(slotPos.y + slotPos.h, lowestY);
				//slotFrame->setDisabled(true);

				createPlayerInventorySlotFrameElements(slotFrame);
			}
		}
		backpackSlotsPos.h = lowestY;
		backPackSlotsFrame->setSize(backpackSlotsPos);
	}

	{
		SDL_Rect dollSlotsPos{ 0, 0, basePos.w, invSlotsPos.y };
		const auto dollSlotsFrame = frame->addFrame("paperdoll slots");
		playerInventoryFrames[player].dollSlotsFrame = dollSlotsFrame;
		dollSlotsFrame->setSize(dollSlotsPos);

		SDL_Rect currentSlotPos{ baseSlotOffsetX, baseSlotOffsetY, inventorySlotSize, inventorySlotSize };

		for ( int x = Player::Inventory_t::PaperDollColumns::DOLL_COLUMN_LEFT; x <= Player::Inventory_t::PaperDollColumns::DOLL_COLUMN_RIGHT; ++x )
		{
			currentSlotPos.x = baseSlotOffsetX;
			if ( x == Player::Inventory_t::PaperDollColumns::DOLL_COLUMN_RIGHT )
			{
				currentSlotPos.x = baseSlotOffsetX + (4 * inventorySlotSize); // 4 slots over
			}

			for ( int y = Player::Inventory_t::PaperDollRows::DOLL_ROW_1; y <= Player::Inventory_t::PaperDollRows::DOLL_ROW_5; ++y )
			{
				currentSlotPos.y = baseSlotOffsetY + ((y - Player::Inventory_t::PaperDollRows::DOLL_ROW_1) * inventorySlotSize);

				char slotname[32] = "";
				snprintf(slotname, sizeof(slotname), "slot %d %d", x, y);

				auto slotFrame = dollSlotsFrame->addFrame(slotname);
				players[player]->inventoryUI.slotFrames[x + y * 100] = slotFrame;
				SDL_Rect slotPos{ currentSlotPos.x, currentSlotPos.y, inventorySlotSize, inventorySlotSize };
				slotFrame->setSize(slotPos);
				//slotFrame->setDisabled(true);

				createPlayerInventorySlotFrameElements(slotFrame);
			}
		}

		{
			auto charFrame = frame->addFrame("inventory character preview");
			playerInventoryFrames[player].characterPreview = charFrame;
			auto charSize = dollSlotsPos;
			charSize.x += inventorySlotSize + baseSlotOffsetX + 4;
			charSize.w -= 2 * (inventorySlotSize + baseSlotOffsetX + 4);
			charFrame->setSize(charSize);
			charFrame->setTickCallback([](Widget& widget) {
				Frame* frame = static_cast<Frame*>(&widget);
				int player = widget.getOwner();
				auto& scrollInertia = players[player]->paperDoll.portraitRotationInertia;
				auto& scrollPercent = players[player]->paperDoll.portraitRotationPercent;
				auto& portraitYaw = players[player]->paperDoll.portraitYaw;
				static ConsoleVariable<float> cvar_char_portrait_spd("/char_portrait_spd", 15.0);
				static ConsoleVariable<float> cvar_char_portrait_decel("/char_portrait_decel", 25.0);

				bool close = false;
				if ( players[player]->GUI.activeModule == Player::GUI_t::MODULE_PORTRAIT )
				{
					SDL_Rect size = frame->getAbsoluteSize();

					// make sure to adjust absolute size to camera viewport
					const int offsetX = 4;
					const int offsetY = 6;
					size.x += offsetX;
					size.y += offsetY;
					size.w -= offsetX * 2;
					size.h -= offsetY * 2;
					size.x -= players[player]->camera_virtualx1();
					size.y -= players[player]->camera_virtualy1();

					players[player]->hud.updateCursorAnimation(size.x - 1, size.y - 1,
						size.w, size.h, inputs.getVirtualMouse(player)->draw_cursor);
					players[player]->paperDoll.portraitActiveToEdit = true;

					if ( inputs.bPlayerUsingKeyboardControl(player) )
					{
						if ( Input::inputs[player].binaryToggle("InventoryCharacterRotateLeftMouse") )
						{
							scrollInertia = std::min(scrollInertia + .05 / *cvar_char_portrait_spd, .05);
						}
						if ( Input::inputs[player].binaryToggle("InventoryCharacterRotateRightMouse") )
						{
							scrollInertia = std::max(scrollInertia - .05 / *cvar_char_portrait_spd, -.05);
						}
						close |= Input::inputs[player].consumeBinaryToggle("MenuLeftClick");
						close |= Input::inputs[player].consumeBinaryToggle("MenuRightClick");
					}
					if ( inputs.hasController(player) )
					{
						close |= Input::inputs[player].consumeBinaryToggle("MenuConfirm");
						close |= Input::inputs[player].consumeBinaryToggle("MenuCancel");
					}
					if ( close )
					{
						Player::soundCancel();
					}

					if ( players[player]->shootmode )
					{
						close = true;
					}

					if ( Input::inputs[player].analog("InventoryCharacterRotateRight") )
					{
						scrollInertia = 0.0;
						real_t delta = Input::inputs[player].analog("InventoryCharacterRotateRight");
						scrollPercent = (scrollPercent + .05 * (getFPSScale(60.0)) * delta);
						while ( scrollPercent >= 1.0 )
						{
							scrollPercent -= 1.0;
						}
					}
					else if ( Input::inputs[player].analog("InventoryCharacterRotateLeft") )
					{
						scrollInertia = 0.0;
						real_t delta = Input::inputs[player].analog("InventoryCharacterRotateLeft");
						scrollPercent = scrollPercent - .05 * (getFPSScale(60.0)) * delta;
						while ( scrollPercent < 0.0 )
						{
							scrollPercent += 1.0;
						}
					}

					if ( abs(scrollInertia) > 0.0 )
					{
						scrollInertia *= .9;
						if ( abs(scrollInertia) < (.01 / *cvar_char_portrait_decel) )
						{
							scrollInertia = 0.0;
						}
						scrollPercent += scrollInertia;
					}

					if ( Input::inputs[player].consumeBinaryToggle("ResetPortraitRotation") )
					{
						Input::inputs[player].consumeBindingsSharedWithBinding("ResetPortraitRotation");
						scrollPercent = 0.0;
						scrollInertia = 0.0;
						portraitYaw = (330) * PI / 180;
						close = true;
						Player::soundCancel();
					}
				}

				if ( close )
				{
					if ( !inputs.getVirtualMouse(player)->draw_cursor )
					{
						players[player]->GUI.returnToPreviousActiveModule();
					}
					else
					{
						players[player]->GUI.activateModule(Player::GUI_t::MODULE_NONE);
					}
				}
				if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_PORTRAIT )
				{
					players[player]->paperDoll.portraitActiveToEdit = false;
				}
				portraitYaw = (330) * PI / 180 + (scrollPercent * 2 * PI);
				if ( portraitYaw > 2 * PI )
				{
					portraitYaw -= 2 * PI;
				}
				if ( portraitYaw < 0.0 )
				{
					portraitYaw += 2 * PI;
				}
				});
			charFrame->setDrawCallback([](const Widget& widget, SDL_Rect pos) {
				drawCharacterPreview(widget.getOwner(), pos, 50, players[widget.getOwner()]->paperDoll.portraitYaw);
			});

			/*charFrame->addImage(SDL_Rect{ 0, 0, charSize.w, charSize.h },
				makeColor( 255, 255, 255, 255),
				"images/system/white.png", "inventory character preview bg");*/
		}
	}

	createPlayerSpellList(player);

	{
		auto selectedFrame = frame->addFrame("inventory selected item");
		playerInventoryFrames[player].selectedSlotFrame = selectedFrame;
		selectedFrame->setSize(SDL_Rect{ 0, 0, inventorySlotSize, inventorySlotSize });
		selectedFrame->setDisabled(true);

		Uint32 color = makeColor( 255, 255, 0, 255);
		selectedFrame->addImage(SDL_Rect{ 0, 0, selectedFrame->getSize().w, selectedFrame->getSize().h },
			color, "*images/system/hotbar_slot.png", "inventory selected highlight");

		auto oldSelectedFrame = frame->addFrame("inventory old selected item");
		oldSelectedFrame->setSize(SDL_Rect{ 0, 0, inventorySlotSize, inventorySlotSize });
		oldSelectedFrame->setDisabled(true);
		playerInventoryFrames[player].oldSelectedSlotFrame = oldSelectedFrame;

		const int itemSpriteSize = players[player]->inventoryUI.getItemSpriteSize();
		SDL_Rect itemSpriteBorder{ 2, 2, itemSpriteSize, itemSpriteSize };

		color = makeColor( 0, 255, 255, 255);
		auto oldImg = oldSelectedFrame->addImage(itemSpriteBorder,
			makeColor( 255, 255, 255, 128), "", "inventory old selected item");
		playerInventoryFrames[player].oldSelectedSlotItemImg = oldImg;
		oldImg->disabled = true;
		oldSelectedFrame->addImage(SDL_Rect{ 0, 0, oldSelectedFrame->getSize().w, oldSelectedFrame->getSize().h },
			color, "*images/system/hotbar_slot.png", "inventory old selected highlight");

		auto bgFrame = frame->findFrame("inventory base");
		playerInventoryFrames[player].inventoryBgFrame = bgFrame;
		auto flourishFrame = frame->addFrame("inventory base flourish");
		playerInventoryFrames[player].flourishFrame = flourishFrame;
		const int flourishW = 126;
		const int flourishH = 26;
		flourishFrame->setHollow(true);
		flourishFrame->setSize(SDL_Rect{ (bgFrame->getSize().w / 2) - (flourishW / 2), 202 - flourishH + 6, flourishW, flourishH });
		auto flourishImg = flourishFrame->addImage(SDL_Rect{ 0, 0, flourishFrame->getSize().w, flourishFrame->getSize().h },
			makeColor( 255, 255, 255, 255),
			"*#images/ui/Inventory/HUD_Inventory_Flourish_00.png", "inventory flourish img");
		//flourishImg->disabled = true;

		{
			SDL_Rect charSize = playerInventoryFrames[player].characterPreview->getSize();
			auto autosortFrame = frame->addFrame("autosort frame");
			playerInventoryFrames[player].autosortFrame = autosortFrame;
			autosortFrame->setHollow(true);
			autosortFrame->setSize(charSize);
			auto autosortButton = autosortFrame->addButton("autosort button");
			autosortButton->setSize(SDL_Rect{ charSize.w - 26,
				charSize.h - 26 - 16, 26, 26 });
			autosortButton->setBackground("*#images/ui/Inventory/HUD_Button_AutosortUnselect.png");
			autosortButton->setBackgroundActivated("*#images/ui/Inventory/HUD_Button_AutosortPress.png");
			autosortButton->setBackgroundHighlighted("*#images/ui/Inventory/HUD_Button_AutosortSelect.png");
			autosortButton->setHideGlyphs(true);
			autosortButton->setHideKeyboardGlyphs(true);
			autosortButton->setHideSelectors(true);
			autosortButton->setMenuConfirmControlType(0);
			//autosortButton->setOntop(true);
			autosortButton->setColor(makeColor(255, 255, 255, 255));
			autosortButton->setHighlightColor(makeColor(255, 255, 255, 255));
			autosortButton->setCallback([](Button& button) {
				autosortInventory(button.getOwner());
				//playSound(139, 64);
				Player::soundActivate();
			});
			autosortButton->setTickCallback([](Widget& widget) {
				if ( widget.isSelected()
					&& (players[widget.getOwner()]->GUI.activeModule != Player::GUI_t::MODULE_INVENTORY
						|| players[widget.getOwner()]->shootmode
						|| !inputs.getVirtualMouse(widget.getOwner())->draw_cursor) )
				{
					widget.deselect();
				}
			});
			auto autosortImg = autosortFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "autosort glyph");
			autosortImg->disabled = true;
			autosortImg->ontop = true;
		}

		GenericGUI[player].tinkerGUI.tinkerFrame = frame->addFrame("tinker");
		GenericGUI[player].tinkerGUI.tinkerFrame->setHollow(true);
		GenericGUI[player].tinkerGUI.tinkerFrame->setBorder(0);
		GenericGUI[player].tinkerGUI.tinkerFrame->setOwner(player);
		GenericGUI[player].tinkerGUI.tinkerFrame->setInheritParentFrameOpacity(false);
		GenericGUI[player].tinkerGUI.tinkerFrame->setDisabled(true);

		GenericGUI[player].alchemyGUI.alchFrame = frame->addFrame("alchemy");
		GenericGUI[player].alchemyGUI.alchFrame->setHollow(true);
		GenericGUI[player].alchemyGUI.alchFrame->setBorder(0);
		GenericGUI[player].alchemyGUI.alchFrame->setOwner(player);
		GenericGUI[player].alchemyGUI.alchFrame->setInheritParentFrameOpacity(false);
		GenericGUI[player].alchemyGUI.alchFrame->setDisabled(true);

		GenericGUI[player].featherGUI.featherFrame = frame->addFrame("feather");
		GenericGUI[player].featherGUI.featherFrame->setHollow(true);
		GenericGUI[player].featherGUI.featherFrame->setBorder(0);
		GenericGUI[player].featherGUI.featherFrame->setOwner(player);
		GenericGUI[player].featherGUI.featherFrame->setInheritParentFrameOpacity(false);
		GenericGUI[player].featherGUI.featherFrame->setDisabled(true);

		GenericGUI[player].itemfxGUI.itemEffectFrame = frame->addFrame("itemfx");
		GenericGUI[player].itemfxGUI.itemEffectFrame->setHollow(true);
		GenericGUI[player].itemfxGUI.itemEffectFrame->setBorder(0);
		GenericGUI[player].itemfxGUI.itemEffectFrame->setOwner(player);
		GenericGUI[player].itemfxGUI.itemEffectFrame->setInheritParentFrameOpacity(false);
		GenericGUI[player].itemfxGUI.itemEffectFrame->setDisabled(true);

		auto oldCursorFrame = frame->addFrame("inventory old item cursor");
		oldCursorFrame->setSize(SDL_Rect{ 0, 0, inventorySlotSize + 16, inventorySlotSize + 16 });
		oldCursorFrame->setDisabled(true);
		oldCursorFrame->setHollow(true);
		color = makeColor( 255, 255, 255, oldSelectedCursorOpacity);
		oldCursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/SelectorGrey_TL.png", "inventory old cursor topleft");
		oldCursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/SelectorGrey_TR.png", "inventory old cursor topright");
		oldCursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/SelectorGrey_BL.png", "inventory old cursor bottomleft");
		oldCursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/SelectorGrey_BR.png", "inventory old cursor bottomright");

		auto cursorFrame = frame->addFrame("inventory selected item cursor");
		players[player]->inventoryUI.selectedItemCursorFrame = cursorFrame;
		cursorFrame->setSize(SDL_Rect{ 0, 0, inventorySlotSize + 16, inventorySlotSize + 16 });
		cursorFrame->setDisabled(true);
		cursorFrame->setHollow(true);
		color = makeColor( 255, 255, 255, selectedCursorOpacity);
		cursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_TL.png", "inventory selected cursor topleft");
		cursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_TR.png", "inventory selected cursor topright");
		cursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_BL.png", "inventory selected cursor bottomleft");
		cursorFrame->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_BR.png", "inventory selected cursor bottomright");
	}

	{
		auto draggingInventoryItem = frame->addFrame("dragging inventory item");
		draggingInventoryItem->setSize(SDL_Rect{ 0, 0, inventorySlotSize, inventorySlotSize });
		draggingInventoryItem->setDisabled(true);
		createPlayerInventorySlotFrameElements(draggingInventoryItem);
	}

	{
		// unused for now, only animating cycling items
		auto draggingInventoryItemOld = frame->addFrame("dragging inventory item old");
		const int itemSpriteSize = players[player]->inventoryUI.getItemSpriteSize();
		SDL_Rect draggingInventoryItemPos{ 2, 2, inventorySlotSize - 2, inventorySlotSize - 2 };
		const int alignOffset = (draggingInventoryItemPos.w - itemSpriteSize) / 2; // align the item sprite within the box by this offset to center
		draggingInventoryItemPos.x += alignOffset;
		draggingInventoryItemPos.y += alignOffset;
		draggingInventoryItemPos.w = itemSpriteSize;
		draggingInventoryItemPos.h = itemSpriteSize;
		draggingInventoryItemOld->setSize(draggingInventoryItemPos);
		draggingInventoryItemOld->setDisabled(true);
		
		SDL_Rect imgPos{ 0, 0, draggingInventoryItemOld->getSize().w, draggingInventoryItemOld->getSize().h };
		auto itemSprite = draggingInventoryItemOld->addImage(imgPos, 0xFFFFFFFF, "", "item sprite img");
	}
}

void Player::Inventory_t::updateSelectedSlotAnimation(int destx, int desty, int width, int height, bool usingMouse)
{
	if ( frame )
	{
		if ( selectedItemCursorFrame )
		{
			if ( usingMouse )
			{
				selectedItemCursorFrame->setSize(
					SDL_Rect{
					destx - cursor.cursorToSlotOffset,
					desty - cursor.cursorToSlotOffset,
					width + 2 * (cursor.cursorToSlotOffset + 1),
					height + 2 * (cursor.cursorToSlotOffset + 1)
				}
				);
				cursor.animateSetpointX = destx;
				cursor.animateSetpointY = desty;
				cursor.animateStartX = destx;
				cursor.animateStartY = desty;
			}
			else if ( cursor.animateSetpointX != destx || cursor.animateSetpointY != desty )
			{
				SDL_Rect size = selectedItemCursorFrame->getSize();
				cursor.animateStartX = size.x;
				cursor.animateStartY = size.y;
				size.w = width + 2 * (cursor.cursorToSlotOffset + 1);
				size.h = height + 2 * (cursor.cursorToSlotOffset + 1);
				selectedItemCursorFrame->setSize(size);
				cursor.animateSetpointX = destx;
				cursor.animateSetpointY = desty;
				cursor.animateX = 0.0;
				cursor.animateY = 0.0;
				cursor.lastUpdateTick = ticks;
			}
		}
	}
	//messagePlayer(player.playernum, "%d %d", destx, desty);
}

void Player::Inventory_t::updateItemContextMenu()
{
	Uint32& itemMenuItem = inputs.getUIInteraction(player.playernum)->itemMenuItem;
	bool& itemMenuOpen = inputs.getUIInteraction(player.playernum)->itemMenuOpen;
	int& itemMenuSelected = inputs.getUIInteraction(player.playernum)->itemMenuSelected;
	bool& itemMenuFromHotbar = inputs.getUIInteraction(player.playernum)->itemMenuFromHotbar;

	Item* item = uidToItem(itemMenuItem);
	if ( itemMenuItem != 0 && !item )
	{
		if ( chestGUI.bOpen && openedChest[player.playernum] )
		{
			list_t* chest_inventory = nullptr;
			if ( multiplayer == CLIENT )
			{
				chest_inventory = &chestInv[player.playernum];
			}
			else if ( openedChest[player.playernum]->children.first && openedChest[player.playernum]->children.first->element )
			{
				chest_inventory = (list_t*)openedChest[player.playernum]->children.first->element;
			}
			if ( chest_inventory )
			{
				node_t* nextnode = nullptr;
				for ( node_t* node = chest_inventory->first; node != NULL; node = nextnode )
				{
					nextnode = node->next;
					Item* chestItem = (Item*)node->element;
					if ( !chestItem ) { continue; }
					if ( chestItem->uid == itemMenuItem )
					{
						item = chestItem;
						break;
					}
				}
			}
		}
	}

	if ( !interactFrame )
	{
		itemMenuOpen = false;
		return;
	}


	if ( !item || !itemMenuOpen )
	{
		itemMenuOpen = false;
		itemMenuSelected = 0;
		itemMenuFromHotbar = false;
		interactFrame->setDisabled(true);
		return;
	}

	bool& toggleclick = inputs.getUIInteraction(player.playernum)->toggleclick;
	int& itemMenuX = inputs.getUIInteraction(player.playernum)->itemMenuX;
	int& itemMenuY = inputs.getUIInteraction(player.playernum)->itemMenuY;
	int& itemMenuOffsetDetectionY = inputs.getUIInteraction(player.playernum)->itemMenuOffsetDetectionY;
	itemMenuOffsetDetectionY = 0;
	const Sint32 mousex = (inputs.getMouse(player.playernum, Inputs::X) / (float)xres) * (float)Frame::virtualScreenX;
	const Sint32 mousey = (inputs.getMouse(player.playernum, Inputs::Y) / (float)yres) * (float)Frame::virtualScreenY;

	auto highlightImageMid = interactFrame->findImage("interact selected highlight mid");
	highlightImageMid->disabled = true;
	highlightImageMid->color = hudColors.itemContextMenuOptionSelectedImg;
	auto highlightImageLeft = interactFrame->findImage("interact selected highlight left");
	highlightImageLeft->disabled = true;
	highlightImageLeft->color = hudColors.itemContextMenuOptionSelectedImg;
	auto highlightImageRight = interactFrame->findImage("interact selected highlight right");
	highlightImageRight->disabled = true;
	highlightImageRight->color = hudColors.itemContextMenuOptionSelectedImg;

	interactFrame->setDisabled(false);

	auto options = getContextMenuOptionsForItem(player.playernum, item);
	if ( itemMenuFromHotbar )
	{
		options.push_back(PROMPT_CLEAR_HOTBAR_SLOT);
		std::reverse(options.begin(), options.end());
		if ( itemCategory(item) == SPELLBOOK )
		{
			for ( auto& it : options )
			{
				if ( it == PROMPT_INTERACT )
				{
					it = PROMPT_INTERACT_SPELLBOOK_HOTBAR;
				}
			}
		}
	}
	std::vector<std::pair<Frame::image_t*, Field*>> optionFrames;
	auto glyph1 = interactFrame->findImage("glyph 1");
	auto option1 = interactFrame->findField("interact option 1");
	auto glyph2 = interactFrame->findImage("glyph 2");
	auto option2 = interactFrame->findField("interact option 2");
	auto glyph3 = interactFrame->findImage("glyph 3");
	auto option3 = interactFrame->findField("interact option 3");
	auto glyph4 = interactFrame->findImage("glyph 4");
	auto option4 = interactFrame->findField("interact option 4");
	auto glyph5 = interactFrame->findImage("glyph 5");
	auto option5 = interactFrame->findField("interact option 5");
	if ( glyph1 && option1 )
	{
		optionFrames.push_back(std::make_pair(glyph1, option1));
	}
	if ( glyph2 && option2 )
	{
		optionFrames.push_back(std::make_pair(glyph2, option2));
	}
	if ( glyph3 && option3 )
	{
		optionFrames.push_back(std::make_pair(glyph3, option3));
	}
	if ( glyph4 && option4 )
	{
		optionFrames.push_back(std::make_pair(glyph4, option4));
	}
	if ( glyph5 && option5 )
	{
		optionFrames.push_back(std::make_pair(glyph5, option5));
	}

	size_t index = 0;
	unsigned int maxWidth = 0;
	if ( auto interactText = interactFrame->findField("interact text") )
	{
		interactText->setColor(hudColors.itemContextMenuHeadingText);
		if ( auto textGet = Text::get(interactText->getText(), interactText->getFont(),
			makeColor(255, 255, 255, 255), makeColor(0, 0, 0, 255)) )
		{
			maxWidth = textGet->getWidth();
		}
	}
	int maxHeight = 0;
	const int textPaddingX = 8;

	for ( auto& optionPair : optionFrames )
	{
		auto& img = optionPair.first;
		auto& txt = optionPair.second;
		txt->setColor(hudColors.itemContextMenuOptionText);
		if ( index >= options.size() )
		{
			txt->setDisabled(true);
			img->disabled = true;
			continue;
		}

		txt->setDisabled(false);
		img->disabled = true;
		auto promptType = options[index];
		
		// in-case we want controller support here.
		/*switch ( promptType ) 
		{
			case PROMPT_EQUIP:
			case PROMPT_UNEQUIP:
			case PROMPT_SPELL_EQUIP:
				img->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuAlt1");
				break;
			case PROMPT_APPRAISE:
				img->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuAlt2");
				break;
			case PROMPT_DROP:
				img->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuCancel");
				break;
			default:
				img->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuConfirm");
				break;
		}

		if ( img->path == "" )
		{
			img->disabled = true;
		}*/

		txt->setText(getContextMenuLangEntry(player.playernum, promptType, *item));
		if ( auto textGet = Text::get(txt->getText(), txt->getFont(),
			makeColor(255, 255, 255, 255), makeColor(0, 0, 0, 255)) )
		{
			maxWidth = std::max(textGet->getWidth(), maxWidth);
			
			SDL_Rect size = txt->getSize();
			size.w = textGet->getWidth();
			if ( img->disabled )
			{
				size.x = textPaddingX;
				txt->setHJustify(Field::justify_t::CENTER);
			}
			else
			{
				size.x = img->pos.x + img->pos.w + textPaddingX;
				txt->setHJustify(Field::justify_t::LEFT);
			}
			txt->setSize(size);
		}
		
		maxHeight = std::max(img->pos.y + img->pos.h, maxHeight);
		++index;
	}

	//maxWidth += 16; -- edit this to add extra left/right padding

	const int rightClickProtectBuffer = (right_click_protect ? 0 : 10);

	bool alignRight = true;
	if ( itemMenuFromHotbar )
	{
		alignRight = true;
	}
	else if ( bCompactView )
	{
		if ( player.paperDoll.isItemOnDoll(*item) )
		{
			if ( paperDollPanelJustify == PanelJustify_t::PANEL_JUSTIFY_RIGHT )
			{
				alignRight = false;
			}
			else
			{
				alignRight = true;
			}
		}
		else if ( itemCategory(item) == SPELL_CAT )
		{
			if ( spellPanel.panelJustify == PanelJustify_t::PANEL_JUSTIFY_RIGHT )
			{
				alignRight = false;
			}
			else
			{
				alignRight = true;
			}
		}
		else if ( isItemFromChest(item) )
		{
			if ( inventoryPanelJustify == PanelJustify_t::PANEL_JUSTIFY_RIGHT )
			{
				alignRight = true;
			}
			else
			{
				alignRight = false;
			}
		}
		else
		{
			// normal inventory items
			if ( inventoryPanelJustify == PanelJustify_t::PANEL_JUSTIFY_RIGHT )
			{
				alignRight = false;
			}
			else
			{
				alignRight = true;
			}
		}
	}

	const int textStartX = (glyph1->disabled ? 0 : glyph1->pos.x + glyph1->pos.w) + textPaddingX;
	const int frameWidth = maxWidth + textStartX + textPaddingX;

	SDL_Rect frameSize = interactFrame->getSize();
	frameSize.x = itemMenuX;
	frameSize.y = itemMenuY;

	// position the frame elements
	int interimHeight = 0;
	{
		auto tl = interactFrame->findImage("interact top left");
		auto tmid = interactFrame->findImage("interact top background");
		tmid->pos.w = frameWidth - tl->pos.w * 2;
		auto tr = interactFrame->findImage("interact top right");
		tr->pos.x = tmid->pos.x + tmid->pos.w;

		interimHeight = tmid->pos.y + tmid->pos.h;
		frameSize.w = tr->pos.x + tr->pos.w;
	}
	{
		const int middleOffsetY = 13;
		auto ml = interactFrame->findImage("interact middle left");
		ml->pos.h = maxHeight - interimHeight - middleOffsetY;
		auto mmid = interactFrame->findImage("interact middle background");
		mmid->pos.h = ml->pos.h;
		mmid->pos.w = frameWidth - (ml->pos.w) * 2;
		mmid->color = hudColors.itemContextMenuOptionImg;
		auto mr = interactFrame->findImage("interact middle right");
		mr->pos.h = ml->pos.h;
		mr->pos.x = mmid->pos.x + mmid->pos.w;

		interimHeight = mmid->pos.y + mmid->pos.h;
	}
	{
		auto bl = interactFrame->findImage("interact bottom left");
		bl->pos.y = interimHeight;
		auto bmid = interactFrame->findImage("interact bottom background");
		bmid->pos.y = interimHeight;
		bmid->pos.w = frameWidth - bl->pos.w * 2;
		auto br = interactFrame->findImage("interact bottom right");
		br->pos.y = interimHeight;
		br->pos.x = bmid->pos.x + bmid->pos.w;

		frameSize.h = br->pos.y + br->pos.h;
	}
	
	if ( auto interactText = interactFrame->findField("interact text") )
	{
		SDL_Rect size = interactText->getSize();
		size.x = 0;
		size.w = frameSize.w;
		interactText->setSize(size);
	}

	if ( !alignRight )
	{
		frameSize.x -= frameSize.w;
	}

	if ( (frameSize.y + frameSize.h) > player.camera_virtualy2() )
	{
		int yoffset = (frameSize.y + frameSize.h) - player.camera_virtualy2();
		frameSize.y -= yoffset;
		itemMenuOffsetDetectionY = yoffset;
	}
	interactFrame->setSize(frameSize);

	index = 0;
	for ( auto& optionPair : optionFrames )
	{
		auto& img = optionPair.first;
		auto& txt = optionPair.second;

		if ( txt->getHJustify() == Field::justify_t::CENTER )
		{
			SDL_Rect size = txt->getSize();
			size.w = maxWidth;
			txt->setSize(size);
		}

		if ( index < options.size() )
		{
			auto ml = interactFrame->findImage("interact middle left");
			SDL_Rect absoluteSize = txt->getAbsoluteSize();
			absoluteSize.x -= (4 + ml->pos.w) + (alignRight ? rightClickProtectBuffer : 0);
			absoluteSize.w += ((4 + ml->pos.w) * 2 + rightClickProtectBuffer);
			absoluteSize.y += 4;
			absoluteSize.h -= 4;
			absoluteSize.y += itemMenuOffsetDetectionY;
			if ( mousex >= absoluteSize.x && mousex < absoluteSize.x + absoluteSize.w
				&& mousey >= absoluteSize.y && mousey < absoluteSize.y + absoluteSize.h )
			{
				itemMenuSelected = index;
			}
		}
		++index;
	}

	SDL_Rect absoluteSize = interactFrame->getAbsoluteSize();
	// right click protect uses exact border, else there is 10 px buffer
	absoluteSize.x -= (alignRight ? rightClickProtectBuffer : 0);
	absoluteSize.w += rightClickProtectBuffer;
	absoluteSize.y += itemMenuOffsetDetectionY;
	if ( !(mousex >= absoluteSize.x && mousex < absoluteSize.x + absoluteSize.w
		&& mousey >= absoluteSize.y && mousey < absoluteSize.y + absoluteSize.h) )
	{
		itemMenuSelected = -1;
	}

	if ( itemMenuSelected >= 0 && itemMenuSelected < options.size() )
	{
		auto& txt = optionFrames[itemMenuSelected].second;
		txt->setColor(hudColors.itemContextMenuOptionSelectedText);
		SDL_Rect size = txt->getSize();
		size.x -= 4;
		size.w += 2 * 4;
		size.y += 3;
		highlightImageMid->pos = size;
		highlightImageMid->pos.x += highlightImageLeft->pos.w;
		highlightImageMid->pos.w -= 2 * highlightImageLeft->pos.w;
		highlightImageMid->pos.h = highlightImageLeft->pos.h;
		highlightImageMid->disabled = false;

		highlightImageLeft->pos.x = highlightImageMid->pos.x - highlightImageLeft->pos.w;
		highlightImageLeft->pos.y = highlightImageMid->pos.y;
		highlightImageLeft->disabled = false;
		highlightImageRight->pos.x = highlightImageMid->pos.x + highlightImageMid->pos.w;
		highlightImageRight->disabled = false;
		highlightImageRight->pos.y = highlightImageMid->pos.y;
	}

	bool activateSelection = false;
	if ( !Input::inputs[player.playernum].binary("MenuRightClick") && !toggleclick )
	{
		activateSelection = true;
	}
	if ( activateSelection )
	{
		if ( itemMenuSelected >= 0 && itemMenuSelected < options.size() )
		{
			if ( options[itemMenuSelected] == ItemContextMenuPrompts::PROMPT_DROP
				&& player.paperDoll.isItemOnDoll(*item) )
			{
				// need to unequip
				player.inventoryUI.activateItemContextMenuOption(item, ItemContextMenuPrompts::PROMPT_UNEQUIP_FOR_DROP);
				player.paperDoll.updateSlots();
				if ( player.paperDoll.isItemOnDoll(*item) )
				{
					// couldn't unequip, no more actions
				}
				else
				{
					// successfully unequipped, let's drop it.
					bool droppedAll = false;
					while ( item && item->count > 1 )
					{
						droppedAll = dropItem(item, player.playernum);
						if ( droppedAll )
						{
							item = nullptr;
						}
					}
					if ( !droppedAll )
					{
						dropItem(item, player.playernum);
					}
				}
			}
			else
			{
				activateItemContextMenuOption(item, options[itemMenuSelected]);
			}
		}
		//Close the menu.
		itemMenuOpen = false;
		itemMenuItem = 0;
		interactFrame->setDisabled(true);
	}
}

void Player::Inventory_t::activateItemContextMenuOption(Item* item, ItemContextMenuPrompts prompt)
{
	if ( !item )
	{
		return;
	}
	const int player = this->player.playernum;
	bool disableItemUsage = false;
	if ( players[player] && players[player]->entity )
	{
		if ( players[player]->entity->effectShapeshift != NOTHING )
		{
			// shape shifted, disable some items
			if ( !item->usableWhileShapeshifted(stats[player]) )
			{
				disableItemUsage = true;
			}
			if ( item->type == FOOD_CREAMPIE && (prompt == PROMPT_UNEQUIP || prompt == PROMPT_EQUIP) )
			{
				disableItemUsage = true;
			}
		}
		else
		{
			if ( itemCategory(item) == SPELL_CAT && item->appearance >= 1000 )
			{
				if ( canUseShapeshiftSpellInCurrentForm(player, *item) != 1 )
				{
					disableItemUsage = true;
				}
			}
		}
	}

	if ( client_classes[player] == CLASS_SHAMAN )
	{
		if ( item->type == SPELL_ITEM && !(playerUnlockedShamanSpell(player, item)) )
		{
			disableItemUsage = true;
		}
	}

	//PROMPT_EQUIP,
	//PROMPT_UNEQUIP,
	//PROMPT_SPELL_EQUIP,
	//PROMPT_INTERACT,
	//PROMPT_EAT,
	//PROMPT_CONSUME,
//PROMPT_SPELL_QUICKCAST,
//PROMPT_INSPECT,
//PROMPT_SELL,
//PROMPT_BUY,
//PROMPT_STORE_CHEST,
//PROMPT_RETRIEVE_CHEST,
	//PROMPT_APPRAISE,
	//PROMPT_DROP

	bool sellingItemToShop = false;
	if ( players[player]->gui_mode == GUI_MODE_SHOP && itemCategory(item) != SPELL_CAT
		&& players[player]->shopGUI.bOpen && uidToEntity(shopkeeper[player]) )
	{
		sellingItemToShop = true;
	}

	if ( prompt == PROMPT_DROPDOWN )
	{
		return;
	}
	if ( prompt == PROMPT_CLEAR_HOTBAR_SLOT )
	{
		for ( auto& slot : players[player]->hotbar.slots() )
		{
			if ( slot.item == item->uid )
			{
				slot.item = 0;
				slot.resetLastItem();
			}
		}
		return;
	}
	if ( prompt == PROMPT_APPRAISE )
	{
		players[player]->inventoryUI.appraisal.appraiseItem(item);
		return;
	}
	else if ( prompt == PROMPT_DROP )
	{
		dropItem(item, player);
		return;
	}
	else if ( prompt == PROMPT_SELL )
	{
		if ( sellingItemToShop )
		{
			sellItemToShop(player, item);
		}
		return;
	}
	else if ( prompt == PROMPT_RETRIEVE_CHEST || prompt == PROMPT_RETRIEVE_CHEST_ALL )
	{
		bool emptiedSlot = false;
		if ( openedChest[player] )
		{
			if ( prompt == PROMPT_RETRIEVE_CHEST )
			{
				bool tryAddToInventory = true;
				while ( tryAddToInventory )
				{
					if ( item->count <= 0 )
					{
						break;
					}
					int oldItemQty = 0;
					int destItemQty = 0;
					int oldQty = item->count;
					item->count = 1;
					bool oldIdentify = item->identified;
					if ( skillCapstoneUnlocked(player, PRO_APPRAISAL) )
					{
						item->identified = true;
					}
					auto result = getItemStackingBehavior(player, item, nullptr, oldItemQty, destItemQty);
					item->identified = oldIdentify;
					item->count = oldQty;

					int amountToPlace = 1;
					switch ( result.resultType )
					{
						case ITEM_ADDED_ENTIRELY_TO_DESTINATION_STACK:
						case ITEM_ADDED_PARTIALLY_TO_DESTINATION_STACK:
						{
							// operation success, can finish here.
							Item* inventoryItem = takeItemFromChest(player, item, amountToPlace, result.itemToStackInto, false);
							tryAddToInventory = false;
							if ( oldQty == 1 )
							{
								emptiedSlot = true;
							}
							break;
						}
						case ITEM_ADDED_WITHOUT_NEEDING_STACK:
						{
							// check for inventory space
							if ( !bItemInventoryHasFreeSlot() )
							{
								// no space
								tryAddToInventory = false;
								messagePlayer(player, MESSAGE_INVENTORY, Language::get(727), item->getName()); // no room
								playSoundPlayer(player, 90, 64);
								break;
							}

							// operation success, can finish here.
							int amountToPlace = 1;
							Item* inventoryItem = takeItemFromChest(player, item, amountToPlace, nullptr, true);
							tryAddToInventory = false;
							if ( oldQty == 1 )
							{
								emptiedSlot = true;
							}
							break;
						}
						default:
							// error out
							tryAddToInventory = false;
							break;
					}
				}
			}
			else if ( prompt == PROMPT_RETRIEVE_CHEST_ALL )
			{
				bool tryAddToInventory = true;
				while ( tryAddToInventory )
				{
					if ( item->count <= 0 )
					{
						break;
					}
					int oldItemQty = 0;
					int destItemQty = 0;
					bool oldIdentify = item->identified;
					if ( skillCapstoneUnlocked(player, PRO_APPRAISAL) )
					{
						item->identified = true;
					}
					auto result = getItemStackingBehavior(player, item, nullptr, oldItemQty, destItemQty);
					item->identified = oldIdentify;
					int amountToPlace = item->count - oldItemQty;
					assert(amountToPlace > 0);
					if ( amountToPlace <= 0 )
					{
						break;
					}
					switch ( result.resultType )
					{
						case ITEM_ADDED_PARTIALLY_TO_DESTINATION_STACK:
						{
							if ( Item* inventoryItem = takeItemFromChest(player, item, amountToPlace, result.itemToStackInto, false) )
							{
								// need to do another place operation.
							}
							else
							{
								tryAddToInventory = false;
							}
							break;
						}
						case ITEM_ADDED_ENTIRELY_TO_DESTINATION_STACK:
						{
							Item* inventoryItem = takeItemFromChest(player, item, amountToPlace, result.itemToStackInto, false);
							if ( oldItemQty > 0 )
							{
								// more work to do (unusually large stacks exceeding normal limits)
							}
							else
							{
								// operation success, can finish here.
								tryAddToInventory = false;
								if ( oldItemQty == 0 )
								{
									emptiedSlot = true;
								}
							}
							break;
						}
						case ITEM_ADDED_WITHOUT_NEEDING_STACK:
						{
							// check for inventory space
							if ( !bItemInventoryHasFreeSlot() )
							{
								// no space
								tryAddToInventory = false;
								messagePlayer(player, MESSAGE_INVENTORY, Language::get(727), item->getName()); // no room
								playSoundPlayer(player, 90, 64);
								break;
							}
							Item* inventoryItem = takeItemFromChest(player, item, amountToPlace, nullptr, true);
							tryAddToInventory = false;
							if ( oldItemQty == 0 )
							{
								emptiedSlot = true;
							}
							break;
						}
						default:
							// error out
							tryAddToInventory = false;
							break;
					}
				}
			}
		}
		if ( !emptiedSlot && (inputs.getUIInteraction(player)->itemMenuOpen || players[player]->inventoryUI.bCompactView) )
		{
			tooltipDelayTick = ticks + TICKS_PER_SECOND / 2;
		}
		return;
	}
	else if ( prompt == PROMPT_STORE_CHEST || prompt == PROMPT_STORE_CHEST_ALL )
	{
		bool emptiedSlot = false;
		if ( !disableItemUsage || (disableItemUsage && !players[player]->paperDoll.isItemOnDoll(*item)) )
		{
			if ( openedChest[player] )
			{
				if ( prompt == PROMPT_STORE_CHEST )
				{
					bool tryAddToChest = true;
					while ( tryAddToChest )
					{
						if ( item->count <= 0 )
						{
							break;
						}
						int oldItemQty = 0;
						int destItemQty = 0;
						int oldQty = item->count;
						item->count = 1;
						auto result = getItemStackingBehaviorIntoChest(player, item, nullptr, oldItemQty, destItemQty);
						item->count = oldQty;
						
						int amountToPlace = 1;
						switch ( result.resultType )
						{
							case ITEM_ADDED_ENTIRELY_TO_DESTINATION_STACK:
							case ITEM_ADDED_PARTIALLY_TO_DESTINATION_STACK:
							{
								// operation success, can finish here.
								Item* itemInChest = openedChest[player]->addItemToChestFromInventory(player, item, amountToPlace, false, result.itemToStackInto);
								tryAddToChest = false;
								if ( oldQty == 1 )
								{
									emptiedSlot = true;
								}
								break;
							}
							case ITEM_ADDED_WITHOUT_NEEDING_STACK:
							{
								// check for chest space
								if ( numItemsInChest(player) + 1 > (players[player]->inventoryUI.MAX_CHEST_X * players[player]->inventoryUI.MAX_CHEST_Y) )
								{
									// no space
									tryAddToChest = false;
									messagePlayer(player, MESSAGE_INVENTORY, Language::get(4098), item->getName()); // no room
									playSoundPlayer(player, 90, 64);
									break;
								}

								// operation success, can finish here.
								int amountToPlace = 1;
								Item* itemInChest = openedChest[player]->addItemToChestFromInventory(player, item, amountToPlace, true, nullptr);
								tryAddToChest = false;
								if ( oldQty == 1 )
								{
									emptiedSlot = true;
								}
								break;
							}
							default:
								// error out
								tryAddToChest = false;
								break;
						}
					}
				}
				else if ( prompt == PROMPT_STORE_CHEST_ALL )
				{
					bool tryAddToChest = true;
					while ( tryAddToChest )
					{
						if ( item->count <= 0 )
						{
							break;
						}
						int oldItemQty = 0;
						int destItemQty = 0;
						auto result = getItemStackingBehaviorIntoChest(player, item, nullptr, oldItemQty, destItemQty);
						int amountToPlace = item->count - oldItemQty;
						assert(amountToPlace > 0);
						if ( amountToPlace <= 0 )
						{
							break;
						}
						switch ( result.resultType )
						{
							case ITEM_ADDED_PARTIALLY_TO_DESTINATION_STACK:
							{
								if ( Item* itemInChest = openedChest[player]->addItemToChestFromInventory(player, item, amountToPlace, false, result.itemToStackInto) )
								{
									// need to do another place operation.
								}
								else
								{
									tryAddToChest = false;
								}
								break;
							}
							case ITEM_ADDED_ENTIRELY_TO_DESTINATION_STACK:
							{
								// operation success, can finish here.
								Item* itemInChest = openedChest[player]->addItemToChestFromInventory(player, item, amountToPlace, false, result.itemToStackInto);
								tryAddToChest = false;
								if ( oldItemQty == 0 )
								{
									emptiedSlot = true;
								}
								break;
							}
							case ITEM_ADDED_WITHOUT_NEEDING_STACK:
							{
								// check for chest space
								if ( numItemsInChest(player) + 1 > (players[player]->inventoryUI.MAX_CHEST_X * players[player]->inventoryUI.MAX_CHEST_Y) )
								{
									// no space
									tryAddToChest = false;
									messagePlayer(player, MESSAGE_INVENTORY, Language::get(4098), item->getName()); // no room
									playSoundPlayer(player, 90, 64);
									break;
								}
								Item* itemInChest = openedChest[player]->addItemToChestFromInventory(player, item, amountToPlace, true, nullptr);
								if ( !itemInChest )
								{
									tryAddToChest = false; // failure adding to chest
								}
								else if ( oldItemQty > 0 )
								{
									// more work to do (unusually large stacks exceeding normal limits)
								}
								else
								{
									tryAddToChest = false;
									if ( oldItemQty == 0 )
									{
										emptiedSlot = true;
									}
								}
								break;
							}
							default:
								// error out
								tryAddToChest = false;
								break;
						}
					}
				}
			}
		}
		else
		{
			messagePlayer(player, MESSAGE_INVENTORY | MESSAGE_HINT | MESSAGE_EQUIPMENT, Language::get(3432)); // unable to use in current form message.
			playSoundPlayer(player, 90, 64);
		}
		if ( !emptiedSlot && (inputs.getUIInteraction(player)->itemMenuOpen || players[player]->inventoryUI.bCompactView) )
		{
			tooltipDelayTick = ticks + TICKS_PER_SECOND / 2;
		}
		return;
	}
	else if ( prompt == PROMPT_GRAB )
	{
		inputs.getUIInteraction(player)->selectedItemFromHotbar = -1;
		if ( this->player.inventoryUI.isItemFromChest(item) )
		{
			inputs.getUIInteraction(player)->selectedItemFromChest = item->uid;
		}
		inputs.getUIInteraction(player)->selectedItem = item;
		playSound(139, 64); // click sound
		inputs.getUIInteraction(player)->toggleclick = true;
		Input::inputs[player].consumeBinaryToggle("MenuLeftClick");
		return;
	}
	else if ( prompt == PROMPT_EAT )
	{
		if ( !disableItemUsage )
		{
			useItem(item, player);
		}
		return;
	}
	else if ( prompt == PROMPT_CONSUME || prompt == PROMPT_CONSUME_ALTERNATE )
	{
		// consume item
		if ( multiplayer == CLIENT )
		{
			strcpy((char*)net_packet->data, "FODA");
			SDLNet_Write32((Uint32)item->type, &net_packet->data[4]);
			SDLNet_Write32((Uint32)item->status, &net_packet->data[8]);
			SDLNet_Write32((Uint32)item->beatitude, &net_packet->data[12]);
			SDLNet_Write32((Uint32)item->count, &net_packet->data[16]);
			SDLNet_Write32((Uint32)item->appearance, &net_packet->data[20]);
			net_packet->data[24] = item->identified;
			net_packet->data[25] = player;
			net_packet->address.host = net_server.host;
			net_packet->address.port = net_server.port;
			net_packet->len = 26;
			sendPacketSafe(net_sock, -1, net_packet, 0);
		}
		item_FoodAutomaton(item, player);
		return;
	}
	else if ( prompt == PROMPT_INTERACT 
		|| prompt == PROMPT_INTERACT_SPELLBOOK_HOTBAR
		|| prompt == PROMPT_INSPECT 
		|| prompt == PROMPT_INSPECT_ALTERNATE 
		|| prompt == PROMPT_TINKER )
	{
		if ( item->type == TOOL_PLAYER_LOOT_BAG )
		{
			if ( prompt == PROMPT_INTERACT )
			{
				item_ToolLootBag(item, player);
			}
			else if ( prompt == PROMPT_INSPECT )
			{
				useItem(item, player);
			}
		}
		else if ( item->type == TOOL_ALEMBIC )
		{
			// not experimenting
			if ( GenericGUI[player].alchemyGUI.bOpen && GenericGUI[player].alembicItem == item )
			{
				GenericGUI[player].closeGUI();
			}
			else if ( !disableItemUsage )
			{
				if ( item->status > BROKEN )
				{
					GenericGUI[player].openGUI(GUI_TYPE_ALCHEMY, true, item);
				}
				else
				{
					messagePlayer(player, MESSAGE_EQUIPMENT, Language::get(1092), item->getName()); // this is useless!
					playSoundPlayer(player, 90, 64);
				}
			}
			else
			{
				messagePlayer(player, MESSAGE_INVENTORY | MESSAGE_HINT | MESSAGE_EQUIPMENT, Language::get(3432)); // unable to use in current form message.
				playSoundPlayer(player, 90, 64);
			}
		}
		else if ( item->type == TOOL_TINKERING_KIT )
		{
			if ( !disableItemUsage )
			{
				if ( true /*item->status > BROKEN*/ ) // allow broken tinker kit
				{
					GenericGUI[player].openGUI(GUI_TYPE_TINKERING, item);
				}
				else
				{
					messagePlayer(player, MESSAGE_EQUIPMENT, Language::get(1092), item->getName()); // this is useless!
					playSoundPlayer(player, 90, 64);
				}
			}
			else
			{
				messagePlayer(player, MESSAGE_INVENTORY | MESSAGE_HINT | MESSAGE_EQUIPMENT, Language::get(3432)); // unable to use in current form message.
				playSoundPlayer(player, 90, 64);
			}
		}
		else
		{
			if ( !disableItemUsage && prompt == PROMPT_INTERACT_SPELLBOOK_HOTBAR )
			{
				if ( itemCategory(item) == SPELLBOOK )
				{
					players[player]->magic.spellbookUidFromHotbarSlot = item->uid;
				}
				useItem(item, player);
				players[player]->magic.spellbookUidFromHotbarSlot = 0;
			}
			else if ( !disableItemUsage && prompt == PROMPT_INTERACT )
			{
				useItem(item, player);
			}
			else
			{
				messagePlayer(player, MESSAGE_INVENTORY | MESSAGE_HINT | MESSAGE_EQUIPMENT, Language::get(3432)); // unable to use in current form message.
				playSoundPlayer(player, 90, 64);
			}
		}
		return;
	}
	else if ( prompt == PROMPT_EQUIP 
		|| prompt == PROMPT_UNEQUIP
		|| prompt == PROMPT_SPELL_EQUIP
		|| prompt == PROMPT_UNEQUIP_FOR_DROP )
	{
		if ( isItemEquippableInShieldSlot(item) && cast_animation[player].active_spellbook )
		{
			return; // don't try to equip shields while casting
		}

		if ( !disableItemUsage )
		{
			if ( item->status == BROKEN )
			{
				messagePlayer(player, MESSAGE_EQUIPMENT, Language::get(1092), item->getName()); // don't try equip broken stuff
				playSoundPlayer(player, 90, 64);
				return;
			}

			if ( prompt == PROMPT_EQUIP
				|| prompt == PROMPT_UNEQUIP
				|| prompt == PROMPT_UNEQUIP_FOR_DROP )
			{
				if ( items[item->type].item_slot == ItemEquippableSlot::EQUIPPABLE_IN_SLOT_WEAPON
					|| itemCategory(item) == SPELLBOOK )
				{
					if ( prompt == PROMPT_UNEQUIP_FOR_DROP )
					{
						playerTryEquipItemAndUpdateServer(player, item, false); // don't check inventory space to unequip
					}
					else
					{
						playerTryEquipItemAndUpdateServer(player, item, true);
					}
					return;
				}
			}

			if ( prompt == PROMPT_UNEQUIP_FOR_DROP )
			{
				useItem(item, player, players[player]->entity, true);
			}
			else
			{
				useItem(item, player);
			}
			return;
		}
		else
		{
			if ( client_classes[player] == CLASS_SHAMAN && item->type == SPELL_ITEM )
			{
				messagePlayer(player, MESSAGE_INVENTORY | MESSAGE_HINT | MESSAGE_EQUIPMENT, Language::get(3488)); // unable to use with current level.
			}
			else
			{
				messagePlayer(player, MESSAGE_INVENTORY | MESSAGE_HINT | MESSAGE_EQUIPMENT, Language::get(3432)); // unable to use in current form message.
			}
			playSoundPlayer(player, 90, 64);
		}
		return;
	}
	else if ( prompt == PROMPT_SPELL_QUICKCAST )
	{
		if ( !disableItemUsage )
		{
			players[player]->magic.setQuickCastSpellFromInventory(item);
		}
		else
		{
			if ( client_classes[player] == CLASS_SHAMAN && item->type == SPELL_ITEM )
			{
				messagePlayer(player, MESSAGE_INVENTORY | MESSAGE_HINT | MESSAGE_EQUIPMENT, Language::get(3488)); // unable to use with current level.
			}
			else
			{
				messagePlayer(player, MESSAGE_INVENTORY | MESSAGE_HINT | MESSAGE_EQUIPMENT, Language::get(3432)); // unable to use in current form message.
			}
			playSoundPlayer(player, 90, 64);
		}
		return;
	}
}

void Player::Hotbar_t::updateSelectedSlotAnimation(int destx, int desty, int width, int height, bool usingMouse)
{
	if ( hotbarFrame )
	{
		if ( auto selectedSlotCursor = hotbarFrame->findFrame("shootmode selected item cursor") )
		{
			if ( usingMouse )
			{
				selectedSlotCursor->setSize(
					SDL_Rect{
					destx - shootmodeCursor.cursorToSlotOffset,
					desty - shootmodeCursor.cursorToSlotOffset,
					width + 2 * (shootmodeCursor.cursorToSlotOffset + 1),
					height + 2 * (shootmodeCursor.cursorToSlotOffset + 1)
				}
				);
				shootmodeCursor.animateSetpointX = destx;
				shootmodeCursor.animateSetpointY = desty;
				shootmodeCursor.animateStartX = destx;
				shootmodeCursor.animateStartY = desty;
			}
			else if ( shootmodeCursor.animateSetpointX != destx || shootmodeCursor.animateSetpointY != desty )
			{
				SDL_Rect size = selectedSlotCursor->getSize();
				shootmodeCursor.animateStartX = size.x;
				shootmodeCursor.animateStartY = size.y;
				size.w = width + 2 * (shootmodeCursor.cursorToSlotOffset + 1);
				size.h = height + 2 * (shootmodeCursor.cursorToSlotOffset + 1);
				selectedSlotCursor->setSize(size);
				shootmodeCursor.animateSetpointX = destx;
				shootmodeCursor.animateSetpointY = desty;
				shootmodeCursor.animateX = 0.0;
				shootmodeCursor.animateY = 0.0;
				shootmodeCursor.lastUpdateTick = ticks;
			}
		}
	}
}

void Player::Inventory_t::updateSelectedItemAnimation()
{
	if ( !player.isLocalPlayer() )
	{
		return;
	}

	if ( frame )
	{
		if ( auto selectedSlotFrame = frame->findFrame("inventory selected item") )
		{
			selectedSlotFrame->setDisabled(true);
		}
		if ( selectedItemCursorFrame )
		{
			selectedItemCursorFrame->setDisabled(true);
		}
	}

	if ( inputs.getUIInteraction(player.playernum)->selectedItem )
	{
		const real_t fpsScale = getFPSScale(144.0);
		real_t setpointDiffX = fpsScale * std::max(.05, (1.0 - selectedItemAnimate.animateX)) / (5);
		real_t setpointDiffY = fpsScale * std::max(.05, (1.0 - selectedItemAnimate.animateY)) / (5);
		selectedItemAnimate.animateX += setpointDiffX;
		selectedItemAnimate.animateY += setpointDiffY;
		selectedItemAnimate.animateX = std::min(1.0, selectedItemAnimate.animateX);
		selectedItemAnimate.animateY = std::min(1.0, selectedItemAnimate.animateY);
	}
	else
	{
		selectedItemAnimate.animateX = 0.0;
		selectedItemAnimate.animateY = 0.0;
	}
}

void Player::Inventory_t::updateInventoryItemTooltip()
{
	if ( !tooltipFrame || !frame || !titleOnlyTooltipFrame )
	{
		return;
	}

	auto& tooltipDisplay = this->itemTooltipDisplay;

	if ( static_cast<int>(tooltipFrame->getOpacity()) != tooltipDisplay.opacitySetpoint )
	{
		const real_t fpsScale = getFPSScale(144.0);
		if ( tooltipDisplay.opacitySetpoint == 0 )
		{
			real_t setpointDiff = fpsScale * std::max(.05, (tooltipDisplay.opacityAnimate)) / (5);
			tooltipDisplay.opacityAnimate -= setpointDiff;
			tooltipDisplay.opacityAnimate = std::max(0.0, tooltipDisplay.opacityAnimate);
		}
		else
		{
			real_t setpointDiff = fpsScale * std::max(.05, (1.0 - tooltipDisplay.opacityAnimate)) / (1);
			tooltipDisplay.opacityAnimate += setpointDiff;
			tooltipDisplay.opacityAnimate = std::min(1.0, tooltipDisplay.opacityAnimate);
		}
		tooltipFrame->setOpacity(tooltipDisplay.opacityAnimate * 100);
	}
	else
	{
		tooltipFrame->setOpacity(tooltipDisplay.opacitySetpoint);
	}

	if ( static_cast<int>(titleOnlyTooltipFrame->getOpacity()) != tooltipDisplay.titleOnlyOpacitySetpoint )
	{
		const real_t fpsScale = getFPSScale(144.0);
		if ( tooltipDisplay.titleOnlyOpacitySetpoint == 0 )
		{
			real_t setpointDiff = fpsScale * std::max(.05, (tooltipDisplay.titleOnlyOpacityAnimate)) / (5);
			tooltipDisplay.titleOnlyOpacityAnimate -= setpointDiff;
			tooltipDisplay.titleOnlyOpacityAnimate = std::max(0.0, tooltipDisplay.titleOnlyOpacityAnimate);
		}
		else
		{
			real_t setpointDiff = fpsScale * std::max(.05, (1.0 - tooltipDisplay.titleOnlyOpacityAnimate)) / (1);
			tooltipDisplay.titleOnlyOpacityAnimate += setpointDiff;
			tooltipDisplay.titleOnlyOpacityAnimate = std::min(1.0, tooltipDisplay.titleOnlyOpacityAnimate);
		}
		titleOnlyTooltipFrame->setOpacity(tooltipDisplay.titleOnlyOpacityAnimate * 100);
	}
	else
	{
		titleOnlyTooltipFrame->setOpacity(tooltipDisplay.titleOnlyOpacitySetpoint);
	}

	if ( tooltipPromptFrame )
	{
		tooltipPromptFrame->setOpacity(tooltipFrame->getOpacity());
	}

	tooltipDisplay.expandSetpoint = tooltipDisplay.expanded ? 100 : 0;
	if ( static_cast<int>(tooltipDisplay.expandCurrent * 100) != tooltipDisplay.expandSetpoint )
	{
		const real_t fpsScale = getFPSScale(144.0);
		if ( tooltipDisplay.expandSetpoint == 0 )
		{
			//real_t setpointDiff = fpsScale * std::max(.05, (tooltipDisplay.expandAnimate) / 50);
			//tooltipDisplay.expandAnimate -= setpointDiff;
			tooltipDisplay.expandAnimate -= 2 * fpsScale / 100.0;
			tooltipDisplay.expandAnimate = std::max(0.0, tooltipDisplay.expandAnimate);
		}
		else
		{
			//real_t setpointDiff = fpsScale * std::max(.05, (1.0 - tooltipDisplay.expandAnimate) / 50);
			//tooltipDisplay.expandAnimate += setpointDiff;
			tooltipDisplay.expandAnimate += 2 * fpsScale / 100.0;
			tooltipDisplay.expandAnimate = std::min(1.0, tooltipDisplay.expandAnimate);
		}
		double t = tooltipDisplay.expandAnimate;
		tooltipDisplay.expandCurrent = t * t * (3.0f - 2.0f * t); // bezier from 0 to width as t (0-1);
	}
	else
	{
		tooltipDisplay.expandCurrent = tooltipDisplay.expandSetpoint / 100.0;
	}
}

void Player::Inventory_t::ItemTooltipDisplay_t::updateItem(const int player, Item* newItem)
{
	if ( newItem && player >= 0 && player < MAXPLAYERS && stats[player] )
	{
		uid = newItem->uid;
		type = newItem->type;
		status = newItem->status;
		beatitude = newItem->beatitude;
		count = newItem->count;
		appearance = newItem->appearance;
		identified = newItem->identified;

		if ( players[player]->inventoryUI.appraisal.current_item == uid )
		{
			wasAppraisalTarget = true;
		}
		else
		{
			wasAppraisalTarget = false;
		}
		if ( stats[player] )
		{
			playernum = player;
			playerLVL = stats[player]->LVL;
			playerEXP = stats[player]->EXP;
			playerSTR = statGetSTR(stats[player], players[player]->entity);
			playerDEX = statGetDEX(stats[player], players[player]->entity);
			playerCON = statGetCON(stats[player], players[player]->entity);
			playerINT = statGetINT(stats[player], players[player]->entity);
			playerPER = statGetPER(stats[player], players[player]->entity);
			playerCHR = statGetCHR(stats[player], players[player]->entity);
		}
	}
}

bool Player::Inventory_t::ItemTooltipDisplay_t::isItemSameAsCurrent(const int player, Item* newItem)
{
	if ( newItem && player >= 0 && player < MAXPLAYERS && stats[player] )
	{
		bool appraisingThisItem = false;
		if ( players[player]->inventoryUI.appraisal.current_item == uid )
		{
			appraisingThisItem = true;
		}

		if ( newItem->uid == uid
			&& newItem->type == type
			&& newItem->status == status
			&& newItem->beatitude == beatitude
			&& newItem->count == count
			&& newItem->appearance == appearance
			&& newItem->identified == identified
			&& (wasAppraisalTarget == appraisingThisItem)
			&& playernum == player
			&& playerLVL == stats[player]->LVL
			&& playerEXP == stats[player]->EXP
			&& playerSTR == statGetSTR(stats[player], players[player]->entity)
			&& playerDEX == statGetDEX(stats[player], players[player]->entity)
			&& playerCON == statGetCON(stats[player], players[player]->entity)
			&& playerINT == statGetINT(stats[player], players[player]->entity)
			&& playerPER == statGetPER(stats[player], players[player]->entity)
			&& playerCHR == statGetCHR(stats[player], players[player]->entity)
		)
		{
			return true;
		}
	}
	return false;
}

Player::Inventory_t::ItemTooltipDisplay_t::ItemTooltipDisplay_t()
{
	uid = 0;
	type = WOODEN_SHIELD;
	status = BROKEN;
	beatitude = 0;
	count = 0;
	appearance = 0;
	identified = false;
	wasAppraisalTarget = false;
	playernum = -1;
	playerLVL = 0;
	playerEXP = 0;
	playerSTR = 0;
	playerDEX = 0;
	playerCON = 0;
	playerINT = 0;
	playerPER = 0;
	playerCHR = 0;
}

void Player::Inventory_t::updateItemContextMenuClickFrame()
{
	if ( !interactBlockClickFrame )
	{
		char interactBlockClickName[64] = "";
		snprintf(interactBlockClickName, sizeof(interactBlockClickName), "player inventory dropdown block click %d", player.playernum);
		if ( interactBlockClickFrame = gameUIFrame[player.playernum]->addFrame(interactBlockClickName) )
		{
			interactBlockClickFrame->setSize(SDL_Rect{ player.camera_virtualx1(),
				player.camera_virtualy1(),
				player.camera_virtualWidth(),
				player.camera_virtualHeight() });
			interactBlockClickFrame->setOwner(player.playernum);
			interactBlockClickFrame->setDisabled(true);
			interactBlockClickFrame->setHollow(true);
		}
	}

	interactBlockClickFrame->setSize(SDL_Rect{ player.camera_virtualx1(),
		player.camera_virtualy1(),
		player.camera_virtualWidth(),
		player.camera_virtualHeight() });

	if ( interactFrame )
	{
		if ( interactFrame->isDisabled() )
		{
			interactBlockClickFrame->setDisabled(true);
			interactBlockClickFrame->setHollow(true);
		}
		else
		{
			interactBlockClickFrame->setDisabled(false);
			interactBlockClickFrame->setHollow(false);
		}
	}
}

void Player::Inventory_t::updateCursor()
{
	if ( !frame )
	{
		return;
	}

	if ( !player.isLocalPlayer() )
	{
		return;
	}

	if ( cursor.queuedModule != Player::GUI_t::MODULE_NONE
		&& !player.shootmode && !nohud )
	{
		int cursorWidth = player.inventoryUI.getSlotSize();
		int cursorHeight = player.inventoryUI.getSlotSize();
		bool moveMouse = false;
		auto queuedModule = cursor.queuedModule;
		if ( cursor.queuedModule == Player::GUI_t::MODULE_INVENTORY )
		{
			if ( frame->isDisabled() || player.inventory_mode != INVENTORY_MODE_ITEM )
			{
				// cancel
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
			else if ( isInteractable )
			{
				moveMouse = true;
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
		}
		else if ( cursor.queuedModule == Player::GUI_t::MODULE_HOTBAR )
		{
			if ( player.hotbar.hotbarFrame && player.hotbar.hotbarFrame->isDisabled() )
			{
				// cancel
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
			else if ( player.hotbar.isInteractable )
			{
				moveMouse = true;
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
		}
		else if ( cursor.queuedModule == Player::GUI_t::MODULE_SPELLS )
		{
			if ( spellFrame->isDisabled() || player.inventory_mode != INVENTORY_MODE_SPELL )
			{
				// cancel
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
			else if ( spellPanel.isInteractable )
			{
				moveMouse = true;
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
		}
		else if ( cursor.queuedModule == Player::GUI_t::MODULE_CHEST )
		{
			if ( !chestFrame 
				|| chestFrame->isDisabled()
				|| player.inventory_mode != INVENTORY_MODE_ITEM
				|| !openedChest[player.playernum] )
			{
				// cancel
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
			else if ( chestGUI.isInteractable )
			{
				moveMouse = true;
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
		}
		else if ( cursor.queuedModule == Player::GUI_t::MODULE_SHOP )
		{
			auto& shopGUI = player.shopGUI;
			if ( !shopGUI.shopFrame
				|| shopGUI.shopFrame->isDisabled()
				|| player.inventory_mode != INVENTORY_MODE_ITEM
				|| !shopGUI.bOpen )
			{
				// cancel
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
			else if ( shopGUI.isInteractable )
			{
				moveMouse = true;
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
		}
		else if ( cursor.queuedModule == Player::GUI_t::MODULE_TINKERING )
		{
			auto& tinkerGUI = GenericGUI[player.playernum].tinkerGUI;
			if ( !tinkerGUI.tinkerGUIHasBeenCreated()
				|| tinkerGUI.tinkerFrame->isDisabled()
				|| !tinkerGUI.isConstructMenuActive() )
			{
				// cancel
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
			else if ( tinkerGUI.isInteractable )
			{
				moveMouse = true;
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
			if ( cursor.queuedFrameToWarpTo )
			{
				cursorWidth = cursor.queuedFrameToWarpTo->getSize().w;
				cursorHeight = cursor.queuedFrameToWarpTo->getSize().h;
			}
		}
		else if ( cursor.queuedModule == Player::GUI_t::MODULE_ALCHEMY )
		{
			auto& alchemyGUI = GenericGUI[player.playernum].alchemyGUI;
			if ( !alchemyGUI.alchemyGUIHasBeenCreated()
				|| alchemyGUI.alchFrame->isDisabled() )
			{
				// cancel
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
			else if ( alchemyGUI.isInteractable )
			{
				moveMouse = true;
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
		}
		else if ( cursor.queuedModule == Player::GUI_t::MODULE_FEATHER )
		{
			auto& featherGUI = GenericGUI[player.playernum].featherGUI;
			if ( !featherGUI.featherGUIHasBeenCreated()
				|| featherGUI.featherFrame->isDisabled() )
			{
				// cancel
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
			else if ( featherGUI.isInteractable )
			{
				moveMouse = true;
				cursor.queuedModule = Player::GUI_t::MODULE_NONE;
			}
			if ( cursor.queuedFrameToWarpTo )
			{
				cursorWidth = cursor.queuedFrameToWarpTo->getSize().w;
				cursorHeight = cursor.queuedFrameToWarpTo->getSize().h;
			}
		}

		if ( moveMouse && cursor.queuedFrameToWarpTo )
		{
			//messagePlayer(0, "Queue warp: %d", queuedModule);
			cursor.queuedFrameToWarpTo->warpMouseToFrame(player.playernum, (Inputs::SET_CONTROLLER));
			SDL_Rect pos = cursor.queuedFrameToWarpTo->getAbsoluteSize();
			pos.x -= player.camera_virtualx1(); // offset any splitscreen camera positioning
			pos.y -= player.camera_virtualy1();
			player.inventoryUI.updateSelectedSlotAnimation(pos.x, pos.y,
				cursorWidth, cursorHeight, false);
			cursor.queuedFrameToWarpTo = nullptr;
		}
		else if ( cursor.queuedFrameToWarpTo && cursor.queuedModule == Player::GUI_t::MODULE_NONE )
		{
			//messagePlayer(0, "Queue cancel: %d", queuedModule);
		}
		else if ( cursor.queuedFrameToWarpTo )
		{
			//selectedItemCursorFrame->setDisabled(false); // show the cursor while we wait
		}
	}
	else
	{
		cursor.queuedFrameToWarpTo = nullptr;
		cursor.queuedModule = Player::GUI_t::MODULE_NONE;
	}

	if ( auto oldSelectedSlotCursor = frame->findFrame("inventory old item cursor") )
	{
		if ( auto oldSelectedFrame = frame->findFrame("inventory old selected item") )
		{
			oldSelectedSlotCursor->setDisabled(oldSelectedFrame->isDisabled());

			if ( player.hotbar.hotbarFrame )
			{
				if ( auto highlight = oldSelectedFrame->findImage("inventory old selected highlight") )
				{
					highlight->disabled = false;
					if ( auto oldHotbarSelectedFrame = player.hotbar.hotbarFrame->findFrame("hotbar old selected item") )
					{
						if ( !oldHotbarSelectedFrame->isDisabled() )
						{
							oldSelectedSlotCursor->setDisabled(true);
							highlight->disabled = true;
						}
					}
				}
			}

			if ( !oldSelectedSlotCursor->isDisabled() )
			{
				SDL_Rect cursorSize = oldSelectedSlotCursor->getSize();
				cursorSize.x = (oldSelectedFrame->getSize().x - 1) - cursor.cursorToSlotOffset;
				cursorSize.y = (oldSelectedFrame->getSize().y - 1) - cursor.cursorToSlotOffset;
				oldSelectedSlotCursor->setSize(cursorSize);

				int offset = 8;// ((ticks - cursor.lastUpdateTick) % 50 < 25) ? largeOffset : smallOffset;

				Uint8 r, g, b, a;
				if ( auto tl = oldSelectedSlotCursor->findImage("inventory old cursor topleft") )
				{
					tl->pos = SDL_Rect{ offset, offset, tl->pos.w, tl->pos.h };
					getColor(tl->color, &r, &g, &b, &a);
					a = oldSelectedCursorOpacity;
					tl->color = makeColor( r, g, b, a);
				}
				if ( auto tr = oldSelectedSlotCursor->findImage("inventory old cursor topright") )
				{
					tr->pos = SDL_Rect{ -offset + cursorSize.w - tr->pos.w, offset, tr->pos.w, tr->pos.h };
					tr->color = makeColor( r, g, b, a);
				}
				if ( auto bl = oldSelectedSlotCursor->findImage("inventory old cursor bottomleft") )
				{
					bl->pos = SDL_Rect{ offset, -offset + cursorSize.h - bl->pos.h, bl->pos.w, bl->pos.h };
					bl->color = makeColor( r, g, b, a);
				}
				if ( auto br = oldSelectedSlotCursor->findImage("inventory old cursor bottomright") )
				{
					br->pos = SDL_Rect{ -offset + cursorSize.w - br->pos.w, -offset + cursorSize.h - br->pos.h, br->pos.w, br->pos.h };
					br->color = makeColor( r, g, b, a);
				}
			}
		}
	}

	if ( selectedItemCursorFrame )
	{
		SDL_Rect cursorSize = selectedItemCursorFrame->getSize();

		const int smallOffset = 2;
		const int largeOffset = 4;

		int offset = ((ticks - cursor.lastUpdateTick) % TICKS_PER_SECOND < TICKS_PER_SECOND / 2) ? largeOffset : smallOffset;
		if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
		{
			if ( inputs.getUIInteraction(player.playernum)->selectedItem 
				|| inputs.getUIInteraction(player.playernum)->itemMenuOpen )
			{
				// animate cursor
			}
			else
			{
				offset = smallOffset; // don't animate while mouse normal hovering
			}
		}

		Uint8 r, g, b, a;
		if ( auto tl = selectedItemCursorFrame->findImage("inventory selected cursor topleft") )
		{
			tl->pos = SDL_Rect{ offset, offset, tl->pos.w, tl->pos.h };
			getColor(tl->color, &r, &g, &b, &a);
			a = selectedCursorOpacity;
			tl->color = makeColor( r, g, b, a);
		}
		if ( auto tr = selectedItemCursorFrame->findImage("inventory selected cursor topright") )
		{
			tr->pos = SDL_Rect{ -offset + cursorSize.w - tr->pos.w, offset, tr->pos.w, tr->pos.h };
			tr->color = makeColor( r, g, b, a);
		}
		if ( auto bl = selectedItemCursorFrame->findImage("inventory selected cursor bottomleft") )
		{
			bl->pos = SDL_Rect{ offset, -offset + cursorSize.h - bl->pos.h, bl->pos.w, bl->pos.h };
			bl->color = makeColor( r, g, b, a);
		}
		if ( auto br = selectedItemCursorFrame->findImage("inventory selected cursor bottomright") )
		{
			br->pos = SDL_Rect{ -offset + cursorSize.w - br->pos.w, -offset + cursorSize.h - br->pos.h, br->pos.w, br->pos.h };
			br->color = makeColor( r, g, b, a);
		}

		SDL_Rect currentPos = selectedItemCursorFrame->getSize();
		const int offsetPosition = cursor.cursorToSlotOffset;
		if ( cursor.animateSetpointX - offsetPosition != currentPos.x
			|| cursor.animateSetpointY - offsetPosition != currentPos.y )
		{
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - cursor.animateX)) / (2.5);
			real_t setpointDiffY = fpsScale * std::max(.1, (1.0 - cursor.animateY)) / (2.5);
			cursor.animateX += setpointDiffX;
			cursor.animateY += setpointDiffY;
			cursor.animateX = std::min(1.0, cursor.animateX);
			cursor.animateY = std::min(1.0, cursor.animateY);

			int destX = cursor.animateSetpointX - cursor.animateStartX - offsetPosition;
			int destY = cursor.animateSetpointY - cursor.animateStartY - offsetPosition;

			currentPos.x = cursor.animateStartX + destX * cursor.animateX;
			currentPos.y = cursor.animateStartY + destY * cursor.animateY;
			selectedItemCursorFrame->setSize(currentPos);
			//messagePlayer(0, "%.2f | %.2f", inventory_t.selectedSlotAnimateX, setpointDiffX);
		}
	}
}

void Player::HUD_t::updateCursorAnimation(int destx, int desty, int width, int height, bool usingMouse)
{
	if ( cursorFrame )
	{
		if ( auto hudCursor = cursorFrame->findFrame("hud cursor") )
		{
			if ( usingMouse )
			{
				hudCursor->setSize(
					SDL_Rect{
					destx - cursor.cursorToSlotOffset,
					desty - cursor.cursorToSlotOffset,
					width + 2 * (cursor.cursorToSlotOffset + 1),
					height + 2 * (cursor.cursorToSlotOffset + 1)
				}
				);
				cursor.animateSetpointX = destx;
				cursor.animateSetpointY = desty;
				cursor.animateSetpointW = width + 2 * (cursor.cursorToSlotOffset + 1);
				cursor.animateSetpointH = height + 2 * (cursor.cursorToSlotOffset + 1);

				cursor.animateStartX = destx;
				cursor.animateStartY = desty;
				cursor.animateStartW = width + 2 * (cursor.cursorToSlotOffset + 1);
				cursor.animateStartH = height + 2 * (cursor.cursorToSlotOffset + 1);
			}
			else if ( cursor.animateSetpointX != destx 
				|| cursor.animateSetpointY != desty
				|| cursor.animateSetpointW != width + 2 * (cursor.cursorToSlotOffset + 1)
				|| cursor.animateSetpointH != height + 2 * (cursor.cursorToSlotOffset + 1) )
			{
				SDL_Rect size = hudCursor->getSize();
				cursor.animateStartX = size.x;
				cursor.animateStartY = size.y;
				cursor.animateStartW = size.w;
				cursor.animateStartH = size.h;

				hudCursor->setSize(size);
				cursor.animateSetpointX = destx;
				cursor.animateSetpointY = desty;
				cursor.animateSetpointW = width + 2 * (cursor.cursorToSlotOffset + 1);
				cursor.animateSetpointH = height + 2 * (cursor.cursorToSlotOffset + 1);

				cursor.animateX = 0.0;
				cursor.animateY = 0.0;
				cursor.animateW = 0.0;
				cursor.animateH = 0.0;

				cursor.lastUpdateTick = ticks;
			}
		}
	}
}

void Player::HUD_t::updateCursor()
{
	if ( !cursorFrame )
	{
		char name[32];
		snprintf(name, sizeof(name), "player hud cursor %d", player.playernum);
		cursorFrame = gameUIFrame[player.playernum]->addFrame(name);
		cursorFrame->setHollow(true);
		cursorFrame->setBorder(0);
		cursorFrame->setOwner(player.playernum);

		auto cursor = cursorFrame->addFrame("hud cursor");
		cursor->setHollow(true);
		cursor->setSize(SDL_Rect{ 0, 0, 0, 0 });
		Uint32 color = makeColor( 255, 255, 255, selectedCursorOpacity);
		cursor->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_TL.png", "hud cursor topleft");
		cursor->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_TR.png", "hud cursor topright");
		cursor->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_BL.png", "hud cursor bottomleft");
		cursor->addImage(SDL_Rect{ 0, 0, 14, 14 },
			color, "*#images/ui/Inventory/Selector_BR.png", "hud cursor bottomright");
	}

	cursorFrame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
		players[player.playernum]->camera_virtualy1(),
		players[player.playernum]->camera_virtualWidth(),
		players[player.playernum]->camera_virtualHeight() });

	if ( !players[player.playernum]->isLocalPlayer() 
		|| players[player.playernum]->shootmode 
		|| players[player.playernum]->GUI.bActiveModuleUsesInventory()
		|| players[player.playernum]->GUI.bActiveModuleHasNoCursor() )
	{
		// hide
		cursorFrame->setDisabled(true);
	}
	else
	{
		cursorFrame->setDisabled(false);
	}

	if ( auto hudCursor = cursorFrame->findFrame("hud cursor") )
	{
		SDL_Rect cursorSize = hudCursor->getSize();
		const int smallOffset = 2;
		const int largeOffset = 4;

		int offset = ((ticks - cursor.lastUpdateTick) % TICKS_PER_SECOND < TICKS_PER_SECOND / 2) ? largeOffset : smallOffset;
		if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
		{
			if ( player.GUI.dropdownMenu.bOpen || player.GUI.activeModule == Player::GUI_t::MODULE_PORTRAIT )
			{
				// animate cursor
			}
			else
			{
				offset = smallOffset; // don't animate while mouse normal hovering
			}
		}

		Uint8 r, g, b, a;
		if ( auto tl = hudCursor->findImage("hud cursor topleft") )
		{
			tl->pos = SDL_Rect{ offset, offset, tl->pos.w, tl->pos.h };
			getColor(tl->color, &r, &g, &b, &a);
			a = selectedCursorOpacity;
			tl->color = makeColor( r, g, b, a);
		}
		if ( auto tr = hudCursor->findImage("hud cursor topright") )
		{
			tr->pos = SDL_Rect{ -offset + cursorSize.w - tr->pos.w, offset, tr->pos.w, tr->pos.h };
			tr->color = makeColor( r, g, b, a);
		}
		if ( auto bl = hudCursor->findImage("hud cursor bottomleft") )
		{
			bl->pos = SDL_Rect{ offset, -offset + cursorSize.h - bl->pos.h, bl->pos.w, bl->pos.h };
			bl->color = makeColor( r, g, b, a);
		}
		if ( auto br = hudCursor->findImage("hud cursor bottomright") )
		{
			br->pos = SDL_Rect{ -offset + cursorSize.w - br->pos.w, -offset + cursorSize.h - br->pos.h, br->pos.w, br->pos.h };
			br->color = makeColor( r, g, b, a);
		}

		SDL_Rect currentPos = hudCursor->getSize();
		const int offsetPosition = cursor.cursorToSlotOffset;
		if ( cursor.animateSetpointX - offsetPosition != currentPos.x
			|| cursor.animateSetpointY - offsetPosition != currentPos.y
			|| cursor.animateSetpointW != currentPos.w
			|| cursor.animateSetpointH != currentPos.h )
		{
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - cursor.animateX)) / (2.5);
			real_t setpointDiffY = fpsScale * std::max(.1, (1.0 - cursor.animateY)) / (2.5);
			real_t setpointDiffW = fpsScale * std::max(.1, (1.0 - cursor.animateW)) / (2.5);
			real_t setpointDiffH = fpsScale * std::max(.1, (1.0 - cursor.animateH)) / (2.5);
			cursor.animateX += setpointDiffX;
			cursor.animateY += setpointDiffY;
			cursor.animateX = std::min(1.0, cursor.animateX);
			cursor.animateY = std::min(1.0, cursor.animateY);
			cursor.animateW += setpointDiffW;
			cursor.animateH += setpointDiffH;
			cursor.animateW = std::min(1.0, cursor.animateW);
			cursor.animateH = std::min(1.0, cursor.animateH);

			int destX = cursor.animateSetpointX - cursor.animateStartX - offsetPosition;
			int destY = cursor.animateSetpointY - cursor.animateStartY - offsetPosition;
			int destW = cursor.animateSetpointW - cursor.animateStartW;
			int destH = cursor.animateSetpointH - cursor.animateStartH;

			currentPos.x = cursor.animateStartX + destX * cursor.animateX;
			currentPos.y = cursor.animateStartY + destY * cursor.animateY;
			currentPos.w = cursor.animateStartW + destW * cursor.animateW;
			currentPos.h = cursor.animateStartH + destH * cursor.animateH;
			hudCursor->setSize(currentPos);
		}
	}
}

void Player::Hotbar_t::updateCursor()
{
	if ( !hotbarFrame )
	{
		return;
	}

	if ( !player.isLocalPlayer() )
	{
		return;
	}

	if ( auto oldSelectedSlotCursor = hotbarFrame->findFrame("hotbar old item cursor") )
	{
		if ( auto oldSelectedFrame = hotbarFrame->findFrame("hotbar old selected item") )
		{
			oldSelectedSlotCursor->setDisabled(oldSelectedFrame->isDisabled());

			if ( !oldSelectedSlotCursor->isDisabled() )
			{
				SDL_Rect cursorSize = oldSelectedSlotCursor->getSize();
				cursorSize.x = (oldSelectedFrame->getSize().x - 1) - shootmodeCursor.cursorToSlotOffset;
				cursorSize.y = (oldSelectedFrame->getSize().y - 1) - shootmodeCursor.cursorToSlotOffset;
				oldSelectedSlotCursor->setSize(cursorSize);

				int offset = 8;// ((ticks - shootmodeCursor.lastUpdateTick) % TICKS_PER_SECOND < 25) ? largeOffset : smallOffset;

				Uint8 r, g, b, a;
				if ( auto tl = oldSelectedSlotCursor->findImage("hotbar old cursor topleft") )
				{
					tl->pos = SDL_Rect{ offset, offset, tl->pos.w, tl->pos.h };
					getColor(tl->color, &r, &g, &b, &a);
					a = oldSelectedCursorOpacity;
					tl->color = makeColor( r, g, b, a);
				}
				if ( auto tr = oldSelectedSlotCursor->findImage("hotbar old cursor topright") )
				{
					tr->pos = SDL_Rect{ -offset + cursorSize.w - tr->pos.w, offset, tr->pos.w, tr->pos.h };
					tr->color = makeColor( r, g, b, a);
				}
				if ( auto bl = oldSelectedSlotCursor->findImage("hotbar old cursor bottomleft") )
				{
					bl->pos = SDL_Rect{ offset, -offset + cursorSize.h - bl->pos.h, bl->pos.w, bl->pos.h };
					bl->color = makeColor( r, g, b, a);
				}
				if ( auto br = oldSelectedSlotCursor->findImage("hotbar old cursor bottomright") )
				{
					br->pos = SDL_Rect{ -offset + cursorSize.w - br->pos.w, -offset + cursorSize.h - br->pos.h, br->pos.w, br->pos.h };
					br->color = makeColor( r, g, b, a);
				}
			}
		}
	}

	if ( auto selectedSlotCursor = hotbarFrame->findFrame("shootmode selected item cursor") )
	{
		SDL_Rect cursorSize = selectedSlotCursor->getSize();

		const int smallOffset = 2;
		const int largeOffset = 4;

		int offset = ((ticks - shootmodeCursor.lastUpdateTick) % TICKS_PER_SECOND < TICKS_PER_SECOND / 2) ? largeOffset : smallOffset;
		if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
		{
			if ( inputs.getUIInteraction(player.playernum)->selectedItem )
			{
				//offset = largeOffset;
			}
			else
			{
				offset = smallOffset;
			}
		}

		Uint8 r, g, b, a;
		if ( auto tl = selectedSlotCursor->findImage("shootmode selected cursor topleft") )
		{
			tl->pos = SDL_Rect{ offset, offset, tl->pos.w, tl->pos.h };
			getColor(tl->color, &r, &g, &b, &a);
			a = selectedCursorOpacity;
			tl->color = makeColor( r, g, b, a);
		}
		if ( auto tr = selectedSlotCursor->findImage("shootmode selected cursor topright") )
		{
			tr->pos = SDL_Rect{ -offset + cursorSize.w - tr->pos.w, offset, tr->pos.w, tr->pos.h };
			tr->color = makeColor( r, g, b, a);
		}
		if ( auto bl = selectedSlotCursor->findImage("shootmode selected cursor bottomleft") )
		{
			bl->pos = SDL_Rect{ offset, -offset + cursorSize.h - bl->pos.h, bl->pos.w, bl->pos.h };
			bl->color = makeColor( r, g, b, a);
		}
		if ( auto br = selectedSlotCursor->findImage("shootmode selected cursor bottomright") )
		{
			br->pos = SDL_Rect{ -offset + cursorSize.w - br->pos.w, -offset + cursorSize.h - br->pos.h, br->pos.w, br->pos.h };
			br->color = makeColor( r, g, b, a);
		}

		SDL_Rect currentPos = selectedSlotCursor->getSize();
		const int offsetPosition = shootmodeCursor.cursorToSlotOffset;
		if ( shootmodeCursor.animateSetpointX - offsetPosition != currentPos.x
			|| shootmodeCursor.animateSetpointY - offsetPosition != currentPos.y )
		{
			auto& cursor = shootmodeCursor;
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - cursor.animateX)) / (2.5);
			real_t setpointDiffY = fpsScale * std::max(.1, (1.0 - cursor.animateY)) / (2.5);
			cursor.animateX += setpointDiffX;
			cursor.animateY += setpointDiffY;
			cursor.animateX = std::min(1.0, cursor.animateX);
			cursor.animateY = std::min(1.0, cursor.animateY);

			int destX = cursor.animateSetpointX - cursor.animateStartX - offsetPosition;
			int destY = cursor.animateSetpointY - cursor.animateStartY - offsetPosition;

			currentPos.x = cursor.animateStartX + destX * cursor.animateX;
			currentPos.y = cursor.animateStartY + destY * cursor.animateY;
			selectedSlotCursor->setSize(currentPos);
			//messagePlayer(0, "%.2f | %.2f", inventory_t.selectedSlotAnimateX, setpointDiffX);
		}
	}
}

void Player::Inventory_t::processInventory()
{
	if ( !player.characterSheet.sheetFrame )
	{
		player.characterSheet.createCharacterSheet();
	}
	if ( !frame )
	{
		createPlayerInventory(player.playernum);
	}
	if ( !tooltipFrame )
	{
		createInventoryTooltipFrame(player.playernum);
	}

	frame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
		players[player.playernum]->camera_virtualy1(),
		players[player.playernum]->camera_virtualWidth(),
		players[player.playernum]->camera_virtualHeight()});

	bool tooltipWasDisabled = tooltipFrame->isDisabled();

	updateInventory();

	player.shopGUI.updateShop();

	if ( tooltipWasDisabled && !tooltipFrame->isDisabled() )
	{
		tooltipFrame->setOpacity(0.0);
	}
}

void Player::HUD_t::resetBars()
{
	xpInfo.cycleProcessedOnTick = 0;
	xpInfo.cycleStatus = XPInfo_t::CYCLE_NONE;
	xpInfo.cycleTicks = 0;
	xpInfo.fade = 1.0;
	xpInfo.fadeIn = true;
	if ( xpFrame )
	{
		xpBar.animateSetpoint = std::min(100, stats[player.playernum]->EXP) * 10;
		xpBar.animateValue = xpBar.animateSetpoint;
		xpBar.animatePreviousSetpoint = xpBar.animateSetpoint;
		xpBar.animateState = ANIMATE_NONE;
		xpBar.xpLevelups = 0;
	}
	if ( hpFrame )
	{
		HPBar.animateSetpoint = stats[player.playernum]->HP;
		HPBar.animateValue = HPBar.animateSetpoint;
		HPBar.animateValue2 = HPBar.animateSetpoint;
		HPBar.animatePreviousSetpoint = HPBar.animateSetpoint;
		HPBar.animateState = ANIMATE_NONE;
		HPBar.flashAnimState = -1;
		HPBar.flashTicks = 0;
	}
	if ( mpFrame )
	{
		MPBar.animateSetpoint = stats[player.playernum]->MP;
		MPBar.animateValue = MPBar.animateSetpoint;
		MPBar.animateValue2 = MPBar.animateSetpoint;
		MPBar.animatePreviousSetpoint = MPBar.animateSetpoint;
		MPBar.animateState = ANIMATE_NONE;
		MPBar.flashAnimState = -1;
		MPBar.flashTicks = 0;
	}
}


void Player::HUD_t::updateMinimapPrompts()
{
	if ( !mapPromptFrame )
	{
		return;
	}

	bool showPrompts = false;
	if ( gamePaused )
	{
		showPrompts = false;
	}
	else if ( ::minimapFrame && !::minimapFrame->isInvisible() )
	{
		if ( player.hud.offsetHUDAboveHotbarHeight > 0 || !player.shootmode )
		{
			showPrompts = false;
		}
		else
		{
			showPrompts = true;
		}
	}
	else if ( this->minimapFrame && !this->minimapFrame->isInvisible() )
	{
		if ( player.hud.offsetHUDAboveHotbarHeight > 0 )
		{
			showPrompts = false;
		}
		else
		{
			showPrompts = true;
		}
	}

	if ( !showPrompts )
	{
		mapPromptFrame->setDisabled(true);
		return;
	}

	int maxHeight1 = 0;
	int maxHeight2 = 0;
	auto imgPromptFrame = mapPromptFrame->findFrame("img prompt frame");
	auto scalePrompt = imgPromptFrame->findImage("scale prompt");
	scalePrompt->path = Input::inputs[player.playernum].getGlyphPathForBinding("Minimap Scale");
	scalePrompt->disabled = true;
	/*if ( auto imgGet = Image::get(scalePrompt->path.c_str()) )
	{
		scalePrompt->pos.w = imgGet->getWidth();
		scalePrompt->pos.h = imgGet->getHeight();
		maxHeight1 = std::max(maxHeight1, scalePrompt->pos.h);
		scalePrompt->disabled = false;
	}*/
	auto scaleImg = imgPromptFrame->findImage("scale img");
	scaleImg->disabled = true;
	/*if ( !scalePrompt->disabled )
	{
		if ( auto imgGet = Image::get(scaleImg->path.c_str()) )
		{
			scaleImg->pos.w = imgGet->getWidth();
			scaleImg->pos.h = imgGet->getHeight();
			maxHeight1 = std::max(maxHeight1, scaleImg->pos.h);
			scaleImg->disabled = false;
		}
	}*/
	auto expandPrompt = imgPromptFrame->findImage("expand prompt");
	expandPrompt->disabled = true;
	expandPrompt->path = Input::inputs[player.playernum].getGlyphPathForBinding("Toggle Minimap");
	if ( auto imgGet = Image::get(expandPrompt->path.c_str()) )
	{
		expandPrompt->pos.w = imgGet->getWidth();
		expandPrompt->pos.h = imgGet->getHeight();
		maxHeight2 = std::max(maxHeight2, expandPrompt->pos.h);
		expandPrompt->disabled = false;
	}
	auto expandImg = imgPromptFrame->findImage("expand img");
	expandImg->disabled = true;
	if ( !expandPrompt->disabled )
	{
		if ( auto imgGet = Image::get(expandImg->path.c_str()) )
		{
			expandImg->pos.w = imgGet->getWidth();
			expandImg->pos.h = imgGet->getHeight();
			maxHeight2 = std::max(maxHeight2, expandImg->pos.h);
			expandImg->disabled = false;
		}
	}
	std::vector<Frame::image_t*> imgs;
	if ( !expandPrompt->disabled )
	{
		imgs.push_back(expandPrompt);
		imgs.push_back(expandImg);
	}
	if ( !scalePrompt->disabled )
	{
		imgs.push_back(scalePrompt);
		imgs.push_back(scaleImg);
	}
	if ( imgs.empty() )
	{
		mapPromptFrame->setDisabled(true);
		return;
	}

	bool alignHorizontal = !*cvar_minimap_prompt_vertical;
	int imgX = -2;
	int index = -1;
	int lowestY = 0;
	int rightX = 0;

	for ( auto img : imgs )
	{
		++index;
		if ( img->disabled ) 
		{
			continue;
		}
		if ( alignHorizontal )
		{
			imgX += 2;
			if ( index == 2 )
			{
				imgX += 2;
			}
			img->pos.x = imgX;
			img->pos.y = (std::max(maxHeight1, maxHeight2) / 2) - img->pos.h / 2;
			if ( img->pos.y % 2 == 1 )
			{
				++img->pos.y;
			}
			imgX += (img->pos.w);
			lowestY = std::max(lowestY, img->pos.y + img->pos.h);
			rightX = std::max(rightX, img->pos.x + img->pos.h);
		}
		else
		{
			imgX += 2;
			if ( index == 2 )
			{
				imgX = 0;
			}
			img->pos.x = imgX;
			if ( img == scaleImg || img == scalePrompt )
			{
				img->pos.y = (maxHeight1 / 2) - img->pos.h / 2;
			}
			else
			{
				img->pos.y = maxHeight1 + 2 + (maxHeight2 / 2) - img->pos.h / 2;
			}
			if ( img->pos.y % 2 == 1 )
			{
				++img->pos.y;
			}
			imgX += (img->pos.w);
			lowestY = std::max(lowestY, img->pos.y + img->pos.h);
			rightX = std::max(rightX, img->pos.x + img->pos.h);
		}
	}
	if ( !player.minimap.bExpandPromptEnabled )
	{
		expandPrompt->disabled = true;
	}
	if ( !player.minimap.bScalePromptEnabled )
	{
		scalePrompt->disabled = true;
	}

	mapPromptFrame->setDisabled(false);

	auto promptBg = mapPromptFrame->findImage("prompt bg");
	promptBg->disabled = true;

	SDL_Rect pos = mapPromptFrame->getSize();
	if ( hudFrame )
	{
		if ( alignHorizontal )
		{
			if ( auto imgGet = Image::get(promptBg->path.c_str()) )
			{
				if ( imgs.size() > 2 )
				{
					promptBg->path = "*#images/ui/MapAndLog/HUD_MapPromptBase_00.png";
				}
				else
				{
					promptBg->path = "*#images/ui/MapAndLog/HUD_MapPromptBase_Short_00.png";
				}
				promptBg->disabled = false;
				promptBg->pos.w = imgGet->getWidth();
				promptBg->pos.h = imgGet->getHeight();
				pos.w = promptBg->pos.w;
				pos.h = std::max(promptBg->pos.h, lowestY);
				
				SDL_Rect imgPromptFramePos = imgPromptFrame->getSize();
				imgPromptFramePos.w = rightX;
				imgPromptFramePos.h = lowestY;
				imgPromptFramePos.x = pos.w / 2 - imgPromptFramePos.w / 2;
				if ( imgPromptFramePos.x % 2 == 1 )
				{
					++imgPromptFramePos.x;
				}
				imgPromptFramePos.y = (pos.h / 2) - imgPromptFramePos.h / 2;
				if ( imgPromptFramePos.y % 2 == 1 )
				{
					++imgPromptFramePos.y;
				}
				imgPromptFrame->setSize(imgPromptFramePos);
			}
			pos.x = hudFrame->getSize().w - pos.w;
			if ( player.bUseCompactGUIHeight() || player.bUseCompactGUIWidth() )
			{
				if ( imgs.size() > 2 )
				{
					pos.x += 16;
				}
				else
				{
					pos.x += 16;
				}
			}
			pos.y = hudFrame->getSize().h - pos.h - player.hud.offsetHUDAboveHotbarHeight;
		}
		else
		{

			SDL_Rect imgPromptFramePos = imgPromptFrame->getSize();
			imgPromptFramePos.x = 0;
			imgPromptFramePos.y = 0;
			imgPromptFramePos.w = rightX + 8;
			imgPromptFramePos.h = lowestY;
			imgPromptFrame->setSize(imgPromptFramePos);

			pos.w = imgPromptFramePos.w;
			pos.h = imgPromptFramePos.h;
			pos.x = hudFrame->getSize().w - pos.w;
			pos.y = hudFrame->getSize().h - player.minimap.minimapPos.h - pos.h;
		}
	}
	mapPromptFrame->setSize(pos);
}

static ConsoleVariable<bool> cvar_showmapseed("/showmapseed", false);

void Player::HUD_t::updateGameTimer()
{
	if ( !gameTimerFrame )
	{
		return;
	}

	bool overrideGameTimerSetting = false;
	if ( splitscreen && !(player.bUseCompactGUIHeight() && player.bUseCompactGUIWidth())
		&& !player.shootmode && !FollowerMenu[player.playernum].followerMenuIsOpen()
		&& !CalloutMenu[player.playernum].calloutMenuIsOpen()
		&& player.gui_mode != GUI_MODE_NONE )
	{
		if ( compactLayoutMode == COMPACT_LAYOUT_INVENTORY || player.bUseCompactGUIWidth() )
		{
			overrideGameTimerSetting = true;
		}
	}

	if ( overrideGameTimerSetting )
	{
		// display on hud in splitscreen !shootmode
	}
	else
	{
		if ( !player.shootmode || (!player.characterSheet.showGameTimerAlways || splitscreen) )
		{
			gameTimerFrame->setDisabled(true);
			return;
		}
	}

	gameTimerFrame->setDisabled(false);
	SDL_Rect pos = gameTimerFrame->getSize();
	pos.x = hudFrame->getSize().w - pos.w - 6;

	Field* timerText = gameTimerFrame->findField("timer txt");
	SDL_Rect timerTextPos = timerText->getSize();
	timerTextPos.x = 72;
	timerTextPos.y = 1;
	timerText->setSize(timerTextPos);
	
	char buf[64] = "";
	Uint32 sec = (completionTime / TICKS_PER_SECOND) % 60;
	Uint32 min = ((completionTime / TICKS_PER_SECOND) / 60) % 60;
	Uint32 hour = (((completionTime / TICKS_PER_SECOND) / 60) / 60) % 24;
	Uint32 day = ((completionTime / TICKS_PER_SECOND) / 60) / 60 / 24;

	auto seed = gameTimerFrame->findField("seed txt");
	seed->setDisabled(true);
	if ( *cvar_showmapseed )
	{
		seed->setDisabled(false);
		pos.h = 44;
		char seedbuf[32];
		snprintf(seedbuf, sizeof(seedbuf), "%u", mapseed);
		seed->setSize(SDL_Rect{ 0, 21, pos.w, 24 });
		seed->setText(seedbuf);
	}
	else
	{
		pos.h = 24;
	}

	pos.y = gameTimerFrame->getParent()->getSize().h - pos.h;

	if ( player.hud.mapPromptFrame && !player.hud.mapPromptFrame->isDisabled() )
	{
		SDL_Rect mapPromptPos = player.hud.mapPromptFrame->getSize();
		pos.y = mapPromptPos.y + mapPromptPos.h / 2 - pos.h / 2;
		pos.x = mapPromptPos.x - pos.w - 4;
		if ( splitscreen && (player.bUseCompactGUIHeight() || player.bUseCompactGUIWidth()) )
		{
			pos.x += 16;
		}
	}

	if ( day > 0 )
	{
		snprintf(buf, sizeof(buf), "%02d:%02d:%02d:%02d", day, hour, min, sec);
		pos.x -= 24;
	}
	else
	{
		snprintf(buf, sizeof(buf), "%02d:%02d:%02d", hour, min, sec);
	}

	gameTimerFrame->setSize(pos);
	timerText->setText(buf);
}

void Player::HUD_t::updateXPBar()
{
	if ( !xpFrame )
	{
		return;
	}

	bool bCompactWidth = false;
	bool bCompactHeight = player.bUseCompactGUIHeight();
	if ( player.bUseCompactGUIWidth() 
		|| (keystatus[SDLK_t] && enableDebugKeys)
		|| (!player.bUseCompactGUIWidth() && player.bUseCompactGUIHeight() && *MainMenu::clipped_splitscreen) )
	{
		bCompactWidth = true;
	}

	xpFrame->setInheritParentFrameOpacity(false);
	xpFrame->setOpacity(100.0);
	SDL_Rect pos = xpFrame->getSize();
	pos.w = XP_FRAME_WIDTH + (bCompactWidth ? xpbarCompactOffsetWidth : xpbarOffsetWidth);
	pos.x = hudFrame->getSize().w / 2 - pos.w / 2;
	if ( bCompactWidth || bCompactHeight )
	{
		pos.y = 0 + ((bCompactWidth || bCompactHeight) ? xpbarCompactOffsetY : xpbarOffsetY);
	}
	else
	{
		pos.y = 8 + ((bCompactWidth || bCompactHeight) ? xpbarCompactOffsetY : xpbarOffsetY);
	}

	bool tempHideXP = false;
	bool fadeOut = false;
	if ( !levelUpAnimation[player.playernum].lvlUps.empty() && !levelUpAnimation[player.playernum].lvlUps[0].titleFinishAnim )
	{
		tempHideXP = true;
	}
	else if ( (player.gui_mode == GUI_MODE_FOLLOWERMENU || player.gui_mode == GUI_MODE_CALLOUT
		|| player.minimap.mapWindow || player.messageZone.logWindow)
		&& player.bUseCompactGUIHeight() )
	{
		tempHideXP = true;
	}
	else if ( player.bUseCompactGUIHeight() && player.shootmode && !skillUpAnimation[player.playernum].skillUps.empty()
		&& !(!levelUpAnimation[player.playernum].lvlUps.empty() && levelUpAnimation[player.playernum].lvlUps[0].titleFinishAnim) )
	{
		// hide xp in compact height, if skillup active and level up isn't playing
		tempHideXP = true;
		fadeOut = true;
	}
	if ( tempHideXP )
	{
		if ( fadeOut )
		{
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			real_t setpointDiff = fpsScale * std::max(.1, (1.0 - animHideXP)) / 2.5;
			animHideXP += setpointDiff;
			animHideXP = std::min(1.0, animHideXP);
		}
		else
		{
			animHideXP = 1.0;
		}
	}
	else
	{
		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
		real_t setpointDiff = fpsScale * std::max(.1, (animHideXP)) / 2.5;
		animHideXP -= setpointDiff;
		animHideXP = std::max(0.0, animHideXP);
	}
	//pos.y -= animHideXP * (pos.y + pos.h);
	xpFrame->setOpacity((1.0 - animHideXP) * 100.0);
	xpFrame->setSize(pos);

	auto xpBg = xpFrame->findImage("xp img base");
	auto xpProgress = xpFrame->findImage("xp img progress");
	xpProgress->disabled = true;
	auto xpProgressEndCap = xpFrame->findImage("xp img progress endcap");
	auto endCapRight = xpFrame->findImage("xp img endcap right");
	xpBg->pos.w = pos.w;
	if ( auto xpBgFlair = xpFrame->findImage("xp img base flair") )
	{
		xpBgFlair->pos.w = pos.w - 8;
	}
	endCapRight->pos.x = pos.w - endCapRight->pos.w;

	xpBar.animateSetpoint = std::min(100, stats[player.playernum]->EXP);
	xpBar.maxValue = 1000.0;

	if ( xpBar.animateState == ANIMATE_LEVELUP_RISING )
	{
		xpBar.animateTicks = ticks;

		real_t fpsScale = getFPSScale(144.0);
		xpBar.animateValue += fpsScale * (10); // constant speed
		xpBar.animateValue = std::min(xpBar.maxValue, xpBar.animateValue);
		if ( xpBar.animateValue == xpBar.maxValue )
		{
			xpBar.animateState = ANIMATE_LEVELUP_FALLING;
		}
	}
	else if ( xpBar.animateState == ANIMATE_LEVELUP_FALLING )
	{
		if ( ticks - xpBar.animateTicks > TICKS_PER_SECOND * 2 )
		{
			int decrement = 40;
			double scaledDecrement = (decrement * (getFPSScale(144.0)));
			xpBar.animateValue -= scaledDecrement;
			if ( xpBar.animateValue <= 0 )
			{
				xpBar.animateValue = 0.0;
				xpBar.xpLevelups = 0; // disable looping maybe one day use it
				if ( xpBar.xpLevelups > 1 )
				{
					--xpBar.xpLevelups;
					xpBar.animateState = ANIMATE_LEVELUP_RISING;
				}
				else
				{
					xpBar.xpLevelups = 0;
					xpBar.animateState = ANIMATE_NONE;
				}
			}
		}
	}
	else
	{
		int increment = 3;
		double scaledIncrement = (increment * (getFPSScale(144.0)));
		if ( xpBar.animateValue < xpBar.animateSetpoint * 10 )
		{
			//real_t diff = std::max(.1, (xpBar.animateSetpoint * 10 - xpBar.animateValue) / 200.0); // 0.1-5 value
			//if ( xpBar.animateSetpoint * 10 >= xpBar.maxValue )
			//{
			//	diff = 5;
			//}
			//scaledIncrement *= 0.2 * pow(diff, 2) + .5;
			//xpBar.animateValue = std::min(xpBar.animateSetpoint * 10.0, xpBar.animateValue + scaledIncrement);

			real_t setpointDiff = std::max(10.0, xpBar.animateSetpoint * 10.0 - xpBar.animateValue);
			real_t fpsScale = getFPSScale(144.0);
			xpBar.animateValue += fpsScale * (setpointDiff / 100.0); // reach it in x intervals, scaled to FPS
			xpBar.animateValue = std::min(static_cast<real_t>(xpBar.animateSetpoint * 10.0), xpBar.animateValue);
			//messagePlayer(0, "%.2f | %.2f", diff, scaledIncrement);
		}
		else if ( xpBar.animateValue > xpBar.animateSetpoint * 10 )
		{
			xpBar.animateValue = xpBar.animateSetpoint * 10; // invalid state, reset progress bar
		}
		//else if ( xpBar.animateValue > xpBar.animateSetpoint * 10 )
		//{
		//	real_t fpsScale = getFPSScale(144.0);
		//	xpBar.animateValue += fpsScale * (10); // constant speed
		//	xpBar.animateValue = std::min(xpBar.maxValue, xpBar.animateValue);
		//}
		//else
		//{
		//	xpBar.animateTicks = ticks;
		//}

		xpBar.animateTicks = ticks;

		//if ( xpBar.animateValue == xpBar.maxValue )
		//{
		//	xpBar.animateState = ANIMATE_LEVELUP;
		//}
	}

	//if ( xpInfo.cycleProcessedOnTick != ticks )
	//{
	//	++xpInfo.cycleTicks;
	//}

	//if ( bCompactWidth )
	//{
	//	if ( xpInfo.cycleStatus == XPInfo_t::CYCLE_NONE )
	//	{
	//		xpInfo.cycleStatus = XPInfo_t::CYCLE_LVL;
	//	}

	//	if ( !xpInfo.fadeIn )
	//	{
	//		xpInfo.cycleTicks = 0;
	//	}

	//	if ( xpInfo.cycleTicks > 0 && 
	//		(xpInfo.cycleTicks >= TICKS_PER_SECOND * 5 || xpBar.animateState != ANIMATE_NONE) )
	//	{
	//		xpInfo.fadeIn = false;
	//	}

	//	if ( !xpInfo.fadeIn )
	//	{
	//		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
	//		real_t setpointDiffX = fpsScale * std::max(.1, (xpInfo.fade)) / (2.5);
	//		xpInfo.fade -= setpointDiffX;
	//		xpInfo.fade = std::max(0.0, xpInfo.fade);
	//		if ( xpInfo.fade <= 0.0 )
	//		{
	//			if ( xpInfo.cycleStatus == XPInfo_t::CYCLE_LVL )
	//			{
	//				xpInfo.cycleStatus = XPInfo_t::CYCLE_XP;
	//			}
	//			else
	//			{
	//				xpInfo.cycleStatus = XPInfo_t::CYCLE_LVL;
	//			}
	//			xpInfo.fadeIn = true;
	//		}
	//	}
	//	else
	//	{
	//		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
	//		real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - xpInfo.fade)) / (2.5);
	//		xpInfo.fade += setpointDiffX;
	//		xpInfo.fade = std::min(1.0, xpInfo.fade);
	//	}

	//	messagePlayer(0, MESSAGE_DEBUG, "%f", xpInfo.fade);
	//}
	//else
	{
		xpInfo.cycleStatus = XPInfo_t::CYCLE_NONE;
		xpInfo.cycleTicks = 0;
		xpInfo.fade = 1.0;
	}

	{
		char playerXPText[16];
		
		auto xpTextStatic = xpFrame->findField("xp text static");
		SDL_Rect xpTextStaticPos = xpTextStatic->getSize();

		int offsetx = pos.w / 2 - xpTextStaticPos.w - 24;
		if ( bCompactWidth )
		{
			xpTextStatic->setDisabled(true);
			snprintf(playerXPText, sizeof(playerXPText), "%.f %s", xpBar.animateValue / 10, Language::get(6107));
		}
		else
		{
			snprintf(playerXPText, sizeof(playerXPText), "%.f", xpBar.animateValue / 10);
			xpTextStatic->setDisabled(false);
		}

		xpTextStaticPos.x = pos.w / 2 - 4 + offsetx;
		xpTextStatic->setSize(xpTextStaticPos);
		auto xpText = xpFrame->findField("xp text current");
		xpText->setText(playerXPText);
		SDL_Rect xpTextPos = xpText->getSize();
		if ( bCompactWidth )
		{
			xpTextPos.x = pos.w - 32 - xpTextPos.w;
		}
		else
		{
			xpTextPos.x = pos.w / 2 - (4 * 2) - xpTextPos.w + offsetx;
		}
		xpText->setSize(xpTextPos);

		if ( xpInfo.cycleStatus != XPInfo_t::CYCLE_NONE )
		{
			Uint8 r, g, b, a;
			getColor(xpText->getColor(), &r, &g, &b, &a);
			if ( xpInfo.cycleStatus == XPInfo_t::CYCLE_XP )
			{
				a = 255 * xpInfo.fade;
			}
			else
			{
				a = 0;
			}
			xpText->setColor(makeColor(r, g, b, a));
			xpTextStatic->setColor(makeColor(r, g, b, a));
		}
	}

	{
		auto textLevel = xpFrame->findField("xp text lvl");
		textLevel->setDisabled(false);
		char textLevelBuf[64];
		snprintf(textLevelBuf, sizeof(textLevelBuf), "LVL %d", stats[player.playernum]->LVL);
		textLevel->setText(textLevelBuf);
		SDL_Rect textPos = textLevel->getSize();

		if ( auto textGet = textLevel->getTextObject() )
		{
			textPos.w = textGet->getWidth();
		}
		textPos.x = 32;
		textLevel->setSize(textPos);
		
		{
			if ( xpInfo.cycleStatus != XPInfo_t::CYCLE_NONE )
			{
				Uint8 r, g, b, a;
				getColor(textLevel->getColor(), &r, &g, &b, &a);
				if ( xpInfo.cycleStatus == XPInfo_t::CYCLE_LVL )
				{
					a = 255 * xpInfo.fade;
				}
				else
				{
					a = 0;
				}
				textLevel->setColor(makeColor(r, g, b, a));
			}
		}

		auto textClass = xpFrame->findField("xp text class");
		textClass->setDisabled(true);
		if ( !bCompactWidth )
		{
			std::string classname = playerClassLangEntry(client_classes[player.playernum], player.playernum);
			if ( !classname.empty() )
			{
				capitalizeString(classname);
				textClass->setText(classname.c_str());
				textClass->setDisabled(false);
			}
			if ( true )
			{
				textClass->setColor(0xFFFFFFFF);
			}
			else if ( client_classes[player.playernum] >= CLASS_CONJURER && client_classes[player.playernum] <= CLASS_BREWER )
			{
				textClass->setColor(hudColors.characterDLC1ClassText);
			}
			else if ( client_classes[player.playernum] >= CLASS_MACHINIST && client_classes[player.playernum] <= CLASS_HUNTER )
			{
				textClass->setColor(hudColors.characterDLC2ClassText);
			}
			else
			{
				textClass->setColor(hudColors.characterBaseClassText);
			}
			{
				SDL_Rect textPos2 = textClass->getSize();
				if ( auto textGet = textClass->getTextObject() )
				{
					textPos2.w = textGet->getWidth();
				}
				textPos2.x = textPos.x + textPos.w + 8;
				textClass->setSize(textPos2);

				if ( xpInfo.cycleStatus != XPInfo_t::CYCLE_NONE )
				{
					Uint8 r, g, b, a;
					getColor(textClass->getColor(), &r, &g, &b, &a);
					if ( xpInfo.cycleStatus == XPInfo_t::CYCLE_LVL )
					{
						a = 255 * xpInfo.fade;
					}
					else
					{
						a = 0;
					}
					textClass->setColor(makeColor(r, g, b, a));
				}
			}
		}
	}


	real_t percent = xpBar.animateValue / 1000.0;
	xpProgress->pos.w = std::max(1, static_cast<int>((xpBg->pos.w - xpProgressEndCap->pos.w) * percent));
	if ( !xpProgress->disabled )
	{
		xpProgressEndCap->pos.x = xpProgress->pos.x + xpProgress->pos.w;
	}

	auto xpProgressClipFrame = xpFrame->findFrame("xp progress clipping frame");
	SDL_Rect clipFramePos = xpProgressClipFrame->getSize();
	clipFramePos.w = std::max(1, static_cast<int>((xpBg->pos.w ) * percent));
	if ( xpProgress->disabled )
	{
		xpProgressEndCap->pos.x = clipFramePos.x + clipFramePos.w;

		bool animate = true;
		if ( ticks % 5 == 0 )
		{
			bool moving = (xpBar.animateSetpoint * 10.0 - xpBar.animateValue != 0);
			std::string playerStr = "00";
			switch ( player.playernum )
			{
				case 0:
				default:
					break;
				case 1:
					playerStr = "01";
					break;
				case 2:
					playerStr = "02";
					break;
				case 3:
					playerStr = "03";
					break;
			}
			int xpPathNum = player.playernum;
			if ( player.playernum >= playerXPCapPaths.size() )
			{
				xpPathNum = 0;
			}
			if ( moving && xpProgressEndCap->path == playerXPCapPaths[xpPathNum][0] )
			{
				xpProgressEndCap->path = playerXPCapPaths[xpPathNum][1];
			}
			else if ( xpProgressEndCap->path == playerXPCapPaths[xpPathNum][1] )
			{
				xpProgressEndCap->path = playerXPCapPaths[xpPathNum][2];
			}
			else if ( xpProgressEndCap->path == playerXPCapPaths[xpPathNum][2] )
			{
				xpProgressEndCap->path = playerXPCapPaths[xpPathNum][3];
			}
			else if ( xpProgressEndCap->path == playerXPCapPaths[xpPathNum][3] )
			{
				xpProgressEndCap->path = playerXPCapPaths[xpPathNum][4];
			}
			else if ( xpProgressEndCap->path == playerXPCapPaths[player.playernum][4] )
			{
				xpProgressEndCap->path = playerXPCapPaths[xpPathNum][0];
			}
		}
	}
	xpProgressClipFrame->setSize(clipFramePos);
	auto xpProgressClipFrameImg = xpProgressClipFrame->findImage("xp img progress clipped");
	xpProgressClipFrameImg->pos.x = -(xpProgressClipFrameImg->pos.w - pos.w) / 2;
}

bool EnemyHPDamageBarHandler::bEnemyBarSimpleBlit = false;
static ConsoleVariable<bool> cvar_enemybar_simple_blit("/enemybar_simple_blit", true);

// to nest deep maps and suppress visual studio warnings
struct enemybarMapLowDurationTick_k {
	std::map<bool, SDL_Surface*> m;
	~enemybarMapLowDurationTick_k()
	{
		if ( EnemyHPDamageBarHandler::bEnemyBarSimpleBlit )
		{
			for ( auto& entry : m )
			{
				if ( entry.second )
				{
					SDL_FreeSurface(entry.second);
					entry.second = nullptr;
				}
			}
		}
	};
};
struct enemybarEffectMapFx2_lowDuration_k {
	std::map<Uint32, enemybarMapLowDurationTick_k> m;
};
struct enemybarEffectMapFx1_lowDuration_k {
	std::map<Uint32, enemybarEffectMapFx2_lowDuration_k> m;
};
struct enemybarEffectMapFx2_k {
	std::map<Uint32, enemybarEffectMapFx1_lowDuration_k> m;
};
struct enemybarEffectMapFx1_k {
	std::map<Uint32, enemybarEffectMapFx2_k> m;
};
enemybarEffectMapFx1_k enemyBarEffectMap;
SDL_Surface* enemyBarEffectMapExists(Uint32 fx1, Uint32 fx2, Uint32 fx_lowDuration1, Uint32 fx_lowDuration2, bool lowDurationTicks)
{
	if ( enemyBarEffectMap.m.find(fx1) != enemyBarEffectMap.m.end() )
	{
		auto& m1 = enemyBarEffectMap.m[fx1];
		if ( m1.m.find(fx2) != m1.m.end() )
		{
			auto& m2 = m1.m[fx2];
			if ( m2.m.find(fx_lowDuration1) != m2.m.end() )
			{
				auto& m3 = m2.m[fx_lowDuration1];
				if ( m3.m.find(fx_lowDuration2) != m3.m.end() )
				{
					auto& m4 = m3.m[fx_lowDuration2];
					if ( m4.m.find(lowDurationTicks) != m4.m.end() )
					{
						return m4.m[lowDurationTicks];
					}
				}
			}
		}
	}
	return nullptr;
}
void enemyBarEffectMapInsert(Uint32 fx1, Uint32 fx2, Uint32 fx_lowDuration1, Uint32 fx_lowDuration2, bool lowDurationTicks,
	SDL_Surface* surf)
{
	enemyBarEffectMap.m[fx1].m[fx2].m[fx_lowDuration1].m[fx_lowDuration2].m[lowDurationTicks] = surf;
}

// to nest deep maps and suppress visual studio warnings
struct enemybarMapFx2_lowDuration_k {
	std::map<Uint32, SDL_Surface*> m;
	~enemybarMapFx2_lowDuration_k()
	{
		if ( EnemyHPDamageBarHandler::bEnemyBarSimpleBlit )
		{
			for ( auto& entry : m )
			{
				if ( entry.second )
				{
					SDL_FreeSurface(entry.second);
					entry.second = nullptr;
				}
			}
		}
	};
};
struct enemybarMapFx1_lowDuration_k {
	std::map<Uint32, enemybarMapFx2_lowDuration_k> m;
};
struct enemybarMapFx2_k {
	std::map<Uint32, enemybarMapFx1_lowDuration_k> m;
};
struct enemybarMapFx1_k {
	std::map<Uint32, enemybarMapFx2_k> m;
};
struct enemybarMapProgress_k {
	std::map<Uint32, enemybarMapFx1_k> m;
};
struct enemybarMapTotalSize_k {
	std::map<Uint32, enemybarMapProgress_k> m;
};
struct enemybarMapName_k {
	std::map<std::string, enemybarMapTotalSize_k> m;
};
enemybarMapName_k enemyBarMap;
SDL_Surface* enemyBarMapExists(std::string name, int baseWidth, int baseHeight,
	int progressWidth, int damageWidth,
	Uint32 fx1, Uint32 fx2, Uint32 fx_lowDuration1, Uint32 fx_lowDuration2)
{
	if ( enemyBarMap.m.find(name) != enemyBarMap.m.end() )
	{
		auto& m1 = enemyBarMap.m[name];
		Uint32 totalSizeKey = baseWidth & 0xFFFF;
		totalSizeKey |= (baseHeight << 16) & 0xFF0000;
		totalSizeKey |= (((ticks % 25) >= 12) << 24) & 0xFF000000;
		if ( m1.m.find(totalSizeKey) != m1.m.end() )
		{
			auto& m2 = m1.m[totalSizeKey];
			Uint32 progressDamageKey = progressWidth & 0xFFFF;
			progressDamageKey |= (damageWidth << 16) & 0xFFFF0000;
			if ( m2.m.find(progressDamageKey) != m2.m.end() )
			{
				auto& m3 = m2.m[progressDamageKey];
				if ( m3.m.find(fx1) != m3.m.end() )
				{
					auto& m4 = m3.m[fx1];
					if ( m4.m.find(fx2) != m4.m.end() )
					{
						auto& m5 = m4.m[fx2];
						if ( m5.m.find(fx_lowDuration1) != m5.m.end() )
						{
							auto& m6 = m5.m[fx_lowDuration1];
							if ( m6.m.find(fx_lowDuration2) != m6.m.end() )
							{
								return m6.m[fx_lowDuration2];
							}
						}
					}
				}
			}
		}
	}
	return nullptr;
}
static void  enemyBarMapInsert(std::string name, int baseWidth, int baseHeight, int progressWidth, int damageWidth,
	Uint32 statusfx1, Uint32 statusfx2,
	Uint32 statusfx_lowDuration1, Uint32 statusfx_lowDuration2,
	SDL_Surface* surf)
{
	Uint32 totalSizeKey = baseWidth & 0xFFFF;
	totalSizeKey |= (baseHeight << 16) & 0xFF0000;
	totalSizeKey |= (((ticks % 25) >= 12) << 24) & 0xFF000000;
	Uint32 progressDamageKey = progressWidth & 0xFFFF;
	progressDamageKey |= ((damageWidth & 0xFFFF) << 16);
	enemyBarMap.m[name].m[totalSizeKey].m[progressDamageKey].m[statusfx1].m[statusfx2].m[statusfx_lowDuration1].m[statusfx_lowDuration2] = surf;
}

SDL_Surface* EnemyHPDamageBarHandler::EnemyHPDetails::blitEnemyBar(const int player, SDL_Surface* statusEffectSprite)
{
	Frame* frame = players[player]->hud.enemyBarFrame;
	if ( !frame || !players[player]->isLocalPlayer() )
	{
		return nullptr;
	}

	auto baseBg = frame->findImage("base img");
	auto baseEndCap = frame->findImage("base img endcap");
	real_t frameOpacity = frame->getOpacity() / 100.0;
	frameOpacity = 1.0;
	/*if ( EnemyHPDamageBarHandler::bEnemyBarSimpleBlit )
	{
		frameOpacity = 1.0;
	}*/

	auto foregroundFrame = frame->findFrame("bar progress frame");
	auto hpProgress = foregroundFrame->findImage("progress img");
	auto hpProgressEndcap = foregroundFrame->findImage("progress img endcap");

	auto dmgFrame = frame->findFrame("bar dmg frame");
	auto dmgProgress = dmgFrame->findImage("dmg img");
	auto dmgEndCap = dmgFrame->findImage("dmg img endcap");

	auto nameField = frame->findField("enemy name txt");

	auto skullFrame = frame->findFrame("skull frame");
	int totalWidth = baseBg->pos.x + baseBg->pos.w + baseEndCap->pos.w;
	int totalHeight = frame->getSize().h;
	int statusEffectOffsetY = 0;

	if ( statusEffectSprite ) 
	{ 
		statusEffectOffsetY = statusEffectSprite->h;
		totalHeight += statusEffectOffsetY;
	}

	SDL_Surface* hashSurf = nullptr;
	if ( EnemyHPDamageBarHandler::bEnemyBarSimpleBlit )
	{
		hashSurf = enemyBarMapExists(nameField->getText(), 
			totalWidth, totalHeight, 
			dmgProgress->pos.w, hpProgress->pos.w,
			enemy_statusEffects1,
			enemy_statusEffects2,
			enemy_statusEffectsLowDuration1,
			enemy_statusEffectsLowDuration2);
		if ( !hashSurf )
		{
			//messagePlayer(0, MESSAGE_DEBUG, "Hash for enemy bar not found!");
		}
		else
		{
			return hashSurf;
		}
	}

	SDL_Surface* sprite = SDL_CreateRGBSurface(0, totalWidth, totalHeight, 32,
		0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000);
	for ( auto& img : frame->getImages() )
	{
		SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
		Uint8 r, g, b, a;
		getColor(img->color, &r, &g, &b, &a);
		SDL_SetSurfaceAlphaMod(srcSurf, a * frameOpacity);
		SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
		SDL_Rect pos = img->pos;
		pos.y += statusEffectOffsetY;
		SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
	}
	for ( auto& img : dmgFrame->getImages() )
	{
		SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
		Uint8 r, g, b, a;
		getColor(img->color, &r, &g, &b, &a);
		if ( EnemyHPDamageBarHandler::bEnemyBarSimpleBlit && a < 255 ) { continue; }
		SDL_SetSurfaceAlphaMod(srcSurf, a * frameOpacity);
		//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
		SDL_Rect pos = img->pos;
		pos.x += dmgFrame->getSize().x;
		pos.y += dmgFrame->getSize().y;
		pos.y += statusEffectOffsetY;
		SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
	}
	for ( auto& img : foregroundFrame->getImages() )
	{
		SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
		Uint8 r, g, b, a;
		getColor(img->color, &r, &g, &b, &a);
		SDL_SetSurfaceAlphaMod(srcSurf, a * frameOpacity);
		//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
		SDL_Rect pos = img->pos;
		pos.x += foregroundFrame->getSize().x;
		pos.y += foregroundFrame->getSize().y;
		pos.y += statusEffectOffsetY;
		SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
	}
	for ( auto& img : skullFrame->getImages() )
	{
		SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
		Uint8 r, g, b, a;
		getColor(img->color, &r, &g, &b, &a);
		if ( EnemyHPDamageBarHandler::bEnemyBarSimpleBlit && a < 255 ) { continue; }
		SDL_SetSurfaceAlphaMod(srcSurf, a * frameOpacity);
		SDL_Rect pos = img->pos;
		pos.x += skullFrame->getSize().x;
		pos.y += skullFrame->getSize().y;
		pos.y += statusEffectOffsetY;
		SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
	}
	for ( auto& txt : frame->getFields() )
	{
		auto textGet = Text::get(txt->getText(), txt->getFont(),
			makeColor(255, 255, 255, 255), makeColor(0, 0, 0, 255));
		SDL_Surface* txtSurf = const_cast<SDL_Surface*>(textGet->getSurf());
		SDL_Rect pos;
		pos.w = textGet->getWidth();
		pos.h = textGet->getHeight();
		pos.x = sprite->w / 2 - pos.w / 2;
		pos.y = frame->getSize().h / 2 - pos.h / 2;
		pos.y += statusEffectOffsetY;
		Uint8 r, g, b, a;
		getColor(txt->getColor(), &r, &g, &b, &a);
		SDL_SetSurfaceAlphaMod(txtSurf, a * frameOpacity);
		SDL_BlitSurface(txtSurf, nullptr, sprite, &pos);
	}
	if ( statusEffectSprite )
	{
		int status_x = (sprite->w / 2) - (statusEffectSprite->w / 2);
		SDL_Rect pos{ status_x, 0, statusEffectSprite->w, statusEffectSprite->h};
		SDL_BlitSurface(statusEffectSprite, nullptr, sprite, &pos);
	}

	if ( !hashSurf && EnemyHPDamageBarHandler::bEnemyBarSimpleBlit )
	{
		enemyBarMapInsert(nameField->getText(), 
			totalWidth, totalHeight, 
			dmgProgress->pos.w, hpProgress->pos.w, 
			enemy_statusEffects1,
			enemy_statusEffects2,
			enemy_statusEffectsLowDuration1,
			enemy_statusEffectsLowDuration2,
			sprite);
	}
	return sprite;
}

SDL_Surface* EnemyHPDamageBarHandler::EnemyHPDetails::blitEnemyBarStatusEffects(const int player)
{
	Entity* entity = uidToEntity(enemy_uid);
	if ( entity && (entity->behavior != &actPlayer && entity->behavior != &actMonster) )
	{
		return nullptr;
	}
	Frame* frame = players[player]->hud.enemyBarFrame;
	if ( !frame || !players[player]->isLocalPlayer() )
	{
		return nullptr;
	}
	if ( enemy_statusEffects1 == 0 && enemy_statusEffects2 == 0 )
	{
		return nullptr;
	}
	//auto baseBg = frame->findImage("base img");
	//auto baseEndCap = frame->findImage("base img endcap");
	//const int maxWidth = baseBg->pos.x + baseBg->pos.w + baseEndCap->pos.w;
	const int iconHeight = 32;
	const int iconWidth = 32;

	SDL_Surface* hashSurf = nullptr;
	if ( EnemyHPDamageBarHandler::bEnemyBarSimpleBlit )
	{
		hashSurf = enemyBarEffectMapExists(
			enemy_statusEffects1,
			enemy_statusEffects2,
			enemy_statusEffectsLowDuration1,
			enemy_statusEffectsLowDuration2,
			(ticks % 25) >= 12);
		if ( !hashSurf )
		{
			//messagePlayer(0, MESSAGE_DEBUG, "Hash for enemy effects not found!");
		}
		else
		{
			return hashSurf;
		}
	}

	int playernum = -1;
	if ( entity && entity->behavior == &actPlayer )
	{
		playernum = entity->skill[2];
	}

	int currentX = 0; // (maxWidth / 2);
	bool anyStatusEffect = false;

	std::vector<std::pair<SDL_Surface*, bool>> statusEffectIcons;
	if ( enemy_statusEffects1 != 0 )
	{
		for ( int i = 0; i < 32; ++i )
		{
			if ( (enemy_statusEffects1 & (1 << i)) != 0 )
			{
				if ( StatusEffectQueue_t::StatusEffectDefinitions_t::effectDefinitionExists(i) )
				{
					int variation = -1;
					SDL_Surface* srcSurf = nullptr;
					if ( i == EFF_SHAPESHIFT )
					{
						if ( entity && entity->behavior == &actPlayer )
						{
							switch ( entity->effectShapeshift )
							{
								case RAT:
									variation = 0;
									break;
								case SPIDER:
									variation = 1;
									break;
								case TROLL:
									variation = 2;
									break;
								case CREATURE_IMP:
									variation = 3;
									break;
								default:
									break;
							}
						}
					}
					auto& definition = StatusEffectQueue_t::StatusEffectDefinitions_t::getEffect(i);
					if ( !definition.neverDisplay )
					{
						std::string imgPath;
						if ( i == EFF_SHAPESHIFT && variation == -1 )
						{
							imgPath = "";
						}
						else
						{
							imgPath = StatusEffectQueue_t::StatusEffectDefinitions_t::getEffectImgPath(definition, variation);
						}
						if ( imgPath != "" )
						{
							srcSurf = const_cast<SDL_Surface*>(Image::get(imgPath.c_str())->getSurf());

							bool blinking = false;
							if ( (enemy_statusEffectsLowDuration1 & (1 << i)) != 0 )
							{
								blinking = true;
							}
							statusEffectIcons.push_back(std::make_pair(srcSurf, blinking));
						}
					}
				}
			}
		}
	}
	if ( enemy_statusEffects2 != 0 )
	{
		for ( int i = 0; i < 32; ++i )
		{
			if ( (enemy_statusEffects2 & (1 << i)) != 0 )
			{
				int effectID = i + 32;
				if ( StatusEffectQueue_t::StatusEffectDefinitions_t::effectDefinitionExists(effectID) )
				{
					int variation = -1;
					SDL_Surface* srcSurf = nullptr;
					if ( i == EFF_SHAPESHIFT )
					{
						if ( entity && entity->behavior == &actPlayer )
						{
							switch ( entity->effectShapeshift )
							{
								case RAT:
									variation = 0;
									break;
								case SPIDER:
									variation = 1;
									break;
								case TROLL:
									variation = 2;
									break;
								case CREATURE_IMP:
									variation = 3;
									break;
								default:
									break;
							}
						}
					}
					auto& definition = StatusEffectQueue_t::StatusEffectDefinitions_t::getEffect(effectID);
					if ( !definition.neverDisplay )
					{
						std::string imgPath;
						if ( i == EFF_SHAPESHIFT && variation == -1 )
						{
							imgPath = "";
						}
						else
						{
							imgPath = StatusEffectQueue_t::StatusEffectDefinitions_t::getEffectImgPath(definition, variation);
						}
						if ( imgPath != "" )
						{
							srcSurf = const_cast<SDL_Surface*>(Image::get(imgPath.c_str())->getSurf());

							bool blinking = false;
							if ( (enemy_statusEffectsLowDuration2 & (1 << i)) != 0 )
							{
								blinking = true;
							}
							statusEffectIcons.push_back(std::make_pair(srcSurf, blinking));
						}
					}
				}
			}
		}
	}

	//const int numIcons = statusEffectIcons.size();
	//const int iconTotalWidth = iconWidth + 2;
	//if ( numIcons % 2 == 1 ) // odd numbered
	//{
	//	currentX -= ((iconTotalWidth) * (numIcons / 2)) + (iconTotalWidth / 2);
	//}
	//else
	//{
	//	currentX -= ((iconTotalWidth) * (numIcons / 2));
	//}

	if ( statusEffectIcons.empty() )
	{
		return nullptr;
	}

	SDL_Surface* sprite = SDL_CreateRGBSurface(0, (iconWidth + 2) * statusEffectIcons.size(), iconHeight + 2, 32,
		0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000);

	for ( auto& icon : statusEffectIcons )
	{
		anyStatusEffect = true;
		int tickModifier = ticks % 25;
		real_t alpha = 255;
		/*if ( !EnemyHPDamageBarHandler::bEnemyBarSimpleBlit )
		{
			const real_t frameOpacity = frame->getOpacity() / 100.0;
			alpha *= frameOpacity;
		}*/
		if ( tickModifier >= 12 && icon.second )
		{
			alpha = 0;
		}
		SDL_SetSurfaceAlphaMod(icon.first, alpha);
		//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
		SDL_Rect pos{ currentX, 0, iconWidth, iconHeight };
		SDL_BlitScaled(icon.first, nullptr, sprite, &pos);
		currentX += (iconWidth + 2);
	}

	if ( !hashSurf && EnemyHPDamageBarHandler::bEnemyBarSimpleBlit )
	{
		enemyBarEffectMapInsert(
			enemy_statusEffects1,
			enemy_statusEffects2,
			enemy_statusEffectsLowDuration1,
			enemy_statusEffectsLowDuration2,
			(ticks % 25) >= 12,
			sprite);
	}
	return sprite;
}

EnemyHPDamageBarHandler::EnemyHPDetails::~EnemyHPDetails()
{
	if ( worldTexture )
	{
		delete worldTexture;
		worldTexture = nullptr;
	}
	if ( !bEnemyBarSimpleBlit )
	{
		if ( worldSurfaceSpriteStatusEffects ) {
			SDL_FreeSurface(worldSurfaceSpriteStatusEffects);
			worldSurfaceSpriteStatusEffects = nullptr;
		}
		if ( worldSurfaceSprite ) {
			SDL_FreeSurface(worldSurfaceSprite);
			worldSurfaceSprite = nullptr;
		}
	}
}

void Player::HUD_t::updateEnemyBar2(Frame* whichFrame, void* enemyHPDetails)
{
	if ( !whichFrame )
	{
		return;
	}

	if ( !enemyHPDetails )
	{
		return;
	}

	if ( !player.isLocalPlayer() )
	{
		return;
	}

	EnemyHPDamageBarHandler::EnemyHPDetails* enemyDetails = static_cast<EnemyHPDamageBarHandler::EnemyHPDetails*>(enemyHPDetails);

	Entity* entity = uidToEntity(enemyDetails->enemy_uid);
	if ( entity )
	{
		//enemyDetails->updateWorldCoordinates(); --moved to main loop before drawEntities3D
		if ( entity->behavior == &actMonster && entity->getMonsterTypeFromSprite() == MIMIC )
		{
			if ( entity->isInertMimic() )
			{
				enemyDetails->barType = EnemyHPDamageBarHandler::BAR_TYPE_FURNITURE;
			}
			else
			{
				enemyDetails->barType = EnemyHPDamageBarHandler::BAR_TYPE_CREATURE;
			}
		}
	}
	else
	{
		enemyDetails->enemy_hp = 0;
	}

	bool bIsMostRecentHPBar = enemyHPDamageBarHandler[player.playernum].getMostRecentHPBar() == enemyDetails;
	//if ( bIsMostRecentHPBar && !enemyDetails->hasDistanceCheck )
	//{
	//	//enemyDetails->hasDistanceCheck = true;
	//	auto& camera = cameras[player.playernum];
	//	double playerdist = sqrt(pow(camera.x * 16.0 - enemyDetails->worldX, 2) + pow(camera.y * 16.0 - enemyDetails->worldY, 2));
	//	if ( playerdist >= 3 * 16.0 )
	//	{
	//		//enemyDetails->displayOnHUD = true;
	//	}
	//}

	SDL_Rect pos = whichFrame->getSize();
	bool doFadeout = false;
	bool doAnimation = true;
	if ( enemyDetails->displayOnHUD && whichFrame == enemyBarFrameHUD )
	{
		doAnimation = false;
	}

	if ( gamePaused && multiplayer == SINGLE )
	{
		enemyDetails->enemy_timer = ticks;
		return;
	}

	if ( doAnimation && !enemyDetails->displayOnHUD && !enemyDetails->expired && enemyDetails->animator.setpoint <= 0 )
	{
		if ( ticks - enemyDetails->enemy_timer >= EnemyHPDamageBarHandler::shortDistanceHPBarFadeTicks )
		{
			if ( splitscreen )
			{
				// if anyone in splitscreen is near the bar, expire it instead of just the owner
				for ( int i = 0; i < MAXPLAYERS; ++i )
				{
					if ( i == player.playernum || players[i]->isLocalPlayerAlive() )
					{
						auto& camera = cameras[i];
						double playerdist = sqrt(pow(camera.x * 16.0 - enemyDetails->worldX, 2) + pow(camera.y * 16.0 - enemyDetails->worldY, 2));
						if ( playerdist <= EnemyHPDamageBarHandler::shortDistanceHPBarFadeDistance * 16.0 )
						{
							enemyDetails->expired = true;
							break;
						}
					}
				}
			}
			else
			{
				auto& camera = cameras[player.playernum];
				double playerdist = sqrt(pow(camera.x * 16.0 - enemyDetails->worldX, 2) + pow(camera.y * 16.0 - enemyDetails->worldY, 2));
				if ( playerdist <= EnemyHPDamageBarHandler::shortDistanceHPBarFadeDistance * 16.0 )
				{
					enemyDetails->expired = true;
				}
			}
		}
	}

	if ( enemyDetails->expired == true )
	{
		doFadeout = true;
	}
	else
	{
		enemyDetails->animator.fadeOut = 100.0;
	}

	if ( doFadeout )
	{
		if ( doAnimation )
		{
			enemyDetails->animator.fadeOut -= 10.0 * getFPSScale(60.0);
			if ( enemyDetails->animator.fadeOut < 0.0 ) 
			{ 
				enemyDetails->animator.fadeOut = 0.0; 
				enemyDetails->animator.fadeIn = 0.0;
			}
		}
		whichFrame->setOpacity(enemyDetails->animator.fadeOut);
	}
	else
	{
		enemyDetails->animator.fadeIn = 100.0;
		whichFrame->setOpacity(enemyDetails->animator.fadeIn);
	}

	auto baseBg = whichFrame->findImage("base img");
	auto baseEndCap = whichFrame->findImage("base img endcap");

	auto foregroundFrame = whichFrame->findFrame("bar progress frame");
	auto hpProgress = foregroundFrame->findImage("progress img");
	auto hpProgressEndcap = foregroundFrame->findImage("progress img endcap");

	auto dmgFrame = whichFrame->findFrame("bar dmg frame");
	auto dmgProgress = dmgFrame->findImage("dmg img");
	auto dmgEndCap = dmgFrame->findImage("dmg img endcap");
	//auto bubblesImg = dmgFrame->findImage("img bubbles");

	real_t progressWidth = ENEMYBAR_BAR_WIDTH - hpProgressEndcap->pos.w;
	int backgroundWidth = ENEMYBAR_BAR_WIDTH - baseEndCap->pos.w;

	auto nameTxt = whichFrame->findField("enemy name txt");

	// handle bar size changing
	{
		std::vector<std::pair<real_t, int>> widthHealthBreakpoints;
		if ( enemyDetails->barType == EnemyHPDamageBarHandler::BAR_TYPE_CREATURE )
		{
			widthHealthBreakpoints = EnemyHPDamageBarHandler::widthHealthBreakpointsMonsters;
		}
		else
		{
			widthHealthBreakpoints = EnemyHPDamageBarHandler::widthHealthBreakpointsFurniture;
		}
		if ( widthHealthBreakpoints.empty() ) // width %, then HP value
		{
			// build some defaults
			widthHealthBreakpoints.push_back(std::make_pair(0.5, 10));
			widthHealthBreakpoints.push_back(std::make_pair(0.60, 20));
			widthHealthBreakpoints.push_back(std::make_pair(0.70, 50));
			widthHealthBreakpoints.push_back(std::make_pair(0.80, 100));
			widthHealthBreakpoints.push_back(std::make_pair(0.90, 250));
			widthHealthBreakpoints.push_back(std::make_pair(1.00, 1000));
		}

		enemyDetails->animator.widthMultiplier = 1.0;
		auto prevIt = widthHealthBreakpoints.end();
		bool foundBreakpoint = false;
		for ( auto it = widthHealthBreakpoints.begin(); it != widthHealthBreakpoints.end(); ++it )
		{
			int healthThreshold = (*it).second;
			real_t widthEntry = (*it).first;
			if ( (int)enemyDetails->animator.maxValue <= healthThreshold )
			{
				real_t width = 0.0;
				if ( prevIt != widthHealthBreakpoints.end() )
				{
					width = (*prevIt).first;
					// get linear scaled value between the breakponts
					width += (widthEntry - (*prevIt).first) * ((int)enemyDetails->animator.maxValue - (*prevIt).second) / ((*it).second - (*prevIt).second);
				}
				else
				{
					// set as minimum width
					width = widthEntry;
				}
				enemyDetails->animator.widthMultiplier = width;
				foundBreakpoint = true;
				break;
			}
			prevIt = it;
		}
		if ( !foundBreakpoint )
		{
			enemyDetails->animator.widthMultiplier = widthHealthBreakpoints[widthHealthBreakpoints.size() - 1].first;
		}

		real_t multiplier = enemyDetails->animator.widthMultiplier;

		int diff = static_cast<int>(std::max(0.0, progressWidth - progressWidth * multiplier)); // how many pixels the progress bar shrinks
		progressWidth *= multiplier; // scale the progress bars
		baseBg->pos.w = backgroundWidth - diff; // move the background bar by x pixels
		baseEndCap->pos.x = baseBg->pos.x + baseBg->pos.w; // move the background endcap by the new width

		hpProgress->pos.w = progressWidth;
		hpProgressEndcap->pos.x = hpProgress->pos.x + hpProgress->pos.w;

		pos.x = (hudFrame->getSize().w / 2) - ENEMYBAR_FRAME_WIDTH / 2 - 6;
		int widthChange = ((ENEMYBAR_BAR_WIDTH - hpProgressEndcap->pos.w) - progressWidth);
		pos.x += widthChange / 2;
		SDL_Rect textPos = nameTxt->getSize();
		textPos.w = ENEMYBAR_FRAME_WIDTH - widthChange;
		textPos.y = baseBg->pos.y;
		textPos.h = baseBg->pos.h;
		nameTxt->setSize(textPos);
	}

	int startY = hudFrame->getSize().h - ENEMYBAR_FRAME_START_Y - 100;
	if ( doFadeout )
	{
		pos.y = startY + (15 * (100.0 - enemyDetails->animator.fadeOut) / 100.0); // slide out downwards
	}
	else
	{
		pos.y = startY;
	}
	whichFrame->setSize(pos);

	enemyDetails->animator.previousSetpoint = enemyDetails->animator.setpoint;
	real_t& hpForegroundValue = enemyDetails->animator.foregroundValue;
	real_t& hpFadedValue = enemyDetails->animator.backgroundValue;

	if ( doAnimation )
	{
		enemyDetails->animator.setpoint = enemyDetails->enemy_hp;
		if ( enemyDetails->animator.setpoint < enemyDetails->animator.previousSetpoint ) // insta-change as losing health
		{
			hpForegroundValue = enemyDetails->animator.setpoint;
			enemyDetails->animator.animateTicks = ticks;
		}

		if ( enemyDetails->animator.maxValue > enemyDetails->enemy_maxhp )
		{
			hpFadedValue = enemyDetails->animator.setpoint; // resetting game etc, stop fade animation sticking out of frame
		}
		enemyDetails->animator.maxValue = enemyDetails->enemy_maxhp;


		if ( hpForegroundValue < enemyDetails->animator.setpoint ) // gaining HP, animate
		{
			real_t setpointDiff = std::max(0.01, enemyDetails->animator.setpoint - hpForegroundValue);
			real_t fpsScale = getFPSScale(144.0);
			hpForegroundValue += fpsScale * (setpointDiff / 20.0); // reach it in 20 intervals, scaled to FPS
			hpForegroundValue = std::min(static_cast<real_t>(enemyDetails->animator.setpoint), hpForegroundValue);

			if ( abs(enemyDetails->animator.setpoint) - abs(hpForegroundValue) <= .05 )
			{
				hpForegroundValue = enemyDetails->animator.setpoint;
			}
		}
		else if ( hpForegroundValue > enemyDetails->animator.setpoint ) // losing HP, snap to value
		{
			hpForegroundValue = enemyDetails->animator.setpoint;
		}

		if ( hpFadedValue < enemyDetails->animator.setpoint )
		{
			hpFadedValue = hpForegroundValue;
			enemyDetails->animator.animateTicks = ticks;
		}
		else if ( hpFadedValue > enemyDetails->animator.setpoint )
		{
			if ( ticks - enemyDetails->animator.animateTicks > 30 || enemyDetails->animator.setpoint <= 0 ) // fall after x ticks
			{
				real_t setpointDiff = std::max(0.01, hpFadedValue - enemyDetails->animator.setpoint);
				real_t fpsScale = getFPSScale(144.0);
				real_t intervals = 10.0;
				if ( enemyDetails->animator.setpoint <= 0 )
				{
					intervals = 30.0; // dramatic
				}
				hpFadedValue -= fpsScale * (setpointDiff / intervals); // reach it in X intervals, scaled to FPS
				hpFadedValue = std::max(static_cast<real_t>(enemyDetails->animator.setpoint), hpFadedValue);
			}
		}
		else
		{
			enemyDetails->animator.animateTicks = ticks;
		}
	}

	auto skullFrame = whichFrame->findFrame("skull frame");
	std::vector<std::pair<Frame::image_t*, int>> allSkulls;
	allSkulls.push_back(std::make_pair(skullFrame->findImage("skull 0 img"), 0));
	allSkulls.push_back(std::make_pair(skullFrame->findImage("skull 25 img"), 25));
	allSkulls.push_back(std::make_pair(skullFrame->findImage("skull 50 img"), 50));
	allSkulls.push_back(std::make_pair(skullFrame->findImage("skull 100 img"), 75));
	real_t healthPercentage = 100 * enemyDetails->animator.setpoint / std::max(1.0, enemyDetails->animator.maxValue);
	int skullIndex = 0;
	for ( auto& skull : allSkulls )
	{
		if ( !skull.first ) { continue; }

		Uint8 r, g, b, a;
		getColor(skull.first->color, &r, &g, &b, &a);
		real_t& skullOpacity = enemyDetails->animator.skullOpacities[skullIndex];

		if ( doAnimation )
		{
			if ( (int)healthPercentage < skull.second )
			{
				real_t opacityChange = 4 * getFPSScale(60.0); // change independent of fps
				skullOpacity = std::max(0, (int)(skullOpacity - opacityChange));
			}
			else if ( (int)healthPercentage >= skull.second )
			{
				real_t opacityChange = 255;// *getFPSScale(144.0); // change independent of fps
				skullOpacity = std::min(255, (int)(skullOpacity + opacityChange));
			}
		}
		a = skullOpacity;
		//a *= enemyDetails->animator.fadeOut / 100.0;
		skull.first->color = makeColor( r, g, b, a);
		++skullIndex;
	}

	nameTxt->setText(enemyDetails->enemy_name.c_str());

	real_t foregroundPercent = hpForegroundValue / enemyDetails->animator.maxValue;
	hpProgress->pos.w = std::max(1, static_cast<int>((progressWidth)* foregroundPercent));
	hpProgressEndcap->pos.x = hpProgress->pos.x + hpProgress->pos.w;

	real_t fadePercent = hpFadedValue / enemyDetails->animator.maxValue;
	dmgProgress->pos.w = std::max(1, static_cast<int>((progressWidth)* fadePercent));
	dmgEndCap->pos.x = dmgProgress->pos.x + dmgProgress->pos.w;
	if ( dmgProgress->pos.w == 1 && enemyDetails->animator.setpoint <= 0 )
	{
		dmgProgress->disabled = true;
		//real_t& opacity = enemyDetails->animator.damageFrameOpacity;
		//if ( doAnimation )
		//{
		//	real_t opacityChange = .5 * getFPSScale(144.0); // change by .05% independent of fps
		//	opacity = std::max(0.0, opacity - opacityChange);
		//}
		//dmgFrame->setOpacity(opacity);
		//dmgFrame->setOpacity(dmgFrame->getOpacity() * enemyDetails->animator.fadeOut / 100.0);
		//// make this element fade out to the left
		//dmgEndCap->pos.x = 0 - (dmgEndCap->pos.w * (1.0 - opacity / 100.0));
	}
	else
	{
		dmgProgress->disabled = false;
		enemyDetails->animator.damageFrameOpacity = enemyDetails->animator.fadeOut;
		dmgFrame->setOpacity(enemyDetails->animator.fadeOut);
	}

	if ( enemyDetails->animator.setpoint <= 0 )
	{
		// hide all the progress elements when dead, as endcap/base don't shrink
		// hpProgress width 0px defaults to original size, so hide that too
		hpProgress->disabled = true;
		hpProgressEndcap->disabled = true;
	}
	else
	{
		hpProgress->disabled = false;
		hpProgressEndcap->disabled = false;
	}

	// damage number on HUD
	if ( enemyDetails->displayOnHUD && whichFrame == enemyBarFrameHUD )
	{
		auto dmgText = hudFrame->findField("enemy dmg txt");
		Sint32 damageNumber = enemyDetails->animator.damageTaken;
		enemyDetails->animator.damageTaken = -1;
		if ( damageNumber >= 0 )
		{
			char buf[128] = "";
			snprintf(buf, sizeof(buf), "%d", damageNumber);
			dmgText->setText(buf);
			dmgText->setDisabled(false);
			SDL_Rect txtPos = dmgText->getSize();
			SDL_Rect barPos = foregroundFrame->getAbsoluteSize();
			//txtPos.x = barPos.x + baseBg->pos.x/* + baseBg->pos.w*/;
			//txtPos.y = barPos.y - 30;
			auto text = Text::get(dmgText->getText(), dmgText->getFont(),
				makeColor(255, 255, 255, 255), makeColor(0, 0, 0, 255));
			txtPos.x = 30 + player.camera_virtualWidth() / 2;
			txtPos.y = -50 + player.camera_virtualHeight() / 2;
			txtPos.w = text->getWidth();
			txtPos.h = text->getHeight();
			dmgText->setSize(txtPos);
			hudDamageTextVelocityX = 1.0;
			hudDamageTextVelocityY = 3.0;
			Uint8 r, g, b, a;
			getColor(dmgText->getColor(), &r, &g, &b, &a);
			dmgText->setColor(makeColor(r, g, b, 255));
		}

		if ( !dmgText->isDisabled() )
		{
			SDL_Rect txtPos = dmgText->getSize();
			txtPos.x += hudDamageTextVelocityX;
			txtPos.y -= hudDamageTextVelocityY;
			hudDamageTextVelocityX += .05;
			hudDamageTextVelocityY -= .3;
			dmgText->setSize(txtPos);
			if ( hudDamageTextVelocityY < -2.0 )
			{
				Uint8 r, g, b, a;
				getColor(dmgText->getColor(), &r, &g, &b, &a);
				a = (std::max(0, (int)a - 16));
				dmgText->setColor(makeColor(r, g, b, a));
				if ( a == 0 )
				{
					dmgText->setDisabled(true);
				}
			}
		}
	}


	bool oldBlitType = EnemyHPDamageBarHandler::bEnemyBarSimpleBlit;
	EnemyHPDamageBarHandler::bEnemyBarSimpleBlit = *cvar_enemybar_simple_blit;

	//auto blit = std::chrono::high_resolution_clock::now();
	if ( !EnemyHPDamageBarHandler::bEnemyBarSimpleBlit )
	{
		if ( !enemyBarMap.m.empty() )
		{
			enemyBarEffectMap.m.clear();
			enemyBarMap.m.clear();
			enemyDetails->worldSurfaceSprite = nullptr;
			enemyDetails->worldSurfaceSpriteStatusEffects = nullptr;
		}

		if ( enemyDetails->worldTexture )
		{
			delete enemyDetails->worldTexture;
			enemyDetails->worldTexture = nullptr;
		}
		if ( enemyDetails->worldSurfaceSprite )
		{
			SDL_FreeSurface(enemyDetails->worldSurfaceSprite);
			enemyDetails->worldSurfaceSprite = nullptr;
		}
		if ( enemyDetails->worldSurfaceSpriteStatusEffects )
		{
			SDL_FreeSurface(enemyDetails->worldSurfaceSpriteStatusEffects);
			enemyDetails->worldSurfaceSpriteStatusEffects = nullptr;
		}

		enemyDetails->worldSurfaceSpriteStatusEffects = enemyDetails->blitEnemyBarStatusEffects(player.playernum);
		//auto blit2 = std::chrono::high_resolution_clock::now();
		enemyDetails->worldSurfaceSprite = enemyDetails->blitEnemyBar(player.playernum, enemyDetails->worldSurfaceSpriteStatusEffects);
		//auto blit3 = std::chrono::high_resolution_clock::now();
		enemyDetails->worldTexture = new TempTexture();
		enemyDetails->worldTexture->load(enemyDetails->worldSurfaceSprite, false, true);
		//auto blit4 = std::chrono::high_resolution_clock::now();
		//float ms1 = 1000 * std::chrono::duration_cast<std::chrono::duration<double>>(blit2 - blit).count();
		//float ms2 = 1000 * std::chrono::duration_cast<std::chrono::duration<double>>(blit3 - blit2).count();
		//float ms3 = 1000 * std::chrono::duration_cast<std::chrono::duration<double>>(blit4 - blit3).count();
		//float msTotal = 1000 * std::chrono::duration_cast<std::chrono::duration<double>>(blit4 - blit).count();
		//printTextFormatted(font16x16_bmp, 8, 8 + 4 * 16, "Total: %.4f\n ms1: %.4f\n ms2: %.4f\nms3: %.4f", msTotal, ms1, ms2, ms3);
	}
	else
	{
		enemyDetails->worldSurfaceSpriteStatusEffects = enemyDetails->blitEnemyBarStatusEffects(player.playernum);
		//auto blit2 = std::chrono::high_resolution_clock::now();
		SDL_Surface* oldWorldSprite = enemyDetails->worldSurfaceSprite;
		enemyDetails->worldSurfaceSprite = enemyDetails->blitEnemyBar(player.playernum, enemyDetails->worldSurfaceSpriteStatusEffects);
		//auto blit3 = std::chrono::high_resolution_clock::now();
		if ( oldWorldSprite != enemyDetails->worldSurfaceSprite )
		{
			if ( enemyDetails->worldTexture )
			{
				delete enemyDetails->worldTexture;
				enemyDetails->worldTexture = nullptr;
			}

			if ( enemyDetails->worldSurfaceSprite )
			{
				enemyDetails->worldTexture = new TempTexture();
				enemyDetails->worldTexture->load(enemyDetails->worldSurfaceSprite, false, true);
			}
		}
		//auto blit4 = std::chrono::high_resolution_clock::now();
		//float ms1 = 1000 * std::chrono::duration_cast<std::chrono::duration<double>>(blit2 - blit).count();
		//float ms2 = 1000 * std::chrono::duration_cast<std::chrono::duration<double>>(blit3 - blit2).count();
		//float ms3 = 1000 * std::chrono::duration_cast<std::chrono::duration<double>>(blit4 - blit3).count();
		//float msTotal = 1000 * std::chrono::duration_cast<std::chrono::duration<double>>(blit4 - blit).count();
		//printTextFormatted(font16x16_bmp, 8, 8 + 4 * 16, "Total: %.4f\n ms1: %.4f\n ms2: %.4f\nms3: %.4f", msTotal, ms1, ms2, ms3);
	}



	whichFrame->setDisabled(true);
	if ( !enemyDetails->displayOnHUD )
	{
		//printTextFormatted(font16x16_bmp, 8, 8 + 4 * 16, "Any vertex visible: %d", anyVertexVisible);
	}
	else
	{
		if ( whichFrame == enemyBarFrameHUD )
		{
			whichFrame->setDisabled(false);
		}
		else
		{
			updateEnemyBar2(enemyBarFrameHUD, enemyHPDetails);
		}
	}
}

static ConsoleCommand ccmd_enemybar_dump_cache("/enemybar_dump_cache", "Dumps cached enemy bars",
	[](int argc, const char** argv) {
	EnemyHPDamageBarHandler::dumpCache();
});

void EnemyHPDamageBarHandler::dumpCache()
{
	enemyBarEffectMap.m.clear();
	enemyBarMap.m.clear();
	for ( int i = 0; i < MAXPLAYERS; ++i )
	{
		enemyHPDamageBarHandler[i].HPBars.clear();
	}
}

void Player::HUD_t::updateEnemyBar(Frame* whichFrame)
{
	if ( !whichFrame )
	{
		return;
	}

	if ( !player.isLocalPlayer() )
	{
		return;
	}

	SDL_Rect pos = whichFrame->getSize();
	bool doFadeout = false;

	EnemyHPDamageBarHandler::EnemyHPDetails* enemyDetails = nullptr;
	Bar_t* enemyBar = nullptr;
	Sint32 damageNumber = -1;
	enemyDetails = enemyHPDamageBarHandler[player.playernum].getMostRecentHPBar();
	enemyBar = &this->enemyBar;

	if ( enemyDetails )
	{
		enemyBar->animatePreviousSetpoint = enemyDetails->animator.previousSetpoint;
		enemyBar->animateValue = enemyDetails->animator.foregroundValue;
		enemyBar->animateValue2 = enemyDetails->animator.backgroundValue;
		enemyBar->animateSetpoint = enemyDetails->animator.setpoint;
		enemyBar->animateTicks = enemyDetails->animator.animateTicks;
		enemyBar->maxValue = enemyDetails->animator.maxValue;
		enemyBar->fadeOut = 100.0;
		damageNumber = enemyDetails->animator.damageTaken;
		enemyDetails->animator.damageTaken = -1;

		if ( Entity* entity = uidToEntity(enemyDetails->enemy_uid) )
		{
			enemyDetails->worldX = entity->x;
			enemyDetails->worldY = entity->y;
			enemyDetails->worldZ = entity->z;
		}
	}
	if ( !enemyDetails || enemyDetails->expired == true )
	{
		doFadeout = true;
	}

	if ( doFadeout )
	{
		enemyBar->fadeOut -= 10.0 * getFPSScale(60.0);
		if ( enemyBar->fadeOut < 0.0 ) { enemyBar->fadeOut = 0.0; enemyBar->fadeIn = 0.0; }
		whichFrame->setOpacity(enemyBar->fadeOut);
	}
	else
	{
		enemyBar->fadeIn = 100.0;
		whichFrame->setOpacity(enemyBar->fadeIn);
	}

	auto baseBg = whichFrame->findImage("base img");
	auto baseEndCap = whichFrame->findImage("base img endcap");
	
	auto foregroundFrame = whichFrame->findFrame("bar progress frame");
	auto hpProgress = foregroundFrame->findImage("progress img");
	auto hpProgressEndcap = foregroundFrame->findImage("progress img endcap");

	auto dmgFrame = whichFrame->findFrame("bar dmg frame");
	auto dmgProgress = dmgFrame->findImage("dmg img");
	auto dmgEndCap = dmgFrame->findImage("dmg img endcap");
	//auto bubblesImg = dmgFrame->findImage("img bubbles");

	real_t progressWidth = ENEMYBAR_BAR_WIDTH - hpProgressEndcap->pos.w;
	int backgroundWidth = ENEMYBAR_BAR_WIDTH - baseEndCap->pos.w;

	auto nameTxt = whichFrame->findField("enemy name txt");

	// handle bar size changing
	{
		std::vector<std::pair<real_t, int>>widthHealthBreakpoints; // width %, then HP value
		widthHealthBreakpoints.push_back(std::make_pair(0.5, 10));
		widthHealthBreakpoints.push_back(std::make_pair(0.60, 20));
		widthHealthBreakpoints.push_back(std::make_pair(0.70, 50));
		widthHealthBreakpoints.push_back(std::make_pair(0.80, 100));
		widthHealthBreakpoints.push_back(std::make_pair(0.90, 250));
		widthHealthBreakpoints.push_back(std::make_pair(1.00, 1000));

		enemyBar->widthMultiplier = 1.0;
		auto prevIt = widthHealthBreakpoints.end();
		bool foundBreakpoint = false;
		for ( auto it = widthHealthBreakpoints.begin(); it != widthHealthBreakpoints.end(); ++it )
		{
			int healthThreshold = (*it).second;
			real_t widthEntry = (*it).first;
			if ( (int)enemyBar->maxValue <= healthThreshold )
			{
				real_t width = 0.0;
				if ( prevIt != widthHealthBreakpoints.end() )
				{
					width = (*prevIt).first;
					// get linear scaled value between the breakponts
					width += (widthEntry - (*prevIt).first) * ((int)enemyBar->maxValue - (*prevIt).second) / ((*it).second - (*prevIt).second);
				}
				else
				{
					// set as minimum width
					width = widthEntry;  /**((int)enemyBar->maxValue) / ((*it).second);*/
				}
				enemyBar->widthMultiplier = width;
				foundBreakpoint = true;
				break;
			}
			prevIt = it;
		}
		if ( !foundBreakpoint )
		{
			enemyBar->widthMultiplier = widthHealthBreakpoints[widthHealthBreakpoints.size() - 1].first;
		}

		real_t multiplier = enemyBar->widthMultiplier;

		int diff = static_cast<int>(std::max(0.0, progressWidth - progressWidth * multiplier)); // how many pixels the progress bar shrinks
		progressWidth *= multiplier; // scale the progress bars
		baseBg->pos.w = backgroundWidth - diff; // move the background bar by x pixels
		baseEndCap->pos.x = baseBg->pos.x + baseBg->pos.w; // move the background endcap by the new width

		hpProgress->pos.w = progressWidth;
		hpProgressEndcap->pos.x = hpProgress->pos.x + hpProgress->pos.w;

		pos.x = (hudFrame->getSize().w / 2) - ENEMYBAR_FRAME_WIDTH / 2 - 6;
		int widthChange = ((ENEMYBAR_BAR_WIDTH - hpProgressEndcap->pos.w) - progressWidth);
		pos.x += widthChange / 2;
		SDL_Rect textPos = nameTxt->getSize();
		textPos.w = ENEMYBAR_FRAME_WIDTH - widthChange;
		textPos.y = baseBg->pos.y;
		textPos.h = baseBg->pos.h;
		nameTxt->setSize(textPos);
	}

	int startY = hudFrame->getSize().h - ENEMYBAR_FRAME_START_Y - 100;
	if ( doFadeout )
	{
		pos.y = startY + (15 * (100.0 - enemyBar->fadeOut) / 100.0); // slide out downwards
	}
	else
	{
		pos.y = startY;
	}
	whichFrame->setSize(pos);
	
	//messagePlayer(0, "%.2f | %.2f | %.2f | %d", enemyDetails->animateValue, 
	//	enemyDetails->animateValue2, enemyDetails->animatePreviousSetpoint, enemyDetails->animateSetpoint);

	enemyBar->animatePreviousSetpoint = enemyBar->animateSetpoint;
	real_t& hpForegroundValue = enemyBar->animateValue;
	real_t& hpFadedValue = enemyBar->animateValue2;

	if ( enemyDetails )
	{
		enemyBar->animateSetpoint = enemyDetails->enemy_hp;
		if ( enemyBar->animateSetpoint < enemyBar->animatePreviousSetpoint ) // insta-change as losing health
		{
			hpForegroundValue = enemyBar->animateSetpoint;
			enemyBar->animateTicks = ticks;
		}
	
		if ( enemyBar->maxValue > enemyDetails->enemy_maxhp )
		{
			hpFadedValue = enemyBar->animateSetpoint; // resetting game etc, stop fade animation sticking out of frame
		}
		enemyBar->maxValue = enemyDetails->enemy_maxhp;
	}


	if ( hpForegroundValue < enemyBar->animateSetpoint ) // gaining HP, animate
	{
		real_t setpointDiff = std::max(0.01, enemyBar->animateSetpoint - hpForegroundValue);
		real_t fpsScale = getFPSScale(144.0);
		hpForegroundValue += fpsScale * (setpointDiff / 20.0); // reach it in 20 intervals, scaled to FPS
		hpForegroundValue = std::min(static_cast<real_t>(enemyBar->animateSetpoint), hpForegroundValue);

		if ( abs(enemyBar->animateSetpoint) - abs(hpForegroundValue) <= .05 )
		{
			hpForegroundValue = enemyBar->animateSetpoint;
		}
	}
	else if ( hpForegroundValue > enemyBar->animateSetpoint ) // losing HP, snap to value
	{
		hpForegroundValue = enemyBar->animateSetpoint;
	}

	if ( hpFadedValue < enemyBar->animateSetpoint )
	{
		hpFadedValue = hpForegroundValue;
		enemyBar->animateTicks = ticks;
	}
	else if ( hpFadedValue > enemyBar->animateSetpoint )
	{
		if ( ticks - enemyBar->animateTicks > 30 || enemyBar->animateSetpoint <= 0 ) // fall after x ticks
		{
			real_t setpointDiff = std::max(0.01, hpFadedValue - enemyBar->animateSetpoint);
			real_t fpsScale = getFPSScale(144.0);
			real_t intervals = 10.0;
			if ( enemyBar->animateSetpoint <= 0 )
			{
				intervals = 30.0; // dramatic
			}
			hpFadedValue -= fpsScale * (setpointDiff / intervals); // reach it in X intervals, scaled to FPS
			hpFadedValue = std::max(static_cast<real_t>(enemyBar->animateSetpoint), hpFadedValue);
		}
	}
	else
	{
		enemyBar->animateTicks = ticks;
	}

	auto skullFrame = whichFrame->findFrame("skull frame");
	std::vector<std::pair<Frame::image_t*, int>> allSkulls;
	allSkulls.push_back(std::make_pair(skullFrame->findImage("skull 0 img"), 0));
	allSkulls.push_back(std::make_pair(skullFrame->findImage("skull 25 img"), 25));
	allSkulls.push_back(std::make_pair(skullFrame->findImage("skull 50 img"), 50));
	allSkulls.push_back(std::make_pair(skullFrame->findImage("skull 100 img"), 75));
	real_t healthPercentage = 100 * enemyBar->animateSetpoint / std::max(1.0, enemyBar->maxValue);
	for ( auto& skull : allSkulls )
	{
		if ( !skull.first ) { continue; }

		Uint8 r, g, b, a;
		getColor(skull.first->color, &r, &g, &b, &a);

		if ( (int)healthPercentage < skull.second )
		{
			real_t opacityChange = 4 * getFPSScale(60.0); // change independent of fps
			a = std::max(0, a - (int)opacityChange);
		}
		else if ( (int)healthPercentage >= skull.second )
		{
			real_t opacityChange = 255;// *getFPSScale(144.0); // change independent of fps
			a = std::min(255, a + (int)opacityChange);
		}
		a *= whichFrame->getOpacity() / 100.0;
		skull.first->color = makeColor( r, g, b, a);
	}

	//char playerHPText[16];
	//snprintf(playerHPText, sizeof(playerHPText), "%d", stats[player.playernum]->HP);
	if ( enemyDetails )
	{
		nameTxt->setText(enemyDetails->enemy_name.c_str());
	}

	//auto hpText = hpForegroundFrame->findField("hp text");
	//hpText->setText(playerHPText);

	real_t foregroundPercent = hpForegroundValue / enemyBar->maxValue;
	hpProgress->pos.w = std::max(1, static_cast<int>((progressWidth) * foregroundPercent));
	hpProgressEndcap->pos.x = hpProgress->pos.x + hpProgress->pos.w;

	real_t fadePercent = hpFadedValue / enemyBar->maxValue;
	dmgProgress->pos.w = std::max(1, static_cast<int>((progressWidth) * fadePercent));
	dmgEndCap->pos.x = dmgProgress->pos.x + dmgProgress->pos.w;
	if ( dmgProgress->pos.w == 1 && enemyBar->animateSetpoint <= 0 )
	{
		dmgProgress->disabled = true;
		real_t opacity = dmgFrame->getOpacity();
		real_t opacityChange = .5 * getFPSScale(144.0); // change by .05% independent of fps
		dmgFrame->setOpacity(std::max(0.0, opacity - opacityChange));
		dmgFrame->setOpacity(dmgFrame->getOpacity() * whichFrame->getOpacity() / 100.0);
		// make this element fade out to the left
		dmgEndCap->pos.x = 0 - (dmgEndCap->pos.w * (1.0 - opacity / 100.0));
	}
	else
	{
		dmgProgress->disabled = false;
		dmgFrame->setOpacity(whichFrame->getOpacity());
	}

	//bubblesImg->pos.x = dmgEndCap->pos.x - bubblesImg->pos.w;

	if ( enemyBar->animateSetpoint <= 0 )
	{
		// hide all the progress elements when dead, as endcap/base don't shrink
		// hpProgress width 0px defaults to original size, so hide that too
		hpProgress->disabled = true;
		hpProgressEndcap->disabled = true;
	}
	else
	{
		hpProgress->disabled = false;
		hpProgressEndcap->disabled = false;
	}

	auto dmgText = hudFrame->findField("enemy dmg txt");
	// damage number on HUD
	{
		if ( damageNumber >= 0 )
		{
			char buf[128] = "";
			snprintf(buf, sizeof(buf), "%d", damageNumber);
			dmgText->setText(buf);
			dmgText->setDisabled(false);
			SDL_Rect txtPos = dmgText->getSize();
			SDL_Rect barPos = foregroundFrame->getAbsoluteSize();
			//txtPos.x = barPos.x + baseBg->pos.x/* + baseBg->pos.w*/;
			//txtPos.y = barPos.y - 30;
			auto text = Text::get(dmgText->getText(), dmgText->getFont(),
				makeColor(255, 255, 255, 255), makeColor(0, 0, 0, 255));
			txtPos.x = 30 + player.camera_virtualWidth() / 2;
			txtPos.y = -50 + player.camera_virtualHeight() / 2;
			txtPos.w = text->getWidth();
			txtPos.h = text->getHeight();
			dmgText->setSize(txtPos);
			hudDamageTextVelocityX = 1.0;
			hudDamageTextVelocityY = 3.0;
			Uint8 r, g, b, a;
			getColor(dmgText->getColor(), &r, &g, &b, &a);
			dmgText->setColor(makeColor(r, g, b, 255));
		}

		if ( !dmgText->isDisabled() )
		{
			SDL_Rect txtPos = dmgText->getSize();
			txtPos.x += hudDamageTextVelocityX;
			txtPos.y -= hudDamageTextVelocityY;
			hudDamageTextVelocityX += .05;
			hudDamageTextVelocityY -= .3;
			dmgText->setSize(txtPos);
			if ( hudDamageTextVelocityY < -2.0 )
			{
				Uint8 r, g, b, a;
				getColor(dmgText->getColor(), &r, &g, &b, &a);
				a = (std::max(0, (int)a - 16));
				dmgText->setColor(makeColor(r, g, b, a));
				if ( a == 0 )
				{
					dmgText->setDisabled(true);
				}
			}
		}
	}

	if ( enemyDetails )
	{
		enemyDetails->animator.previousSetpoint = enemyBar->animatePreviousSetpoint;
		enemyDetails->animator.foregroundValue = enemyBar->animateValue;
		enemyDetails->animator.backgroundValue = enemyBar->animateValue2;
		enemyDetails->animator.setpoint = enemyBar->animateSetpoint;
		enemyDetails->animator.animateTicks = enemyBar->animateTicks;
		enemyDetails->animator.maxValue = enemyBar->maxValue;
		enemyDetails->animator.fadeIn = enemyBar->fadeIn;
		enemyDetails->animator.fadeOut = enemyBar->fadeOut;
		if ( enemyDetails->worldTexture )
		{
			delete enemyDetails->worldTexture;
			enemyDetails->worldTexture = nullptr;
		}
		if ( enemyDetails->worldSurfaceSprite )
		{
			SDL_FreeSurface(enemyDetails->worldSurfaceSprite);
			enemyDetails->worldSurfaceSprite = nullptr;
		}
		enemyDetails->worldSurfaceSprite = enemyDetails->blitEnemyBar(player.playernum, enemyDetails->worldSurfaceSpriteStatusEffects);
		enemyDetails->worldTexture = new TempTexture();
		enemyDetails->worldTexture->load(enemyDetails->worldSurfaceSprite, false, true);
	}

	whichFrame->setDisabled(true);
}

const int HPMPdividerThresholdInterval = 20;
const int kHPMPWidthReduce2pWideClippedActionPrompts = 60;
//static ConsoleVariable<int> cvar_hpanimdebug("/hpmpanimdebug", 1);
void Player::HUD_t::updateHPBar()
{
	if ( !hpFrame )
	{
		return;
	}

	bool bCompactWidth = false;
	bool bCompactHeight = player.bUseCompactGUIHeight();
	if ( player.bUseCompactGUIWidth() || (keystatus[SDLK_t] && enableDebugKeys) )
	{
		bCompactWidth = true;
	}

	SDL_Rect pos = hpFrame->getSize();
	pos.w = HPMP_FRAME_WIDTH + (bCompactWidth ? hpmpbarCompactOffsetWidth : hpmpbarOffsetWidth);
	if ( !player.bUseCompactGUIWidth() 
		&& player.bUseCompactGUIHeight() && *MainMenu::clipped_splitscreen
		&& bShortHPMPForActionBars )
	{
		// shorten if action prompts visible in clipped wide mode
		pos.w -= kHPMPWidthReduce2pWideClippedActionPrompts; 
	}
	pos.x = HPMP_FRAME_START_X + ((bCompactWidth || bCompactHeight) ? hpmpbarCompactOffsetX : hpmpbarOffsetX);
	pos.y = hudFrame->getSize().h - HPMP_FRAME_START_Y + ((bCompactWidth || bCompactHeight) ? hpmpbarCompactOffsetY : hpmpbarOffsetY);
	pos.y -= player.hud.offsetHUDAboveHotbarHeight;
	hpFrame->setSize(pos);

	auto hpForegroundFrame = hpFrame->findFrame("hp foreground frame");
	{
		auto _pos = hpForegroundFrame->getSize();
		_pos.w = pos.w;
		hpForegroundFrame->setSize(_pos);
	}
	auto hpBg = hpFrame->findImage("hp img base");
	auto hpEndcap = hpForegroundFrame->findImage("hp img endcap");
	auto hpProgressBot = hpForegroundFrame->findImage("hp img progress bot");
	auto hpProgress = hpForegroundFrame->findImage("hp img progress");
	auto hpProgressEndCap = hpForegroundFrame->findImage("hp img progress endcap");
	auto hpFadeFrame = hpFrame->findFrame("hp fade frame");
	{
		auto _pos = hpFadeFrame->getSize();
		_pos.w = pos.w;
		hpFadeFrame->setSize(_pos);
	}
	auto hpFadedBase = hpFadeFrame->findImage("hp img fade bot");
	auto hpFaded = hpFadeFrame->findImage("hp img fade");
	auto hpFadedEndCap = hpFadeFrame->findImage("hp img fade endcap");

	real_t progressWidth = hpFrame->getSize().w - 74;
	int backgroundWidth = hpFrame->getSize().w - 54;

	// handle bar size changing
	{
		real_t multiplier = 1.0;
		const Sint32 maxHPWidth = (bCompactWidth ? hpmpbarCompactMaxWidthAmount : hpmpbarMaxWidthAmount);
		if ( stats[player.playernum]->MAXHP < maxHPWidth )
		{
			// start at 30%, increase 2.5% every 5 HP past 20 MAXHP
			multiplier = (bCompactWidth ? hpmpbarCompactBasePercentSize : hpmpbarBasePercentSize) / 100.0;
			real_t widthIntervalPercent = (bCompactWidth ? hpmpbarCompactWidthIncreasePercentOnInterval : hpmpbarWidthIncreasePercentOnInterval) / 100.0;
			int intervalThreshold = (bCompactWidth ? hpmpbarCompactIntervalToIncreaseWidth : hpmpbarIntervalToIncreaseWidth);
			int baseIntervalStart = (bCompactWidth ? hpmpbarCompactIntervalStartValue : hpmpbarIntervalStartValue);
			multiplier += (widthIntervalPercent * ((std::max(0, stats[player.playernum]->MAXHP - baseIntervalStart) / intervalThreshold)));
		}

		int diff = static_cast<int>(std::max(0.0, progressWidth - progressWidth * multiplier)); // how many pixels the progress bar shrinks
		progressWidth *= multiplier; // scale the progress bars
		hpBg->pos.w = backgroundWidth - diff; // move the background bar by x pixels as above
		hpEndcap->pos.x = hpFrame->getSize().w - hpEndcap->pos.w - diff; // move the background endcap by x pixels as above
	}

	HPBar.animatePreviousSetpoint = HPBar.animateSetpoint;
	real_t& hpForegroundValue = HPBar.animateValue;
	real_t& hpFadedValue = HPBar.animateValue2;

	HPBar.animateSetpoint = stats[player.playernum]->HP;
	if ( HPBar.animateSetpoint < HPBar.animatePreviousSetpoint ) // insta-change as losing health
	{
		hpForegroundValue = HPBar.animateSetpoint;
		HPBar.animateTicks = ticks;

		// flash for taking damage
		HPBar.flashTicks = ticks;
		HPBar.flashAnimState = -1;
		HPBar.flashType = FLASH_ON_DAMAGE;
	}

	if ( HPBar.maxValue > stats[player.playernum]->MAXHP )
	{
		hpFadedValue = HPBar.animateSetpoint; // resetting game etc, stop fade animation sticking out of frame
	}

	HPBar.maxValue = stats[player.playernum]->MAXHP;

	if ( hpForegroundValue < HPBar.animateSetpoint ) // gaining HP, animate
	{
		// flash for gaining HP, provided not already flashing
		/*if ( HPBar.flashAnimState == -1 || (HPBar.flashAnimState >= 0 && HPBar.flashType != FLASH_ON_DAMAGE) )
		{
			HPBar.flashTicks = ticks;
			HPBar.flashAnimState = -1;
			HPBar.flashType = FLASH_ON_RECOVERY;
		}*/

		real_t setpointDiff = std::max(0.0, HPBar.animateSetpoint - hpForegroundValue);
		real_t fpsScale = getFPSScale(144.0);
		hpForegroundValue += fpsScale * (setpointDiff / 20.0); // reach it in 20 intervals, scaled to FPS
		hpForegroundValue = std::min(static_cast<real_t>(HPBar.animateSetpoint), hpForegroundValue);

		if ( abs(HPBar.animateSetpoint) - abs(hpForegroundValue) <= 1.0 )
		{
			hpForegroundValue = HPBar.animateSetpoint;
		}

		/*	int increment = 3;
			double scaledIncrement = (increment * (getFPSScale(144.0)));*/
		//real_t diff = std::max(.1, (HPBar.animateSetpoint * 10 - hpForegroundValue) / (maxValue / 5)); // 0.1-5 value
		//if ( HPBar.animateSetpoint * 10 >= maxValue )
		//{
		//	diff = 5;
		//}
		//scaledIncrement *= 0.2 * pow(diff, 2) + .5;

		//hpForegroundValue = std::min(HPBar.animateSetpoint * 10.0, hpForegroundValue + scaledIncrement);
		//messagePlayer(0, "%.2f | %.2f", hpForegroundValue);
	}
	else if ( hpForegroundValue > HPBar.animateSetpoint ) // losing HP, snap to value
	{
		hpForegroundValue = HPBar.animateSetpoint;
	}

	if ( hpFadedValue < HPBar.animateSetpoint )
	{
		hpFadedValue = hpForegroundValue;
		HPBar.animateTicks = ticks;
	}
	else if ( hpFadedValue > HPBar.animateSetpoint )
	{
		if ( ticks - HPBar.animateTicks > 30 /*|| stats[player.playernum]->HP <= 0*/ ) // fall after x ticks
		{
			real_t setpointDiff = std::max(0.01, hpFadedValue - HPBar.animateSetpoint);
			real_t fpsScale = getFPSScale(144.0);
			hpFadedValue -= fpsScale * (setpointDiff / 20.0); // reach it in 20 intervals, scaled to FPS
			hpFadedValue = std::max(static_cast<real_t>(HPBar.animateSetpoint), hpFadedValue);
		}
	}
	else
	{
		HPBar.animateTicks = ticks;
	}

	char playerHPText[16];
	snprintf(playerHPText, sizeof(playerHPText), "%d", stats[player.playernum]->HP);

	auto hpText = hpForegroundFrame->findField("hp text");
	hpText->setText(playerHPText);

	real_t foregroundPercent = hpForegroundValue / HPBar.maxValue;
	hpProgress->pos.w = std::max(1, static_cast<int>((progressWidth) * foregroundPercent));
	hpProgressEndCap->pos.x = hpProgress->pos.x + hpProgress->pos.w;

	real_t fadePercent = hpFadedValue / HPBar.maxValue;
	hpFaded->pos.w = std::max(1, static_cast<int>((progressWidth) * fadePercent));
	hpFadedEndCap->pos.x = hpFaded->pos.x + hpFaded->pos.w;
	if ( hpFaded->pos.w == 1 && stats[player.playernum]->HP <= 0 )
	{
		hpFaded->disabled = true;
		real_t opacity = hpFadeFrame->getOpacity();
		real_t opacityChange = .5 * getFPSScale(144.0); // change by .05% independant of fps
		hpFadeFrame->setOpacity(std::max(0.0, opacity - opacityChange));

		// make this element fade out to the left, starting 54px then finally at 40px. @ 40px it's out of shot (6 width + 8 endcap width)
		hpFadedBase->pos.x = 54 - (14 * (1.0 - opacity / 100.0)); 
		hpFadedEndCap->pos.x = hpFadedBase->pos.x + hpFadedBase->pos.w;
	}
	else
	{
		hpFaded->disabled = false;
		hpFadeFrame->setOpacity(100.0);

		// reset to 54px left as we altered in above if statement
		hpFadedBase->pos.x = 54;
	}

	if ( stats[player.playernum]->HP <= 0 ) 
	{
		// hide all the progress elements when dead, as endcap/base don't shrink
		// hpProgress width 0px defaults to original size, so hide that too
		hpProgress->disabled = true;
		hpProgressEndCap->disabled = true;
		hpProgressBot->disabled = true;
	}
	else
	{
		hpProgress->disabled = false;
		hpProgressEndCap->disabled = false;
		hpProgressBot->disabled = false;
	}

	// dividers
	{
		const int fullBarWidth = hpProgressBot->pos.w + progressWidth + hpEndcap->pos.w / 2;
		auto div25Percent = hpForegroundFrame->findImage("hp img div 25pc");
		div25Percent->disabled = false;
		div25Percent->pos.x = hpProgressBot->pos.x + fullBarWidth * .25 - 2;
		auto div50Percent = hpForegroundFrame->findImage("hp img div 50pc");
		div50Percent->disabled = false;
		div50Percent->pos.x = hpProgressBot->pos.x + fullBarWidth * .5 - 2;
		auto div75Percent = hpForegroundFrame->findImage("hp img div 75pc");
		div75Percent->disabled = false;
		div75Percent->pos.x = hpProgressBot->pos.x + fullBarWidth * .75 - 2;

		if ( div50Percent->pos.x - div25Percent->pos.x < HPMPdividerThresholdInterval )
		{
			div75Percent->disabled = true;
			// 2 dividers 33%/66%
			div25Percent->pos.x = hpProgressBot->pos.x + fullBarWidth * .33 - 2;
			div50Percent->pos.x = hpProgressBot->pos.x + fullBarWidth * .66 - 2;
			if ( div50Percent->pos.x - div25Percent->pos.x < HPMPdividerThresholdInterval )
			{
				// 1 divider 50%
				div25Percent->disabled = true;
				div50Percent->pos.x = hpProgressBot->pos.x + fullBarWidth * .5 - 2;
			}
		}
	}

	hpProgress->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPMid_00.png";
	hpProgressBot->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPBot_00.png";
	hpProgressEndCap->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPEnd_00.png";
	auto hpProgressEndCapFlash = hpForegroundFrame->findImage("hp img progress endcap flash");
	hpProgressEndCapFlash->disabled = true;
	const int framesPerAnimation = (HPBar.flashType == FLASH_ON_DAMAGE ? 1 : 2)/* * *cvar_hpanimdebug*/;
	const int numAnimationFrames = (HPBar.flashType == FLASH_ON_DAMAGE ? 20 : 2)/* * *cvar_hpanimdebug*/;
	if ( HPBar.flashTicks > 0 )
	{
		//messagePlayer(0, MESSAGE_DEBUG, "ticks: %d, animticks: %d, state: %d", ticks, HPBarFlashTicks, HPBarFlashAnimState);
		if ( HPBar.flashAnimState > numAnimationFrames || hpProgress->disabled )
		{
			HPBar.flashTicks = 0;
			HPBar.flashType = FLASH_ON_DAMAGE;
			HPBar.flashAnimState = -1;
			hpProgressEndCapFlash->disabled = true;
		}
		else
		{
			hpProgressEndCapFlash->disabled = hpProgressEndCap->disabled;
			if ( ticks == HPBar.flashTicks )
			{
				HPBar.flashAnimState = 1;
				HPBar.flashProcessedOnTick = ticks;
			}
			else if ( (HPBar.flashProcessedOnTick != ticks)
				&& (ticks > HPBar.flashTicks) 
				&& (ticks - HPBar.flashTicks) % framesPerAnimation == 0 )
			{
				++HPBar.flashAnimState;
				HPBar.flashProcessedOnTick = ticks;
			}

			if ( HPBar.flashType == 0 )
			{
				if ( HPBar.flashAnimState <= 6 )
				{
					hpProgressEndCapFlash->color = 0xFFFFFFFF;
				}

				if ( HPBar.flashAnimState == 0 )
				{
					hpProgress->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPMid_00.png";
					hpProgressEndCapFlash->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPEnd_F00.png";
					hpProgressBot->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPBot_00.png";
				}
				else if ( HPBar.flashAnimState >= 1 && HPBar.flashAnimState <= 2 )
				{
					hpProgress->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPMid_01.png";
					hpProgressEndCapFlash->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPEnd_F01.png";
					hpProgressBot->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPBot_01.png";
				}
				else if ( HPBar.flashAnimState == 3 )
				{
					hpProgress->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPMid_02.png";
					hpProgressEndCapFlash->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPEnd_F02.png";
					hpProgressBot->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPBot_02.png";
				}
				else if ( HPBar.flashAnimState >= 4 && HPBar.flashAnimState <= 5 )
				{
					hpProgress->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPMid_01.png";
					hpProgressEndCapFlash->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPEnd_F01.png";
					hpProgressBot->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPBot_01.png";
				}
				else if ( HPBar.flashAnimState == 6 )
				{
					hpProgress->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPMid_03.png";
					hpProgressEndCapFlash->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPEnd_F03.png";
					hpProgressBot->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPBot_03.png";
				}
				else
				{
					hpProgress->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPMid_00.png";
					hpProgressEndCapFlash->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPEnd_F04.png";
					Uint8 r, g, b, a;
					getColor(hpProgressEndCapFlash->color, &r, &g, &b, &a);
					int decrement = 20;
					real_t fpsScale = getFPSScale(60.0);
					decrement *= fpsScale;
					a = std::max(0, (int)a - decrement);
					hpProgressEndCapFlash->color = makeColor(r, g, b, a);
				}
			}
			else
			{
				hpProgressEndCapFlash->color = 0xFFFFFFFF;
				hpProgressEndCapFlash->disabled = true;
				if ( HPBar.flashAnimState == 1 )
				{
					hpProgress->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPMid_03.png";
					hpProgressBot->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPBot_03.png";
					hpProgressEndCap->path = "*#images/ui/HUD/hpmpbars/HUD_Bars_HPEnd_01.png";
				}
			}
		}
	}
	else
	{
		HPBar.flashAnimState = -1;
		hpProgressEndCapFlash->disabled = true;
	}
	{
		hpProgressEndCapFlash->pos.w = 22;
		hpProgressEndCapFlash->section.x = 0;
		hpProgressEndCapFlash->section.w = 0;
		if ( !hpProgressEndCap->disabled )
		{
			hpProgressEndCapFlash->pos.x = hpProgressEndCap->pos.x - (hpProgressEndCapFlash->pos.w - hpProgressEndCap->pos.w);
		}
		if ( hpProgressEndCapFlash->pos.x < hpProgressBot->pos.x )
		{
			// adjust end cap flash to clip correctly sliding past end of bar
			int overflowx = (hpProgressBot->pos.x - hpProgressEndCapFlash->pos.x);
			hpProgressEndCapFlash->section.x = (overflowx);
			hpProgressEndCapFlash->pos.x += overflowx;
			hpProgressEndCapFlash->pos.w -= overflowx;
			hpProgressEndCapFlash->section.w = hpProgressEndCapFlash->pos.w;
		}
	}

	hpFrame->setDisabled(player.ghost.isActive());
}

void Player::HUD_t::updateMPBar()
{
	if ( !mpFrame )
	{
		return;
	}

	bool bCompactWidth = false;
	bool bCompactHeight = player.bUseCompactGUIHeight();
	if ( player.bUseCompactGUIWidth() || (keystatus[SDLK_t] && enableDebugKeys) )
	{
		bCompactWidth = true;
	}

	SDL_Rect pos = mpFrame->getSize();
	pos.w = HPMP_FRAME_WIDTH + (bCompactWidth ? hpmpbarCompactOffsetWidth : hpmpbarOffsetWidth);
	if ( !player.bUseCompactGUIWidth()
		&& player.bUseCompactGUIHeight() && *MainMenu::clipped_splitscreen
		&& bShortHPMPForActionBars )
	{
		// shorten if action prompts visible in clipped wide mode
		pos.w -= kHPMPWidthReduce2pWideClippedActionPrompts; 
	}
	pos.x = HPMP_FRAME_START_X + ((bCompactWidth || bCompactHeight) ? hpmpbarCompactOffsetX : hpmpbarOffsetX);
	pos.y = hudFrame->getSize().h - HPMP_FRAME_START_Y + HPMP_FRAME_HEIGHT + ((bCompactWidth || bCompactHeight) ? hpmpbarCompactOffsetY : hpmpbarOffsetY);
	pos.y -= player.hud.offsetHUDAboveHotbarHeight;
	mpFrame->setSize(pos);

	auto mpForegroundFrame = mpFrame->findFrame("mp foreground frame");
	{
		auto _pos = mpForegroundFrame->getSize();
		_pos.w = pos.w;
		mpForegroundFrame->setSize(_pos);
	}

	auto mpBg = mpFrame->findImage("mp img base");
	auto mpEndcap = mpForegroundFrame->findImage("mp img endcap");
	auto mpProgressBot = mpForegroundFrame->findImage("mp img progress bot");
	auto mpProgress = mpForegroundFrame->findImage("mp img progress");
	auto mpProgressEndCap = mpForegroundFrame->findImage("mp img progress endcap");
	auto mpFadeFrame = mpFrame->findFrame("mp fade frame");
	{
		auto _pos = mpFadeFrame->getSize();
		_pos.w = pos.w;
		mpFadeFrame->setSize(_pos);
	}
	auto mpFadedBase = mpFadeFrame->findImage("mp img fade bot");
	mpFadedBase->path = MPBarPaths_t::get(player.playernum, "mp img fade bot");
	auto mpFaded = mpFadeFrame->findImage("mp img fade");
	mpFaded->path = MPBarPaths_t::get(player.playernum, "mp img fade");
	auto mpFadedEndCap = mpFadeFrame->findImage("mp img fade endcap");
	mpFadedEndCap->path = MPBarPaths_t::get(player.playernum, "mp img fade endcap");
	auto mpBase = mpForegroundFrame->findImage("mp img value");
	mpBase->path = MPBarPaths_t::get(player.playernum, "mp img value");

	real_t progressWidth = mpFrame->getSize().w - 74;
	int backgroundWidth = mpFrame->getSize().w - 54;

	// handle bar size changing
	{
		real_t multiplier = 1.0;
		const Sint32 maxMPWidth = (bCompactWidth ? hpmpbarCompactMaxWidthAmount : hpmpbarMaxWidthAmount);
		if ( stats[player.playernum]->MAXMP < maxMPWidth )
		{
			// start at 30%, increase 2.5% every 5 MP past 20 MAXMP
			multiplier = (bCompactWidth ? hpmpbarCompactBasePercentSize : hpmpbarBasePercentSize) / 100.0;
			real_t widthIntervalPercent = (bCompactWidth ? hpmpbarCompactWidthIncreasePercentOnInterval : hpmpbarWidthIncreasePercentOnInterval) / 100.0;
			int intervalThreshold = (bCompactWidth ? hpmpbarCompactIntervalToIncreaseWidth : hpmpbarIntervalToIncreaseWidth);
			int baseIntervalStart = (bCompactWidth ? hpmpbarCompactIntervalStartValue : hpmpbarIntervalStartValue);
			multiplier += (widthIntervalPercent * ((std::max(0, stats[player.playernum]->MAXMP - baseIntervalStart) / intervalThreshold)));
		}

		int diff = static_cast<int>(std::max(0.0, progressWidth - progressWidth * multiplier)); // how many pixels the progress bar shrinks
		progressWidth *= multiplier; // scale the progress bars
		mpBg->pos.w = backgroundWidth - diff; // move the background bar by x pixels as above
		mpEndcap->pos.x = mpFrame->getSize().w - mpEndcap->pos.w - diff; // move the background endcap by x pixels as above
	}

	MPBar.animatePreviousSetpoint = MPBar.animateSetpoint;
	real_t& mpForegroundValue = MPBar.animateValue;
	real_t& mpFadedValue = MPBar.animateValue2;

	MPBar.animateSetpoint = stats[player.playernum]->MP;

	bool flashAnimationPreviouslyPlaying = MPBar.flashTicks > 0;
	if ( MPBar.animateSetpoint < MPBar.animatePreviousSetpoint ) // insta-change as losing health
	{
		mpForegroundValue = MPBar.animateSetpoint;
		MPBar.animateTicks = ticks;

		// flash for taking damage
		MPBar.flashTicks = ticks;
		MPBar.flashProcessedOnTick = 0;
		MPBar.flashAnimState = -1;
		MPBar.flashType = FLASH_ON_DAMAGE;
	}

	if ( MPBar.maxValue > stats[player.playernum]->MAXMP )
	{
		mpFadedValue = MPBar.animateSetpoint; // resetting game etc, stop fade animation sticking out of frame
	}

	MPBar.maxValue = stats[player.playernum]->MAXMP;
	if ( mpForegroundValue < MPBar.animateSetpoint ) // gaining MP, animate
	{
		// flash for gaining MP, provided not already flashing
		/*if ( MPBar.flashAnimState == -1 || (MPBar.flashAnimState >= 0 && MPBar.flashType != FLASH_ON_DAMAGE) )
		{
			MPBar.flashTicks = ticks;
			MPBar.flashAnimState = -1;
			MPBar.flashType = FLASH_ON_RECOVERY;
		}*/

		real_t setpointDiff = std::max(.1, MPBar.animateSetpoint - mpForegroundValue);
		real_t fpsScale = getFPSScale(144.0);
		mpForegroundValue += fpsScale * (setpointDiff / 20.0); // reach it in 20 intervals, scaled to FPS
		mpForegroundValue = std::min(static_cast<real_t>(MPBar.animateSetpoint), mpForegroundValue);

		/*if ( abs(MPBar.animateSetpoint) - abs(mpForegroundValue) <= 1.0 )
		{
			mpForegroundValue = MPBar.animateSetpoint;
		}*/
	}
	else if ( mpForegroundValue > MPBar.animateSetpoint ) // losing MP, snap to value
	{
		mpForegroundValue = MPBar.animateSetpoint;
	}

	if ( mpFadedValue < MPBar.animateSetpoint )
	{
		mpFadedValue = mpForegroundValue;
		MPBar.animateTicks = ticks;
	}
	else if ( mpFadedValue > MPBar.animateSetpoint )
	{
		if ( ticks - MPBar.animateTicks > 30 /*|| stats[player.playernum]->MP <= 0*/ ) // fall after x ticks
		{
			real_t setpointDiff = std::max(0.1, mpFadedValue - MPBar.animateSetpoint);
			real_t fpsScale = getFPSScale(144.0);
			mpFadedValue -= fpsScale * (setpointDiff / 20.0); // reach it in 20 intervals, scaled to FPS
			mpFadedValue = std::max(static_cast<real_t>(MPBar.animateSetpoint), mpFadedValue);
		}
	}
	else
	{
		MPBar.animateTicks = ticks;
	}

	char playerMPText[16];
	snprintf(playerMPText, sizeof(playerMPText), "%d", stats[player.playernum]->MP);

	auto mpText = mpForegroundFrame->findField("mp text");
	mpText->setText(playerMPText);

	real_t foregroundPercent = mpForegroundValue / MPBar.maxValue;
	mpProgress->pos.w = std::max(1, static_cast<int>((progressWidth)* foregroundPercent));
	mpProgressEndCap->pos.x = mpProgress->pos.x + mpProgress->pos.w;

	real_t fadePercent = mpFadedValue / MPBar.maxValue;
	mpFaded->pos.w = std::max(1, static_cast<int>((progressWidth)* fadePercent));
	mpFadedEndCap->pos.x = mpFaded->pos.x + mpFaded->pos.w;
	if ( mpFaded->pos.w == 1 && stats[player.playernum]->MP <= 0 )
	{
		mpFaded->disabled = true;
		real_t opacity = mpFadeFrame->getOpacity();
		real_t opacityChange = .5 * getFPSScale(144.0); // change by .05% independant of fps
		mpFadeFrame->setOpacity(std::max(0.0, opacity - opacityChange));

		// make this element fade out to the left, starting 54px then finally at 40px. @ 40px it's out of shot (6 width + 8 endcap width)
		mpFadedBase->pos.x = 54 - (14 * (1.0 - opacity / 100.0));
		mpFadedEndCap->pos.x = mpFadedBase->pos.x + mpFadedBase->pos.w;
	}
	else
	{
		mpFaded->disabled = false;
		mpFadeFrame->setOpacity(100.0);

		// reset to 54px left as we altered in above if statement
		mpFadedBase->pos.x = 54;
	}

	if ( stats[player.playernum]->MP <= 0 )
	{
		// hide all the progress elements when dead, as endcap/base don't shrink
		// mpProgress width 0px defaults to original size, so hide that too
		mpProgress->disabled = true;
		mpProgressEndCap->disabled = true;
		mpProgressBot->disabled = true;
	}
	else
	{
		mpProgress->disabled = false;
		mpProgressEndCap->disabled = false;
		mpProgressBot->disabled = false;
	}

	// dividers
	{
		const int fullBarWidth = mpProgressBot->pos.w + progressWidth + mpEndcap->pos.w / 2;
		auto div25Percent = mpForegroundFrame->findImage("mp img div 25pc");
		div25Percent->disabled = false;
		div25Percent->pos.x = mpProgressBot->pos.x + fullBarWidth * .25 - 2;
		auto div50Percent = mpForegroundFrame->findImage("mp img div 50pc");
		div50Percent->disabled = false;
		div50Percent->pos.x = mpProgressBot->pos.x + fullBarWidth * .5 - 2;
		auto div75Percent = mpForegroundFrame->findImage("mp img div 75pc");
		div75Percent->disabled = false;
		div75Percent->pos.x = mpProgressBot->pos.x + fullBarWidth * .75 - 2;

		if ( div50Percent->pos.x - div25Percent->pos.x < HPMPdividerThresholdInterval )
		{
			div75Percent->disabled = true;
			// 2 dividers 33%/66%
			div25Percent->pos.x = mpProgressBot->pos.x + fullBarWidth * .33 - 2;
			div50Percent->pos.x = mpProgressBot->pos.x + fullBarWidth * .66 - 2;
			if ( div50Percent->pos.x - div25Percent->pos.x < HPMPdividerThresholdInterval )
			{
				// 1 divider 50%
				div25Percent->disabled = true;
				div50Percent->pos.x = mpProgressBot->pos.x + fullBarWidth * .5 - 2;
			}
		}
	}

	mpProgress->path = MPBarPaths_t::get(player.playernum, "mp img progress");
	mpProgressBot->path = MPBarPaths_t::get(player.playernum, "mp img progress bot");
	mpProgressEndCap->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap");
	auto mpProgressEndCapFlash = mpForegroundFrame->findImage("mp img progress endcap flash");
	mpProgressEndCapFlash->disabled = true;
	const int framesPerAnimation = (MPBar.flashType == FLASH_ON_DAMAGE ? 1 : 2)/* * *cvar_hpanimdebug*/;
	const int numAnimationFrames = (MPBar.flashType == FLASH_ON_DAMAGE ? 30 : 2)/* * *cvar_hpanimdebug*/;
	if ( MPBar.flashTicks > 0 )
	{
		if ( MPBar.flashAnimState > numAnimationFrames || mpProgress->disabled )
		{
			MPBar.flashTicks = 0;
			MPBar.flashType = FLASH_ON_DAMAGE;
			MPBar.flashAnimState = -1;
			mpProgressEndCapFlash->disabled = true;
		}
		else
		{
			mpProgressEndCapFlash->disabled = mpProgressEndCap->disabled;
			bool processedOnTick = MPBar.flashProcessedOnTick == ticks;
			if ( ticks == MPBar.flashTicks )
			{
				MPBar.flashAnimState = 1;
				MPBar.flashProcessedOnTick = ticks;

				if ( mpProgressEndCapFlash->path == MPBarPaths_t::get(player.playernum, "mp img progress endcap flash 1")
					|| mpProgressEndCapFlash->path == MPBarPaths_t::get(player.playernum, "mp img progress endcap flash 2")
					|| mpProgressEndCapFlash->path == MPBarPaths_t::get(player.playernum, "mp img progress endcap flash 3") )
				{
					mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash"); // reset to no full flash
				}
			}
			else if ( (!processedOnTick)
				&& (ticks > MPBar.flashTicks)
				&& (ticks - MPBar.flashTicks) % framesPerAnimation == 0 )
			{
				++MPBar.flashAnimState;
				MPBar.flashProcessedOnTick = ticks;
			}

			if ( MPBar.flashType == 0 )
			{
				if ( MPBar.flashAnimState <= 16 && MPBar.flashAnimState >= 10 )
				{
					mpProgressEndCapFlash->color = 0xFFFFFFFF;
				}
				else if ( MPBar.flashAnimState == 0 )
				{
					mpProgressEndCapFlash->color = makeColor(255, 255, 255, 0);
					mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash");
				}

				if ( MPBar.flashAnimState <= 9 )
				{
					if ( MPBar.flashAnimState == 7 )
					{
						// we need the MP bar to flash long enough for long spellcast times
						// can adjust how many animStates we skip here to play with timing,
						// without changing other state machine code
						MPBar.flashAnimState = 9; // 1, 2 skip a few..
					}
					Uint8 r, g, b, a;
					getColor(mpProgressEndCapFlash->color, &r, &g, &b, &a);
					int increment = 10;
					real_t fpsScale = getFPSScale(60.0);
					increment *= fpsScale;
					a = std::min(255, (int)a + increment);
					mpProgressEndCapFlash->color = makeColor(r, g, b, a);

					mpProgress->path = MPBarPaths_t::get(player.playernum, "mp img progress");
					mpProgressBot->path = MPBarPaths_t::get(player.playernum, "mp img progress bot");

					if ( MPBar.flashAnimState % 2 == 0
						&& !processedOnTick )
					{
						if ( mpProgressEndCapFlash->path == MPBarPaths_t::get(player.playernum, "mp img progress endcap flash") )
						{
							mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash b");
						}
						else if ( mpProgressEndCapFlash->path == MPBarPaths_t::get(player.playernum, "mp img progress endcap flash b") )
						{
							mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash c");
						}
						else if ( mpProgressEndCapFlash->path == MPBarPaths_t::get(player.playernum, "mp img progress endcap flash c") )
						{
							mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash d");
						}
						else 
						{
							mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash");
						}
					}
				}
				else if ( MPBar.flashAnimState <= 10 )
				{
					mpProgress->path = MPBarPaths_t::get(player.playernum, "mp img progress");
					mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash");
					mpProgressBot->path = MPBarPaths_t::get(player.playernum, "mp img progress bot");
				}
				else if ( MPBar.flashAnimState >= 11 && MPBar.flashAnimState <= 12 )
				{
					mpProgress->path = MPBarPaths_t::get(player.playernum, "mp img progress 1");
					mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash 1");
					mpProgressBot->path = MPBarPaths_t::get(player.playernum, "mp img progress bot 1");
				}
				else if ( MPBar.flashAnimState == 13 )
				{
					mpProgress->path = MPBarPaths_t::get(player.playernum, "mp img progress 2");
					mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash 2");
					mpProgressBot->path = MPBarPaths_t::get(player.playernum, "mp img progress bot 2");
				}
				else if ( MPBar.flashAnimState >= 14 && MPBar.flashAnimState <= 15 )
				{
					mpProgress->path = MPBarPaths_t::get(player.playernum, "mp img progress 1");
					mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash 1");
					mpProgressBot->path = MPBarPaths_t::get(player.playernum, "mp img progress bot 1");
				}
				else if ( MPBar.flashAnimState == 16 )
				{
					mpProgress->path = MPBarPaths_t::get(player.playernum, "mp img progress 3");
					mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash 3");
					mpProgressBot->path = MPBarPaths_t::get(player.playernum, "mp img progress bot 3");
				}
				else
				{
					mpProgress->path = MPBarPaths_t::get(player.playernum, "mp img progress");
					mpProgressEndCapFlash->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap flash 4");
					Uint8 r, g, b, a;
					getColor(mpProgressEndCapFlash->color, &r, &g, &b, &a);
					int decrement = 20;
					real_t fpsScale = getFPSScale(60.0);
					decrement *= fpsScale;
					a = std::max(0, (int)a - decrement);
					mpProgressEndCapFlash->color = makeColor(r, g, b, a);
				}
			}
			else
			{
				mpProgressEndCapFlash->color = 0xFFFFFFFF;
				mpProgressEndCapFlash->disabled = true;
				if ( MPBar.flashAnimState == 1 )
				{
					mpProgress->path = MPBarPaths_t::get(player.playernum, "mp img progress 3");
					mpProgressBot->path = MPBarPaths_t::get(player.playernum, "mp img progress bot 3");
					mpProgressEndCap->path = MPBarPaths_t::get(player.playernum, "mp img progress endcap 1");
				}
			}
		}
	}
	else
	{
		MPBar.flashAnimState = -1;
		mpProgressEndCapFlash->disabled = true;
	}

	{
		mpProgressEndCapFlash->pos.w = 22;
		mpProgressEndCapFlash->section.x = 0;
		mpProgressEndCapFlash->section.w = 0;
		if ( !mpProgressEndCap->disabled )
		{
			mpProgressEndCapFlash->pos.x = mpProgressEndCap->pos.x - (mpProgressEndCapFlash->pos.w - mpProgressEndCap->pos.w);
		}
		if ( mpProgressEndCapFlash->pos.x < mpProgressBot->pos.x )
		{
			// adjust end cap flash to clip correctly sliding past end of bar
			int overflowx = (mpProgressBot->pos.x - mpProgressEndCapFlash->pos.x);
			mpProgressEndCapFlash->section.x = (overflowx);
			mpProgressEndCapFlash->pos.x += overflowx;
			mpProgressEndCapFlash->pos.w -= overflowx;
			mpProgressEndCapFlash->section.w = mpProgressEndCapFlash->pos.w;
		}
	}

	if ( player.magic.noManaProcessedOnTick != 0 )
	{
		if ( ticks != player.magic.noManaProcessedOnTick )
		{
			++player.magic.noManaFeedbackTicks;
			player.magic.noManaProcessedOnTick = ticks;
		}
		if ( player.magic.noManaFeedbackTicks > TICKS_PER_SECOND )
		{
			player.magic.noManaProcessedOnTick = 0;
			player.magic.noManaFeedbackTicks = 0;
		}
	}

	mpFrame->setDisabled(player.ghost.isActive());
}

bool hotbar_slot_t::matchesExactLastItem(int player, Item* item)
{
	if ( !item ) { return false; }
	if ( lastItem.uid == item->uid ) { return true; }
	if ( lastItem.type == item->type
		&& lastItem.status == item->status
		&& lastItem.count == item->count
		&& lastItem.identified == item->identified )
	{
		if ( item->shouldItemStack(player, true) )
		{
			return true;
		}
		else
		{
			return lastItem.appearance == item->appearance;
		}
	}
	return false;
}

void hotbar_slot_t::resetLastItem()
{
	lastCategory = -1;
	lastItem.type = WOODEN_SHIELD;
	lastItem.appearance = -1;
	lastItem.status = BROKEN;
	lastItem.count = 0;
	lastItem.identified = false;
	lastItem.uid = 0;
}

void hotbar_slot_t::storeLastItem(Item* item)
{
	if ( !item ) { return; }
	if ( !item->identified ) { return; }
	lastItem.type = item->type;
	lastItem.appearance = item->appearance;
	lastItem.status = item->status;
	lastItem.count = item->count;
	lastItem.identified = item->identified;
	lastItem.uid = item->uid;
	lastCategory = itemCategory(item);
}

std::string hotbarSlotBindingText(const int player, const int slotnum, const Input::binding_t& binding)
{
	std::string inputName = "";
	if ( binding.type == Input::binding_t::KEYBOARD && binding.keycode != SDLK_UNKNOWN )
	{
		if ( binding.keycode >= SDLK_0 && binding.keycode <= SDLK_9 )
		{
			inputName = SDL_GetKeyName(binding.keycode);
		}
	}
	else if ( binding.type != Input::binding_t::MOUSE_BUTTON )
	{
		if ( slotnum + 1 == 10 )
		{
			inputName = "0";
		}
		else
		{
			inputName = std::to_string(slotnum + 1);
		}
	}
	return inputName;
}

void Player::Hotbar_t::updateHotbar()
{
	if ( !hotbarFrame )
	{
		return;
	}

	hotbarFrame->setOpacity(hotbarFrame->getParent()->getOpacity());
	bool tempHideHotbar = false;
	if ( player.ghost.isActive() )
	{
		tempHideHotbar = true;
	}
	else if ( player.bUseCompactGUIHeight()
		&& (player.gui_mode == GUI_MODE_FOLLOWERMENU
			|| player.gui_mode == GUI_MODE_CALLOUT
			|| (player.hud.compactLayoutMode == Player::HUD_t::COMPACT_LAYOUT_CHARSHEET && !player.shootmode)
			|| (player.gui_mode == GUI_MODE_MAGIC)
			|| (player.shopGUI.bOpen)
			|| (player.inventoryUI.chestGUI.bOpen)
			|| player.minimap.mapWindow
			|| player.messageZone.logWindow
			|| (GenericGUI[player.playernum].isGUIOpen())
		) )
	{
		tempHideHotbar = true;
	}
	else if ( (!player.bUseCompactGUIHeight() && player.bUseCompactGUIWidth())
		&& (player.hud.compactLayoutMode == Player::HUD_t::COMPACT_LAYOUT_CHARSHEET && !player.shootmode) )
	{
		tempHideHotbar = true;
	}
	if ( tempHideHotbar )
	{
		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
		real_t setpointDiff = fpsScale * std::max(.1, (1.0 - animHide)) / 2.5;
		animHide += setpointDiff;
		animHide = std::min(1.0, animHide);
		isInteractable = true;
	}
	else
	{
		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
		real_t setpointDiff = fpsScale * std::max(.1, (animHide)) / 2.5;
		animHide -= setpointDiff;
		animHide = std::max(0.0, animHide);
		if ( animHide <= 0.001 )
		{
			isInteractable = true;
		}
	}

	if ( player.bUseCompactGUIHeight() && player.bUseCompactGUIWidth() 
		&& !player.shootmode && player.GUI.activeModule != Player::GUI_t::MODULE_HOTBAR )
	{
		hotbarFrame->setOpacity(75.0);
	}

	bool bCompactView = false;
	bool loweredY = false;
	int compactDisableLeftRightOffsetX = 0;
	if ( (keystatus[SDLK_u] && enableDebugKeys) || player.bUseCompactGUIWidth() )
	{
		if ( !*cvar_hotbar_compact_disable )
		{
			bCompactView = true;
		}
		else
		{
			compactDisableLeftRightOffsetX = 8;
		}
		loweredY = true;
	}
	else if ( player.bUseCompactGUIHeight() )
	{
		loweredY = true;
	}
	int hotbarStartY1 = hotbarFrame->getSize().h + getHotbarStartY1(); // higher row (center group)
	int hotbarStartY2 = hotbarFrame->getSize().h + getHotbarStartY2(); // lower row (left/right)
	hotbarStartY1 += ((bCompactView || loweredY) ? hotbarCompactOffsetY : hotbarOffsetY);
	hotbarStartY2 += ((bCompactView || loweredY) ? hotbarCompactOffsetY : hotbarOffsetY);

	static ConsoleVariable<int> cvar_hotbar_splitscreen_center_x("/hotbar_splitscreen_center_x", 0);
	const int hotbarCentreX = (hotbarFrame->getSize().w / 2) + *cvar_hotbar_splitscreen_center_x;
	int hotbarCentreXLeft = hotbarCentreX - 148 + (bCompactView ? hotbarCompactOffsetX : compactDisableLeftRightOffsetX);
	int hotbarCentreXRight = hotbarCentreX + 148 - (bCompactView ? hotbarCompactOffsetX : compactDisableLeftRightOffsetX);
	hotbarStartY1 += animHide * abs(getHotbarStartY1());
	hotbarStartY2 += animHide * abs(getHotbarStartY1());

	if ( !player.shootmode || FollowerMenu[player.playernum].followerMenuIsOpen()
		|| CalloutMenu[player.playernum].calloutMenuIsOpen() )
	{
        if (player.hotbar.useHotbarFaceMenu)
        {
            if ( Input::inputs[player.playernum].binaryToggle("Hotbar Down / Cancel") )
            {
                Input::inputs[player.playernum].consumeBinaryToggle("Hotbar Down / Cancel");
            }
            if ( Input::inputs[player.playernum].binaryToggle("Hotbar Left") )
            {
                Input::inputs[player.playernum].consumeBinaryToggle("Hotbar Left");
            }
            if ( Input::inputs[player.playernum].binaryToggle("Hotbar Up / Select") )
            {
                Input::inputs[player.playernum].consumeBinaryToggle("Hotbar Up / Select");
            }
            if ( Input::inputs[player.playernum].binaryToggle("Hotbar Right") )
            {
                Input::inputs[player.playernum].consumeBinaryToggle("Hotbar Right");
            }
        }
		faceMenuButtonHeld = FaceMenuGroup::GROUP_NONE;
	}

	bool faceMenuSnapCursorInstantly = false;
	if ( faceMenuButtonHeld != FaceMenuGroup::GROUP_NONE || (player.GUI.activeModule == Player::GUI_t::MODULE_HOTBAR && !player.shootmode) )
	{
		if ( selectedSlotAnimateCurrentValue == 0.0 )
		{
			faceMenuSnapCursorInstantly = true;
		}
		real_t fpsScale = getFPSScale(144.0);
		real_t setpointDiff = std::max(0.1, 1.0 - selectedSlotAnimateCurrentValue);
		selectedSlotAnimateCurrentValue += fpsScale * (setpointDiff / 10.0);
		selectedSlotAnimateCurrentValue = std::min(1.0, selectedSlotAnimateCurrentValue);
	}
	else
	{
		selectedSlotAnimateCurrentValue = 0.0;
	}

	auto highlightSlot = hotbarFrame->findFrame("hotbar highlight");
	auto highlightSlotImg = highlightSlot->findImage("highlight img");
	highlightSlotImg->disabled = true;
	auto highlightNumText = highlightSlot->findField("slot num text");
	highlightNumText->setDisabled(true);

	auto shootmodeSelectedSlotCursor = hotbarFrame->findFrame("shootmode selected item cursor");
	if ( shootmodeSelectedSlotCursor )
	{
		shootmodeSelectedSlotCursor->setDisabled(true);
	}

	if ( player.shootmode || !inputs.getUIInteraction(player.playernum)->selectedItem )
	{
		if ( auto oldSelectedItemFrame = hotbarFrame->findFrame("hotbar old selected item") )
		{
			oldSelectedItemFrame->setDisabled(true);
		}
	}

	auto cancelPromptTxt = hotbarFrame->findField("hotbar cancel prompt");
	cancelPromptTxt->setDisabled(true);
	auto cancelPromptGlyph = hotbarFrame->findImage("hotbar cancel glyph");
	cancelPromptGlyph->disabled = true;

	if ( (!bCompactView && !loweredY) && useHotbarFaceMenu && faceMenuButtonHeld != FaceMenuGroup::GROUP_NONE )
	{
		cancelPromptTxt->setDisabled(false);
		cancelPromptTxt->setText(Language::get(3063));
		static ConsoleVariable<int> cvar_hotbar_cancel_prompt_y("/hotbar_cancel_prompt_y", -6);
		static ConsoleVariable<int> cvar_hotbar_cancel_prompt_x("/hotbar_cancel_prompt_x", 29);
		cancelPromptGlyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("Hotbar Down / Cancel");
		if ( auto imgGet = Image::get(cancelPromptGlyph->path.c_str()) )
		{
			cancelPromptGlyph->pos.w = imgGet->getWidth();
			cancelPromptGlyph->pos.h = imgGet->getHeight();
			cancelPromptGlyph->disabled = false;
		}
		SDL_Rect promptTxtPos = cancelPromptTxt->getSize();
		promptTxtPos.x = hotbarCentreX + *cvar_hotbar_cancel_prompt_x;
		promptTxtPos.y = hotbarStartY1 + getSlotSize() - 2;
		if ( auto textGet = cancelPromptTxt->getTextObject() )
		{
			promptTxtPos.x -= textGet->getWidth() / 2;
			promptTxtPos.x += cancelPromptGlyph->pos.w / 2 + 2;
			if ( promptTxtPos.x % 2 == 1 )
			{
				++promptTxtPos.x;
			}
		}
		cancelPromptGlyph->pos.y = promptTxtPos.y + *cvar_hotbar_cancel_prompt_y;
		cancelPromptGlyph->pos.x = promptTxtPos.x - 4 - cancelPromptGlyph->pos.w;
		cancelPromptTxt->setSize(promptTxtPos);
	}

	// position the slots
	for ( int num = 0; num < NUM_HOTBAR_SLOTS; ++num )
	{
		if ( hotbar[num].item != 0 )
		{
			if ( Item* item = uidToItem(hotbar[num].item) )
			{
				if ( hotbar[num].item == hotbar[num].lastItem.uid
					&& hotbar[num].lastItem.status > BROKEN
					&& item->status == BROKEN )
				{
					// de-hotbar newly broken stuff
					hotbar[num].item = 0;
					hotbar[num].resetLastItem();
				}
				else
				{
					hotbar[num].storeLastItem(item);
				}
			}
		}

		auto slot = getHotbarSlotFrame(num);
		assert(slot);

		if ( auto img = slot->findImage("slot img") ) // apply any opacity from config
		{
			Uint8 r, g, b, a;
			getColor(img->color, &r, &g, &b, &a);
			a = hotbarSlotOpacity;
			img->color = makeColor( r, g, b, a);
		}
		if ( highlightSlotImg )
		{
			Uint8 r, g, b, a;
			getColor(highlightSlotImg->color, &r, &g, &b, &a);
			a = hotbarSelectedSlotOpacity;
			highlightSlotImg->color = makeColor( r, g, b, a);
		}

		char glyphname[32];
		snprintf(glyphname, sizeof(glyphname), "hotbar glyph %d", num);
		auto glyph = hotbarFrame->findImage(glyphname);
		assert(glyph);
		glyph->disabled = true;

		if ( useHotbarFaceMenu && num == 9 )
		{
			slot->setDisabled(true);
		}
		else
		{
			slot->setDisabled(false);
		}

		SDL_Rect pos = slot->getSize();
		int compactViewOffset = 0;
		int compactInactiveSlotOffset = 0;
		int compactExpandedOffsetX = 0;
		int centreXLeft = hotbarCentreXLeft;
		int centreXRight = hotbarCentreXRight;
		int centreX = hotbarCentreX;
		bool compactViewNavigation = (player.GUI.activeModule == Player::GUI_t::MODULE_HOTBAR && !player.shootmode)
			|| *cvar_hotbar_compact_use_fullsize;
		if ( bCompactView )
		{
			if ( compactViewNavigation )
			{
				compactViewOffset = pos.w * hotbarCompactSlotOverlapPercent / 2.0;

				compactExpandedOffsetX = hotbarCompactExpandedOffsetX;
				centreXLeft -= compactExpandedOffsetX;
				centreXRight += compactExpandedOffsetX;
			}
			else
			{
				compactViewOffset = pos.w * hotbarCompactSlotOverlapPercent;
			}
			compactInactiveSlotOffset = (hotbarCompactInactiveSlotMovementX + (*cvar_hotbar_compact_use_fullsize ? -6 : 0))
				* selectedSlotAnimateCurrentValue;

			if ( faceMenuButtonHeld != FaceMenuGroup::GROUP_NONE )
			{
				if ( faceMenuButtonHeld == FaceMenuGroup::GROUP_LEFT )
				{
					centreX += compactInactiveSlotOffset;
					centreXRight += compactInactiveSlotOffset;
				}
				else if( faceMenuButtonHeld == FaceMenuGroup::GROUP_MIDDLE )
				{
					centreXLeft -= compactInactiveSlotOffset;
					centreXRight += compactInactiveSlotOffset;
				}
				else if ( faceMenuButtonHeld == FaceMenuGroup::GROUP_RIGHT )
				{
					centreXLeft -= compactInactiveSlotOffset;
					centreX -= compactInactiveSlotOffset;
				}
			}
		}
		pos.x = centreX;
		pos.y = hotbarStartY2;

		int slotYMovement = pos.h / 4;

		auto slotItem = slot->findFrame("hotbar slot item");
		slotItem->setDisabled(true);

		if ( useHotbarFaceMenu )
		{
			GameController* controller = inputs.getController(player.playernum);
			if ( controller )
			{
				glyph->disabled = slot->isDisabled();
				if ( !player.shootmode || !player.entity )
				{
					glyph->disabled = true;
				}
			}

			slot->findField("slot num text")->setDisabled(true); // disable the hotkey prompts per slot
			switch ( num )
			{
				// left group
				case 0:
					pos.x = centreXLeft - pos.w / 2 - pos.w + 2 + compactViewOffset;
					if ( faceMenuButtonHeld == FaceMenuGroup::GROUP_LEFT )
					{
						pos.y -= slotYMovement * selectedSlotAnimateCurrentValue;
						pos.x -= compactViewOffset * selectedSlotAnimateCurrentValue;
					}
					else
					{
						glyph->disabled = true;
					}
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("HotbarFacebarModifierLeft");
					break;
				case 1:
					pos.x = centreXLeft - pos.w / 2;
					pos.y -= slotYMovement;
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("Hotbar Left",
						faceMenuButtonHeld == FaceMenuGroup::GROUP_LEFT);
					if ( faceMenuButtonHeld != FaceMenuGroup::GROUP_LEFT
						&& faceMenuButtonHeld != FaceMenuGroup::GROUP_NONE )
					{
						glyph->color = makeColor(255, 255, 255, 255 * (1.0 - selectedSlotAnimateCurrentValue / 2));
						//glyph->disabled = true;
					}
					else
					{
						glyph->color = 0xFFFFFFFF;
					}
					break;
				case 2:
					pos.x = centreXLeft + (pos.w / 2 - 2) - compactViewOffset;
					if ( faceMenuButtonHeld == FaceMenuGroup::GROUP_LEFT )
					{
						pos.y -= slotYMovement * selectedSlotAnimateCurrentValue;
						pos.x += compactViewOffset * selectedSlotAnimateCurrentValue;
					}
					else
					{
						glyph->disabled = true;
					}
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("HotbarFacebarModifierRight");
					break;
				// middle group
				case 3:
					pos.y = hotbarStartY1;
					pos.x = centreX - pos.w / 2 - pos.w + 2 + compactViewOffset;
					if ( faceMenuButtonHeld == FaceMenuGroup::GROUP_MIDDLE )
					{
						pos.y -= slotYMovement * selectedSlotAnimateCurrentValue;
						pos.x -= compactViewOffset * selectedSlotAnimateCurrentValue;
					}
					else
					{
						glyph->disabled = true;
					}
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("HotbarFacebarModifierLeft");
					break;
				case 4:
					pos.y = hotbarStartY1;
					pos.y -= slotYMovement;
					pos.x = centreX - pos.w / 2;
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("Hotbar Up / Select",
						faceMenuButtonHeld == FaceMenuGroup::GROUP_MIDDLE);
					if ( faceMenuButtonHeld != FaceMenuGroup::GROUP_MIDDLE
						&& faceMenuButtonHeld != FaceMenuGroup::GROUP_NONE )
					{
						glyph->color = makeColor(255, 255, 255, 255 * (1.0 - selectedSlotAnimateCurrentValue / 2));
						//glyph->disabled = true;
					}
					else
					{
						glyph->color = 0xFFFFFFFF;
					}
					break;
				case 5:
					pos.y = hotbarStartY1;
					pos.x = centreX + (pos.w / 2 - 2) - compactViewOffset;
					if ( faceMenuButtonHeld == FaceMenuGroup::GROUP_MIDDLE )
					{
						pos.y -= slotYMovement * selectedSlotAnimateCurrentValue;
						pos.x += compactViewOffset * selectedSlotAnimateCurrentValue;
					}
					else
					{
						glyph->disabled = true;
					}
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("HotbarFacebarModifierRight");
					break;
				// right group
				case 6:
					pos.x = centreXRight - pos.w / 2 - pos.w + 2 + compactViewOffset;
					if ( faceMenuButtonHeld == FaceMenuGroup::GROUP_RIGHT )
					{
						pos.y -= slotYMovement * selectedSlotAnimateCurrentValue;
						pos.x -= compactViewOffset * selectedSlotAnimateCurrentValue;
					}
					else
					{
						glyph->disabled = true;
					}
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("HotbarFacebarModifierLeft");
					break;
				case 7:
					pos.x = centreXRight - pos.w / 2;
					pos.y -= slotYMovement;
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("Hotbar Right",
						faceMenuButtonHeld == FaceMenuGroup::GROUP_RIGHT);
					if ( faceMenuButtonHeld != FaceMenuGroup::GROUP_RIGHT
						&& faceMenuButtonHeld != FaceMenuGroup::GROUP_NONE )
					{
						glyph->color = makeColor(255, 255, 255, 255 * (1.0 - selectedSlotAnimateCurrentValue / 2));
						//glyph->disabled = true;
					}
					else
					{
						glyph->color = 0xFFFFFFFF;
					}
					break;
				case 8:
					pos.x = centreXRight + (pos.w / 2 - 2) - compactViewOffset;
					if ( faceMenuButtonHeld == FaceMenuGroup::GROUP_RIGHT )
					{
						pos.y -= slotYMovement * selectedSlotAnimateCurrentValue;
						pos.x += compactViewOffset * selectedSlotAnimateCurrentValue;
					}
					else
					{
						glyph->disabled = true;
					}
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("HotbarFacebarModifierRight");
					break;
				default:
					break;
			}

			slot->setSize(pos);

			auto glyphImage = Image::get(glyph->path.c_str());
			if ( glyphImage )
			{
				glyph->pos.w = std::min((int)glyphImage->getWidth(), slot->getSize().w);
				glyph->pos.h = glyphImage->getHeight();
				glyph->pos.x = pos.x + pos.w / 2 - glyph->pos.w / 2;
				glyph->pos.y = pos.y - glyph->pos.h;
			}
		}
		else
		{
			auto slot_text = slot->findField("slot num text");
			slot_text->setDisabled(false); // enable the hotkey prompts per slot
			std::string slotstr = "Hotbar Slot " + std::to_string(num + 1);
			auto binding = Input::inputs[player.playernum].input(slotstr.c_str());
			std::string inputName = hotbarSlotBindingText(player.playernum, num, binding);

			const unsigned int midpoint = NUM_HOTBAR_SLOTS / 2;
			if ( num < midpoint )
			{
				pos.x -= (pos.w) * (midpoint - num);
			}
			else
			{
				pos.x += (pos.w) * (num - midpoint);
			}

			if ( inputName == "" )
			{
				slot_text->setText("");
				glyph->disabled = slot->isDisabled();
				glyph->color = 0xFFFFFFFF;// player.shootmode ? 0xFFFFFFFF : makeColor(255, 255, 255, 192);
				if ( binding.type == Input::binding_t::KEYBOARD )
				{
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding(slotstr.c_str(), true);
				}
				else
				{
					glyph->path = Input::inputs[player.playernum].getGlyphPathForBinding(slotstr.c_str());
				}
			}
			else
			{
				slot_text->setText(inputName.c_str());
			}

			slot->setSize(pos);

			auto glyphImage = Image::get(glyph->path.c_str());
			if ( glyphImage )
			{
				glyph->pos.w = std::min((int)glyphImage->getWidth(), slot->getSize().w);
				glyph->pos.h = glyphImage->getHeight();
				glyph->pos.x = pos.x + pos.w / 2 - glyph->pos.w / 2;
				glyph->pos.y = pos.y - glyph->pos.h;

				if ( binding.type == Input::binding_t::MOUSE_BUTTON )
				{
					glyph->pos.y += 4;
				}
			}
		}

		if ( current_hotbar == num )
		{
			bool showHighlightedSlot = true;
			if ( players[player.playernum]->GUI.activeModule != Player::GUI_t::MODULE_HOTBAR
				&& player.inventoryUI.frame && !player.inventoryUI.frame->isDisabled() )
			{
				// if inventory visible, don't show selection if navigating within inventory
				showHighlightedSlot = false;
			}
			else if ( player.hotbar.useHotbarFaceMenu && inputs.getVirtualMouse(player.playernum)->lastMovementFromController
				&& player.hotbar.faceMenuButtonHeld == Player::Hotbar_t::FaceMenuGroup::GROUP_NONE
				&& player.inventoryUI.frame && player.inventoryUI.frame->isDisabled() )
			{
				// if inventory invisible, don't show selection if face button not held
				showHighlightedSlot = false;
			}

			auto highlightSlotItem = highlightSlot->findFrame("hotbar slot item");
			highlightSlotItem->setDisabled(true);

			if ( showHighlightedSlot )
			{
				auto slotNumText = slot->findField("slot num text");

				highlightNumText->setText(slotNumText->getText());
				highlightNumText->setDisabled(slotNumText->isDisabled());

				highlightSlot->setSize(pos); // this follows the slots around
				highlightSlotImg->disabled = false;
				updateSlotFrameFromItem(highlightSlotItem, uidToItem(hotbar[num].item));

				if ( player.inventoryUI.frame )
				{
					bool showCursor = true;
					if ( !player.shootmode )
					{
						if ( inputs.getUIInteraction(player.playernum)->itemMenuOpen &&
							inputs.getUIInteraction(player.playernum)->itemMenuFromHotbar )
						{
							showCursor = true;
						}
						else if ( inputs.getUIInteraction(player.playernum)->selectedItem 
							&& !highlightSlot->capturesMouseInRealtimeCoords() )
						{
							showCursor = false;
						}
						else if ( !inputs.getUIInteraction(player.playernum)->selectedItem
							&& !inputs.getVirtualMouse(player.playernum)->lastMovementFromController
							&& !highlightSlot->capturesMouse() )
						{
							showCursor = false;
						}
					}
					else if ( player.shootmode )
					{
						showCursor = true;
					}

					if ( showCursor )
					{
						if ( !player.shootmode )
						{
							if ( players[player.playernum]->inventoryUI.selectedItemCursorFrame )
							{
								players[player.playernum]->inventoryUI.selectedItemCursorFrame->setDisabled(false);
								player.inventoryUI.updateSelectedSlotAnimation(pos.x - 1, pos.y - 1, getSlotSize() - 2, getSlotSize() - 2, 
									inputs.getVirtualMouse(player.playernum)->draw_cursor);
							}
						}
						else if ( player.shootmode )
						{
							if ( shootmodeSelectedSlotCursor )
							{
								shootmodeSelectedSlotCursor->setDisabled(false);
								bool snapCursor = !inputs.getVirtualMouse(player.playernum)->lastMovementFromController;
								if ( useHotbarFaceMenu && faceMenuSnapCursorInstantly )
								{
									snapCursor = true;
								}
								updateSelectedSlotAnimation(pos.x - 1, pos.y - 1, getSlotSize() - 2, getSlotSize() - 2, snapCursor);
							}
						}
					}
					else
					{
						highlightSlotImg->disabled = true;
						highlightSlotItem->setDisabled(true);
						updateSlotFrameFromItem(slotItem, uidToItem(hotbar[num].item));
					}
				}
			}
			else
			{
				updateSlotFrameFromItem(slotItem, uidToItem(hotbar[num].item));
			}
		}
		else
		{
			updateSlotFrameFromItem(slotItem, uidToItem(hotbar[num].item));
		}
	}
}

bool Player::Hotbar_t::warpMouseToHotbar(const int hotbarSlot, Uint32 flags)
{
	if ( !hotbarFrame || hotbarSlot < 0 || hotbarSlot >= NUM_HOTBAR_SLOTS )
	{
		return false;
	}
	if ( auto slotFrame = getHotbarSlotFrame(hotbarSlot) )
	{
		slotFrame->warpMouseToFrame(player.playernum, flags);
		return true;
	}
	return false;
}

Frame* Player::Hotbar_t::getHotbarSlotFrame(const int hotbarSlot)
{
	if ( !hotbarFrame || hotbarSlot < 0 || hotbarSlot >= NUM_HOTBAR_SLOTS )
	{
		return nullptr;
	}

	return hotbarSlotFrames[hotbarSlot];
}

static void drawConsoleCommandBuffer() {
    if (!command) {
        return;
    }
	int commandPlayer = clientnum;
	for ( int i = 0; i < MAXPLAYERS; ++i ) {
		if ( inputs.bPlayerUsingKeyboardControl(i) ) {
			commandPlayer = i;
			break;
		}
	}
	char buf[1024];
	if ( (ticks - cursorflash) % TICKS_PER_SECOND < TICKS_PER_SECOND / 2 ) {
	    snprintf(buf, sizeof(buf), "> %s_", command_str);
	} else {
	    snprintf(buf, sizeof(buf), "> %s", command_str);
	}
    const char* font;
    if (intro) {
        font = "fonts/pixelmix.ttf#16#2";
    } else {
		if ( players[commandPlayer]->isLocalPlayer() )
		{
			font = players[commandPlayer]->messageZone.useBigFont ?
			    "fonts/pixelmix.ttf#16#2" : "fonts/pixel_maz_multiline.ttf#16#2";
		}
		else
		{
			font = "fonts/pixelmix.ttf#16#2";
		}
    }
	auto text = Text::get(buf, font, 0xffffffff, makeColor(0, 0, 0, 255));
	const int printx = players[commandPlayer]->camera_virtualx1() + 8;
	int printy = players[commandPlayer]->camera_virtualy2() - 192;
	if ( players[commandPlayer]->messageZone.actualAlignment == Player::MessageZone_t::ALIGN_LEFT_BOTTOM 
		&& players[commandPlayer]->messageZone.chatFrame )
	{
		if ( Frame* messageBoxFrame = players[commandPlayer]->messageZone.chatFrame->findFrame("message box") )
		{
			printy = messageBoxFrame->getSize().y + messageBoxFrame->getSize().h + 4;
			if ( !players[commandPlayer]->messageZone.useBigFont )
			{
				printy -= 4;
			}
			printy += players[commandPlayer]->camera_virtualy1();
		}
	}
	text->draw(SDL_Rect{0,0,0,0}, SDL_Rect{printx, printy, 0, 0},
	    SDL_Rect{0, 0, Frame::virtualScreenX, Frame::virtualScreenY});
}

static Uint32 gui_ticks = 0u;
Frame::result_t doFrames() {
    Frame::result_t result;
    result.usable = false;
    result.highlightTime = 0;
    result.tooltip = nullptr;
    result.removed = false;
	if ( gui )
	{
		while ( gui_ticks < ticks )
		{
			++gui_ticks;
		}

        static ConsoleVariable<bool> gui_process("/gui_process", true);
        if (*gui_process) {
	        result = gui->process();
	    }

        static ConsoleVariable<bool> gui_draw("/gui_draw", true);
        if (*gui_draw) {
		    gui->predraw();
		    gui->draw();
            if (!movie) {
                drawConsoleCommandBuffer();
            }
		    gui->postdraw();
		}
	}
	return result;
}

real_t Player::SkillSheet_t::windowCompactHeightScaleX = 0.0;
real_t Player::SkillSheet_t::windowCompactHeightScaleY = 0.0;
real_t Player::SkillSheet_t::windowHeightScaleX = 0.0;
real_t Player::SkillSheet_t::windowHeightScaleY = 0.0;
bool Player::SkillSheet_t::generateFollowerTableForSkillsheet = false;
SkillSheetFrames_t skillSheetEntryFrames[MAXPLAYERS];

void Player::SkillSheet_t::createSkillSheet()
{
	if ( skillFrame )
	{
		return;
	}

	char name[32];
	snprintf(name, sizeof(name), "player skills %d", player.playernum);
	Frame* frame = gameUIFrame[player.playernum]->addFrame(name);
	skillFrame = frame;
	frame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
		players[player.playernum]->camera_virtualy1(),
		players[player.playernum]->camera_virtualWidth(),
		players[player.playernum]->camera_virtualHeight() });
	frame->setHollow(false);
	frame->setBorder(0);
	frame->setOwner(player.playernum);
	frame->setInheritParentFrameOpacity(false);

	auto fade = skillFrame->addImage(
		SDL_Rect{ 0, 0, skillFrame->getSize().w, skillFrame->getSize().h },
		0, "images/system/white.png", "fade img");
	Uint8 r, g, b, a;
	getColor(fade->color, &r, &g, &b, &a);
	a = 0;
	fade->color = makeColor( r, g, b, a);
	fade->disabled = true;

	Frame* skillBackground = frame->addFrame("skills frame");
	skillBackground->setHollow(true);
	skillSheetEntryFrames[player.playernum].skillsFrame = skillBackground;
	const int width = 684;
	const int height = 404;
	skillBackground->setInheritParentFrameOpacity(false);
	skillBackground->setSize(SDL_Rect{ frame->getSize().x, frame->getSize().y, width, height });
	/*auto bgImg = skillBackground->addImage(SDL_Rect{ 0, 0, width, height }, 0xFFFFFFFF,
		"*#images/ui/SkillSheet/UI_Skills_Window_02.png", "skills img");*/

	Frame* allSkillEntriesLeft = skillBackground->addFrame("skill entries frame left");
	allSkillEntriesLeft->setHollow(true);
	Frame* allSkillEntriesRight = skillBackground->addFrame("skill entries frame right");
	allSkillEntriesRight->setHollow(true);
	skillSheetEntryFrames[player.playernum].entryFrameLeft = allSkillEntriesLeft;
	skillSheetEntryFrames[player.playernum].entryFrameRight = allSkillEntriesRight;
	//allSkillEntries->setSize(SDL_Rect{ 0, 0, skillBackground->getSize().w, skillBackground->getSize().h });

	SDL_Rect allSkillEntriesPosLeft{ 0, 0, 182, skillBackground->getSize().h };
	SDL_Rect allSkillEntriesPosRight{ skillBackground->getSize().w - 182, 0, 182, skillBackground->getSize().h };
	allSkillEntriesLeft->setSize(allSkillEntriesPosLeft);
	allSkillEntriesRight->setSize(allSkillEntriesPosRight);

	allSkillEntriesLeft->addImage(SDL_Rect{ 0, 12, 182, 376 },
		0xFFFFFFFF, "*#images/ui/SkillSheet/UI_Skills_Window_Left_04.png", "bg wing left");
	allSkillEntriesLeft->addImage(SDL_Rect{0, 0, 0, 0},
		0xFFFFFFFF, "*#images/ui/SkillSheet/UI_Skills_Left_Full_00000000.png", "bg wing all skills left");
	allSkillEntriesRight->addImage(SDL_Rect{ 0, 12, 182, 376 },
		0xFFFFFFFF, "*#images/ui/SkillSheet/UI_Skills_Window_Right_04.png", "bg wing right");
	allSkillEntriesRight->addImage(SDL_Rect{ 0, 0, 0, 0 },
		0xFFFFFFFF, "*#images/ui/SkillSheet/UI_Skills_Right_Full_00000000.png", "bg wing all skills right");

	auto skillBackgroundImagesFrame = skillBackground->addFrame("skills bg images");
	skillBackgroundImagesFrame->setHollow(true);
	skillSheetEntryFrames[player.playernum].skillBgImgsFrame = skillBackgroundImagesFrame;
	skillBackgroundImagesFrame->setSize(SDL_Rect{ 0, 0, skillBackground->getSize().w, skillBackground->getSize().h });
	{
		Uint32 color = makeColor(255, 255, 255, 255);
		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/SkillSheet/UI_Skills_Window_TL_04.png", skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/SkillSheet/UI_Skills_Window_TR_04.png", skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/SkillSheet/UI_Skills_Window_T_04.png", skillsheetEffectBackgroundImages[TOP].c_str());
		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/SkillSheet/UI_Skills_Window_L_03.png", skillsheetEffectBackgroundImages[MIDDLE_LEFT].c_str());
		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/SkillSheet/UI_Skills_Window_R_03.png", skillsheetEffectBackgroundImages[MIDDLE_RIGHT].c_str());
		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			makeColor(0, 0, 0, 255), "images/system/white.png", skillsheetEffectBackgroundImages[MIDDLE].c_str());
		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/SkillSheet/UI_Skills_Window_BL_03.png", skillsheetEffectBackgroundImages[BOTTOM_LEFT].c_str());
		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/SkillSheet/UI_Skills_Window_BR_03.png", skillsheetEffectBackgroundImages[BOTTOM_RIGHT].c_str());
		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
			color, "*#images/ui/SkillSheet/UI_Skills_Window_B_03.png", skillsheetEffectBackgroundImages[BOTTOM].c_str());
		imageSetWidthHeight9x9(skillBackgroundImagesFrame, skillsheetEffectBackgroundImages);

		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 78, 18 },
			color, "*#images/ui/SkillSheet/UI_Skills_Window_Flourish_T.png", "flourish top");
		skillBackgroundImagesFrame->addImage(SDL_Rect{ 0, 0, 34, 14 },
			color, "*#images/ui/SkillSheet/UI_Skills_Window_Flourish_B.png", "flourish bottom");
	}

	const int skillEntryStartY = 38;
	SDL_Rect skillEntryPos{ 0, skillEntryStartY, 182, 40 };
	SDL_Rect skillSelectorPos{ 0, 2, 146, 32 };
	const char* boldFont = "fonts/pixel_maz_multiline.ttf#16#2";
	const char* numberFont = "fonts/pixelmix.ttf#16";
	//const char* titleFont = "fonts/pixel_maz_multiline.ttf#24#2";
	const char* titleFont = "fonts/pixelmix.ttf#24#2";
	const char* descFont = "fonts/pixel_maz_multiline.ttf#16#2";
	for ( int i = 0; i < 8; ++i )
	{
		char skillname[32];
		snprintf(skillname, sizeof(skillname), "skill %d", i);
		Frame* entry = allSkillEntriesRight->addFrame(skillname);
		entry->setHollow(true);
		skillSheetEntryFrames[player.playernum].entryFrames[i] = entry;
		entry->setSize(skillEntryPos);
		auto selector = entry->addImage(skillSelectorPos, 0xFFFFFFFF, "*#images/ui/SkillSheet/UI_Skills_SkillSelector_00.png", "selector img");
		SDL_Rect imgBgPos{ skillEntryPos.w - 36, 0, 36, 36 };
		entry->addImage(imgBgPos, 0xFFFFFFFF, "*#images/ui/SkillSheet/UI_Skills_Icons_BG00_00.png", "skill icon bg");
		SDL_Rect imgFgPos{ imgBgPos.x + 6, imgBgPos.y + 6, 24, 24 };
		entry->addImage(imgFgPos, 0xFFFFFFFF, "", "skill icon fg");
		SDL_Rect statPos{ 10, 6, 24, 24 };
		auto statIcon = entry->addImage(statPos, 0xFFFFFFFF, "", "stat icon");
		if ( i < skillSheetData.skillEntries.size() )
		{
			statIcon->path = skillSheetData.skillEntries[i].statIconPath;
		}
		skillEntryPos.y += skillEntryPos.h;

		SDL_Rect profNamePos{ statPos.x + statPos.w - 32, 4, 98, 28 };
		Field* profName = entry->addField("skill name", 64);
		profName->setSize(profNamePos);
		profName->setHJustify(Field::justify_t::RIGHT);
		profName->setVJustify(Field::justify_t::CENTER);
		profName->setFont(boldFont);
		profName->setTextColor(skillSheetData.defaultTextColor);
		if ( i < skillSheetData.skillEntries.size() )
		{
			profName->setText(skillSheetData.skillEntries[i].name.c_str());
		}
		else
		{
			profName->setText("Default");
		}

		SDL_Rect profLevelPos{ profNamePos.x + profNamePos.w + 8 - 2, profNamePos.y, 34, 28 };
		Field* profLevel = entry->addField("skill level", 16);
		profLevel->setSize(profLevelPos);
		profLevel->setHJustify(Field::justify_t::RIGHT);
		profLevel->setVJustify(Field::justify_t::CENTER);
		profLevel->setFont(numberFont);
		profLevel->setTextColor(skillSheetData.defaultTextColor);
		profLevel->setText("0");
	}

	skillEntryPos.x = 0;
	skillEntryPos.y = skillEntryStartY;
	skillSelectorPos.x = 36;

	for ( int i = 8; i < 16; ++i )
	{
		char skillname[32];
		snprintf(skillname, sizeof(skillname), "skill %d", i);
		Frame* entry = allSkillEntriesLeft->addFrame(skillname);
		entry->setHollow(true);
		skillSheetEntryFrames[player.playernum].entryFrames[i] = entry;
		entry->setSize(skillEntryPos);
		auto selector = entry->addImage(skillSelectorPos, 0xFFFFFFFF, "*#images/ui/SkillSheet/UI_Skills_SkillSelectorR_00.png", "selector img");
		SDL_Rect imgBgPos{ 0, 0, 36, 36 };
		entry->addImage(imgBgPos, 0xFFFFFFFF, "*#images/ui/SkillSheet/UI_Skills_Icons_BG00_00.png", "skill icon bg");
		SDL_Rect imgFgPos{ imgBgPos.x + 6, imgBgPos.y + 6, 24, 24 };
		entry->addImage(imgFgPos, 0xFFFFFFFF, "*#images/ui/SkillSheet/icons/Alchemy01.png", "skill icon fg");
		SDL_Rect statPos{ skillEntryPos.w - 10 - 24, 6, 24, 24 };
		auto statIcon = entry->addImage(statPos, 0xFFFFFFFF, "", "stat icon");
		if ( i < skillSheetData.skillEntries.size() )
		{
			statIcon->path = skillSheetData.skillEntries[i].statIconPath;
		}
		skillEntryPos.y += skillEntryPos.h;

		SDL_Rect profNamePos{ statPos.x - 98 + 32, 4, 98, 28 };
		Field* profName = entry->addField("skill name", 64);
		profName->setSize(profNamePos);
		profName->setHJustify(Field::justify_t::LEFT);
		profName->setVJustify(Field::justify_t::CENTER);
		profName->setFont(boldFont);
		profName->setTextColor(skillSheetData.defaultTextColor);
		if ( i < skillSheetData.skillEntries.size() )
		{
			profName->setText(skillSheetData.skillEntries[i].name.c_str());
		}
		else
		{
			profName->setText("Default");
		}

		SDL_Rect profLevelPos{ profNamePos.x - 12 - 32, profNamePos.y, 34, 28 };
		Field* profLevel = entry->addField("skill level", 16);
		profLevel->setSize(profLevelPos);
		profLevel->setHJustify(Field::justify_t::RIGHT);
		profLevel->setVJustify(Field::justify_t::CENTER);
		profLevel->setFont(numberFont);
		profLevel->setTextColor(skillSheetData.defaultTextColor);
		profLevel->setText("0");
	}

	SDL_Rect skillTitlePos{ skillBackground->getSize().w / 2 - 320 / 2, 14, 320, 40 };
	auto skillTitleTxt = skillBackground->addField("skill title txt", 64);
	skillTitleTxt->setHJustify(Field::justify_t::CENTER);
	skillTitleTxt->setVJustify(Field::justify_t::CENTER);
	skillTitleTxt->setText("");
	skillTitleTxt->setSize(skillTitlePos);
	skillTitleTxt->setFont(titleFont);
	skillTitleTxt->setOntop(true);
	skillTitleTxt->setTextColor(makeColor(201, 162, 100, 255));

	{
		auto closeBtn = skillBackground->addButton("close skills button");
		SDL_Rect closeBtnPos;
		closeBtnPos.x = skillBackground->getSize().w - 66;
		closeBtnPos.y = 22;
		closeBtnPos.w = 26;
		closeBtnPos.h = 26;
		closeBtn->setSize(closeBtnPos);
		closeBtn->setColor(makeColor(255, 255, 255, 255));
		closeBtn->setHighlightColor(makeColor(255, 255, 255, 255));
		closeBtn->setTextHighlightColor(makeColor(201, 162, 100, 255));
		closeBtn->setText("X");
		closeBtn->setOntop(true);
		closeBtn->setFont(boldFont);
		closeBtn->setHideGlyphs(true);
		closeBtn->setHideKeyboardGlyphs(true);
		closeBtn->setHideSelectors(true);
		closeBtn->setMenuConfirmControlType(0);
		closeBtn->setBackground("*#images/ui/Skillsheet/Button_X_00.png");
		closeBtn->setBackgroundHighlighted("*#images/ui/Skillsheet/Button_XHigh_00.png");
		closeBtn->setBackgroundActivated("*#images/ui/Skillsheet/Button_XPress_00.png");
		closeBtn->setCallback([](Button& button) {
			players[button.getOwner()]->skillSheet.closeSkillSheet();
			Player::soundCancel();
		});
		closeBtn->setTickCallback([](Widget& widget) {
			if ( widget.isSelected() )
			{
				if ( !inputs.getVirtualMouse(widget.getOwner())->draw_cursor )
				{
					widget.deselect();
				}
			}
		});
	}

	SDL_Rect descPos{ 0, 54, 320, 324 };
	descPos.x = skillBackground->getSize().w / 2 - descPos.w / 2;
	auto skillDescriptionFrame = skillBackground->addFrame("skill desc frame");
	skillDescriptionFrame->setHollow(true);
	skillSheetEntryFrames[player.playernum].skillDescFrame = skillDescriptionFrame;
	skillDescriptionFrame->setSize(descPos);

	/*auto debugRect = skillDescriptionFrame->addImage(SDL_Rect{ 0, 0, descPos.w, descPos.h }, 0xFFFFFFFF,
		"images/system/white.png", "")*/;

	auto slider = skillDescriptionFrame->addSlider("skill slider");
	slider->setBorder(24);
	slider->setMinValue(0);
	slider->setMaxValue(100);
	slider->setValue(0);
	SDL_Rect sliderPos{ descPos.w - 34, 4, 30, descPos.h - 8 };
	slider->setRailSize(sliderPos);
	slider->setHandleSize(SDL_Rect{ 0, 0, 34, 34 });
	slider->setOrientation(Slider::SLIDER_VERTICAL);
	//slider->setCallback(callback);
	slider->setColor(makeColor(255, 255, 255, 255));
	slider->setHighlightColor(makeColor(255, 255, 255, 255));
	slider->setHandleImage("*#images/ui/Main Menus/Settings/Settings_Slider_Boulder00.png");
	slider->setRailImage("*#images/ui/Main Menus/Settings/Settings_Slider_Backing00.png");
	slider->setHideGlyphs(true);
	slider->setHideKeyboardGlyphs(true);
	slider->setHideSelectors(true);
	slider->setMenuConfirmControlType(0);

	Font* actualFont = Font::get(descFont);
	int fontHeight;
	actualFont->sizeText("_", nullptr, &fontHeight);

	auto scrollAreaOuterFrame = skillDescriptionFrame->addFrame("scroll area outer frame");
	scrollAreaOuterFrame->setHollow(true);
	skillSheetEntryFrames[player.playernum].scrollAreaOuterFrame = scrollAreaOuterFrame;
	scrollAreaOuterFrame->setSize(SDL_Rect{ 16, 4, sliderPos.x - 4 - 16, descPos.h - 8 });
	auto scrollAreaFrame = scrollAreaOuterFrame->addFrame("skill scroll area");
	scrollAreaFrame->setHollow(true);
	skillSheetEntryFrames[player.playernum].scrollArea = scrollAreaFrame;
	scrollAreaFrame->setSize(SDL_Rect{ 0, 0, scrollAreaOuterFrame->getSize().w, 1000 });

	SDL_Rect txtPos{ 0, 0, scrollAreaFrame->getSize().w, scrollAreaFrame->getSize().h };
	{
		auto skillLvlHeaderTxt = scrollAreaFrame->addField("skill lvl header txt", 128);
		skillLvlHeaderTxt->setFont(descFont);
		skillLvlHeaderTxt->setSize(txtPos);
		skillLvlHeaderTxt->setText(Language::get(5961));

		auto skillLvlHeaderVal = scrollAreaFrame->addField("skill lvl header val", 128);
		skillLvlHeaderVal->setFont(descFont);
		skillLvlHeaderVal->setSize(txtPos);
		skillLvlHeaderVal->setText("");
		skillLvlHeaderVal->setHJustify(Field::justify_t::RIGHT);

		txtPos.y += fontHeight;
	}
	{
		const int iconSize = 24;
		auto statIcon = scrollAreaFrame->addImage(
			SDL_Rect{ txtPos.x + txtPos.w - iconSize, txtPos.y, iconSize, iconSize },
			0xFFFFFFFF, "*#images/ui/CharSheet/HUD_CharSheet_DEX_00.png",	"stat icon");

		txtPos.y += std::max(0, iconSize - fontHeight);
		auto statHeaderTxt = scrollAreaFrame->addField("stat header txt", 128);
		statHeaderTxt->setFont(descFont);
		statHeaderTxt->setSize(txtPos);
		statHeaderTxt->setText(Language::get(5962));

		auto statTypeTxt = scrollAreaFrame->addField("stat type txt", 128);
		statTypeTxt->setFont(descFont);
		txtPos.w -= iconSize + 4;
		statTypeTxt->setSize(txtPos);
		txtPos.w += iconSize + 4;
		statTypeTxt->setText("");
		statTypeTxt->setHJustify(Field::justify_t::RIGHT);
		txtPos.y += fontHeight;
		txtPos.y += fontHeight / 2;
	}
	{
		auto skillDescriptionTxt = scrollAreaFrame->addField("skill desc txt", 1024);
		skillDescriptionTxt->setFont(descFont);
		skillDescriptionTxt->setSize(txtPos);
		skillDescriptionTxt->setText("");
		//skillDescriptionTxt->setTextColor(makeColor(201, 162, 100, 255));
		skillDescriptionTxt->setHJustify(Field::justify_t::CENTER);
		skillDescriptionTxt->setOntop(true);

		auto skillDescriptionBgFrame = scrollAreaFrame->addFrame("skill desc bg frame");
		skillDescriptionBgFrame->setHollow(true);
		{
			//Uint32 color = makeColor(22, 24, 29, 255);
			Uint32 color = makeColor(255, 255, 255, 128);
			skillDescriptionBgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/SkillSheet/UI_Skills_LegendBox_TL_00.png", skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
			skillDescriptionBgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/SkillSheet/UI_Skills_LegendBox_TR_00.png", skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
			skillDescriptionBgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/SkillSheet/UI_Skills_LegendBox_T_00.png", skillsheetEffectBackgroundImages[TOP].c_str());
			skillDescriptionBgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/SkillSheet/UI_Skills_LegendBox_ML_00.png", skillsheetEffectBackgroundImages[MIDDLE_LEFT].c_str());
			skillDescriptionBgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/SkillSheet/UI_Skills_LegendBox_MR_00.png", skillsheetEffectBackgroundImages[MIDDLE_RIGHT].c_str());
			skillDescriptionBgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/SkillSheet/UI_Skills_LegendBox_M_00.png", skillsheetEffectBackgroundImages[MIDDLE].c_str());
			skillDescriptionBgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/SkillSheet/UI_Skills_LegendBox_BL_00.png", skillsheetEffectBackgroundImages[BOTTOM_LEFT].c_str());
			skillDescriptionBgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/SkillSheet/UI_Skills_LegendBox_BR_00.png", skillsheetEffectBackgroundImages[BOTTOM_RIGHT].c_str());
			skillDescriptionBgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
				color, "*#images/ui/SkillSheet/UI_Skills_LegendBox_B_00.png", skillsheetEffectBackgroundImages[BOTTOM].c_str());
			imageSetWidthHeight9x9(skillDescriptionBgFrame, skillsheetEffectBackgroundImages);
		}


		int txtHeight = skillDescriptionTxt->getNumTextLines() * actualFont->height(true);

		txtPos.y += txtHeight;
		txtPos.y += fontHeight / 2;

	}
	{
		char effectFrameName[64] = "";
		char effectFieldName[64] = "";
		char effectFieldVal[64] = "";
		char effectBgName[64];
		int effectXOffset = 72; // tmp paramters - configured in skillsheet json
		int effectBackgroundXOffset = 8;
		int effectBackgroundWidth = 80;
		auto effectLargeBgImg = scrollAreaFrame->addImage(
			SDL_Rect{ 0, 0, 0, 0 },
			makeColor(10, 4, 4, 255), "images/system/white.png", "effect frame bg tmp");
		effectLargeBgImg->disabled = true;
		for ( int i = 0; i < 10; ++i )
		{
			snprintf(effectFrameName, sizeof(effectFrameName), "effect %d frame", i);
			auto effectFrame = scrollAreaFrame->addFrame(effectFrameName);
			effectFrame->setHollow(true);
			skillSheetEntryFrames[player.playernum].effectFrames[i] = effectFrame;
			effectFrame->setSize(SDL_Rect{ txtPos.x, txtPos.y - 2, txtPos.w, fontHeight + 8 });
			effectFrame->addImage(
				SDL_Rect{ 0, 0, effectFrame->getSize().w, effectFrame->getSize().h - 4 }, 
				makeColor(91, 73, 57, 255), "images/system/white.png", "effect frame bg highlight");
			int valueX =  effectFrame->getSize().w - effectXOffset;

			auto valBgImgFrame = effectFrame->addFrame("effect val bg frame");
			valBgImgFrame->setHollow(true);
			valBgImgFrame->setSize(SDL_Rect{ valueX - effectBackgroundXOffset, 0, effectBackgroundWidth, effectFrame->getSize().h - 4});
			{
				Uint32 color = makeColor(51, 33, 26, 255);
				valBgImgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_TL00.png", skillsheetEffectBackgroundImages[TOP_LEFT].c_str());
				valBgImgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_TR00.png", skillsheetEffectBackgroundImages[TOP_RIGHT].c_str());
				valBgImgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_T00.png", skillsheetEffectBackgroundImages[TOP].c_str());
				valBgImgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_L00.png", skillsheetEffectBackgroundImages[MIDDLE_LEFT].c_str());
				valBgImgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_R00.png", skillsheetEffectBackgroundImages[MIDDLE_RIGHT].c_str());
				valBgImgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_M00.png", skillsheetEffectBackgroundImages[MIDDLE].c_str());
				valBgImgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_BL00.png", skillsheetEffectBackgroundImages[BOTTOM_LEFT].c_str());
				valBgImgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_BR00.png", skillsheetEffectBackgroundImages[BOTTOM_RIGHT].c_str());
				valBgImgFrame->addImage(SDL_Rect{ 0, 0, 6, 6 },
					color, "*#images/ui/SkillSheet/UI_Skills_EffectBG_B00.png", skillsheetEffectBackgroundImages[BOTTOM].c_str());

				/*valBgImgFrame->addImage(
					SDL_Rect{ 0, 0, effectFrame->getSize().w, effectFrame->getSize().h - 4 },
					makeColor(255, 255, 255, 128), "images/system/white.png", "tmp tmp");*/
				imageSetWidthHeight9x9(valBgImgFrame, skillsheetEffectBackgroundImages);
			}

			auto effectTxtFrame = effectFrame->addFrame("effect txt frame");
			effectTxtFrame->setHollow(true);
			effectTxtFrame->setSize(SDL_Rect{ 0, 0, effectFrame->getSize().w - effectXOffset - effectBackgroundXOffset, effectFrame->getSize().h - 4 });
			auto effectTxt = effectTxtFrame->addField("effect txt", 1024);
			effectTxt->setFont(descFont);
			effectTxt->setSize(SDL_Rect{0, 0, 1000, effectTxtFrame->getSize().h}); // large 1000px to handle large text length marquee
			effectTxt->setVJustify(Field::justify_t::CENTER);
			effectTxt->setText("");
			effectTxt->setTextColor(makeColor(201, 162, 100, 255));

			auto effectValFrame = effectFrame->addFrame("effect val frame");
			effectValFrame->setHollow(true);
			effectValFrame->setSize(SDL_Rect{ valueX, 0, effectXOffset, effectFrame->getSize().h - 4 });
			auto effectVal = effectValFrame->addField("effect val", 1024);
			effectVal->setFont(descFont);
			effectVal->setSize(SDL_Rect{ 0, 0, 1000, effectValFrame->getSize().h }); // large 1000px to handle large text length marquee
			effectVal->setVJustify(Field::justify_t::CENTER);
			effectVal->setText("");
			effectVal->setTextColor(makeColor(201, 162, 100, 255));

			//effectFrame->setDisabled(true);

			txtPos.y += effectFrame->getSize().h;
		}
	}
	{
		auto legendDivImg = scrollAreaFrame->addImage(SDL_Rect{ 0, txtPos.y, 212, 28 }, 0xFFFFFFFF,
			"*#images/ui/SkillSheet/UI_Skills_Separator_00.png", "legend div");
		legendDivImg->pos.x = scrollAreaFrame->getSize().w / 2 - legendDivImg->pos.w / 2;
		auto legendDivTxt = scrollAreaFrame->addField("legend div text", 128);
		legendDivTxt->setText(Language::get(4056));
		SDL_Rect legendDivTxtPos = legendDivImg->pos;
		legendDivTxt->setSize(legendDivTxtPos);
		legendDivTxt->setFont(descFont);
		legendDivTxt->setHJustify(Field::justify_t::CENTER);

		auto legendFrame = scrollAreaFrame->addFrame("legend frame");
		legendFrame->setHollow(true);
		skillSheetEntryFrames[player.playernum].legendFrame = legendFrame;
		SDL_Rect legendPos{ 0, txtPos.y, txtPos.w, 100 };
		legendFrame->setSize(legendPos);
		auto tl = legendFrame->addImage(SDL_Rect{ 0, 0, 18, 18 }, 0xFFFFFFFF, 
			"*#images/ui/SkillSheet/UI_Skills_LegendBox_TL_00.png", "top left img");
		auto tm = legendFrame->addImage(SDL_Rect{ 18, 0, legendPos.w - 18 * 2, 18 }, 0xFFFFFFFF,
			"*#images/ui/SkillSheet/UI_Skills_LegendBox_T_00.png", "top img");
		auto tr = legendFrame->addImage(SDL_Rect{ legendPos.w - 18, 0, 18, 18 }, 0xFFFFFFFF,
			"*#images/ui/SkillSheet/UI_Skills_LegendBox_TR_00.png", "top right img");

		auto ml = legendFrame->addImage(SDL_Rect{ 0, 18, 18, legendPos.h - 18 * 2 }, 0xFFFFFFFF,
			"*#images/ui/SkillSheet/UI_Skills_LegendBox_ML_00.png", "middle left img");
		auto mm = legendFrame->addImage(SDL_Rect{ 18, 18, legendPos.w - 18 * 2, ml->pos.h }, 0xFFFFFFFF,
			"*#images/ui/SkillSheet/UI_Skills_LegendBox_M_00.png", "middle img");
		auto mr = legendFrame->addImage(SDL_Rect{ legendPos.w - 18, 18, 18, ml->pos.h }, 0xFFFFFFFF,
			"*#images/ui/SkillSheet/UI_Skills_LegendBox_MR_00.png", "middle right img");

		auto bl = legendFrame->addImage(SDL_Rect{ 0, ml->pos.y + ml->pos.h, 18, 18 }, 0xFFFFFFFF,
			"*#images/ui/SkillSheet/UI_Skills_LegendBox_BL_00.png", "bottom left img");
		auto bm = legendFrame->addImage(SDL_Rect{ 18, bl->pos.y, legendPos.w - 18 * 2, 18 }, 0xFFFFFFFF,
			"*#images/ui/SkillSheet/UI_Skills_LegendBox_B_00.png", "bottom img");
		auto br = legendFrame->addImage(SDL_Rect{ legendPos.w - 18, bl->pos.y, 18, 18 }, 0xFFFFFFFF,
			"*#images/ui/SkillSheet/UI_Skills_LegendBox_BR_00.png", "bottom right img");

		auto backerImg = scrollAreaFrame->addImage(SDL_Rect{ 0, 0, 154, 12 }, 0xFFFFFFFF,
			"*#images/ui/SkillSheet/UI_Skills_LegendTextBacker_00.png", "legend txt backer img");
		backerImg->disabled = true;

		auto legendText = legendFrame->addField("legend text", 256);
		legendText->setText("");
		legendText->setSize(mm->pos);
		legendText->setFont(descFont);
		legendText->setHJustify(Field::justify_t::CENTER);

		skillBackground->setBlitChildren(true);
	}
	
	std::string promptFont = "fonts/pixel_maz.ttf#32#2";
	const int promptWidth = 60;
	const int promptHeight = 27;
	auto promptBack = frame->addField("prompt back txt", 16);
	promptBack->setSize(SDL_Rect{ frame->getSize().w - promptWidth - 16, // lower right corner
		0, promptWidth, promptHeight });
	promptBack->setFont(promptFont.c_str());
	promptBack->setHJustify(Field::justify_t::RIGHT);
	promptBack->setVJustify(Field::justify_t::CENTER);
	promptBack->setText(Language::get(4053));
	//promptBack->setOntop(true);
	promptBack->setTextColor(makeColor(201, 162, 100, 255));

	auto promptBackImg = frame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
		"", "prompt back img");
	promptBackImg->disabled = true;
	//promptBackImg->ontop = true;

	auto promptScroll = frame->addField("prompt scroll txt", 16);
	promptScroll->setSize(SDL_Rect{ frame->getSize().w - promptWidth - 16, // lower right corner
		0, promptWidth, promptHeight });
	promptScroll->setFont(promptFont.c_str());
	promptScroll->setHJustify(Field::justify_t::LEFT);
	promptScroll->setVJustify(Field::justify_t::CENTER);
	promptScroll->setText(Language::get(4062));
	//promptScroll->setOntop(true);
	promptScroll->setTextColor(makeColor(201, 162, 100, 255));

	auto promptScrollImg = frame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
		"", "prompt scroll img");
	promptScrollImg->disabled = true;
	promptScrollImg->ontop = true;
}

struct SkillSheetCache_t
{
	int proficiencyLevelCached;
	int highlightedSkill = -2;
	int selectedSkill = -2;
};
SkillSheetCache_t skillsheetCache[MAXPLAYERS][NUMPROFICIENCIES];

void Player::SkillSheet_t::resetSkillDisplay()
{
	bSkillSheetEntryLoaded = false;
	scrollInertia = 0.0;
	for ( int i = 0; i < NUMPROFICIENCIES; ++i )
	{
		skillsheetCache[player.playernum][i].proficiencyLevelCached = -1;
		skillsheetCache[player.playernum][i].highlightedSkill = -2;
		skillsheetCache[player.playernum][i].selectedSkill = -2;
	}

	for ( auto& skillEntry : skillSheetData.skillEntries )
	{
		for ( auto& skillEffect : skillEntry.effects )
		{
			skillEffect.marqueeTicks[player.playernum] = 0;
			skillEffect.marquee[player.playernum] = 0.0;
			skillEffect.marqueeCompleted[player.playernum] = false;
			skillEffect.effectUpdatedAtSkillLevel = -1;
			skillEffect.cachedWidth = -1;
			skillEffect.effectUpdatedAtMonsterType = -1;
		}
	}
}

void Player::SkillSheet_t::closeSkillSheet()
{
	bSkillSheetOpen = false;
	if ( skillFrame )
	{
		skillFrame->setDisabled(true);
	}
	resetSkillDisplay();

	if ( player.gui_mode == GUI_MODE_NONE )
	{
		player.shootmode = true;
	}
	else
	{
		player.GUI.returnToPreviousActiveModule();
	}
}

static ConsoleVariable<bool> cvar_skillsheet_blit("/skillsheet_blit", true);
void Player::SkillSheet_t::openSkillSheet()
{
	player.GUI.previousModule = player.GUI.activeModule;
	if ( player.shootmode )
	{
		players[player.playernum]->openStatusScreen(GUI_MODE_NONE,
			INVENTORY_MODE_ITEM, player.GUI.MODULE_SKILLS_LIST);
	}
	else
	{
		players[player.playernum]->openStatusScreen(GUI_MODE_INVENTORY,
			players[player.playernum]->inventory_mode, player.GUI.MODULE_SKILLS_LIST); // Reset the GUI to the inventory.
	}
	if ( !bSkillSheetOpen )
	{
		Player::soundActivate();
	}
	bSkillSheetOpen = true;
	openTick = ticks;
	scrollPercent = 0.0;
	if ( skillFrame )
	{
		auto innerFrame = skillFrame->findFrame("skills frame");
		innerFrame->setBlitChildren(*cvar_skillsheet_blit);
		auto skillDescriptionFrame = innerFrame->findFrame("skill desc frame");
		auto slider = skillDescriptionFrame->findSlider("skill slider");
		slider->setValue(0.0);
	}
	resetSkillDisplay();
	if ( selectedSkill < 0 )
	{
		selectSkill(0);
	}
	if ( !::inputs.getVirtualMouse(player.playernum)->draw_cursor )
	{
		highlightedSkill = selectedSkill;
	}
	if ( bUseCompactSkillsView || bSlideWindowsOnly )
	{
		if ( selectedSkill >= 8 )
		{
			skillSlideAmount = 1.0;
			skillSlideDirection = 1;
		}
		else
		{
			skillSlideAmount = -1.0;
			skillSlideDirection = -1;
		}
	}
}

std::string formatSkillSheetEffects(int playernum, int proficiency, std::string& tag, std::string& rawValue)
{
	char buf[1024] = "";
	if ( !players[playernum] ) { return ""; }
	Entity* player = players[playernum]->entity;
	real_t val = 0.0;
	real_t val2 = 0.0;
	if ( proficiency == PRO_STEALTH )
	{
		if ( tag == "STEALTH_VIS_REDUCTION" )
		{
			//val = stats[playernum]->getModifiedProficiency(proficiency) * 2 * 100 / 512.f; // % visibility reduction
			val = 100.f * (255 - TOUCHRANGE) * (1.0 * (stats[playernum]->getModifiedProficiency(PRO_STEALTH) / 100.f)) / 255.f;
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "STEALTH_SNEAK_VIS" )
		{
			val = (2 + (stats[playernum]->getModifiedProficiency(proficiency) / 40)); // night vision when sneaking
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "STEALTH_BACKSTAB" )
		{
			val = (stats[playernum]->getModifiedProficiency(proficiency) / 20 + 2) * 2; // backstab dmg
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val *= 2;
			}
			if ( stats[playernum]->helmet && stats[playernum]->helmet->type == HAT_HOOD_ASSASSIN )
			{
				if ( stats[playernum]->helmet->beatitude >= 0 || shouldInvertEquipmentBeatitude(stats[playernum]) )
				{
					val += std::min(4 + (2 * abs(stats[playernum]->helmet->beatitude)), 8);
				}
				else
				{
					val /= 2;
				}
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "STEALTH_CURRENT_VIS" )
		{
			if ( player )
			{
				val = player->entityLightAfterReductions(*stats[playernum], nullptr);
				val = std::max(1, (static_cast<int>(val / 16.0))); // general visibility
				snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
			}
			else
			{
				return "-";
			}
		}
		return buf;
	}
	else if ( proficiency == PRO_RANGED )
	{
		if ( tag == "RANGED_DMG_RANGE" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 3.f; // lowest damage roll
			}
			else
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 2.f; // lowest damage roll
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "RANGED_DMG_EFFECTIVENESS" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			else
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "RANGED_DEGRADE_CHANCE" )
		{
			val = 50 + static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20) * 10;
			if ( stats[playernum]->type == GOBLIN )
			{
				val += 20;
				if ( stats[playernum]->getModifiedProficiency(proficiency) < SKILL_LEVEL_LEGENDARY )
				{
					val = std::min(val, 90.0);
				}
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "RANGED_THROWN_DMG" )
		{
			int skillLVL = stats[playernum]->getModifiedProficiency(proficiency) / 20; // thrown dmg bonus
			// +0% baseline
			val = 100 * (thrownDamageSkillMultipliers[std::min(skillLVL, 5)] - thrownDamageSkillMultipliers[0]);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "RANGED_PIERCE_CHANCE" )
		{
			val = std::min(std::max(statGetPER(stats[playernum], player) / 2, 0), 50);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		return buf;
	}
	else if ( proficiency == PRO_SHIELD )
	{
		if ( tag == "BLOCK_AC_INCREASE" )
		{
			val = stats[playernum]->getActiveShieldBonus(false);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "PASSIVE_AC_INCREASE" )
		{
			val = stats[playernum]->getPassiveShieldBonus(false);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "BLOCK_DEGRADE_NORMAL_CHANCE" )
		{
			val = 25 + (stats[playernum]->type == GOBLIN ? 10 : 0); // degrade > 0 dmg taken
			val += 2 * (static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 10));
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "BLOCK_DEGRADE_DEFENDING_CHANCE" )
		{
			val = 10 + (stats[playernum]->type == GOBLIN ? 10 : 0); // degrade on 0 dmg
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val = 40 + (stats[playernum]->type == GOBLIN ? 10 : 0);
			}
			val += 2 * (static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 10));
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		return buf;
	}
	else if ( proficiency == PRO_UNARMED )
	{
		if ( tag == "UNARMED_DMG_RANGE" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 3.f; // lowest damage roll
			}
			else
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 2.f; // lowest damage roll
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "UNARMED_DMG_EFFECTIVENESS" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			else
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "UNARMED_BONUS_DMG" )
		{
			val = static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "GLOVE_DEGRADE_CHANCE" )
		{
			val = 100 + (stats[playernum]->type == GOBLIN ? 20 : 0); // chance to degrade on > 0 dmg
			val += (static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20)) * 10;
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val *= 2;
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "GLOVE_DEGRADE0_CHANCE" )
		{
			val = 8 + (stats[playernum]->type == GOBLIN ? 4 : 0); // chance to degrade on 0 dmg
			val += static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20);
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val *= 2;
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "UNARMED_KNOCKBACK_DIST" )
		{
			val = static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20) * 20;
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		return buf;
	}
	else if ( proficiency == PRO_SWORD )
	{
		if ( tag == "SWORD_DMG_RANGE" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 3.f; // lowest damage roll
			}
			else
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 2.f; // lowest damage roll
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "SWORD_DMG_EFFECTIVENESS" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			else
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "SWORD_DEGRADE_CHANCE" )
		{
			val = 50 + (stats[playernum]->type == GOBLIN ? 20 : 0); // chance to degrade on > 0 dmg
			val += (static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20)) * 10;
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val *= 2;
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "SWORD_DEGRADE0_CHANCE" )
		{
			val = 4 + (stats[playernum]->type == GOBLIN ? 4 : 0); // chance to degrade on 0 dmg
			val += static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20);
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val *= 2;
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		return buf;
	}
	else if ( proficiency == PRO_POLEARM )
	{
		if ( tag == "POLEARM_DMG_RANGE" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 3.f; // lowest damage roll
			}
			else
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 2.f; // lowest damage roll
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "POLEARM_DMG_EFFECTIVENESS" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			else
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "POLEARM_DEGRADE_CHANCE" )
		{
			val = 50 + (stats[playernum]->type == GOBLIN ? 20 : 0); // chance to degrade on > 0 dmg
			val += (static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20)) * 10;
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val *= 2;
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "POLEARM_DEGRADE0_CHANCE" )
		{
			val = 4 + (stats[playernum]->type == GOBLIN ? 4 : 0); // chance to degrade on 0 dmg
			val += static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20);
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val *= 2;
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		return buf;
	}
	else if ( proficiency == PRO_AXE )
	{
		if ( tag == "AXE_DMG_RANGE" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 3.f; // lowest damage roll
			}
			else
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 2.f; // lowest damage roll
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "AXE_DMG_EFFECTIVENESS" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			else
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "AXE_DEGRADE_CHANCE" )
		{
			val = 50 + (stats[playernum]->type == GOBLIN ? 20 : 0); // chance to degrade on > 0 dmg
			val += (static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20)) * 10;
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val *= 2;
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "AXE_DEGRADE0_CHANCE" )
		{
			val = 4 + (stats[playernum]->type == GOBLIN ? 4 : 0); // chance to degrade on 0 dmg
			val += static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20);
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val *= 2;
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		return buf;
	}
	else if ( proficiency == PRO_MACE )
	{
		if ( tag == "MACE_DMG_RANGE" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 3.f; // lowest damage roll
			}
			else
			{
				val = 100 - (100 - stats[playernum]->getModifiedProficiency(proficiency)) / 2.f; // lowest damage roll
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "MACE_DMG_EFFECTIVENESS" )
		{
			if ( proficiency == PRO_POLEARM )
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			else
			{
				val = -25 + (stats[playernum]->getModifiedProficiency(proficiency) / 2); // -25% to +25%
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "MACE_DEGRADE_CHANCE" )
		{
			val = 50 + (stats[playernum]->type == GOBLIN ? 20 : 0); // chance to degrade on > 0 dmg
			val += (static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20)) * 10;
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val *= 2;
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "MACE_DEGRADE0_CHANCE" )
		{
			val = 4 + (stats[playernum]->type == GOBLIN ? 4 : 0); // chance to degrade on 0 dmg
			val += static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20);
			if ( svFlags & SV_FLAG_HARDCORE )
			{
				val *= 2;
			}
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				val = 0.0;
			}
			if ( val > 0.0001 )
			{
				val = 100 / val;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		return buf;
	}
	else if ( proficiency == PRO_SWIMMING )
	{
		if ( tag == "SWIM_SPEED_TOTAL" )
		{
			val = (((stats[playernum]->getModifiedProficiency(proficiency) / 100.f) * 50.f) + 50); // water movement speed
			if ( stats[playernum]->type == SKELETON )
			{
				val *= .5;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "SWIM_SPEED_BASE" )
		{
			val = -50.0; // water movement speed
			if ( stats[playernum]->type == SKELETON )
			{
				val -= 25.0;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "SWIM_SPEED_BONUS" )
		{
			val = (((stats[playernum]->getModifiedProficiency(proficiency) / 100.f) * 50.f)); // water movement speed
			if ( stats[playernum]->type == SKELETON )
			{
				val *= .5;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		return buf;
	}
	else if ( proficiency == PRO_LEADERSHIP )
	{
		if ( tag == "LEADER_MAX_FOLLOWERS" )
		{
			val = std::min(8, std::max(4, 2 * (stats[playernum]->getModifiedProficiency(proficiency) / 20))); // max followers
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "LEADER_FOLLOWER_SPEED" )
		{
			val = 1 + (stats[playernum]->getModifiedProficiency(proficiency) / 20);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "LEADER_CHARM_MONSTER" )
		{
			val = 80 + ((statGetCHR(stats[playernum], player) + stats[playernum]->getModifiedProficiency(proficiency)) / 20) * 10;
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "LIST_LEADER_AVAILABLE_FOLLOWERS" )
		{
			std::string outputList = "";
			Monster playerRace = stats[playernum]->type;
			std::map<Monster, std::vector<Monster>>* allyTable = &Player::SkillSheet_t::skillSheetData.leadershipAllyTableBase;
			enum TableOrder : int 
			{
				LEADER_BASE_TABLE,
				LEADER_UNIQUE_TABLE,
				LEADER_CAPSTONE_TABLE,
				TABLE_MAX
			};
			for ( int i = LEADER_BASE_TABLE; i < TABLE_MAX; ++i )
			{
				if ( i == LEADER_CAPSTONE_TABLE )
				{
					if ( skillCapstoneUnlocked(playernum, proficiency) )
					{
						allyTable = &Player::SkillSheet_t::skillSheetData.leadershipAllyTableLegendary;
					}
					else
					{
						continue;
					}
				}
				if ( i == LEADER_CAPSTONE_TABLE || i == LEADER_BASE_TABLE )
				{
					if ( allyTable->find(playerRace) != allyTable->end() )
					{
						if ( !(*allyTable)[playerRace].empty() )
						{
							for ( auto& ally : (*allyTable)[playerRace] )
							{
								if ( ally < 0 || ally >= NUMMONSTERS ) { continue; }
								std::string monsterName = "";
								monsterName = getMonsterLocalizedName(ally);
								capitalizeString(monsterName);
								if ( outputList != "" )
								{
									outputList += '\n';
								}
								outputList += "\x1E " + monsterName;
							}
						}
					}
				}
				else if ( i == LEADER_UNIQUE_TABLE )
				{
					auto* allyTable = &Player::SkillSheet_t::skillSheetData.leadershipAllyTableSpecialRecruitment;
					if ( allyTable->find(playerRace) != allyTable->end() )
					{
						if ( !(*allyTable)[playerRace].empty() )
						{
							for ( auto& allyPair : (*allyTable)[playerRace] )
							{
								auto& ally = allyPair.first;
								if ( ally < 0 || ally >= NUMMONSTERS ) { continue; }
								std::string monsterName = "";
								monsterName = getMonsterLocalizedName(ally);
								capitalizeString(monsterName);
								if ( outputList != "" )
								{
									outputList += '\n';
								}
								outputList += "\x1E " + monsterName;
								outputList += "\n" + allyPair.second;
							}
						}
					}
				}
			}
			if ( outputList == "" ) { outputList = "-"; }
			snprintf(buf, sizeof(buf), rawValue.c_str(), outputList.c_str());
		}
		return buf;
	}
	else if ( proficiency == PRO_TRADING )
	{
		if ( tag == "TRADING_BUY_PRICE" )
		{
			val = 1 / ((50 + stats[playernum]->getModifiedProficiency(proficiency)) / 150.f); // buy value
			//val /= 1.f + statGetCHR(stats[playernum], players[playernum]->entity) / 20.f;
			val = std::max(1.0, val);
			val = val * 100.0 - 100.0;
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "TRADING_SELL_PRICE" )
		{
			val = (50 + stats[playernum]->getModifiedProficiency(proficiency)) / 150.f; // sell value
			val *= 1.f + statGetCHR(stats[playernum], players[playernum]->entity) / 20.f;
			val = std::min(1.0, val);
			val = val * 100.0 - 100.0;
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		return buf;
	}
	else if ( proficiency == PRO_APPRAISAL )
	{
		if ( tag == "APPRAISE_GOLD_SPEED" )
		{
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				snprintf(buf, sizeof(buf), "%s", Language::get(4064)); // "instant"
			}
			else
			{
				val = (60.f / (stats[playernum]->getModifiedProficiency(proficiency) + 1)) / (TICKS_PER_SECOND); // appraisal time per gold value
				snprintf(buf, sizeof(buf), rawValue.c_str(), val);
			}
		}
		else if ( tag == "APPRAISE_MAX_GOLD_VALUE" )
		{
			if ( skillCapstoneUnlocked(playernum, proficiency) )
			{
				snprintf(buf, sizeof(buf), "%s", Language::get(4065)); // "any"
			}
			else
			{
				val = 10 * (stats[playernum]->getModifiedProficiency(proficiency) + (statGetPER(stats[playernum], player) * 5)); // max gold value can appraise
				if ( val < 0.0 )
				{
					snprintf(buf, sizeof(buf), "??? Gold");
				}
				else if ( val < 0.1 )
				{
					val = 9;
					snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
				}
				else
				{
					snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
				}
			}
		}
		else if ( tag == "APPRAISE_WORTHLESS_GLASS" )
		{
			if ( (stats[playernum]->getModifiedProficiency(proficiency) + (statGetPER(stats[playernum], player) * 5)) >= 100 )
			{
				snprintf(buf, sizeof(buf), rawValue.c_str(), Language::get(1314)); // yes
			}
			else
			{
				snprintf(buf, sizeof(buf), rawValue.c_str(), Language::get(1315)); // no
			}
		}
		return buf;
	}
	else if ( proficiency == PRO_LOCKPICKING )
	{
		Sint32 PER = statGetPER(stats[playernum], player);
		if ( tag == "TINKERING_LOCKPICK_CHESTS_DOORS" )
		{
			val = stats[playernum]->getModifiedProficiency(proficiency) / 2.f; // lockpick chests/doors
			if ( stats[playernum]->getModifiedProficiency(proficiency) >= SKILL_LEVEL_LEGENDARY )
			{
				val = 100.f;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "TINKERING_SCRAP_CHESTS" )
		{
			val = std::min(100.f, stats[playernum]->getModifiedProficiency(proficiency) + 50.f);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "TINKERING_SCRAP_AUTOMATONS" )
		{
			if ( stats[playernum]->getModifiedProficiency(proficiency) >= SKILL_LEVEL_EXPERT )
			{
				val = 100.f; // lockpick automatons
			}
			else
			{
				val = (100 - 100 / (static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20 + 1))); // lockpick automatons
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "TINKERING_DISARM_ARROWS" )
		{
			val = (100 - 100 / (std::max(1, static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 10)))); // disarm arrow traps
			if ( stats[playernum]->getModifiedProficiency(proficiency) < SKILL_LEVEL_BASIC )
			{
				val = 0.f;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "TINKERING_KIT_SCRAP_BONUS" )
		{
			// bonus scrapping chances.
			int skillLVL = std::min(5, static_cast<int>((stats[playernum]->getModifiedProficiency(proficiency) + PER) / 20));
			skillLVL = std::max(0, skillLVL);
			switch ( skillLVL )
			{
				case 5:
					val = 150.f;
					break;
				case 4:
					val = 125.f;
					break;
				case 3:
					val = 50.f;
					break;
				case 2:
					val = 25.f;
					break;
				case 1:
					val = 12.5;
					break;
				default:
					val = 0.f;
					break;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "TINKERING_KIT_REPAIR_ITEM" )
		{
			std::string canRepairItems = Language::get(4057); // none
			char metalbuf[64] = "";
			char magicbuf[64] = "";
			if ( (stats[playernum]->getModifiedProficiency(proficiency) + PER + (stats[playernum]->type == AUTOMATON ? 20 : 0)) >= SKILL_LEVEL_LEGENDARY )
			{
				canRepairItems = Language::get(4058); // all
			}
			else if ( (stats[playernum]->getModifiedProficiency(proficiency) + PER + (stats[playernum]->type == AUTOMATON ? 20 : 0)) >= SKILL_LEVEL_MASTER )
			{
				// 2/0
				snprintf(metalbuf, sizeof(metalbuf), Language::get(4059), 2);
				snprintf(magicbuf, sizeof(magicbuf), Language::get(4060), 0);
				canRepairItems = "\x1E ";
				canRepairItems += metalbuf;
				canRepairItems += '\n';
				canRepairItems += "\x1E ";
				canRepairItems += magicbuf;
			}
			else if ( (stats[playernum]->getModifiedProficiency(proficiency) + PER + (stats[playernum]->type == AUTOMATON ? 20 : 0)) >= SKILL_LEVEL_EXPERT )
			{
				// 1/0
				snprintf(metalbuf, sizeof(metalbuf), Language::get(4059), 1);
				snprintf(magicbuf, sizeof(magicbuf), Language::get(4060), 0);
				canRepairItems = "\x1E ";
				canRepairItems += metalbuf;
				canRepairItems += '\n';
				canRepairItems += "\x1E ";
				canRepairItems += magicbuf;
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), canRepairItems.c_str());
		}
		else if ( tag == "TINKERING_MAX_ALLIES" )
		{
			val = maximumTinkeringBotsCanBeDeployed(stats[playernum]);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		return buf;
	}
	else if ( proficiency == PRO_ALCHEMY )
	{
		if ( tag == "ALCHEMY_POTION_EFFECT_DMG" )
		{
			int skillLVL = stats[playernum]->getModifiedProficiency(proficiency) / 20;
			// +0% baseline
			val = 100 * (potionDamageSkillMultipliers[std::min(skillLVL, 5)] - potionDamageSkillMultipliers[0]);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "ALCHEMY_THROWN_IMPACT_DMG" )
		{
			int skillLVL = stats[playernum]->getModifiedProficiency(proficiency) / 20;
			// +0% baseline
			val = 100 * (potionDamageSkillMultipliers[std::min(skillLVL, 5)] - potionDamageSkillMultipliers[0]);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "ALCHEMY_DUPLICATION_CHANCE" )
		{
			val = 50.f + static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20) * 10;
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "ALCHEMY_EMPTY_BOTTLE_CONSUME" )
		{
			val = std::min(80, (60 + static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20) * 10));
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "ALCHEMY_EMPTY_BOTTLE_BREW" )
		{
			val = 50.f + static_cast<int>(stats[playernum]->getModifiedProficiency(proficiency) / 20) * 5;
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "ALCHEMY_LEARNT_INGREDIENTS_BASE" )
		{
			std::string outputList = "";
			for ( auto it = clientLearnedAlchemyIngredients[playernum].begin(); 
				it != clientLearnedAlchemyIngredients[playernum].end(); ++it )
			{
				auto alchemyEntry = *it;
				if ( GenericGUI[playernum].isItemBaseIngredient(alchemyEntry) )
				{
					std::string itemName = items[alchemyEntry].getIdentifiedName();
					size_t pos = std::string::npos;
					for ( auto& potionName : Player::SkillSheet_t::skillSheetData.potionNamesToFilter )
					{
						if ( (pos = itemName.find(potionName)) != std::string::npos )
						{
							itemName.erase(pos, potionName.length());
						}
					}
					capitalizeString(itemName);
					if ( outputList != "" )
					{
						outputList += '\n';
					}
					outputList += "\x1E " + itemName;
				}
			}
			if ( outputList == "" ) { outputList = "-"; }
			snprintf(buf, sizeof(buf), rawValue.c_str(), outputList.c_str());
		}
		else if ( tag == "ALCHEMY_LEARNT_INGREDIENTS_SECONDARY" )
		{
			std::string outputList = "";
			for ( auto it = clientLearnedAlchemyIngredients[playernum].begin();
				it != clientLearnedAlchemyIngredients[playernum].end(); ++it )
			{
				auto alchemyEntry = *it;
				if ( GenericGUI[playernum].isItemSecondaryIngredient(alchemyEntry)
					&& !GenericGUI[playernum].isItemBaseIngredient(alchemyEntry) )
				{
					std::string itemName = items[alchemyEntry].getIdentifiedName();
					size_t pos = std::string::npos;
					for ( auto& potionName : Player::SkillSheet_t::skillSheetData.potionNamesToFilter )
					{
						if ( (pos = itemName.find(potionName)) != std::string::npos )
						{
							itemName.erase(pos, potionName.length());
						}
					}
					capitalizeString(itemName);
					if ( outputList != "" )
					{
						outputList += '\n';
					}
					outputList += "\x1E " + itemName;
				}
			}
			if ( outputList == "" ) { outputList = "-"; }
			snprintf(buf, sizeof(buf), rawValue.c_str(), outputList.c_str());
		}
		return buf;
	}
	else if ( proficiency == PRO_SPELLCASTING )
	{
		if ( tag == "CASTING_MP_REGEN" )
		{
			if ( (stats[playernum])->playerRace == RACE_INSECTOID && (stats[playernum])->appearance == 0 )
			{
				return Language::get(4066);
			}
			else if ( (stats[playernum])->type == AUTOMATON )
			{
				return Language::get(4067);
			}
			else
			{
				val = getBaseManaRegen(player, *(stats[playernum])) / (TICKS_PER_SECOND * 1.f);
				snprintf(buf, sizeof(buf), rawValue.c_str(), val);
			}
		}
		else if ( tag == "CASTING_MP_REGEN_SKILL_MULTIPLIER" )
		{
			if ( (stats[playernum])->playerRace == RACE_INSECTOID && (stats[playernum])->appearance == 0 )
			{
				return Language::get(4066);
			}
			else if ( (stats[playernum])->type == AUTOMATON )
			{
				return Language::get(4067);
			}
			else
			{
				val = 0.0;
				int skill = stats[playernum]->getModifiedProficiency(proficiency);
				int multiplier = (skill / 20) + 1;
				val = multiplier;
				//real_t normalValue = player->getBaseManaRegen(*(stats[playernum])) / (TICKS_PER_SECOND * 1.f);
				//stats[playernum]->getModifiedProficiency(proficiency) = 0;
				//real_t zeroValue = player->getBaseManaRegen(*(stats[playernum])) / (TICKS_PER_SECOND * 1.f);
				//stats[playernum]->getModifiedProficiency(proficiency) = skill;
				//
				//val = (100 * zeroValue / normalValue) - 100;
				snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
			}
		}
		else if ( tag == "CASTING_MP_REGEN_SKILL_BONUS" )
		{
			val = 0.0;
			int skill = stats[playernum]->getProficiency(proficiency);
			real_t normalValue = getBaseManaRegen(player, *(stats[playernum])) / (TICKS_PER_SECOND * 1.f);
			stats[playernum]->setProficiencyUnsafe(proficiency, -999);
			real_t zeroValue = getBaseManaRegen(player, *(stats[playernum])) / (TICKS_PER_SECOND * 1.f);
			stats[playernum]->setProficiency(proficiency, skill);
				
			val = (100 * zeroValue / normalValue) - 100;
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "CASTING_MP_REGEN_BONUS_INT" )
		{
			val = 0.0;
			int stat = stats[playernum]->INT;
			real_t normalValue = getBaseManaRegen(player, *(stats[playernum])) / (TICKS_PER_SECOND * 1.f);
			stats[playernum]->INT = 0;
			real_t zeroValue = getBaseManaRegen(player, *(stats[playernum])) / (TICKS_PER_SECOND * 1.f);
			stats[playernum]->INT = stat;

			val = (100 * zeroValue / normalValue) - 100;
			snprintf(buf, sizeof(buf), rawValue.c_str(), val);
		}
		else if ( tag == "CASTING_BEGINNER" )
		{
			if ( isSpellcasterBeginner(playernum, player) )
			{
				snprintf(buf, sizeof(buf), rawValue.c_str(), Language::get(1314)); // yes
			}
			else
			{
				snprintf(buf, sizeof(buf), rawValue.c_str(), Language::get(1315)); // no
			}
		}
		else if ( tag == "CASTING_SPELLBOOK_FUMBLE" )
		{
			int skillLVL = std::min(std::max(0, stats[playernum]->getModifiedProficiency(proficiency) + statGetINT(stats[playernum], player)), 100);
			skillLVL /= 20;
			std::string tierName = Language::get(4061);
			tierName += " ";
			if ( skillLVL <= 0 )
			{
				tierName += "I";
			}
			else if ( skillLVL == 1 )
			{
				tierName += "II";
			}
			else if ( skillLVL == 2 )
			{
				tierName += "III";
			}
			else if ( skillLVL == 3 )
			{
				tierName += "IV";
			}
			else if ( skillLVL == 4 )
			{
				tierName += "V";
			}
			else if ( skillLVL >= 5 )
			{
				tierName += "VI";
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), tierName.c_str());
		}
		return buf;
	}
	else if ( proficiency == PRO_MAGIC )
	{
		if ( tag == "MAGIC_CURRENT_TIER" )
		{
			std::string tierName = Language::get(4061);
			int skillLVL = std::min(stats[playernum]->getModifiedProficiency(proficiency) + statGetINT(stats[playernum], player), 100);
			if ( skillLVL < 0 )
			{
				tierName = Language::get(4057); // none
			}
			else
			{
				skillLVL /= 20;
				tierName += " ";
				if ( skillLVL == 0 )
				{
					tierName += "I";
				}
				else if ( skillLVL == 1 )
				{
					tierName += "II";
				}
				else if ( skillLVL == 2 )
				{
					tierName += "III";
				}
				else if ( skillLVL == 3 )
				{
					tierName += "IV";
				}
				else if ( skillLVL == 4 )
				{
					tierName += "V";
				}
				else if ( skillLVL >= 5 )
				{
					tierName += "VI";
				}
			}
			snprintf(buf, sizeof(buf), rawValue.c_str(), tierName.c_str());
		}
		else if ( tag == "MAGIC_SPELLPOWER_TOTAL" )
		{
			val = (getBonusFromCasterOfSpellElement(player, stats[playernum], nullptr, SPELL_NONE) * 100.0);
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "MAGIC_SPELLPOWER_INT" )
		{
			//val = (getBonusFromCasterOfSpellElement(player, stats[playernum], nullptr, SPELL_NONE) * 100.0);
			int INT = statGetINT(stats[playernum], players[playernum]->entity);
			real_t bonus = 0.0;
			if ( INT > 0 )
			{
				bonus += INT / 100.0;
			}
			val = bonus * 100.0;
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "MAGIC_SPELLPOWER_EQUIPMENT" )
		{
			val = (getBonusFromCasterOfSpellElement(player, stats[playernum], nullptr, SPELL_NONE) * 100.0);
			int INT = statGetINT(stats[playernum], players[playernum]->entity);
			real_t bonus = 0.0;
			if ( INT > 0 )
			{
				bonus += INT / 100.0;
			}
			val -= bonus * 100.0;
			snprintf(buf, sizeof(buf), rawValue.c_str(), (int)val);
		}
		else if ( tag == "MAGIC_CURRENT_TIER_SPELLS" )
		{
			int skillLVL = std::min(stats[playernum]->getModifiedProficiency(proficiency) + statGetINT(stats[playernum], player), 100);
			if ( skillLVL >= 0 )
			{
				skillLVL /= 20;
			}
			std::string magics = "";
			for ( auto it = allGameSpells.begin(); it != allGameSpells.end(); ++it )
			{
				auto spellEntry = *it;
				if ( spellEntry->ID == SPELL_WEAKNESS || spellEntry->ID == SPELL_GHOST_BOLT )
				{
					continue;
				}
				if ( spellEntry && spellEntry->difficulty == (skillLVL * 20) )
				{
					if ( magics != "" )
					{
						magics += '\n';
					}
					magics += "\x1E ";
					magics += spellEntry->getSpellName();
				}
			}
			if ( magics == "" ) { magics = "-"; }
			snprintf(buf, sizeof(buf), rawValue.c_str(), magics.c_str());
		}
		return buf;
	}
	
	return "";
}

void Player::SkillSheet_t::selectSkill(int skill)
{
	selectedSkill = skill;
	bSkillSheetEntryLoaded = false;
	openTick = ticks;
	resetSkillDisplay();
}

//void positionSkillSheetBlitField(Field* f, Text* tex, SDL_Rect& pos, int yoff = 0)
//{
//	Font* actualFont = Font::get(f->getFont());
//	int lines = std::max(1, tex->getNumTextLines());
//	int fullH = lines * (actualFont->height(false) + actualFont->getOutline() * 2);
//	if ( f->getVJustify() == Field::justify_t::TOP )
//	{
//		pos.y = pos.y + yoff + std::min(pos.h - fullH, 0);
//	}
//	else if ( f->getVJustify() == Field::justify_t::CENTER )
//	{
//		pos.y = pos.y + yoff + (pos.h - fullH) / 2;
//	}
//	if ( f->getHJustify() == Field::justify_t::RIGHT )
//	{
//		pos.x = pos.x + pos.w - tex->getWidth();
//	}
//	else if ( f->getHJustify() == Field::justify_t::CENTER )
//	{
//		pos.x = pos.x + pos.w / 2 - tex->getWidth() / 2;
//	}
//}
//
//SDL_Surface* blitSkillSheet(Frame* skillsFrame)
//{
//	int player = skillsFrame->getOwner();
//	SDL_Surface* sprite = SDL_CreateRGBSurface(0, skillsFrame->getSize().w, skillsFrame->getSize().h, 32,
//		0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000);
//
//	real_t opacity = 1.0; // skillsFrame->getOpacity() / 100.0
//
//	SDL_Rect totalPos = skillSheetEntryFrames[player].skillsFrame->getSize();
//	/*for ( auto& img : skillSheetEntryFrames[player].entryFrameLeft->getImages() )
//	{
//		if ( img->disabled ) { continue; }
//		if ( img->path == "" ) { continue; }
//		SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
//		Uint8 r, g, b, a;
//		getColor(img->color, &r, &g, &b, &a);
//		SDL_SetSurfaceAlphaMod(srcSurf, a * opacity);
//		SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//		SDL_Rect pos = img->pos;
//		pos.x += totalPos.x;
//		pos.y += totalPos.y;
//		pos.x += skillSheetEntryFrames[player].entryFrameLeft->getSize().x;
//		pos.y += skillSheetEntryFrames[player].entryFrameLeft->getSize().y;
//		SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
//	}
//
//	for ( auto& img : skillSheetEntryFrames[player].entryFrameRight->getImages() )
//	{
//		if ( img->disabled ) { continue; }
//		if ( img->path == "" ) { continue; }
//		SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
//		Uint8 r, g, b, a;
//		getColor(img->color, &r, &g, &b, &a);
//		SDL_SetSurfaceAlphaMod(srcSurf, a * opacity);
//		SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//		SDL_Rect pos = img->pos;
//		pos.x += totalPos.x;
//		pos.y += totalPos.y;
//		pos.x += skillSheetEntryFrames[player].entryFrameRight->getSize().x;
//		pos.y += skillSheetEntryFrames[player].entryFrameRight->getSize().y;
//		SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
//	}*/
//
//	for ( auto frame : skillSheetEntryFrames[player].skillsFrame->getFrames() )
//	{
//		totalPos = skillSheetEntryFrames[player].skillsFrame->getSize();
//
//		totalPos.x += frame->getSize().x;
//		totalPos.y += frame->getSize().y;
//		for ( auto& img : frame->getImages() )
//		{
//			if ( img->disabled ) { continue; }
//			if ( img->path == "" ) { continue; }
//			if ( img->ontop ) { continue; }
//			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
//			Uint8 r, g, b, a;
//			getColor(img->color, &r, &g, &b, &a);
//			SDL_SetSurfaceAlphaMod(srcSurf, a * opacity);
//			//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//			SDL_Rect pos = img->pos;
//			pos.x += totalPos.x;
//			pos.y += totalPos.y;
//			SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
//		}
//	}
//
//	for ( int i = 0; i < NUMPROFICIENCIES; ++i )
//	{
//		Frame* frame = skillSheetEntryFrames[player].entryFrames[i];
//		totalPos = skillSheetEntryFrames[player].skillsFrame->getSize();
//		totalPos.x += frame->getSize().x;
//		if ( i >= 8 )
//		{
//			totalPos.x += skillSheetEntryFrames[player].entryFrameLeft->getSize().x;
//		}
//		else
//		{
//			totalPos.x += skillSheetEntryFrames[player].entryFrameRight->getSize().x;
//		}
//		totalPos.y += frame->getSize().y;
//		if ( i >= 8 )
//		{
//			totalPos.y += skillSheetEntryFrames[player].entryFrameLeft->getSize().y;
//		}
//		else
//		{
//			totalPos.y += skillSheetEntryFrames[player].entryFrameRight->getSize().y;
//		}
//		for ( auto img : frame->getImages() )
//		{
//			if ( img->disabled ) { continue; }
//			if ( img->path == "" ) { continue; }
//			if ( img->ontop ) { continue; }
//			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
//			Uint8 r, g, b, a;
//			getColor(img->color, &r, &g, &b, &a);
//			SDL_SetSurfaceAlphaMod(srcSurf, a * opacity);
//			//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//			SDL_Rect pos = img->pos;
//			pos.x += totalPos.x;
//			pos.y += totalPos.y;
//			SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
//		}
//
//		for ( auto img : frame->getImages() )
//		{
//			if ( img->disabled ) { continue; }
//			if ( img->path == "" ) { continue; }
//			if ( !img->ontop ) { continue; }
//			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
//			Uint8 r, g, b, a;
//			getColor(img->color, &r, &g, &b, &a);
//			SDL_SetSurfaceAlphaMod(srcSurf, a * opacity);
//			//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//			SDL_Rect pos = img->pos;
//			pos.x += totalPos.x;
//			pos.y += totalPos.y;
//			SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
//		}
//
//		for ( auto f : frame->getFields() )
//		{
//			auto tex = f->getTextObject();
//			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(tex->getSurf());
//			SDL_SetSurfaceAlphaMod(srcSurf, 255 * opacity);
//			//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//			SDL_Rect pos = f->getSize();
//
//			positionSkillSheetBlitField(f, tex, pos);
//
//			pos.x += totalPos.x;
//			pos.y += totalPos.y;
//			SDL_BlitSurface(srcSurf, nullptr, sprite, &pos);
//		}
//	}
//
//	for ( auto frame : skillSheetEntryFrames[player].skillsFrame->getFrames() )
//	{
//		totalPos = skillSheetEntryFrames[player].skillsFrame->getSize();
//
//		totalPos.x += frame->getSize().x;
//		totalPos.y += frame->getSize().y;
//		for ( auto& img : frame->getImages() )
//		{
//			if ( img->disabled ) { continue; }
//			if ( img->path == "" ) { continue; }
//			if ( !img->ontop ) { continue; }
//			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
//			Uint8 r, g, b, a;
//			getColor(img->color, &r, &g, &b, &a);
//			SDL_SetSurfaceAlphaMod(srcSurf, a * opacity);
//			//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//			SDL_Rect pos = img->pos;
//			pos.x += totalPos.x;
//			pos.y += totalPos.y;
//			SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
//		}
//	}
//
//	//for ( auto img : skillsFrame->getImages() )
//	//{
//	//	if ( img->disabled ) { continue; }
//	//	if ( img->path == "" ) { continue; }
//	//	SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
//	//	Uint8 r, g, b, a;
//	//	getColor(img->color, &r, &g, &b, &a);
//	//	SDL_SetSurfaceAlphaMod(srcSurf, a * opacity);
//	//	//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//	//	SDL_Rect pos = img->pos;
//	//	SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
//	//}
//
//	for ( auto frame : skillsFrame->getFrames() )
//	{
//		totalPos = skillSheetEntryFrames[player].skillsFrame->getSize();
//
//		for ( auto f : frame->getFields() )
//		{
//			auto tex = f->getTextObject();
//			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(tex->getSurf());
//			SDL_SetSurfaceAlphaMod(srcSurf, 255 * opacity);
//			//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//			SDL_Rect pos = f->getSize();
//
//			positionSkillSheetBlitField(f, tex, pos);
//
//			pos.x += totalPos.x;
//			pos.y += totalPos.y;
//			SDL_BlitSurface(srcSurf, nullptr, sprite, &pos);
//		}
//	}
//
//	for ( auto frame : skillSheetEntryFrames[player].skillDescFrame->getFrames() )
//	{
//		totalPos = skillSheetEntryFrames[player].skillsFrame->getSize();
//		totalPos.x += skillSheetEntryFrames[player].skillDescFrame->getSize().x;
//		totalPos.y += skillSheetEntryFrames[player].skillDescFrame->getSize().y;
//
//		totalPos.x += frame->getSize().x;
//		totalPos.y += frame->getSize().y;
//		for ( auto& img : frame->getImages() )
//		{
//			if ( img->disabled ) { continue; }
//			if ( img->path == "" ) { continue; }
//			//if ( !img->ontop ) { continue; }
//			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
//			Uint8 r, g, b, a;
//			getColor(img->color, &r, &g, &b, &a);
//			SDL_SetSurfaceAlphaMod(srcSurf, a * opacity);
//			//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//			SDL_Rect pos = img->pos;
//			pos.x += totalPos.x;
//			pos.y += totalPos.y;
//			SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
//		}
//
//		for ( auto f : frame->getFields() )
//		{
//			auto tex = f->getTextObject();
//			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(tex->getSurf());
//			SDL_SetSurfaceAlphaMod(srcSurf, 255 * opacity);
//			//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//			SDL_Rect pos = f->getSize();
//
//			positionSkillSheetBlitField(f, tex, pos);
//
//			pos.x += totalPos.x;
//			pos.y += totalPos.y;
//			SDL_BlitSurface(srcSurf, nullptr, sprite, &pos);
//		}
//	}
//
//	for ( auto frame : skillSheetEntryFrames[player].scrollAreaOuterFrame->getFrames() )
//	{
//		totalPos = skillSheetEntryFrames[player].skillsFrame->getSize();
//		totalPos.x += skillSheetEntryFrames[player].skillDescFrame->getSize().x;
//		totalPos.y += skillSheetEntryFrames[player].skillDescFrame->getSize().y;
//		totalPos.x += skillSheetEntryFrames[player].scrollAreaOuterFrame->getSize().x;
//		totalPos.y += skillSheetEntryFrames[player].scrollAreaOuterFrame->getSize().y;
//
//		totalPos.x += frame->getSize().x;
//		totalPos.y += frame->getSize().y;
//		for ( auto& img : frame->getImages() )
//		{
//			if ( img->disabled ) { continue; }
//			if ( img->path == "" ) { continue; }
//			//if ( !img->ontop ) { continue; }
//			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
//			Uint8 r, g, b, a;
//			getColor(img->color, &r, &g, &b, &a);
//			SDL_SetSurfaceAlphaMod(srcSurf, a * opacity);
//			//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//			SDL_Rect pos = img->pos;
//			pos.x += totalPos.x;
//			pos.y += totalPos.y;
//			SDL_BlitScaled(srcSurf, nullptr, sprite, &pos);
//		}
//
//		for ( auto f : frame->getFields() )
//		{
//			if ( f->isDisabled() ) { continue; }
//			auto tex = f->getTextObject();
//			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(tex->getSurf());
//			SDL_SetSurfaceAlphaMod(srcSurf, 255 * opacity);
//			//SDL_SetSurfaceBlendMode(srcSurf, SDL_BLENDMODE_NONE);
//			SDL_Rect pos = f->getSize();
//
//			if ( tex->getNumTextLines() > 1 )
//			{
//				char* buf = (char*)malloc(f->getTextLen() + 1);
//				memcpy(buf, f->getText(), f->getTextLen() + 1);
//
//				int yoff = 0;
//				int currentLine = -1;
//				char* nexttoken;
//				char* token = buf;
//				do {
//					++currentLine;
//					nexttoken = Field::tokenize(token, "\n");
//
//					Text* text = Text::get(token, f->getFont(), f->getTextColor(), f->getOutlineColor());
//					assert(text);
//
//					positionSkillSheetBlitField(f, text, pos, yoff);
//					pos.x += totalPos.x;
//					pos.y += totalPos.y;
//
//					srcSurf = const_cast<SDL_Surface*>(text->getSurf());
//					SDL_SetSurfaceAlphaMod(srcSurf, 255 * opacity);
//
//					SDL_Rect srcPos = pos;
//					srcPos.x = 0;
//					srcPos.y = 0;
//					if ( f->getSize().y + yoff + frame->getSize().y < 0 )
//					{
//						int diff = f->getSize().y + yoff + frame->getSize().y;
//						srcPos.y -= diff;
//						pos.y -= diff;
//					}
//					else if ( f->getSize().y + yoff + text->getHeight() - (frame->getSize().h - frame->getSize().y) < 0 )
//					{
//						int diff = f->getSize().y + yoff + text->getHeight() - (frame->getSize().h - frame->getSize().y);
//						srcPos.y -= diff;
//						pos.y -= diff;
//					}
//					SDL_BlitSurface(srcSurf, &srcPos, sprite, &pos);
//
//					Font* actualFont = Font::get(f->getFont());
//					yoff += actualFont->height(true);
//					pos = f->getSize();
//				} while ( (token = nexttoken) != NULL );
//
//				free(buf);
//			}
//			else
//			{
//				positionSkillSheetBlitField(f, tex, pos);
//				pos.x += totalPos.x;
//				pos.y += totalPos.y;
//				SDL_BlitSurface(srcSurf, nullptr, sprite, &pos);
//			}
//		}
//	}
//
//	return sprite;
//}

void buttonSkillsheetUpdateSelectorOnHighlight(const int player, Button* button)
{
	if ( button->isHighlighted() )
	{
		players[player]->GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_SKILLS_LIST);
		if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_SKILLS_LIST )
		{
			players[player]->GUI.activateModule(Player::GUI_t::MODULE_SKILLS_LIST);
		}
		SDL_Rect pos = button->getAbsoluteSize();
		// make sure to adjust absolute size to camera viewport
		pos.x -= players[player]->camera_virtualx1();
		pos.y -= players[player]->camera_virtualy1();
		players[player]->hud.setCursorDisabled(false);
		players[player]->hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, inputs.getVirtualMouse(player)->draw_cursor);
	}
}

void sliderSkillsheetUpdateSelectorOnHighlight(const int player, Slider* slider)
{
	if ( slider->isHighlighted() )
	{
		players[player]->GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_SKILLS_LIST);
		if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_SKILLS_LIST )
		{
			players[player]->GUI.activateModule(Player::GUI_t::MODULE_SKILLS_LIST);
		}
		SDL_Rect pos = slider->getAbsoluteSize();
		// make sure to adjust absolute size to camera viewport
		pos.x -= players[player]->camera_virtualx1();
		pos.y -= players[player]->camera_virtualy1();
		players[player]->hud.setCursorDisabled(false);
		players[player]->hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, inputs.getVirtualMouse(player)->draw_cursor);
	}
}

static ConsoleVariable<bool> cvar_skillsheet_optimise("/skillsheet_optimise", true);
void Player::SkillSheet_t::processSkillSheet()
{
	//DebugTimers.addTimePoint("skill 1", "start");
	//DebugTimers.addTimePoint("skill", "start");
	if ( !skillFrame )
	{
		createSkillSheet();
	}

	if ( !player.usingCommand() && Input::inputs[player.playernum].consumeBinaryToggle("Skill Sheet")
		&& !gamePaused && players[player.playernum]->bControlEnabled )
	{
		if ( !bSkillSheetOpen )
		{
			openSkillSheet();
		}
		else
		{
			closeSkillSheet();
			Player::soundCancel();
		}
	}

	auto oldSkillSlideAmount = skillSlideAmount;
	auto oldHighlightedSkill = highlightedSkill;

	if ( !bSkillSheetOpen )
	{
		skillFrame->setDisabled(true);

		auto innerFrame = skillFrame->findFrame("skills frame");
		SDL_Rect pos = innerFrame->getSize();
		skillsFadeInAnimationY = 0.0;
		pos.y = -pos.h;
		innerFrame->setSize(pos);

		auto fade = skillFrame->findImage("fade img");
		Uint8 r, g, b, a;
		getColor(fade->color, &r, &g, &b, &a);
		a = 0;
		fade->color = makeColor( r, g, b, a);
		fade->disabled = true;
		return;
	}

	bool reblitFrame = false;

	skillFrame->setDisabled(false);
	skillFrame->setSize(SDL_Rect{ players[player.playernum]->camera_virtualx1(),
		players[player.playernum]->camera_virtualy1(),
		players[player.playernum]->camera_virtualWidth(),
		players[player.playernum]->camera_virtualHeight() });

	bool oldCompactViewVal = bUseCompactSkillsView;
	bool oldSlideWindowsOnly = bSlideWindowsOnly;
	if ( splitscreen && (player.bUseCompactGUIHeight() || player.bUseCompactGUIWidth()) )
	{
		// use compact view.
		if ( player.bUseCompactGUIWidth() && !player.bUseCompactGUIHeight() )
		{
			bSlideWindowsOnly = true; // 2 player vertical splitscreen, slide but don't use compact view
			bUseCompactSkillsView = false;
		}
		else
		{
			bUseCompactSkillsView = true;
			bSlideWindowsOnly = false;
		}
	}
	else
	{
		bUseCompactSkillsView = false;
		bSlideWindowsOnly = false;
	}
	if ( (oldCompactViewVal != bUseCompactSkillsView && bUseCompactSkillsView)
		|| (oldSlideWindowsOnly != bSlideWindowsOnly && bSlideWindowsOnly) )
	{
		if ( selectedSkill >= 8 )
		{
			skillSlideAmount = 1.0;
			skillSlideDirection = 1;
		}
		else
		{
			skillSlideAmount = -1.0;
			skillSlideDirection = -1;
		}
	}
	if ( !bUseCompactSkillsView && !bSlideWindowsOnly || (bUseCompactSkillsView && !player.bUseCompactGUIWidth()) )
	{
		skillSlideAmount = 0.0;
		skillSlideDirection = 0;
	}

	auto innerFrame = skillSheetEntryFrames[player.playernum].skillsFrame;
	SDL_Rect sheetSize = innerFrame->getSize();
	Frame* allSkillEntriesLeft = skillSheetEntryFrames[player.playernum].entryFrameLeft;
	Frame* allSkillEntriesRight = skillSheetEntryFrames[player.playernum].entryFrameRight;
	auto leftWingImg = allSkillEntriesLeft->findImage("bg wing left");
	auto rightWingImg = allSkillEntriesRight->findImage("bg wing right");
	auto skillDescriptionFrame = skillSheetEntryFrames[player.playernum].skillDescFrame;
	auto bgImgFrame = skillSheetEntryFrames[player.playernum].skillBgImgsFrame;
	auto scrollAreaOuterFrame = skillSheetEntryFrames[player.playernum].scrollAreaOuterFrame;
	auto scrollArea = skillSheetEntryFrames[player.playernum].scrollArea;
	SDL_Rect scrollOuterFramePos = scrollAreaOuterFrame->getSize();
	SDL_Rect scrollAreaPos = scrollArea->getSize();

	real_t slideTravelDistance = 52;
	int compactViewWidthOffset = (skillSlideDirection != 0 ? 104: 0);
	{
		// dynamic width/height adjustments of outer containers
		sheetSize.h = std::max(0, std::min(skillFrame->getSize().h - 8, 
			(int)(404 + (bUseCompactSkillsView ? windowCompactHeightScaleY : windowHeightScaleY) * 80)));
		sheetSize.w = std::max(0, std::min(skillFrame->getSize().w - 8, 
			(int)(684 + (bUseCompactSkillsView ? windowCompactHeightScaleX : windowHeightScaleX) * 80)));
		if ( player.bUseCompactGUIHeight() && !player.bUseCompactGUIWidth() )
		{
			sheetSize.w += 12; // some adjustment to match 4 player as it's bigger
		}
		innerFrame->setSize(sheetSize);

		SDL_Rect skillDescPos = skillDescriptionFrame->getSize();
		skillDescPos.h = innerFrame->getSize().h - skillDescPos.y - 16;
		skillDescPos.w = innerFrame->getSize().w + compactViewWidthOffset - allSkillEntriesLeft->getSize().w - allSkillEntriesRight->getSize().w;
		int xMove = innerFrame->getSize().w / 2 - skillDescPos.w / 2;
		if ( skillSlideDirection != 0 )
		{
			xMove += (skillSlideAmount) * slideTravelDistance;
		}
		if ( xMove != skillDescPos.x )
		{
			reblitFrame = true;
		}
		skillDescPos.x = xMove;
		skillDescriptionFrame->setSize(skillDescPos);

		scrollOuterFramePos.h = skillDescPos.h - 4;

		auto leftWingPos = allSkillEntriesLeft->getSize();
		auto rightWingPos = allSkillEntriesRight->getSize();

		leftWingPos.x = 0;
		rightWingPos.x = innerFrame->getSize().w - rightWingPos.w;
		leftWingPos.y = std::max(0, innerFrame->getSize().h / 2 - leftWingPos.h / 2);
		rightWingPos.y = std::max(0, innerFrame->getSize().h / 2 - rightWingPos.h / 2);
		allSkillEntriesLeft->setSize(leftWingPos);
		allSkillEntriesRight->setSize(rightWingPos);

		auto leftWingAllSkillsImg = allSkillEntriesLeft->findImage("bg wing all skills left");
		leftWingAllSkillsImg->ontop = true;
		auto rightWingAllSkillsImg = allSkillEntriesRight->findImage("bg wing all skills right");
		rightWingAllSkillsImg->ontop = true;
		int index = 0;
		std::string leftBinary = "00000000";
		std::string rightBinary = "00000000";
		for ( auto& skillEntry : skillSheetData.skillEntries )
		{
			if ( index >= 8 )
			{
				if ( stats[player.playernum]->getModifiedProficiency(skillEntry.skillId) >= SKILL_LEVEL_LEGENDARY )
				{
					leftBinary[7 - (index - 8)] = '1';
				}
			}
			else
			{
				if ( stats[player.playernum]->getModifiedProficiency(skillEntry.skillId) >= SKILL_LEVEL_LEGENDARY )
				{
					rightBinary[7 - index] = '1';
				}
			}
			++index;
		}
		if ( bUseCompactSkillsView )
		{
			leftWingImg->path = "*#images/ui/SkillSheet/UI_Skills_Window_LeftCompact_04.png";
			rightWingImg->path = "*#images/ui/SkillSheet/UI_Skills_Window_RightCompact_04.png";

			leftWingAllSkillsImg->path = "*#images/ui/SkillSheet/Icons2/UI_Skills_Left_Comp_" + leftBinary + ".png";
			rightWingAllSkillsImg->path = "*#images/ui/SkillSheet/Icons2/UI_Skills_Right_Comp_" + rightBinary + ".png";
		}
		else
		{
			leftWingImg->path = "*#images/ui/SkillSheet/UI_Skills_Window_Left_04.png";
			rightWingImg->path = "*#images/ui/SkillSheet/UI_Skills_Window_Right_04.png";

			leftWingAllSkillsImg->path = "*#images/ui/SkillSheet/Icons2/UI_Skills_Left_Full_" + leftBinary + ".png";
			rightWingAllSkillsImg->path = "*#images/ui/SkillSheet/Icons2/UI_Skills_Right_Full_" + rightBinary + ".png";
		}
		if ( auto imgGet = Image::get(leftWingAllSkillsImg->path.c_str()) )
		{
			if ( bUseCompactSkillsView )
			{
				leftWingAllSkillsImg->pos.x = 6 + leftWingImg->pos.x;
				leftWingAllSkillsImg->pos.y = 22 + leftWingImg->pos.y;
			}
			else
			{
				leftWingAllSkillsImg->pos.x = 6 + leftWingImg->pos.x;
				leftWingAllSkillsImg->pos.y = 32 + leftWingImg->pos.y;
			}
			leftWingAllSkillsImg->pos.w = imgGet->getWidth();
			leftWingAllSkillsImg->pos.h = imgGet->getHeight();
		}
		if ( auto imgGet = Image::get(rightWingAllSkillsImg->path.c_str()) )
		{
			if ( bUseCompactSkillsView )
			{
				rightWingAllSkillsImg->pos.x = 152 + rightWingImg->pos.x;
				rightWingAllSkillsImg->pos.y = 22 + rightWingImg->pos.y;
			}
			else
			{
				rightWingAllSkillsImg->pos.x = 152 + rightWingImg->pos.x;
				rightWingAllSkillsImg->pos.y = 32 + rightWingImg->pos.y;
			}
			rightWingAllSkillsImg->pos.w = imgGet->getWidth();
			rightWingAllSkillsImg->pos.h = imgGet->getHeight();
		}
		leftWingImg->pos.h = Image::get(leftWingImg->path.c_str())->getHeight();
		rightWingImg->pos.h = Image::get(rightWingImg->path.c_str())->getHeight();
	}
	{
		// dynamic main panel width/height background image adjustment
		SDL_Rect bgImgFramePos = bgImgFrame->getSize();
		int backgroundWidth = skillDescriptionFrame->getSize().w;
		int backgroundHeight = innerFrame->getSize().h;

		auto flourishTop = bgImgFrame->findImage("flourish top");
		flourishTop->pos.x = bgImgFramePos.w / 2 - flourishTop->pos.w / 2;
		auto flourishBottom = bgImgFrame->findImage("flourish bottom");
		flourishBottom->pos.x = bgImgFramePos.w / 2 - flourishBottom->pos.w / 2;
		flourishBottom->pos.y = backgroundHeight - flourishBottom->pos.h;
		flourishTop->disabled = true;
		flourishBottom->disabled = true;


		bgImgFramePos.x = innerFrame->getSize().w / 2 - backgroundWidth / 2;
		if ( skillSlideDirection != 0 )
		{
			bgImgFramePos.x += (skillSlideAmount) * slideTravelDistance;
		}
		bgImgFramePos.y = 0;
		bgImgFramePos.w = backgroundWidth;
		bgImgFramePos.h = backgroundHeight;
		bgImgFrame->setSize(bgImgFramePos);

		if ( backgroundWidth == 480 && backgroundHeight == 500 && *cvar_skillsheet_optimise )
		{
			for ( auto img : bgImgFrame->getImages() )
			{
				img->disabled = true;
			}
			auto mm = bgImgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE].c_str());
			mm->pos.x = 0;
			mm->pos.y = 0;
			mm->pos.w = backgroundWidth;
			mm->pos.h = backgroundHeight;
			mm->color = makeColorRGB(255, 255, 255);
			mm->path = ("*#images/ui/SkillSheet/UI_Skills_Full_480x500.png");
			mm->disabled = false;
		}
		else if ( backgroundWidth == 360 && backgroundHeight == 352 && *cvar_skillsheet_optimise )
		{
			for ( auto img : bgImgFrame->getImages() )
			{
				img->disabled = true;
			}
			auto mm = bgImgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE].c_str());
			mm->pos.x = 0;
			mm->pos.y = 0;
			mm->pos.w = backgroundWidth;
			mm->pos.h = backgroundHeight;
			mm->color = makeColorRGB(255, 255, 255);
			mm->path = ("*#images/ui/SkillSheet/UI_Skills_Full_360x352.png");
			mm->disabled = false;
		}
		else if ( backgroundWidth == 372 && backgroundHeight == 352 && *cvar_skillsheet_optimise )
		{
			for ( auto img : bgImgFrame->getImages() )
			{
				img->disabled = true;
			}
			auto mm = bgImgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE].c_str());
			mm->pos.x = 0;
			mm->pos.y = 0;
			mm->pos.w = backgroundWidth;
			mm->pos.h = backgroundHeight;
			mm->color = makeColorRGB(255, 255, 255);
			mm->path = ("*#images/ui/SkillSheet/UI_Skills_Full_372x352.png");
			mm->disabled = false;
		}
		else if ( backgroundWidth == 372 && backgroundHeight == 500 && *cvar_skillsheet_optimise )
		{
			for ( auto img : bgImgFrame->getImages() )
			{
				img->disabled = true;
			}
			auto mm = bgImgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE].c_str());
			mm->pos.x = 0;
			mm->pos.y = 0;
			mm->pos.w = backgroundWidth;
			mm->pos.h = backgroundHeight;
			mm->color = makeColorRGB(255, 255, 255);
			mm->path = ("*#images/ui/SkillSheet/UI_Skills_Full_372x500.png");
			mm->disabled = false;
		}
		else
		{
			for ( auto img : bgImgFrame->getImages() )
			{
				img->disabled = false;
			}
			flourishTop->disabled = false;
			flourishBottom->disabled = false;
			auto mm = bgImgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE].c_str());
			mm->path = "images/system/white.png";
			mm->color = makeColor(0, 0, 0, 255);
			imageResizeToContainer9x9(bgImgFrame, SDL_Rect{0, 12, backgroundWidth, backgroundHeight - 6 }, skillsheetEffectBackgroundImages);
		}
	}

	//DebugTimers.addTimePoint("skill", "post resize");

	sheetSize.x = skillFrame->getSize().w / 2 - sheetSize.w / 2;

	const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
	real_t setpointDiffX = fpsScale * std::max(.01, (1.0 - skillsFadeInAnimationY)) / 3.0;
	skillsFadeInAnimationY += setpointDiffX;
	skillsFadeInAnimationY = std::min(1.0, skillsFadeInAnimationY);

	auto fade = skillFrame->findImage("fade img");
	Uint8 r, g, b, a;
	getColor(fade->color, &r, &g, &b, &a);
	a = 128 * skillsFadeInAnimationY;
	fade->color = makeColor( r, g, b, a);
	fade->disabled = false;
	fade->pos.w = skillFrame->getSize().w;
	fade->pos.h = skillFrame->getSize().h;

	int baseY = (skillFrame->getSize().h / 2 - sheetSize.h / 2);
	sheetSize.y = -sheetSize.h + skillsFadeInAnimationY * (baseY + sheetSize.h);
	innerFrame->setOpacity(pow(skillsFadeInAnimationY, 2) * 100.0);
	innerFrame->setSize(sheetSize);

	auto slider = skillDescriptionFrame->findSlider("skill slider");
	if ( slider->isSelected() )
	{
		slider->deselect();
	}
	//slider->setHideSelectors(false);
	bool sliderDisabled = slider->isDisabled();

	auto titleText = innerFrame->findField("skill title txt");
	SDL_Rect titleTextPos = titleText->getSize();
	titleTextPos.x = skillDescriptionFrame->getSize().x + skillDescriptionFrame->getSize().w / 2 - titleTextPos.w / 2;
	titleText->setSize(titleTextPos);

	if ( skillSlideDirection != 0 )
	{
		const real_t fpsScale = (getFPSScale(144.0)); // ported from 144Hz
		real_t setpointDiff = std::max(0.1, 1.0 - abs(skillSlideAmount));
		skillSlideAmount += fpsScale * (setpointDiff / 5.0) * skillSlideDirection;
		if ( skillSlideAmount < -1.0 )
		{
			skillSlideAmount = -1.0;
		}
		if ( skillSlideAmount > 1.0 )
		{
			skillSlideAmount = 1.0;
		}
	}

	if ( oldSkillSlideAmount != skillSlideAmount )
	{
		reblitFrame = true;
	}

	int lowestSkillEntryY = 0;
	bool dpad_moved = false;
	if ( ::inputs.getVirtualMouse(player.playernum)->draw_cursor )
	{
		highlightedSkill = -1; // if using mouse, clear out the highlighted skill data to be updated below
	}
	int defaultHighlightedSkill = 0;
	if ( selectedSkill >= 0 && selectedSkill < NUMPROFICIENCIES )
	{
		defaultHighlightedSkill = selectedSkill;
	}
	bool closeSheetAction = false;
	if ( player.GUI.activeModule == player.GUI.MODULE_SKILLS_LIST )
	{
		if ( Input::inputs[player.playernum].binaryToggle("MenuUp")
			&& player.bControlEnabled && !gamePaused && !player.usingCommand() )
		{
			dpad_moved = true;
			Input::inputs[player.playernum].consumeBinaryToggle("MenuUp");
			if ( highlightedSkill < 0 || highlightedSkill >= NUMPROFICIENCIES )
			{
				highlightedSkill = defaultHighlightedSkill;
			}
			else if ( highlightedSkill < NUMPROFICIENCIES / 2 )
			{
				--highlightedSkill;
				if ( highlightedSkill < 0 )
				{
					highlightedSkill = (NUMPROFICIENCIES / 2) - 1;
				}
			}
			else
			{
				--highlightedSkill;
				if ( highlightedSkill < NUMPROFICIENCIES / 2 )
				{
					highlightedSkill = NUMPROFICIENCIES - 1;
				}
			}
			if ( selectedSkill != highlightedSkill )
			{
				selectSkill(highlightedSkill);
			}
		}
		if ( Input::inputs[player.playernum].binaryToggle("MenuDown")
			&& player.bControlEnabled && !gamePaused && !player.usingCommand() )
		{
			dpad_moved = true;
			Input::inputs[player.playernum].consumeBinaryToggle("MenuDown");
			if ( highlightedSkill < 0 || highlightedSkill >= NUMPROFICIENCIES )
			{
				highlightedSkill = defaultHighlightedSkill;
			}
			else if ( highlightedSkill < (NUMPROFICIENCIES / 2) )
			{
				++highlightedSkill;
				if ( highlightedSkill >= NUMPROFICIENCIES / 2 )
				{
					highlightedSkill = 0;
				}
			}
			else
			{
				++highlightedSkill;
				if ( highlightedSkill >= NUMPROFICIENCIES )
				{
					highlightedSkill = (NUMPROFICIENCIES / 2);
				}
			}
			if ( selectedSkill != highlightedSkill )
			{
				selectSkill(highlightedSkill);
			}
		}
		if ( Input::inputs[player.playernum].binaryToggle("MenuLeft") 
			&& player.bControlEnabled && !gamePaused && !player.usingCommand() )
		{
			dpad_moved = true;
			Input::inputs[player.playernum].consumeBinaryToggle("MenuLeft");
			if ( highlightedSkill < 0 || highlightedSkill >= NUMPROFICIENCIES )
			{
				highlightedSkill = defaultHighlightedSkill;
			}
			else if ( highlightedSkill < NUMPROFICIENCIES / 2 )
			{
				highlightedSkill += NUMPROFICIENCIES / 2;
			}
			else
			{
				highlightedSkill -= NUMPROFICIENCIES / 2;
			}
			if ( selectedSkill != highlightedSkill )
			{
				selectSkill(highlightedSkill);
			}
		}
		if ( Input::inputs[player.playernum].binaryToggle("MenuRight")
			&& player.bControlEnabled && !gamePaused && !player.usingCommand() )
		{
			dpad_moved = true;
			Input::inputs[player.playernum].consumeBinaryToggle("MenuRight");
			if ( highlightedSkill < 0 || highlightedSkill >= NUMPROFICIENCIES )
			{
				highlightedSkill = defaultHighlightedSkill;
			}
			else if ( highlightedSkill < NUMPROFICIENCIES / 2 )
			{
				highlightedSkill += NUMPROFICIENCIES / 2;
			}
			else
			{
				highlightedSkill -= NUMPROFICIENCIES / 2;
			}
			if ( selectedSkill != highlightedSkill )
			{
				selectSkill(highlightedSkill);
			}
		}

		if ( dpad_moved )
		{
			if ( skillSlideDirection != 0 )
			{
				if ( highlightedSkill >= 8 )
				{
					skillSlideDirection = 1;
				}
				else
				{
					skillSlideDirection = -1;
				}
			}
			inputs.getVirtualMouse(player.playernum)->draw_cursor = false;
			Player::soundMovement();
		}
		if ( Input::inputs[player.playernum].binaryToggle("MenuCancel")
			&& player.bControlEnabled && !gamePaused && !player.usingCommand() )
		{
			Input::inputs[player.playernum].consumeBinaryToggle("MenuCancel");
			closeSheetAction = true;
		}
	}
	bool mouseClickedOutOfBounds = false;
	if ( inputs.bPlayerUsingKeyboardControl(player.playernum) && Input::inputs[player.playernum].binaryToggle("MenuLeftClick") )
	{
		mouseClickedOutOfBounds = true;
	}

	//DebugTimers.addTimePoint("skill", "post inputs");

	if ( stats[player.playernum] && skillSheetData.skillEntries.size() > 0 )
	{
		bool skillDescAreaCapturesMouse = bgImgFrame->capturesMouse();
		if ( skillDescAreaCapturesMouse ) { mouseClickedOutOfBounds = false; }
		const int skillEntryStartY = bUseCompactSkillsView ? 28 : 38;
		const int entryHeight = bUseCompactSkillsView ? 36 : 40;
		SDL_Rect entryResizePos{ 0, skillEntryStartY, 0, entryHeight };
		bool capturedMouseOnEntry = false;
		for ( int i = 0; i < NUMPROFICIENCIES; ++i )
		{
			Frame* allSkillEntries = allSkillEntriesRight;
			if ( i >= 8 )
			{
				allSkillEntries = allSkillEntriesLeft;
				if ( i == 8 )
				{
					entryResizePos.y = skillEntryStartY;
				}
			}
			auto entry = skillSheetEntryFrames[player.playernum].entryFrames[i];

			if ( i >= skillSheetData.skillEntries.size() )
			{
				entry->setDisabled(true);
				break;
			}
			entry->setDisabled(false);
			SDL_Rect entryPos = entry->getSize();
			entryPos.y = entryResizePos.y;
			entryPos.h = entryResizePos.h;
			entry->setSize(entryPos);
			entryResizePos.y += entryResizePos.h;
			lowestSkillEntryY = std::max(lowestSkillEntryY, entryPos.y + entryPos.h);

			int proficiency = skillSheetData.skillEntries[i].skillId;
			bool updateSkillAssets = false;
			if ( !capturedMouseOnEntry )
			{
				const bool entryCapturesMouse = entry->capturesMouse();
				if ( entryCapturesMouse )
				{
					capturedMouseOnEntry = true;
					mouseClickedOutOfBounds = false;
					if ( ::inputs.getVirtualMouse(player.playernum)->draw_cursor
						&& entryCapturesMouse && !skillDescAreaCapturesMouse )
					{
						highlightedSkill = i;
						if ( skillSlideDirection != 0 )
						{
							if ( highlightedSkill >= 8 )
							{
								skillSlideDirection = 1;
							}
							else
							{
								skillSlideDirection = -1;
							}
						}
						if ( Input::inputs[player.playernum].binaryToggle("MenuLeftClick") && inputs.bPlayerUsingKeyboardControl(player.playernum) )
						{
							selectSkill(i);
							Input::inputs[player.playernum].consumeBinaryToggle("MenuLeftClick");
							Player::soundActivate();
						}
					}
				}
			}

			if ( !bSkillSheetEntryLoaded
				|| skillsheetCache[player.playernum][proficiency].proficiencyLevelCached != stats[player.playernum]->getModifiedProficiency(proficiency)
				|| skillsheetCache[player.playernum][proficiency].selectedSkill != selectedSkill
				|| skillsheetCache[player.playernum][proficiency].highlightedSkill != highlightedSkill )
			{
				if ( skillsheetCache[player.playernum][proficiency].proficiencyLevelCached != stats[player.playernum]->getModifiedProficiency(proficiency)
					|| skillsheetCache[player.playernum][proficiency].selectedSkill != selectedSkill )
				{
					reblitFrame = true;
				}
				skillsheetCache[player.playernum][proficiency].proficiencyLevelCached = stats[player.playernum]->getModifiedProficiency(proficiency);
				skillsheetCache[player.playernum][proficiency].selectedSkill = selectedSkill;
				skillsheetCache[player.playernum][proficiency].highlightedSkill = highlightedSkill;
				updateSkillAssets = true;
			}

			if ( updateSkillAssets )
			{
				auto skillLevel = entry->findField("skill level");
				char skillLevelText[32];
				snprintf(skillLevelText, sizeof(skillLevelText), "%d", stats[player.playernum]->getModifiedProficiency(proficiency));
				skillLevel->setText(skillLevelText);

				auto skillIconBg = entry->findImage("skill icon bg");
				auto skillIconFg = entry->findImage("skill icon fg");
				//skillIconFg->path = skillSheetData.skillEntries[i].skillIconPath;
				skillIconFg->disabled = true;
				auto statIcon = entry->findImage("stat icon");
				statIcon->disabled = true;

				auto selectorIcon = entry->findImage("selector img");
				selectorIcon->disabled = true;
				skillIconBg->disabled = false;

				if ( selectedSkill == i || highlightedSkill == i )
				{
					selectorIcon->disabled = false;
					if ( selectedSkill == i && highlightedSkill == i )
					{
						selectorIcon->path = (i < 8) ? "*#images/ui/SkillSheet/UI_Skills_SkillSelector100_01.png" : "*#images/ui/SkillSheet/UI_Skills_SkillSelector100R_01.png";
					}
					else if ( highlightedSkill == i )
					{
						selectorIcon->path = (i < 8) ? skillSheetData.highlightSkillImg : skillSheetData.highlightSkillImg_Right;
					}
					else if ( selectedSkill == i )
					{
						selectorIcon->path = (i < 8) ? skillSheetData.selectSkillImg : skillSheetData.selectSkillImg_Right;
					}
				}

				if ( stats[player.playernum]->getModifiedProficiency(proficiency) >= SKILL_LEVEL_LEGENDARY )
				{
					//skillIconFg->path = skillSheetData.skillEntries[i].skillIconPathLegend;
					skillLevel->setTextColor(skillSheetData.legendTextColor);
					if ( selectedSkill == i )
					{
						skillIconBg->path = skillSheetData.iconBgSelectedPathLegend;
					}
					else
					{
						skillIconBg->path = skillSheetData.iconBgPathLegend;
					}
				}
				else if ( stats[player.playernum]->getModifiedProficiency(proficiency) >= SKILL_LEVEL_EXPERT )
				{
					skillLevel->setTextColor(skillSheetData.expertTextColor);
					if ( selectedSkill == i )
					{
						skillIconBg->path = skillSheetData.iconBgSelectedPathExpert;
					}
					else
					{
						skillIconBg->path = skillSheetData.iconBgPathExpert;
					}
				}
				else if ( stats[player.playernum]->getModifiedProficiency(proficiency) >= SKILL_LEVEL_BASIC )
				{
					skillLevel->setTextColor(skillSheetData.noviceTextColor);
					if ( selectedSkill == i )
					{
						skillIconBg->path = skillSheetData.iconBgSelectedPathNovice;
					}
					else
					{
						skillIconBg->path = skillSheetData.iconBgPathNovice;
					}
				}
				else
				{
					skillLevel->setTextColor(skillSheetData.defaultTextColor);
					if ( selectedSkill == i )
					{
						skillIconBg->path = skillSheetData.iconBgSelectedPathDefault;
					}
					else
					{
						skillIconBg->path = skillSheetData.iconBgPathDefault;
						skillIconBg->disabled = true;
					}
				}
			}
			//statIcon->path = skillIconFg->path;
			//skillIconFg->path = "";
		}

		//DebugTimers.addTimePoint("skill", "post basic numbers");

		int lowestY = 0;

		SDL_Rect sliderPos = slider->getRailSize();
		sliderPos.x = skillDescriptionFrame->getSize().w - 34;
		sliderPos.h = skillDescriptionFrame->getSize().h - 8;
		slider->setRailSize(sliderPos);

		int sliderOffsetW = 0;
		if ( slider->isDisabled() )
		{
			int diff = (scrollOuterFramePos.w - (skillDescriptionFrame->getSize().w - 32));
			sliderOffsetW = -diff;
		}
		else
		{
			int diff = (scrollOuterFramePos.w - (slider->getRailSize().x - 4 - 16));
			sliderOffsetW = -diff;
		}
		if ( sliderOffsetW != 0 )
		{
			bSkillSheetEntryLoaded = false;
		}

		scrollOuterFramePos.w += sliderOffsetW;
		scrollAreaOuterFrame->setSize(scrollOuterFramePos);
		scrollAreaPos.w = scrollOuterFramePos.w;
		scrollArea->setSize(scrollAreaPos);

		if ( slider->isDisabled() )
		{
			scrollInertia = 0.0;
		}

		//DebugTimers.addTimePoint("skill", "post resize");

		if ( selectedSkill >= 0 && selectedSkill < skillSheetData.skillEntries.size() )
		{
			int proficiency = skillSheetData.skillEntries[selectedSkill].skillId;
			int proficiencyValue = stats[player.playernum]->getModifiedProficiency(proficiency);

			bool updateTitle = false;
			for ( auto& eff_t : skillSheetData.skillEntries[selectedSkill].effects )
			{
				if ( eff_t.effectUpdatedAtSkillLevel != proficiencyValue
					|| eff_t.effectUpdatedAtBaseSkillLevel != stats[player.playernum]->getProficiency(proficiency) )
				{
					updateTitle = true;
					break;
				}
			}

			if ( !bSkillSheetEntryLoaded || updateTitle )
			{
				auto skillLvlHeaderVal = scrollArea->findField("skill lvl header val");
				char skillLvl[128] = "";
				std::string skillLvlTitle = "";
				if ( proficiencyValue >= SKILL_LEVEL_LEGENDARY )
				{
					skillLvlTitle = Language::get(369);
				}
				else if ( proficiencyValue >= SKILL_LEVEL_MASTER )
				{
					skillLvlTitle = Language::get(368);
				}
				else if ( proficiencyValue >= SKILL_LEVEL_EXPERT )
				{
					skillLvlTitle = Language::get(367);
				}
				else if ( proficiencyValue >= SKILL_LEVEL_SKILLED )
				{
					skillLvlTitle = Language::get(366);
				}
				else if ( proficiencyValue >= SKILL_LEVEL_BASIC )
				{
					skillLvlTitle = Language::get(365);
				}
				else if ( proficiencyValue >= SKILL_LEVEL_NOVICE )
				{
					skillLvlTitle = Language::get(364);
				}
				else
				{
					skillLvlTitle = Language::get(363);
				}
				skillLvlTitle.erase(std::remove(skillLvlTitle.begin(), skillLvlTitle.end(), ' '), skillLvlTitle.end()); // trim whitespace
				int effectsModifier = stats[player.playernum]->getModifiedProficiency(proficiency) - stats[player.playernum]->getProficiency(proficiency);
				if ( proficiencyValue > 100 )
				{
					effectsModifier = std::max(effectsModifier - (proficiencyValue - 100), 0);
				}
				if ( effectsModifier > 0 )
				{
					snprintf(skillLvl, sizeof(skillLvl), "%s (%d + %d)", skillLvlTitle.c_str(), 
						stats[player.playernum]->getProficiency(proficiency), effectsModifier);
				}
				else if ( effectsModifier < 0 )
				{
					snprintf(skillLvl, sizeof(skillLvl), "%s (%d - %d)", skillLvlTitle.c_str(), 
						stats[player.playernum]->getProficiency(proficiency), abs(effectsModifier));
				}
				else
				{
					snprintf(skillLvl, sizeof(skillLvl), "%s (%d)", skillLvlTitle.c_str(), stats[player.playernum]->getModifiedProficiency(proficiency));
				}
				skillLvlHeaderVal->setText(skillLvl);

				SDL_Rect skillLvlHeaderValPos = skillLvlHeaderVal->getSize();
				skillLvlHeaderValPos.x += sliderOffsetW;
				skillLvlHeaderVal->setSize(skillLvlHeaderValPos);

				if ( !bSkillSheetEntryLoaded )
				{
					auto skillTitleTxt = innerFrame->findField("skill title txt");
					skillTitleTxt->setText(skillSheetData.skillEntries[selectedSkill].name.c_str());

					auto statTypeTxt = scrollArea->findField("stat type txt");
					auto statIcon = scrollArea->findImage("stat icon");
					statIcon->path = skillSheetData.skillEntries[selectedSkill].statIconPath;
					switch ( getStatForProficiency(proficiency) )
					{
						case STAT_STR:
							statTypeTxt->setText(Language::get(5300));
							break;
						case STAT_DEX:
							statTypeTxt->setText(Language::get(5301));
							break;
						case STAT_CON:
							statTypeTxt->setText(Language::get(5302));
							break;
						case STAT_INT:
							statTypeTxt->setText(Language::get(5303));
							break;
						case STAT_PER:
							statTypeTxt->setText(Language::get(5304));
							break;
						case STAT_CHR:
							statTypeTxt->setText(Language::get(5305));
							break;
						default:
							break;
					}

					SDL_Rect statTypeTxtPos = statTypeTxt->getSize();
					statTypeTxtPos.x += sliderOffsetW;
					statTypeTxt->setSize(statTypeTxtPos);
					statIcon->pos.x += sliderOffsetW;
				}
			}

			//DebugTimers.addTimePoint("skill", "process 1");

			int moveEffectsOffsetY = 0;
			const int actualFontHeight = 20;
			if ( !bSkillSheetEntryLoaded )
			{
				auto skillDescriptionTxt = scrollArea->findField("skill desc txt");
				auto skillDescriptionBgFrame = scrollArea->findFrame("skill desc bg frame");
				//Font* actualFont = Font::get(skillDescriptionTxt->getFont());
				SDL_Rect skillDescriptionTxtPos = skillDescriptionTxt->getSize();
				skillDescriptionTxtPos.w = scrollAreaPos.w;
				skillDescriptionTxt->setSize(skillDescriptionTxtPos);

				int txtHeightOld = skillDescriptionTxt->getNumTextLines() * actualFontHeight/*actualFont->height(true)*/;
				skillDescriptionTxt->setText(skillSheetData.skillEntries[selectedSkill].description.c_str());
				skillDescriptionTxt->reflowTextToFit(0);
				int txtHeightNew = skillDescriptionTxt->getNumTextLines() * actualFontHeight/*actualFont->height(true)*/;

				if ( txtHeightNew != txtHeightOld )
				{
					moveEffectsOffsetY = (txtHeightNew - txtHeightOld);
				}
				skillDescriptionBgFrame->setSize(SDL_Rect{skillDescriptionTxtPos.x, skillDescriptionTxtPos.y - 4,
					skillDescriptionTxtPos.w, txtHeightNew + 8 });
				lowestY = std::max(lowestY, skillDescriptionTxt->getSize().y + skillDescriptionTxt->getNumTextLines() * actualFontHeight/*actualFont->height(true)*/);

				std::string staticImgPath = "*#images/ui/SkillSheet/UI_Skills_Desc_Full_";
				staticImgPath += std::to_string(skillDescriptionBgFrame->getSize().w) + 'x' + std::to_string(skillDescriptionBgFrame->getSize().h) + ".png";

				auto staticImg = Image::get(staticImgPath.c_str());
				if ( staticImg && staticImg->getWidth() > 0 && *cvar_skillsheet_optimise )
				{
					for ( auto img : skillDescriptionBgFrame->getImages() )
					{
						img->disabled = true;
					}
					auto mm = skillDescriptionBgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE].c_str());
					mm->disabled = false;
					mm->path = staticImgPath;
					mm->pos = SDL_Rect{ 0, 0, skillDescriptionBgFrame->getSize().w, skillDescriptionBgFrame->getSize().h };
				}
				else
				{
					for ( auto img : skillDescriptionBgFrame->getImages() )
					{
						img->disabled = false;
					}
					auto mm = skillDescriptionBgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE].c_str());
					mm->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox_M_00.png";
					imageResizeToContainer9x9(skillDescriptionBgFrame,
						SDL_Rect{ 0, 0, skillDescriptionBgFrame->getSize().w, skillDescriptionBgFrame->getSize().h }, skillsheetEffectBackgroundImages);
				}
			}

			bool skillLVLUpdated = false;
			int previousEffectFrameHeight = 0;

			auto effectFrameBgImgTmp = scrollArea->findImage("effect frame bg tmp");
			effectFrameBgImgTmp->disabled = false;

			for ( int eff = 0; eff < 10; ++eff )
			{
				auto effectFrame = skillSheetEntryFrames[player.playernum].effectFrames[eff];
				if ( !effectFrame ) { continue; }

				effectFrame->setDisabled(true);

				if ( eff < skillSheetData.skillEntries[selectedSkill].effects.size() )
				{
					SDL_Rect effectFramePos = effectFrame->getSize();
					effectFramePos.w = scrollAreaPos.w;
					effectFrameBgImgTmp->pos.w = effectFramePos.w;

					if ( moveEffectsOffsetY != 0 )
					{
						effectFramePos.y += moveEffectsOffsetY;
					}
					effectFrame->setSize(effectFramePos);

					effectFrame->setDisabled(false);

					auto& effect_t = skillSheetData.skillEntries[selectedSkill].effects[eff];

					bool bEffUpdated = false;
					if ( (effect_t.bAllowRealtimeUpdate && (ticks % (std::max(TICKS_PER_SECOND, MAXPLAYERS * 10))) == (player.playernum * 10))
						|| effect_t.effectUpdatedAtSkillLevel != stats[player.playernum]->getModifiedProficiency(proficiency)
						|| effect_t.effectUpdatedAtBaseSkillLevel != stats[player.playernum]->getProficiency(proficiency)
						|| effect_t.effectUpdatedAtMonsterType != stats[player.playernum]->type
						|| effect_t.value == "" )
					{
						if ( effect_t.effectUpdatedAtSkillLevel != stats[player.playernum]->getModifiedProficiency(proficiency)
							|| effect_t.effectUpdatedAtBaseSkillLevel != stats[player.playernum]->getProficiency(proficiency) )
						{
							skillLVLUpdated = true;
							bEffUpdated = true;
						}
						else if ( effect_t.effectUpdatedAtMonsterType != stats[player.playernum]->type )
						{
							bEffUpdated = true;
						}
						effect_t.effectUpdatedAtSkillLevel = stats[player.playernum]->getModifiedProficiency(proficiency);
						effect_t.effectUpdatedAtBaseSkillLevel = stats[player.playernum]->getProficiency(proficiency);
						effect_t.effectUpdatedAtMonsterType = stats[player.playernum]->type;
						std::string oldValue = effect_t.value;
						effect_t.value = formatSkillSheetEffects(player.playernum, proficiency, effect_t.tag, effect_t.rawValue);
						if ( oldValue != effect_t.value )
						{
							bEffUpdated = true;
						}
						auto effectValFrame = effectFrame->findFrame("effect val frame");
						auto effectVal = effectValFrame->findField("effect val");
						effectVal->setText(effect_t.value.c_str());
						if ( effect_t.bAllowAutoResizeValue )
						{
							auto textGetValue = Text::get(effectVal->getLongestLine().c_str(), effectVal->getFont(),
								effectVal->getTextColor(), effectVal->getOutlineColor());
							effect_t.cachedWidth = textGetValue->getWidth();
						}
					}

					if ( !bSkillSheetEntryLoaded || bEffUpdated )
					{
						reblitFrame = true;

						auto effectValFrame = effectFrame->findFrame("effect val frame");
						auto effectVal = effectValFrame->findField("effect val");
						auto effectTxtFrame = effectFrame->findFrame("effect txt frame");
						auto effectTxt = effectTxtFrame->findField("effect txt");
						auto effectBgImgFrame = effectFrame->findFrame("effect val bg frame");
						effectTxt->setText(effect_t.title.c_str());

						{
							// adjust position to match width of container
							SDL_Rect effectTxtFramePos = effectTxtFrame->getSize();
							SDL_Rect effectValFramePos = effectValFrame->getSize();
							SDL_Rect effectBgImgFramePos = effectBgImgFrame->getSize();
							const auto& effectStartOffsetX = skillSheetData.skillEntries[selectedSkill].effectStartOffsetX;
							const auto& effectBackgroundOffsetX = skillSheetData.skillEntries[selectedSkill].effectBackgroundOffsetX;
							const auto& effectBackgroundWidth = skillSheetData.skillEntries[selectedSkill].effectBackgroundWidth;
							int valueCustomWidthOffset = effect_t.valueCustomWidthOffset;
							effectBgImgFramePos.x = effectFrame->getSize().w - effectStartOffsetX - effectBackgroundOffsetX - valueCustomWidthOffset;
							effectBgImgFramePos.w = effectBackgroundWidth + valueCustomWidthOffset;
							effectTxtFramePos.w = effectFrame->getSize().w - effectStartOffsetX - effectBackgroundOffsetX - valueCustomWidthOffset;
							effectValFramePos.x = effectFrame->getSize().w - effectStartOffsetX - valueCustomWidthOffset;
							effectValFramePos.w = effectStartOffsetX + valueCustomWidthOffset;
							if ( effect_t.bAllowAutoResizeValue 
								&& effect_t.cachedWidth > (effectValFramePos.w - effectVal->getSize().x - effectBackgroundOffsetX) )
							{
								int diff = (effect_t.cachedWidth - (effectValFramePos.w - effectVal->getSize().x - effectBackgroundOffsetX));
								effectBgImgFramePos.x -= diff;
								effectBgImgFramePos.w += diff;
								effectTxtFramePos.w -= diff;
								effectValFramePos.x -= diff;
								effectValFramePos.w += diff;
							}

							effectTxtFrame->setSize(effectTxtFramePos);
							effectValFrame->setSize(effectValFramePos);
							effectBgImgFrame->setSize(effectBgImgFramePos);
						}

						effectFramePos = effectFrame->getSize();

						//Font* effectTxtFont = Font::get(effectTxt->getFont());
						const int fontHeight = 20;
						//effectTxtFont->sizeText("_", nullptr, &fontHeight);
						int numEffectLines = effectTxt->getNumTextLines();
						int numEffectValLines = effectVal->getNumTextLines();
						int numEffectValBgLines = numEffectValLines;
						if ( numEffectLines > 1 || numEffectValLines > 1 )
						{
							if ( numEffectValLines <= 1 )
							{
								// single line value, only need lines of title
								effectFramePos.h = (fontHeight * std::max(1, numEffectLines)) + 8;
							}
							else
							{
								if ( numEffectLines <= numEffectValLines )
								{
									numEffectValLines += 1; // need more buffer area for the values as it is larger than title
									effectFramePos.h = (fontHeight * numEffectValLines) + 8;
								}
								else
								{
									effectFramePos.h = (fontHeight * numEffectLines) + 8;
								}
							}
						}
						else
						{
							// both title and value are 1 line, add .5 padding
							effectFramePos.h = (fontHeight) * 1.5 + 8;
						}
						if ( eff > 0 )
						{
							effectFramePos.y = previousEffectFrameHeight; // don't adjust first effect frame y pos
						}
						else
						{
							effectFrameBgImgTmp->pos.y = effectFramePos.y;
						}
						effectFrame->setSize(effectFramePos);

						{
							// adjust position to match height of container
							SDL_Rect effectTxtFramePos = effectTxtFrame->getSize();
							SDL_Rect effectValFramePos = effectValFrame->getSize();
							SDL_Rect effectBgImgFramePos = effectBgImgFrame->getSize();
							const int containerHeight = effectFramePos.h - 4;
							effectTxtFramePos.h = containerHeight;
							effectValFramePos.h = containerHeight;
							effectTxtFrame->setSize(effectTxtFramePos);
							effectValFrame->setSize(effectValFramePos);

							SDL_Rect effectTxtPos = effectTxt->getSize();
							effectTxtPos.h = containerHeight;
							effectTxt->setSize(effectTxtPos);
							SDL_Rect effectValPos = effectVal->getSize();
							effectValPos.h = containerHeight;
							effectVal->setSize(effectValPos);

							effectBgImgFramePos.h = (fontHeight * numEffectValBgLines) + 8;
							effectBgImgFramePos.y = (containerHeight / 2 - effectBgImgFramePos.h / 2);
							effectBgImgFrame->setSize(effectBgImgFramePos);

							auto effectFrameBgImg = effectFrame->findImage("effect frame bg highlight");
							effectFrameBgImg->pos = SDL_Rect{ 0, effectFrame->getSize().h - 2, effectFrame->getSize().w, 1 };
						}

						{
							// adjust inner background image elements

							std::string staticImgPath = "*#images/ui/SkillSheet/UI_Skills_Eff_Full_";
							staticImgPath += std::to_string(effectBgImgFrame->getSize().w) + 'x' + std::to_string(effectBgImgFrame->getSize().h) + ".png";

							auto staticImg = Image::get(staticImgPath.c_str());
							if ( staticImg && staticImg->getWidth() > 0 && *cvar_skillsheet_optimise )
							{
								for ( auto img : effectBgImgFrame->getImages() )
								{
									img->disabled = true;
								}
								auto mm = effectBgImgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE].c_str());
								mm->disabled = false;
								mm->path = staticImgPath;
								mm->color = makeColorRGB(255, 255, 255);
								mm->pos = SDL_Rect{ 0, 0, effectBgImgFrame->getSize().w, effectBgImgFrame->getSize().h };
							}
							else
							{
								for ( auto img : effectBgImgFrame->getImages() )
								{
									img->disabled = false;
								}
								auto mm = effectBgImgFrame->findImage(skillsheetEffectBackgroundImages[MIDDLE].c_str());
								mm->path = "*#images/ui/SkillSheet/UI_Skills_EffectBG_M00.png";
								mm->color = makeColor(51, 33, 26, 255);
								imageResizeToContainer9x9(effectBgImgFrame,
									SDL_Rect{ 0, 0, effectBgImgFrame->getSize().w, effectBgImgFrame->getSize().h }, skillsheetEffectBackgroundImages);
								/*static std::map<int, std::pair<int, int>> sizes;
								sizes[effectBgImgFrame->getSize().w + effectBgImgFrame->getSize().h * 1000] = std::make_pair(effectBgImgFrame->getSize().w, effectBgImgFrame->getSize().h);
								printlog("sizes");
								for ( auto & pair : sizes )
								{
									printlog("%d | %d", pair.second.first, pair.second.second);
								}*/
							}


						}
					}

					lowestY = std::max(lowestY, effectFrame->getSize().y + effectFrame->getSize().h);
					effectFrameBgImgTmp->pos.h = lowestY - effectFrameBgImgTmp->pos.y;
					// check marquee if needed
					//if ( false )
					//{
					//	auto textGetTitle = Text::get(effectTxt->getText(), effectTxt->getFont(),
					//		effectTxt->getTextColor(), effectTxt->getOutlineColor());
					//	int titleWidth = textGetTitle->getWidth();
					//	if ( numEffectLines > 1 )
					//	{
					//		auto textGetTitle = Text::get(effectTxt->getLongestLine().c_str(), effectTxt->getFont(),
					//			effectTxt->getTextColor(), effectTxt->getOutlineColor());
					//		titleWidth = textGetTitle->getWidth();
					//	}

					//	if ( ticks - openTick > TICKS_PER_SECOND * 2 )
					//	{
					//		bool doMarquee = false;
					//		doMarquee = doMarquee || (titleWidth > (effectTxt->getSize().x + effectTxtFrame->getSize().w));
					//		doMarquee = doMarquee || (valueWidth > (effectVal->getSize().x + effectValFrame->getSize().w));

					//		if ( doMarquee )
					//		{
					//			const real_t fpsScale = getFPSScale(60.0); // ported from 60Hz
					//			effect_t.marquee[player.playernum] += (.005 * fpsScale);
					//			//effect_t.marquee[player.playernum] = std::min(1.0, effect_t.marquee[player.playernum]);

					//			/*if ( effect_t.marqueeTicks[player.playernum] == 0 && effect_t.marquee[player.playernum] >= 1.0 )
					//			{
					//				effect_t.marqueeTicks[player.playernum] = ticks;
					//			}*/
					//			/*if ( effect_t.marqueeTicks[player.playernum] > 0 && (ticks - effect_t.marqueeTicks[player.playernum] > TICKS_PER_SECOND * 2) )
					//			{
					//				effect_t.marqueeTicks[player.playernum] = 0;
					//				effect_t.marquee[player.playernum] = 0.0;
					//			}*/
					//		}
					//	}
					//	SDL_Rect posTitle = effectTxt->getSize();
					//	int scrollTitleLength = titleWidth - effectTxtFrame->getSize().w;
					//	if ( titleWidth <= effectTxtFrame->getSize().w )
					//	{
					//		scrollTitleLength = 0;
					//		posTitle.x = 0;
					//		effect_t.marqueeCompleted[player.playernum] = false;
					//		effect_t.marquee[player.playernum] = 0.0;
					//		effect_t.marqueeTicks[player.playernum] = 0;
					//	}
					//	else
					//	{
					//		posTitle.x = std::max((int)(-effect_t.marquee[player.playernum] * 100), -scrollTitleLength);
					//		if ( posTitle.x == -scrollTitleLength )
					//		{
					//			if ( !effect_t.marqueeCompleted[player.playernum] )
					//			{
					//				effect_t.marqueeTicks[player.playernum] = ticks;
					//			}
					//			effect_t.marqueeCompleted[player.playernum] = true;
					//		}
					//		else
					//		{
					//			effect_t.marqueeCompleted[player.playernum] = false;
					//		}
					//	}
					//	//posTitle.x = -scrollTitleLength * effect_t.marquee[player.playernum];
					//	effectTxt->setSize(posTitle);

					//	SDL_Rect posValue = effectVal->getSize();
					//	int scrollValueLength = valueWidth - effectValFrame->getSize().w;
					//	if ( valueWidth <= effectValFrame->getSize().w )
					//	{
					//		scrollValueLength = 0;
					//	}
					//	posValue.x = -scrollValueLength * effect_t.marquee[player.playernum];
					//	effectVal->setSize(posValue);
					//}
					previousEffectFrameHeight = effectFrame->getSize().y + effectFrame->getSize().h;
					//DebugTimers.addTimePoint("skill", effectFrame->getName());
				}
			}

			//DebugTimers.addTimePoint("skill", "process fx 2");

			if ( false )
			{
				Uint32 lastMarqueeTick = 0;
				bool allMarqueeCompleted = true;
				for ( auto& effect_t : skillSheetData.skillEntries[selectedSkill].effects )
				{
					if ( effect_t.marquee[player.playernum] > 0.0 )
					{
						if ( !effect_t.marqueeCompleted[player.playernum] )
						{
							allMarqueeCompleted = false;
						}
						lastMarqueeTick = std::max(effect_t.marqueeTicks[player.playernum], lastMarqueeTick);
					}
				}
				if ( allMarqueeCompleted && lastMarqueeTick > 0 && ((ticks - lastMarqueeTick) > 2 * TICKS_PER_SECOND) )
				{
					for ( auto& effect_t : skillSheetData.skillEntries[selectedSkill].effects )
					{
						effect_t.marquee[player.playernum] = 0.0;
						effect_t.marqueeCompleted[player.playernum] = false;
						effect_t.marqueeTicks[player.playernum] = 0;
					}
					openTick = (ticks > TICKS_PER_SECOND) ? (ticks - TICKS_PER_SECOND) : ticks;
				}
			}

			// legend panel
			auto legendDivImg = scrollArea->findImage("legend div");
			legendDivImg->pos.x = scrollArea->getSize().w / 2 - legendDivImg->pos.w / 2;
			legendDivImg->pos.y = lowestY + 8;
			auto legendDivTxt = scrollArea->findField("legend div text");
			SDL_Rect legendDivTxtPos = legendDivTxt->getSize();
			legendDivTxtPos.x = legendDivImg->pos.x;
			legendDivTxtPos.w = legendDivImg->pos.w;
			legendDivTxtPos.y = legendDivImg->pos.y + legendDivImg->pos.h - 16;
			legendDivTxtPos.h = actualFontHeight/*actualFont->height(true)*/;
			legendDivTxt->setSize(legendDivTxtPos);
			lowestY = legendDivTxtPos.y + legendDivTxtPos.h;

			auto legendBackerImg = scrollArea->findImage("legend txt backer img");
			legendBackerImg->disabled = true;
			if ( proficiencyValue >= SKILL_LEVEL_LEGENDARY )
			{
				legendBackerImg->pos.x = scrollArea->getSize().w / 2 - legendBackerImg->pos.w / 2;
				legendBackerImg->pos.y = legendDivTxtPos.y + 6;
				legendBackerImg->disabled = false;
			}

			auto legendFrame = skillSheetEntryFrames[player.playernum].legendFrame;
			SDL_Rect legendPos = legendFrame->getSize();
			legendPos.y = lowestY;
			legendPos.w = scrollArea->getSize().w;
			legendFrame->setSize(legendPos);

			auto tl = legendFrame->findImage("top left img");
			auto tm = legendFrame->findImage("top img");
			auto tr = legendFrame->findImage("top right img");
			tm->pos.w = legendPos.w - tl->pos.w - tr->pos.w;
			tr->pos.x = legendPos.w - tr->pos.w;

			if ( !bSkillSheetEntryLoaded || skillLVLUpdated )
			{
				reblitFrame = true;
				Uint32 legendGoldColor = makeColor(230, 183, 20, 255);
				Uint32 legendRegularColor = makeColor(201, 162, 100, 255);

				auto legendText = legendFrame->findField("legend text");
				SDL_Rect legendTextPos = legendText->getSize();
				legendText->setText(skillSheetData.skillEntries[selectedSkill].legendaryDescription.c_str());
				legendTextPos.w = tm->pos.w;
				legendText->setSize(legendTextPos);
				legendText->reflowTextToFit(0);
				legendTextPos.h = legendText->getNumTextLines() * actualFontHeight;
				legendTextPos.y = tm->pos.y + tm->pos.h / 2 /*+ 2*/;
				legendTextPos.h += 4; // handle hanging chars
				legendText->setSize(legendTextPos);

				auto ml = legendFrame->findImage("middle left img");
				ml->pos.h = legendTextPos.h - tm->pos.h;
				auto mm = legendFrame->findImage("middle img");
				mm->pos.h = ml->pos.h;
				auto mr = legendFrame->findImage("middle right img");
				mr->pos.h = ml->pos.h;
				mm->pos.w = legendPos.w - ml->pos.w - mr->pos.w;
				mr->pos.x = legendPos.w - mr->pos.w;

				auto bl = legendFrame->findImage("bottom left img");
				bl->pos.y = ml->pos.y + ml->pos.h;
				auto bm = legendFrame->findImage("bottom img");
				bm->pos.y = bl->pos.y;
				auto br = legendFrame->findImage("bottom right img");
				br->pos.y = bl->pos.y;
				bm->pos.w = legendPos.w - bl->pos.w - br->pos.w;
				br->pos.x = legendPos.w - br->pos.w;


				legendPos.h = bl->pos.y + bl->pos.h - 4;
				legendFrame->setSize(legendPos);


				if ( proficiencyValue < SKILL_LEVEL_LEGENDARY )
				{
					legendDivTxt->setTextColor(legendRegularColor);
					legendText->setTextColor(legendRegularColor);
					
					std::string staticImgPath = "*#images/ui/SkillSheet/UI_Skills_LegendBox_Full_";
					staticImgPath += std::to_string(legendPos.w) + 'x' + std::to_string(legendPos.h) + ".png";

					auto staticImg = Image::get(staticImgPath.c_str());
					if ( staticImg && staticImg->getWidth() > 0 && *cvar_skillsheet_optimise )
					{
						for ( auto img : legendFrame->getImages() )
						{
							img->disabled = true;
						}
						mm->disabled = false;
						mm->path = staticImgPath;
						mm->color = makeColorRGB(255, 255, 255);
						mm->pos = SDL_Rect{ 0, 0, legendPos.w, legendPos.h };
					}
					else
					{
						for ( auto img : legendFrame->getImages() )
						{
							img->disabled = false;
						}
						mm->pos.x = 18;
						mm->pos.y = 18;
						tl->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox_TL_00.png";
						tm->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox_T_00.png";
						tr->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox_TR_00.png";

						ml->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox_ML_00.png";
						mm->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox_M_00.png";
						mr->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox_MR_00.png";

						bl->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox_BL_00.png";
						bm->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox_B_00.png";
						br->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox_BR_00.png";
					}
				}
				else
				{
					legendDivTxt->setTextColor(legendGoldColor);
					legendText->setTextColor(legendGoldColor);

					std::string staticImgPath = "*#images/ui/SkillSheet/UI_Skills_LegendBox100_Full_";
					staticImgPath += std::to_string(legendPos.w) + 'x' + std::to_string(legendPos.h) + ".png";

					auto staticImg = Image::get(staticImgPath.c_str());
					if ( staticImg && staticImg->getWidth() > 0 && *cvar_skillsheet_optimise )
					{
						for ( auto img : legendFrame->getImages() )
						{
							img->disabled = true;
						}
						mm->disabled = false;
						mm->path = staticImgPath;
						mm->color = makeColorRGB(255, 255, 255);
						mm->pos = SDL_Rect{ 0, 0, legendPos.w, legendPos.h };
					}
					else
					{
						for ( auto img : legendFrame->getImages() )
						{
							img->disabled = false;
						}
						mm->pos.x = 18;
						mm->pos.y = 18;
						tl->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox100_TL_00.png";
						tm->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox100_T_00.png";
						tr->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox100_TR_00.png";

						ml->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox100_ML_00.png";
						mm->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox100_M_00.png";
						mr->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox100_MR_00.png";

						bl->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox100_BL_00.png";
						bm->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox100_B_00.png";
						br->path = "*#images/ui/SkillSheet/UI_Skills_LegendBox100_BR_00.png";
					}
				}
			}

			lowestY = legendPos.y + legendPos.h;
			if ( lowestY < scrollAreaOuterFrame->getSize().h )
			{
				// shift the legend items as far to the bottom as possible.
				int offset = scrollAreaOuterFrame->getSize().h - lowestY;
				legendDivImg->pos.y += offset;
				legendBackerImg->pos.y += offset;
				legendDivTxt->setPos(legendDivTxt->getSize().x, legendDivTxt->getSize().y + offset);
				legendFrame->setPos(legendFrame->getSize().x, legendFrame->getSize().y + offset);
			}
			//lowestY += 4; // small buffer after legend box
		}

		auto oldScrollPercent = scrollPercent;
		if ( !slider->isDisabled() && player.bControlEnabled && !gamePaused && !player.usingCommand() )
		{
			if ( inputs.bPlayerUsingKeyboardControl(player.playernum) )
			{
				if ( Input::inputs[player.playernum].binaryToggle("MenuMouseWheelDownAlt") )
				{
					//Input::inputs[player.playernum].consumeBinaryToggle("MenuMouseWheelDownAlt");
					scrollInertia = std::min(scrollInertia + .05, .05);
				}
				if ( Input::inputs[player.playernum].binaryToggle("MenuMouseWheelUpAlt") )
				{
					//Input::inputs[player.playernum].consumeBinaryToggle("MenuMouseWheelUpAlt");
					scrollInertia = std::max(scrollInertia - .05, -.05);
				}
			}
			if ( Input::inputs[player.playernum].analog("MenuScrollDown") )
			{
				scrollInertia = 0.0;
				real_t delta = Input::inputs[player.playernum].analog("MenuScrollDown");
				scrollPercent = std::min(1.0, scrollPercent + .05 * (getFPSScale(60.0)) * delta);
				slider->setValue(scrollPercent * 100);
			}
			else if ( Input::inputs[player.playernum].analog("MenuScrollUp") )
			{
				scrollInertia = 0.0;
				real_t delta = Input::inputs[player.playernum].analog("MenuScrollUp");
				scrollPercent = std::max(0.0, scrollPercent -.05 * (getFPSScale(60.0)) * delta);
				slider->setValue(scrollPercent * 100);
			}
		}

		if ( abs(scrollInertia) > 0.0 )
		{
			scrollInertia *= .9;
			if ( abs(scrollInertia) < .01 )
			{
				scrollInertia = 0.0;
			}
			scrollPercent = std::min(1.0, std::max(scrollPercent + scrollInertia, 0.00));
			if ( scrollPercent >= 1.0 || scrollPercent <= 0.0 )
			{
				scrollInertia = 0.0;
			}
			slider->setValue(scrollPercent * 100);
		}

		scrollPercent = slider->getValue() / 100.0;
		scrollAreaPos = scrollArea->getSize();
		if ( lowestY > scrollAreaOuterFrame->getSize().h )
		{
			SDL_Rect actualSize = scrollArea->getActualSize();
			actualSize.y = (lowestY - scrollAreaOuterFrame->getSize().h) * scrollPercent;
			actualSize.h = scrollAreaPos.h;
			scrollArea->setActualSize(actualSize);
			
			scrollAreaPos.y = 0;
			slider->setDisabled(false);
		}
		else
		{
			SDL_Rect actualSize = scrollArea->getActualSize();
			actualSize.y = 0;
			scrollArea->setActualSize(actualSize);

			scrollAreaPos.y = 0;
			slider->setDisabled(true);
		}
		if ( scrollPercent != oldScrollPercent )
		{
			reblitFrame = true;
		}
		scrollArea->setSize(scrollAreaPos);

		if ( !slider->isDisabled() && inputs.getVirtualMouse(player.playernum)->draw_cursor )
		{
			sliderSkillsheetUpdateSelectorOnHighlight(player.playernum, slider);
		}
	}

	if ( oldHighlightedSkill != highlightedSkill )
	{
		reblitFrame = true;
	}

	//DebugTimers.addTimePoint("skill", "post display");

	bool drawGlyphs = !::inputs.getVirtualMouse(player.playernum)->draw_cursor && inputs.hasController(player.playernum);
	if ( auto promptBack = skillFrame->findField("prompt back txt") )
	{
		promptBack->setDisabled(!drawGlyphs);
		promptBack->setText(Language::get(4053));
		auto promptImg = skillFrame->findImage("prompt back img");
		promptImg->disabled = !drawGlyphs;
		SDL_Rect glyphPos = promptImg->pos;
		if ( auto textGet = Text::get(promptBack->getText(), promptBack->getFont(),
			promptBack->getTextColor(), promptBack->getOutlineColor()) )
		{
			SDL_Rect textPos = promptBack->getSize();
			textPos.w = textGet->getWidth();
			textPos.x = innerFrame->getSize().x + innerFrame->getSize().w - textPos.w - 16;
			textPos.y = innerFrame->getSize().y + allSkillEntriesLeft->getSize().y + lowestSkillEntryY + 4;
			if ( !bUseCompactSkillsView )
			{
				textPos.y -= 4;
			}
			promptBack->setSize(textPos);
			glyphPos.x = promptBack->getSize().x + promptBack->getSize().w - textGet->getWidth() - 4;
		}
		promptImg->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuCancel");
		Image* glyphImage = Image::get(promptImg->path.c_str());
		if ( glyphImage )
		{
			glyphPos.w = glyphImage->getWidth();
			glyphPos.h = glyphImage->getHeight();
			glyphPos.x -= glyphPos.w;
			glyphPos.y = promptBack->getSize().y + promptBack->getSize().h / 2 - glyphPos.h / 2;
			promptImg->pos = glyphPos;
		}
	}
	if ( auto promptScroll = skillFrame->findField("prompt scroll txt") )
	{
		promptScroll->setDisabled(!drawGlyphs);
		if ( bUseCompactSkillsView )
		{
			promptScroll->setText(Language::get(4063));
		}
		else
		{
			promptScroll->setText(Language::get(4062));
		}
		auto promptImg = skillFrame->findImage("prompt scroll img");
		promptImg->disabled = !drawGlyphs;
		SDL_Rect glyphPos = promptImg->pos;
		if ( auto textGet = Text::get(promptScroll->getText(), promptScroll->getFont(),
			promptScroll->getTextColor(), promptScroll->getOutlineColor()) )
		{
			SDL_Rect textPos = promptScroll->getSize();
			textPos.w = textGet->getWidth();
			if ( bUseCompactSkillsView )
			{
				textPos.x = innerFrame->getSize().x + 16;
				textPos.y = innerFrame->getSize().y + allSkillEntriesLeft->getSize().y + lowestSkillEntryY + 4;
			}
			else
			{
				textPos.x = innerFrame->getSize().x + innerFrame->getSize().w / 2 - textPos.w / 2;
				textPos.y = innerFrame->getSize().y + innerFrame->getSize().h - 8;
			}
			promptScroll->setSize(textPos);
		}
		promptImg->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuScrollDown");
		Image* glyphImage = Image::get(promptImg->path.c_str());
		if ( glyphImage )
		{
			SDL_Rect textPos = promptScroll->getSize();
			glyphPos.w = glyphImage->getWidth();
			glyphPos.h = glyphImage->getHeight();
			glyphPos.x = textPos.x;
			if ( !bUseCompactSkillsView ) // centred
			{
				glyphPos.x -= glyphPos.w / 2 + 2;
			}
			glyphPos.y = promptScroll->getSize().y + promptScroll->getSize().h / 2 - glyphPos.h / 2;
			promptImg->pos = glyphPos;

			textPos.x = glyphPos.x + glyphPos.w + 4;
			promptScroll->setSize(textPos);
		}
	}

	{
		// close btn
		auto closeBtn = innerFrame->findButton("close skills button");
		closeBtn->setDisabled(true);
		if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
		{
			closeBtn->setDisabled(!(skillsFadeInAnimationY >= 0.999));
			closeBtn->setInvisible(false);
			if ( !closeBtn->isDisabled() )
			{
				buttonSkillsheetUpdateSelectorOnHighlight(player.playernum, closeBtn);
			}
		}
		else
		{
			closeBtn->setDisabled(true);
			closeBtn->setInvisible(true);
			if ( closeBtn->isSelected() )
			{
				closeBtn->deselect();
			}
		}

		SDL_Rect closeBtnPos = closeBtn->getSize();
		SDL_Rect bgImgPos = bgImgFrame->getSize();
		closeBtnPos.x = bgImgPos.x + bgImgPos.w - 38;
		closeBtnPos.y = bgImgPos.y + 22;
		closeBtn->setSize(closeBtnPos);
	}

	if ( closeSheetAction || mouseClickedOutOfBounds )
	{
		if ( mouseClickedOutOfBounds )
		{
			Input::inputs[player.playernum].consumeBinaryToggle("MenuLeftClick");
			Input::inputs[player.playernum].consumeBindingsSharedWithBinding("MenuLeftClick");
			if ( inputs.bPlayerUsingKeyboardControl(player.playernum) )
			{
				mousestatus[SDL_BUTTON_LEFT] = 0;
			}
		}
		closeSkillSheet();
		Player::soundCancel();
		return;
	}

	{
		if ( !bSkillSheetEntryLoaded || reblitFrame || skillsFadeInAnimationY < 1.0 )
		{
			skillSheetEntryFrames[player.playernum].skillsFrame->setBlitDirty(true);
		}
	}

	if ( sliderDisabled != slider->isDisabled() )
	{
		// rerun this function
		processSkillSheet();
		//bSkillSheetEntryLoaded = false;
	}
	else
	{
		bSkillSheetEntryLoaded = true;
	}
	//DebugTimers.addTimePoint("skill", "end");
	//DebugTimers.addTimePoint("skill 1", "end");
}

void Player::Inventory_t::SpellPanel_t::openSpellPanel()
{
	if ( player.inventoryUI.spellFrame )
	{
		bool wasDisabled = player.inventoryUI.spellFrame->isDisabled();
		player.inventoryUI.spellFrame->setDisabled(false);
		if ( wasDisabled )
		{
			animx = 0.0;
			isInteractable = false;
			currentScrollRow = 0;
			scrollPercent = 0.0;
			scrollInertia = 0.0;
			bFirstTimeSnapCursor = false;
			if ( !inputs.getUIInteraction(player.playernum)->selectedItem )
			{
				Player::soundActivate();
			}
		}
		bOpen = true;
	}
}

void Player::Inventory_t::SpellPanel_t::closeSpellPanel()
{
	if ( player.inventoryUI.spellFrame )
	{
		player.inventoryUI.spellFrame->setDisabled(true);
	}
	animx = 0.0;
	isInteractable = false;
	currentScrollRow = 0;
	scrollPercent = 0.0;
	scrollInertia = 0.0;
	scrollAnimateX = scrollSetpoint;
	if ( bOpen 
		&& !(player.inventoryUI.bCompactView 
			&& player.hud.compactLayoutMode == Player::HUD_t::COMPACT_LAYOUT_CHARSHEET) )
	{
		if ( !inputs.getUIInteraction(player.playernum)->selectedItem )
		{
			Player::soundCancel();
		}
	}
	bOpen = false;
	bFirstTimeSnapCursor = false;
}

int Player::Inventory_t::SpellPanel_t::getNumSpellsToDisplayVertical() const
{
	if ( !player.bUseCompactGUIHeight() )
	{
		return kNumSpellsToDisplayVertical;
	}
	else
	{
		return kNumSpellsToDisplayVertical;
	}
}

void buttonSpellUpdateSelectorOnHighlight(const int player, Button* button)
{
	if ( button->isHighlighted() )
	{
		players[player]->GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_SPELLS);
		if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_SPELLS )
		{
			players[player]->GUI.activateModule(Player::GUI_t::MODULE_SPELLS);
		}
		SDL_Rect pos = button->getAbsoluteSize();
		// make sure to adjust absolute size to camera viewport
		pos.x -= players[player]->camera_virtualx1();
		pos.y -= players[player]->camera_virtualy1();
		players[player]->hud.setCursorDisabled(false);
		players[player]->hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, inputs.getVirtualMouse(player)->draw_cursor);
	}
}

void sliderSpellUpdateSelectorOnHighlight(const int player, Slider* slider)
{
	if ( slider->isHighlighted() )
	{
		players[player]->GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_SPELLS);
		if ( players[player]->GUI.activeModule != Player::GUI_t::MODULE_SPELLS )
		{
			players[player]->GUI.activateModule(Player::GUI_t::MODULE_SPELLS);
		}
		SDL_Rect pos = slider->getAbsoluteSize();
		// make sure to adjust absolute size to camera viewport
		pos.x -= players[player]->camera_virtualx1();
		pos.y -= players[player]->camera_virtualy1();
		players[player]->hud.setCursorDisabled(false);
		players[player]->hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, inputs.getVirtualMouse(player)->draw_cursor);
	}
}

int Player::Inventory_t::SpellPanel_t::heightOffsetWhenNotCompact = 0;
void Player::Inventory_t::SpellPanel_t::updateSpellPanel()
{
	Frame* spellFrame = player.inventoryUI.spellFrame;
	if ( !spellFrame ) { return; }

	if ( !spellFrame->isDisabled() && bOpen )
	{
		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
		real_t setpointDiffX = fpsScale * std::max(.01, (1.0 - animx)) / 2.0;
		animx += setpointDiffX;
		animx = std::min(1.0, animx);
		if ( animx >= .9999 )
		{
			if ( !bFirstTimeSnapCursor )
			{
				bFirstTimeSnapCursor = true;
				if ( !inputs.getUIInteraction(player.playernum)->selectedItem
					&& player.GUI.activeModule == Player::GUI_t::MODULE_SPELLS )
				{
					player.inventoryUI.warpMouseToSelectedSpell(nullptr, (Inputs::SET_CONTROLLER));
				}
			}
			isInteractable = true;
		}
	}
	else
	{
		animx = 0.0;
		isInteractable = false;
		scrollInertia = 0.0;
	}
	auto spellFramePos = spellFrame->getSize();
	if ( player.inventoryUI.inventoryPanelJustify == Player::PANEL_JUSTIFY_LEFT )
	{
		spellFramePos.x = -spellFramePos.w + animx * spellFramePos.w;
		if ( player.bUseCompactGUIWidth() )
		{
			if ( player.inventoryUI.slideOutPercent >= .0001 )
			{
				isInteractable = false;
			}
			spellFramePos.x -= player.inventoryUI.slideOutWidth * player.inventoryUI.slideOutPercent;
		}
	}
	else
	{
		spellFramePos.x = player.camera_virtualWidth() - animx * spellFramePos.w;
		if ( player.bUseCompactGUIWidth() )
		{
			if ( player.inventoryUI.slideOutPercent >= .0001 )
			{
				isInteractable = false;
			}
			spellFramePos.x -= -player.inventoryUI.slideOutWidth * player.inventoryUI.slideOutPercent;
		}
	}
	spellFrame->setSize(spellFramePos);

	auto baseFrame = spellFrame->findFrame("spell base");
	auto slider = baseFrame->findSlider("spell slider");
	auto spellSlotsFrame = spellFrame->findFrame("spell slots");
	auto baseBackgroundImg = baseFrame->findImage("spell base img");
	// handle height changing..
	{
		int frameHeight = kSpellListHeight;
		int totalFrameHeightChange = 0;
		if ( !player.bUseCompactGUIHeight() )
		{
			totalFrameHeightChange = heightOffsetWhenNotCompact;
		}
		spellFramePos.h = frameHeight + totalFrameHeightChange;
		spellFrame->setSize(spellFramePos);
		baseBackgroundImg->pos.y = totalFrameHeightChange;

		SDL_Rect spellBasePos = baseFrame->getSize();
		spellBasePos.h = spellFramePos.h;
		baseFrame->setSize(spellBasePos);

		int numGrids = (players[player.playernum]->inventoryUI.MAX_SPELLS_Y / getNumSpellsToDisplayVertical()) + 1;
		SDL_Rect spellSlotsFramePos = spellSlotsFrame->getSize();

		int heightChange = 0;
		if ( getNumSpellsToDisplayVertical() < kNumSpellsToDisplayVertical )
		{
			heightChange = player.inventoryUI.getSlotSize() * (kNumSpellsToDisplayVertical - getNumSpellsToDisplayVertical());
		}
		spellSlotsFramePos.y = 4 + heightChange + totalFrameHeightChange;
		spellSlotsFramePos.h = 242 - heightChange;
		spellSlotsFrame->setActualSize(SDL_Rect{ spellSlotsFrame->getActualSize().x, 
			spellSlotsFrame->getActualSize().y, 
			spellSlotsFrame->getActualSize().w, 
			(spellSlotsFramePos.h) * numGrids });
		spellSlotsFrame->setSize(spellSlotsFramePos);
		auto gridImg = spellSlotsFrame->findImage("grid img");
		gridImg->pos.y = kSpellListGridY;
		gridImg->pos.h = (spellSlotsFramePos.h) * numGrids;

		SDL_Rect sliderPos = slider->getRailSize();
		sliderPos.y = 50 + heightChange + totalFrameHeightChange;
		sliderPos.h = 192 - heightChange;
		slider->setRailSize(sliderPos);

		auto sliderCapTop = baseFrame->findImage("spell slider top");
		auto sliderCapBot = baseFrame->findImage("spell slider bot");
		sliderCapTop->pos.y = sliderPos.y;
		sliderCapBot->pos.y = sliderPos.y + sliderPos.h - sliderCapBot->pos.h;
	}

	auto skillBg = baseFrame->findImage("spell skill bg");
	skillBg->pos.x = 14;
	skillBg->pos.y = 6;

	int lowestItemY = getNumSpellsToDisplayVertical() - 1;
	for ( node_t* node = stats[player.playernum]->inventory.first; node != NULL; node = node->next )
	{
		Item* item = (Item*)node->element;
		if ( !item ) { continue; }
		if ( itemCategory(item) != SPELL_CAT ) { continue; }

		lowestItemY = std::max(lowestItemY, item->y);
	}

	int scrollAmount = std::max((lowestItemY + 1) - (getNumSpellsToDisplayVertical()), 0) * player.inventoryUI.getSlotSize();
	if ( scrollAmount == 0 )
	{
		slider->setDisabled(true);
	}
	else
	{
		if ( bOpen )
		{
			slider->setDisabled(false);
		}
		else
		{
			slider->setDisabled(true);
		}
	}

	currentScrollRow = scrollSetpoint / player.inventoryUI.getSlotSize();

	bool usingGamepad = inputs.hasController(player.playernum) && !inputs.getVirtualMouse(player.playernum)->draw_cursor;
	// close btn
	auto closeBtn = baseFrame->findButton("close spell button");
	auto closeGlyph = baseFrame->findImage("close spell glyph");
	closeBtn->setDisabled(true);
	SDL_Rect closeBtnPos = closeBtn->getSize();
	closeBtnPos.x = 166;
	closeBtnPos.y = 8;
	closeBtn->setSize(closeBtnPos);
	closeGlyph->disabled = true;
	if ( inputs.getVirtualMouse(player.playernum)->draw_cursor )
	{
		closeBtn->setDisabled(!isInteractable);
		if ( isInteractable )
		{
			buttonSpellUpdateSelectorOnHighlight(player.playernum, closeBtn);
		}
	}
	else if ( closeBtn->isSelected() )
	{
		closeBtn->deselect();
	}
	if ( closeBtn->isDisabled() && usingGamepad )
	{
		SDL_Rect closeBtnPos = closeBtn->getSize();
		closeBtnPos.x -= 10;
		closeBtn->setSize(closeBtnPos);

		closeGlyph->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuCancel");
		if ( auto imgGet = Image::get(closeGlyph->path.c_str()) )
		{
			closeGlyph->pos.w = imgGet->getWidth();
			closeGlyph->pos.h = imgGet->getHeight();
			closeGlyph->disabled = false;
		}
		closeGlyph->pos.x = closeBtn->getSize().x + closeBtn->getSize().w;
		if ( closeGlyph->pos.x % 2 == 1 )
		{
			++closeGlyph->pos.x;
		}
		closeGlyph->pos.y = closeBtn->getSize().y + closeBtn->getSize().h / 2 - closeGlyph->pos.w / 2;
		if ( closeGlyph->pos.y % 2 == 1 )
		{
			++closeGlyph->pos.y;
		}
	}

	auto skillIcon = baseFrame->findImage("spell skill icon");
	skillIcon->pos.x = skillBg->pos.x + 4;
	skillIcon->pos.y = skillBg->pos.y + 4;
	for ( auto& skillEntry : Player::SkillSheet_t::skillSheetData.skillEntries )
	{
		if ( skillEntry.skillId == PRO_MAGIC )
		{
			if ( skillCapstoneUnlocked(player.playernum, PRO_MAGIC) )
			{
				skillIcon->path = skillEntry.skillIconPathLegend.c_str();
			}
			else
			{
				skillIcon->path = skillEntry.skillIconPath.c_str();
			}
			break;
		}
	}

	if ( bOpen && isInteractable )
	{
		// do sliders
		if ( !slider->isDisabled() )
		{
			if ( !inputs.getUIInteraction(player.playernum)->selectedItem
				&& player.GUI.activeModule == Player::GUI_t::MODULE_SPELLS )
			{
				auto& input = Input::inputs[player.playernum];
				if ( !player.inventoryUI.itemTooltipDisplay.scrollable )
				{
					if ( inputs.bPlayerUsingKeyboardControl(player.playernum) )
					{
						if ( input.binaryToggle("MenuMouseWheelDown") )
						{
							scrollSetpoint = std::max(scrollSetpoint + player.inventoryUI.getSlotSize(), 0);
						}
						if ( input.binaryToggle("MenuMouseWheelUp") )
						{
							scrollSetpoint = std::max(scrollSetpoint - player.inventoryUI.getSlotSize(), 0);
						}
					}

					if ( input.consumeBinaryToggle("MenuScrollDown") )
					{
						scrollSetpoint = std::max(scrollSetpoint + player.inventoryUI.getSlotSize(), 0);
						if ( player.inventoryUI.cursor.queuedModule == Player::GUI_t::MODULE_SPELLS )
						{
							player.inventoryUI.cursor.queuedModule = Player::GUI_t::MODULE_NONE;
						}
					}
					else if ( input.consumeBinaryToggle("MenuScrollUp") )
					{
						scrollSetpoint = std::max(scrollSetpoint - player.inventoryUI.getSlotSize(), 0);
						if ( player.inventoryUI.cursor.queuedModule == Player::GUI_t::MODULE_SPELLS )
						{
							player.inventoryUI.cursor.queuedModule = Player::GUI_t::MODULE_NONE;
						}
					}
				}
			}
		}

		scrollSetpoint = std::min(scrollSetpoint, scrollAmount);
		currentScrollRow = scrollSetpoint / player.inventoryUI.getSlotSize();

		if ( abs(scrollSetpoint - scrollAnimateX) > 0.00001 )
		{
			isInteractable = false;
			player.inventoryUI.tooltipDelayTick = ticks + TICKS_PER_SECOND / 10;
			const real_t fpsScale = getFPSScale(60.0);
			real_t setpointDiff = 0.0;

			// slightly faster on gamepad
			static ConsoleVariable<float> cvar_spell_slider_speed("/spell_slider_speed", 1.f);
			const real_t factor = (3.0 * (*cvar_spell_slider_speed + (usingGamepad ? -.25f : 0.f)));
			if ( scrollSetpoint - scrollAnimateX > 0.0 )
			{
				setpointDiff = fpsScale * std::max(3.0, (scrollSetpoint - scrollAnimateX)) / factor;
			}
			else
			{
				setpointDiff = fpsScale * std::min(-3.0, (scrollSetpoint - scrollAnimateX)) / factor;
			}
			scrollAnimateX += setpointDiff;
			if ( setpointDiff > 0.0 )
			{
				scrollAnimateX = std::min((real_t)scrollSetpoint, scrollAnimateX);
			}
			else
			{
				scrollAnimateX = std::max((real_t)scrollSetpoint, scrollAnimateX);
			}
		}
		else
		{
			scrollAnimateX = scrollSetpoint;
		}

		if ( !inputs.getUIInteraction(player.playernum)->selectedItem 
			&& !player.GUI.isDropdownActive()
			&& player.GUI.bModuleAccessibleWithMouse(Player::GUI_t::MODULE_SPELLS)
			&& player.bControlEnabled && !gamePaused && !player.usingCommand() )
		{
			if ( Input::inputs[player.playernum].binaryToggle("MenuCancel") )
			{
				Input::inputs[player.playernum].consumeBinaryToggle("MenuCancel");
				player.GUI.activateModule(Player::GUI_t::MODULE_SPELLS);
				player.inventoryUI.cycleInventoryTab();
				player.inventoryUI.spellPanel.closeSpellPanel();
			}
		}
	}

	if ( scrollAmount > 0 )
	{
		if ( !slider->isDisabled() && !usingGamepad && isInteractable )
		{
			sliderSpellUpdateSelectorOnHighlight(player.playernum, slider);
		}
		if ( slider->isCurrentlyPressed() )
		{
			auto val = slider->getValue() / 100.0;
			int animX = val * scrollAmount;
			animX /= player.inventoryUI.getSlotSize();
			animX *= player.inventoryUI.getSlotSize();

			scrollSetpoint = animX;
			scrollSetpoint = std::min(scrollSetpoint, scrollAmount);
		}
		else
		{
			slider->setValue((scrollAnimateX / scrollAmount) * 100.0);
		}
	}
	else
	{
		slider->setValue(0.0);
	}

	SDL_Rect actualSize = spellSlotsFrame->getActualSize();
	actualSize.y = scrollAnimateX;
	spellSlotsFrame->setActualSize(actualSize);
}

bool Player::Inventory_t::SpellPanel_t::isSlotVisible(int x, int y) const
{
	if ( player.inventoryUI.spellFrame )
	{
		if ( player.inventoryUI.spellFrame->isDisabled() )
		{
			return false;
		}
	}
	int lowerY = currentScrollRow;
	int upperY = currentScrollRow + getNumSpellsToDisplayVertical() - 1;

	if ( y >= lowerY && y <= upperY )
	{
		return true;
	}
	return false;
}

bool Player::Inventory_t::SpellPanel_t::isItemVisible(Item* item) const
{
	if ( !item ) { return false; }
	return isSlotVisible(item->x, item->y);
}

void Player::Inventory_t::SpellPanel_t::scrollToSlot(int x, int y, bool instantly)
{
	int lowerY = currentScrollRow;
	int upperY = currentScrollRow + getNumSpellsToDisplayVertical() - 1;

	if ( y >= lowerY && y <= upperY )
	{
		// no work to do.
		return;
	}

	int lowestItemY = getNumSpellsToDisplayVertical() - 1;
	for ( node_t* node = stats[player.playernum]->inventory.first; node != NULL; node = node->next )
	{
		Item* item = (Item*)node->element;
		if ( !item ) { continue; }
		if ( itemCategory(item) != SPELL_CAT ) { continue; }

		lowestItemY = std::max(lowestItemY, item->y);
	}
	int maxScroll = std::max((lowestItemY + 1) - (getNumSpellsToDisplayVertical()), 0) * player.inventoryUI.getSlotSize();
	
	int scrollAmount = 0;
	if ( y < lowerY )
	{
		scrollAmount = (y) * player.inventoryUI.getSlotSize();
		//scrollAmount += scrollSetpoint;
	}
	else if ( y > upperY )
	{
		scrollAmount = (y - upperY) * player.inventoryUI.getSlotSize();
		scrollAmount += scrollSetpoint;
	}
	scrollAmount = std::min(scrollAmount, maxScroll);

	scrollSetpoint = scrollAmount;
	if ( instantly )
	{
		scrollAnimateX = scrollSetpoint;
	}
	currentScrollRow = scrollSetpoint / player.inventoryUI.getSlotSize();
	if ( abs(scrollSetpoint - scrollAnimateX) > 0.00001 )
	{
		isInteractable = false;
	}
}

void Player::Inventory_t::ChestGUI_t::openChest()
{
	if ( player.inventoryUI.chestFrame )
	{
		bool wasDisabled = player.inventoryUI.chestFrame->isDisabled();
		player.inventoryUI.chestFrame->setDisabled(false);
		if ( wasDisabled )
		{
			animx = 0.0;
			isInteractable = false;
			currentScrollRow = 0;
			scrollPercent = 0.0;
			scrollInertia = 0.0;
			bFirstTimeSnapCursor = false;
		}
		/*if ( player.inventoryUI.getSelectedChestX() < 0 || player.inventoryUI.getSelectedChestX() >= MAX_CHEST_X
			|| player.inventoryUI.getSelectedChestY() < 0 || player.inventoryUI.getSelectedChestY() >= MAX_CHEST_Y )*/
		{
			player.inventoryUI.selectChestSlot(0, 0); // always select first slot
		}
		player.hud.compactLayoutMode = Player::HUD_t::COMPACT_LAYOUT_INVENTORY;
		player.inventory_mode = INVENTORY_MODE_ITEM;
		bOpen = true;
	}
	if ( inputs.getUIInteraction(player.playernum)->selectedItem )
	{
		inputs.getUIInteraction(player.playernum)->selectedItem = nullptr;
		inputs.getUIInteraction(player.playernum)->toggleclick = false;
	}
	inputs.getUIInteraction(player.playernum)->selectedItemFromChest = 0;
}

bool Player::Inventory_t::ChestGUI_t::isChestSelected()
{
	if ( !bOpen )
	{
		return false;
	}

	if ( player.GUI.activeModule == Player::GUI_t::MODULE_CHEST )
	{
		if ( selectedChestSlotX >= 0 && selectedChestSlotX < MAX_CHEST_X
			&& selectedChestSlotY >= 0 && selectedChestSlotY < MAX_CHEST_Y )
		{
			return true;
		}
	}

	return false;
}

void Player::Inventory_t::ChestGUI_t::closeChest()
{
	if ( player.inventoryUI.chestFrame )
	{
		player.inventoryUI.chestFrame->setDisabled(true);
	}
	animx = 0.0;
	isInteractable = false;
	currentScrollRow = 0;
	scrollPercent = 0.0;
	scrollInertia = 0.0;
	scrollAnimateX = scrollSetpoint;
	bOpen = false;
	bFirstTimeSnapCursor = false;
	if ( inputs.getUIInteraction(player.playernum)->selectedItemFromChest > 0 )
	{
		inputs.getUIInteraction(player.playernum)->selectedItem = nullptr;
		inputs.getUIInteraction(player.playernum)->toggleclick = false;
	}
	inputs.getUIInteraction(player.playernum)->selectedItemFromChest = 0;
	if ( player.GUI.dropdownMenu.currentName == "chest_interact" )
	{
		player.GUI.dropdownMenu.close();
	}
	if ( players[player.playernum]->GUI.activeModule == Player::GUI_t::MODULE_CHEST
		&& !players[player.playernum]->shootmode )
	{
		// reset to inventory mode if still hanging in chest GUI
		players[player.playernum]->hud.compactLayoutMode = Player::HUD_t::COMPACT_LAYOUT_INVENTORY;
		players[player.playernum]->GUI.activateModule(Player::GUI_t::MODULE_INVENTORY);
		if ( !inputs.getVirtualMouse(player.playernum)->draw_cursor )
		{
			players[player.playernum]->GUI.warpControllerToModule(false);
		}
	}
}

int Player::Inventory_t::ChestGUI_t::getNumItemsToDisplayVertical() const
{
	return kNumItemsToDisplayVertical;
}

void Player::Inventory_t::selectChestSlot(const int x, const int y)
{
	chestGUI.selectedChestSlotX = x;
	chestGUI.selectedChestSlotY = y;
}

const bool Player::Inventory_t::isItemFromChest(Item* item) const
{
	if ( !item )
	{
		return false;
	}

	if ( !openedChest[player.playernum] || !chestGUI.bOpen )
	{
		return false;
	}

	list_t* chest_inventory = nullptr;
	if ( multiplayer == CLIENT )
	{
		chest_inventory = &chestInv[player.playernum];
	}
	else if ( openedChest[player.playernum]->children.first && openedChest[player.playernum]->children.first->element )
	{
		chest_inventory = (list_t*)openedChest[player.playernum]->children.first->element;
	}

	if ( item->node && item->node->list == chest_inventory )
	{
		return true;
	}
	return false;
}

int Player::Inventory_t::ChestGUI_t::heightOffsetWhenNotCompact = 0;
void Player::Inventory_t::ChestGUI_t::updateChest()
{
	updateChestInventory(player.playernum);

	Frame* chestFrame = player.inventoryUI.chestFrame;
	if ( !chestFrame ) { return; }

	auto baseFrame = chestFrame->findFrame("chest base");
	auto grabAllBtn = baseFrame->findButton("grab all button");
	auto closeBtn = baseFrame->findButton("close chest button");
	if ( !chestFrame->isDisabled() && bOpen )
	{
		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
		real_t setpointDiffX = fpsScale * std::max(.01, (1.0 - animx)) / 2.0;
		animx += setpointDiffX;
		animx = std::min(1.0, animx);
		if ( animx >= .9999 )
		{
			if ( !bFirstTimeSnapCursor )
			{
				bFirstTimeSnapCursor = true;
				if ( !inputs.getUIInteraction(player.playernum)->selectedItem
					&& player.GUI.activeModule == Player::GUI_t::MODULE_CHEST )
				{
					player.inventoryUI.warpMouseToSelectedChestSlot(nullptr, (Inputs::SET_CONTROLLER));
				}
			}
			isInteractable = true;
		}
	}
	else
	{
		animx = 0.0;
		isInteractable = false;
		scrollInertia = 0.0;
	}

	auto chestFramePos = chestFrame->getSize();
	auto baseBackgroundImg = baseFrame->findImage("chest base img");
	auto lidBackgroundImg = baseFrame->findImage("chest lid img");

	int playercount = 0;
	for ( int c = 0; c < MAXPLAYERS; ++c ) {
		if ( !client_disconnected[c] && players[c]->isLocalPlayer() ) {
			++playercount;
		}
	}

	if ( player.inventoryUI.inventoryPanelJustify == Player::PANEL_JUSTIFY_LEFT )
	{
		if ( !player.inventoryUI.bCompactView )
		{
			const int fullWidth = chestFramePos.w + 210; // inventory width 210
			chestFramePos.x = -chestFramePos.w + animx * fullWidth;
			if ( player.bUseCompactGUIWidth() )
			{
				if ( player.inventoryUI.slideOutPercent >= .0001 )
				{
					isInteractable = false;
				}
				chestFramePos.x -= player.inventoryUI.slideOutWidth * player.inventoryUI.slideOutPercent;
			}
		}
		else
		{
			if ( player.bAlignGUINextToInventoryCompact() )
			{
				const int fullWidth = chestFramePos.w + 210; // inventory width 210
				chestFramePos.x = -chestFramePos.w + animx * fullWidth;
			}
			else
			{
				chestFramePos.x = player.camera_virtualWidth() - animx * chestFramePos.w;
			}
			if ( player.bUseCompactGUIWidth() )
			{
				if ( player.inventoryUI.slideOutPercent >= .0001 )
				{
					isInteractable = false;
				}
				chestFramePos.x -= -player.inventoryUI.slideOutWidth * player.inventoryUI.slideOutPercent;
			}
		}
	}
	else if ( player.inventoryUI.inventoryPanelJustify == Player::PANEL_JUSTIFY_RIGHT )
	{
		if ( !player.inventoryUI.bCompactView )
		{
			chestFramePos.x = player.camera_virtualWidth() - animx * chestFramePos.w * 2;
			if ( player.bUseCompactGUIWidth() )
			{
				if ( player.inventoryUI.slideOutPercent >= .0001 )
				{
					isInteractable = false;
				}
				chestFramePos.x -= -player.inventoryUI.slideOutWidth * player.inventoryUI.slideOutPercent;
			}
		}
		else
		{
			if ( player.bAlignGUINextToInventoryCompact() )
			{
				const int fullWidth = chestFramePos.w + 210; // inventory width 210
				chestFramePos.x = player.camera_virtualWidth() - animx * fullWidth;
			}
			else
			{
				chestFramePos.x = -chestFramePos.w + animx * chestFramePos.w;
			}
			if ( player.bUseCompactGUIWidth() )
			{
				if ( player.inventoryUI.slideOutPercent >= .0001 )
				{
					isInteractable = false;
				}
				chestFramePos.x -= player.inventoryUI.slideOutWidth * player.inventoryUI.slideOutPercent;
			}
		}
	}
	chestFrame->setSize(chestFramePos);

	bool drawGlyphs = !::inputs.getVirtualMouse(player.playernum)->draw_cursor;
	if ( !drawGlyphs )
	{
		closeBtn->setInvisible(false);
		grabAllBtn->setInvisible(false);
		grabAllBtn->setDisabled(!isInteractable);
		closeBtn->setDisabled(!isInteractable);
	}
	else
	{
		closeBtn->setInvisible(false);
		grabAllBtn->setInvisible(false);
		grabAllBtn->setDisabled(!isInteractable);
		closeBtn->setDisabled(!isInteractable);
	}

	//auto slider = baseFrame->findSlider("chest slider");
	auto chestSlotsFrame = chestFrame->findFrame("chest slots");

	auto promptBack = baseFrame->findField("prompt back txt");
	promptBack->setDisabled(true);
	auto promptBackImg = baseFrame->findImage("prompt back img");
	promptBackImg->disabled = !drawGlyphs || player.inventoryUI.spellPanel.bOpen;
	auto promptGrab = baseFrame->findField("prompt grab txt");
	promptGrab->setDisabled(true);
	auto promptGrabImg = baseFrame->findImage("prompt grab img");
	promptGrabImg->disabled = !drawGlyphs || player.inventoryUI.spellPanel.bOpen;
	// handle height changing..
	{
		int frameHeight = 236 + 16;
		if ( !player.bUseCompactGUIHeight() && !player.bUseCompactGUIWidth() )
		{
			chestFramePos.y = 130;
		}
		else
		{
			chestFramePos.y = 0;
		}
		chestFramePos.h = frameHeight;
		chestFrame->setSize(chestFramePos);
		baseBackgroundImg->pos.y = 16 + 48;
		lidBackgroundImg->pos.y = baseBackgroundImg->pos.y - lidBackgroundImg->pos.h + 2;
		SDL_Rect chestBasePos = baseFrame->getSize();
		chestBasePos.h = chestFramePos.h;
		baseFrame->setSize(chestBasePos);

		int numGrids = (players[player.playernum]->inventoryUI.MAX_CHEST_Y / getNumItemsToDisplayVertical()) + 1;
		SDL_Rect chestSlotsFramePos = chestSlotsFrame->getSize();

		const int gridHeight = 120 + 2; // 120px is grid img, plus 2px to tile the image for bottom border.

		int heightChange = 0;
		if ( getNumItemsToDisplayVertical() < kNumItemsToDisplayVertical )
		{
			heightChange = player.inventoryUI.getSlotSize() * (kNumItemsToDisplayVertical - getNumItemsToDisplayVertical());
		}
		chestSlotsFramePos.y = 4 + chestBaseImgBorderTopHeight + heightChange + 48;
		chestSlotsFramePos.h = gridHeight - heightChange;
		chestSlotsFrame->setActualSize(SDL_Rect{ chestSlotsFrame->getActualSize().x,
			chestSlotsFrame->getActualSize().y,
			chestSlotsFrame->getActualSize().w,
			(chestSlotsFramePos.h) * numGrids });
		chestSlotsFrame->setSize(chestSlotsFramePos);
		//auto gridImg = chestSlotsFrame->findImage("grid img");
		//gridImg->pos.y = 0;
		//gridImg->pos.h = (chestSlotsFramePos.h) * numGrids;

		/*SDL_Rect sliderPos = slider->getRailSize();
		sliderPos.y = 8 + heightChange + totalFrameHeightChange;
		sliderPos.h = 234 - heightChange;
		slider->setRailSize(sliderPos);*/

		// align title
		auto titleText = baseFrame->findField("title txt");
		auto titlePos = titleText->getSize();
		titlePos.y = baseBackgroundImg->pos.y - 24;
		titlePos.x = baseBackgroundImg->pos.x + baseBackgroundImg->pos.w / 2 - titlePos.w / 2;
		titleText->setSize(titlePos);

		chestFrame->setSize(chestFramePos);
		baseFrame->setSize(chestBasePos);

		// align buttons
		auto grabAllBtnPos = grabAllBtn->getSize();
		auto bg = baseFrame->findImage("chest base img");
		grabAllBtnPos.y = bg->pos.y + bg->pos.h - 4 - grabAllBtnPos.h - 4;
		grabAllBtnPos.x = bg->pos.x + bg->pos.w / 2 - grabAllBtnPos.w / 2;
		grabAllBtn->setSize(grabAllBtnPos);

		auto closeBtnPos = closeBtn->getSize();
		closeBtnPos.x = bg->pos.x + bg->pos.w - closeBtnPos.w - 8 - 4;
		closeBtnPos.y = titlePos.y + titlePos.h / 2 - closeBtnPos.h / 2;
		closeBtn->setSize(closeBtnPos);


		if ( player.GUI.bModuleAccessibleWithMouse(Player::GUI_t::MODULE_CHEST)
			&& inputs.getVirtualMouse(player.playernum)->draw_cursor && !drawGlyphs )
		{
			if ( !grabAllBtn->isDisabled() && grabAllBtn->isHighlighted() )
			{
				player.GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_CHEST);
				if ( player.GUI.activeModule != Player::GUI_t::MODULE_CHEST )
				{
					player.GUI.activateModule(Player::GUI_t::MODULE_CHEST);
				}
				SDL_Rect pos = grabAllBtn->getAbsoluteSize();
				// make sure to adjust absolute size to camera viewport
				pos.x -= player.camera_virtualx1();
				pos.y -= player.camera_virtualy1();
				player.hud.setCursorDisabled(false);
				player.hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, inputs.getVirtualMouse(player.playernum)->draw_cursor);
			}
			if ( !closeBtn->isDisabled() && closeBtn->isHighlighted() )
			{
				player.GUI.setHoveringOverModuleButton(Player::GUI_t::MODULE_CHEST);
				if ( player.GUI.activeModule != Player::GUI_t::MODULE_CHEST )
				{
					player.GUI.activateModule(Player::GUI_t::MODULE_CHEST);
				}
				SDL_Rect pos = closeBtn->getAbsoluteSize();
				// make sure to adjust absolute size to camera viewport
				pos.x -= player.camera_virtualx1();
				pos.y -= player.camera_virtualy1();
				player.hud.setCursorDisabled(false);
				player.hud.updateCursorAnimation(pos.x - 1, pos.y - 1, pos.w, pos.h, inputs.getVirtualMouse(player.playernum)->draw_cursor);
			}
		}

		int furthestLeftPrompt = xres;
		if ( !promptBack->isDisabled() )
		{
			promptBack->setText(Language::get(4053));
			SDL_Rect glyphPos = promptBackImg->pos;
			if ( auto textGet = Text::get(promptBack->getText(), promptBack->getFont(),
				promptBack->getTextColor(), promptBack->getOutlineColor()) )
			{
				SDL_Rect textPos = promptBack->getSize();
				textPos.w = textGet->getWidth();
				textPos.x = bg->pos.x + bg->pos.w - textPos.w - 8;
				textPos.y = bg->pos.y + bg->pos.h - textPos.h + 8 + 8;
				promptBack->setSize(textPos);
				glyphPos.x = promptBack->getSize().x + promptBack->getSize().w - textGet->getWidth() - 4;
			}
			promptBackImg->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuCancel");
			Image* glyphImage = Image::get(promptBackImg->path.c_str());
			if ( glyphImage )
			{
				glyphPos.w = glyphImage->getWidth();
				glyphPos.h = glyphImage->getHeight();
				glyphPos.x -= glyphPos.w;
				furthestLeftPrompt = std::min(glyphPos.x + glyphPos.w / 2, furthestLeftPrompt);
				glyphPos.y = promptBack->getSize().y + promptBack->getSize().h / 2 - glyphPos.h / 2;
				promptBackImg->pos = glyphPos;
			}
		}
		else if ( drawGlyphs )
		{
			SDL_Rect glyphPos = closeBtn->getSize();
			//glyphPos.x += glyphPos.w / 2;
			promptBackImg->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuCancel");
			promptBackImg->ontop = true;
			Image* glyphImage = Image::get(promptBackImg->path.c_str());
			if ( glyphImage )
			{
				glyphPos.w = glyphImage->getWidth();
				glyphPos.h = glyphImage->getHeight();
				glyphPos.x -= glyphPos.w;
				glyphPos.x += 2;
				glyphPos.y += 2;
				promptBackImg->pos = glyphPos;
			}
		}
		if ( !promptGrab->isDisabled() )
		{
			promptGrab->setText(Language::get(4091));
			auto promptGrabImg = baseFrame->findImage("prompt grab img");
			SDL_Rect glyphPos = promptGrabImg->pos;
			if ( auto textGet = Text::get(promptGrab->getText(), promptGrab->getFont(),
				promptGrab->getTextColor(), promptGrab->getOutlineColor()) )
			{
				SDL_Rect textPos = promptGrab->getSize();
				textPos.w = textGet->getWidth();
				textPos.x = bg->pos.x + bg->pos.w - textPos.w - 8;
				textPos.y = promptBack->getSize().y - textPos.h + 2;
				promptGrab->setSize(textPos);
				glyphPos.x = promptGrab->getSize().x + promptGrab->getSize().w - textGet->getWidth() - 4;
			}
			promptGrabImg->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuPageRightAlt");
			Image* glyphImage = Image::get(promptGrabImg->path.c_str());
			if ( glyphImage )
			{
				glyphPos.w = glyphImage->getWidth();
				glyphPos.h = glyphImage->getHeight();
				glyphPos.x -= glyphPos.w;
				furthestLeftPrompt = std::min(glyphPos.x + glyphPos.w / 2, furthestLeftPrompt);
				glyphPos.y = promptGrab->getSize().y + promptGrab->getSize().h / 2 - glyphPos.h / 2;
				promptGrabImg->pos = glyphPos;

				if ( furthestLeftPrompt < promptGrabImg->pos.x + promptGrabImg->pos.w / 2 )
				{
					int offset = (promptGrabImg->pos.x + promptGrabImg->pos.w / 2) - furthestLeftPrompt;
					promptGrabImg->pos.x -= offset;
					auto pos = promptGrab->getSize();
					pos.x -= offset;
					promptGrab->setSize(pos);
				}
			}
		}
		else if ( drawGlyphs )
		{
			SDL_Rect glyphPos = grabAllBtn->getSize();
			glyphPos.x += glyphPos.w / 2;
			glyphPos.y += glyphPos.h - 4;
			promptGrabImg->path = Input::inputs[player.playernum].getGlyphPathForBinding("MenuPageRightAlt");
			promptGrabImg->ontop = true;
			Image* glyphImage = Image::get(promptGrabImg->path.c_str());
			if ( glyphImage )
			{
				glyphPos.w = glyphImage->getWidth();
				glyphPos.h = glyphImage->getHeight();
				glyphPos.x -= glyphPos.w / 2;
				promptGrabImg->pos = glyphPos;
			}
		}
		if ( !promptBack->isDisabled() )
		{
			if ( furthestLeftPrompt < promptBackImg->pos.x + promptBackImg->pos.w / 2 )
			{
				int offset = (promptBackImg->pos.x + promptBackImg->pos.w / 2) - furthestLeftPrompt;
				promptBackImg->pos.x -= offset;
				auto pos = promptBack->getSize();
				pos.x = promptGrab->getSize().x;
				promptBack->setSize(pos);
			}
		}
	}

	bool closeChestAction = false;
	if ( !inputs.getUIInteraction(player.playernum)->selectedItem 
		&& player.GUI.bModuleAccessibleWithMouse(Player::GUI_t::MODULE_CHEST)
		&& !player.GUI.isDropdownActive()
		&& !player.inventoryUI.spellPanel.bOpen
		&& player.bControlEnabled && !gamePaused && !player.usingCommand() )
	{
		if ( openedChest[player.playernum] || bOpen )
		{
			if ( Input::inputs[player.playernum].binaryToggle("MenuCancel") )
			{
				Input::inputs[player.playernum].consumeBinaryToggle("MenuCancel");
				closeChestAction = true;
			}
			else if ( !promptGrabImg->disabled && Input::inputs[player.playernum].consumeBinaryToggle("MenuPageRightAlt") )
			{
				takeAllChestGUIAction(player.playernum);
				Player::soundActivate();
			}
		}
	}

	SDL_Rect actualSize = chestSlotsFrame->getActualSize();
	actualSize.y = scrollAnimateX;
	chestSlotsFrame->setActualSize(actualSize);

	if ( closeChestAction )
	{
		closeChestGUIAction(player.playernum);
		return;
	}
}

bool Player::Inventory_t::ChestGUI_t::isSlotVisible(int x, int y) const
{
	if ( player.inventoryUI.chestFrame )
	{
		if ( player.inventoryUI.chestFrame->isDisabled() )
		{
			return false;
		}
	}
	int lowerY = currentScrollRow;
	int upperY = currentScrollRow + getNumItemsToDisplayVertical() - 1;

	if ( y >= lowerY && y <= upperY )
	{
		return true;
	}
	return false;
}

bool Player::Inventory_t::ChestGUI_t::isItemVisible(Item* item) const
{
	if ( !item ) { return false; }
	return isSlotVisible(item->x, item->y);
}

void Player::Inventory_t::ChestGUI_t::scrollToSlot(int x, int y, bool instantly)
{
	int lowerY = currentScrollRow;
	int upperY = currentScrollRow + getNumItemsToDisplayVertical() - 1;

	if ( y >= lowerY && y <= upperY )
	{
		// no work to do.
		return;
	}

	int lowestItemY = getNumItemsToDisplayVertical() - 1;
	for ( node_t* node = stats[player.playernum]->inventory.first; node != NULL; node = node->next )
	{
		Item* item = (Item*)node->element;
		if ( !item ) { continue; }
		if ( itemCategory(item) != SPELL_CAT ) { continue; }

		lowestItemY = std::max(lowestItemY, item->y);
	}
	int maxScroll = std::max((lowestItemY + 1) - (getNumItemsToDisplayVertical()), 0) * player.inventoryUI.getSlotSize();

	int scrollAmount = 0;
	if ( y < lowerY )
	{
		scrollAmount = (y)* player.inventoryUI.getSlotSize();
		//scrollAmount += scrollSetpoint;
	}
	else if ( y > upperY )
	{
		scrollAmount = (y - upperY) * player.inventoryUI.getSlotSize();
		scrollAmount += scrollSetpoint;
	}
	scrollAmount = std::min(scrollAmount, maxScroll);

	scrollSetpoint = scrollAmount;
	if ( instantly )
	{
		scrollAnimateX = scrollSetpoint;
	}
	currentScrollRow = scrollSetpoint / player.inventoryUI.getSlotSize();
	if ( abs(scrollSetpoint - scrollAnimateX) > 0.00001 )
	{
		isInteractable = false;
	}
}

void MinotaurWarning_t::deinit()
{
	started = false;
	state = 0;
	stateInit = 0;
	animFade = 0.0;
	animTicks = 0;
	animBg = 0.0;
	initialWarningCompleted = false;
	minotaurSpawned = false;
	minotaurDied = false;
	minotaurUid = 0;
	animFlashIncrease = true;
	animFlash = 0.0;
}

void MinotaurWarning_t::init()
{
	deinit();
	started = true;
}

void MinotaurWarning_t::setAnimatePosition(const int destx, const int desty, const int destw, const int desth)
{
	animateStartX = pos.x;
	animateStartY = pos.y;
	animateStartW = pos.w;
	animateStartH = pos.h;
	animateSetpointX = destx;
	animateSetpointY = desty;
	animateSetpointW = destw;
	animateSetpointH = desth;
	animateX = 0.0;
	animateY = 0.0;
	animateW = 0.0;
	animateH = 0.0;
}

void MinotaurWarning_t::setAnimatePosition(int destx, int desty)
{
	animateStartX = pos.x;
	animateStartY = pos.y;
	animateStartW = pos.w;
	animateStartH = pos.h;
	animateSetpointX = destx;
	animateSetpointY = desty;
	animateSetpointW = 0;
	animateSetpointH = 0;
	animateX = 0.0;
	animateY = 0.0;
	animateW = 0.0;
	animateH = 0.0;
}

void Player::HUD_t::updateMinotaurWarning()
{
	auto& m = minotaurWarning[player.playernum];

	if ( gamePaused && multiplayer == SINGLE )
	{
		if ( minotaurFrame )
		{
			minotaurFrame->setDisabled(true);
		}
		return;
	}

	static ConsoleVariable<bool> cvar_minoanimdebug("/minoanimdebug", false);
	if ( *cvar_minoanimdebug && player.playernum == clientnum )
	{
		*cvar_minoanimdebug = false;
		m.init();
	}

	static ConsoleVariable<float> cvar_minoflashmax("/minoflashmax", 1.25);
	static ConsoleVariable<float> cvar_minoflashmin("/minoflashmin", 0.25);
	static ConsoleVariable<float> cvar_minoflashrate("/minoflashrate", 0.125);

	if ( m.processedOnTick == 0 )
	{
		m.processedOnTick = ticks;
	}
	else if ( m.processedOnTick != ticks )
	{
		m.processedOnTick = ticks;
		++m.animTicks;
	}

	bool newLevel = m.levelProcessed != currentlevel;
	if ( !minotaurlevel || (newLevel && m.started) )
	{
		m.deinit();
	}
	m.levelProcessed = currentlevel;

	if ( !m.started )
	{
		if ( minotaurFrame )
		{
			minotaurFrame->setDisabled(true);
		}
	}
	if ( minotaurDisplay )
	{
		minotaurDisplay->setDisabled(true);
	}
	if ( player.playernum == 0 && minotaurSharedDisplay )
	{
		minotaurSharedDisplay->setDisabled(true);
	}

	if ( !player.isLocalPlayer() )
	{
		m.deinit();
		return;
	}

	if ( minotaurlevel && m.animTicks >= 50 && !m.started )
	{
		m.init();
	}

	if ( !m.started )
	{
		return;
	}

	if ( !minotaurFrame )
	{
		minotaurFrame = gameUIFrame[player.playernum]->addFrame("minotaur");
		minotaurFrame->setInheritParentFrameOpacity(false);
		minotaurFrame->setHollow(true);

		Frame::image_t* img = minotaurFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0,
			"*images/system/white.png", "mino dimmer");
		img->disabled = true;

		img = minotaurFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
			"*images/ui/HUD/HUD_Minotaur_00.png", "mino img bg");
		img->disabled = true;

		img = minotaurFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF,
			"*images/ui/HUD/HUD_Minotaur_00.png", "mino img fg");
		img->disabled = true;
	}

	minotaurFrame->setSize(SDL_Rect{ 
		player.camera_virtualx1(),
		player.camera_virtualy1(),
		player.camera_virtualWidth(),
		player.camera_virtualHeight() });

	auto dimmer = minotaurFrame->findImage("mino dimmer");
	dimmer->pos = SDL_Rect{ 0, 0, minotaurFrame->getSize().w, minotaurFrame->getSize().h };
	dimmer->disabled = false;
	auto minotaurImgBg = minotaurFrame->findImage("mino img bg");
	minotaurImgBg->disabled = true;
	auto minotaurImgFg = minotaurFrame->findImage("mino img fg");
	minotaurImgFg->disabled = true;
	minotaurFrame->setDisabled(player.hud.hudFrame->isDisabled());
	int imgSizeX = 60;
	int imgSizeY = 66;
	if ( auto imgGet = Image::get(minotaurImgBg->path.c_str()) )
	{
		imgSizeX = imgGet->getWidth();
		imgSizeY = imgGet->getHeight();
	}
	const int midX = dimmer->pos.w / 2;
	const int midY = dimmer->pos.h / 2;

	std::string minimapFrameName = "minimap";
	minimapFrameName.append(std::to_string(player.playernum));
	SDL_Rect sharedminimapPos{ 0, 0, 0, 0 };
	SDL_Rect minimapPos{ 0, 0, 0, 0 };
	Frame* minimap = nullptr;
	bool leftAlignToMap = splitscreen
		&& player.bUseCompactGUIHeight()
		&& !player.bUseCompactGUIWidth();
	int leftAlignYOffset = 16;
	int leftAlignXOffset = 0;
	int topAlignYOffset = 0;
	if ( leftAlignToMap && *MainMenu::clipped_splitscreen && player.hud.actionPromptsFrame && !player.hud.actionPromptsFrame->isDisabled() )
	{
		leftAlignYOffset += 16;
		leftAlignXOffset += 8;
	}
	else if ( !leftAlignToMap && *MainMenu::clipped_splitscreen && !player.bUseCompactGUIHeight() && player.bUseCompactGUIWidth() )
	{
		topAlignYOffset = -8;
	}
	if ( minimap = player.hud.hudFrame->findFrame(minimapFrameName.c_str()) )
	{
		minimapPos.x = minotaurFrame->getSize().w - player.minimap.minimapPos.w;
		minimapPos.y = minotaurFrame->getSize().h - player.minimap.minimapPos.h;
		int mapHeightOffset = 0;
		if ( player.hud.mapPromptFrame && !player.hud.mapPromptFrame->isDisabled() )
		{
			mapHeightOffset = player.hud.mapPromptFrame->getSize().h;
		}
		else if ( player.hud.gameTimerFrame && !player.hud.gameTimerFrame->isDisabled()
			// ignore if ui raised above hotbar and vertical split layout
			&& (!(player.hud.offsetHUDAboveHotbarHeight > 0 && splitscreen && !player.bUseCompactGUIHeight() && player.bUseCompactGUIWidth())) )
		{
			mapHeightOffset = player.hud.gameTimerFrame->getSize().h;
		}
		else if ( player.hud.actionPromptsFrame && !player.hud.actionPromptsFrame->isDisabled() )
		{
			leftAlignYOffset += 44;
		}
		mapHeightOffset += player.hud.offsetHUDAboveHotbarHeight;
		minimapPos.y -= mapHeightOffset;
	}
	minimapPos.w = player.minimap.minimapPos.w;
	minimapPos.h = player.minimap.minimapPos.h;
	if ( ::minimapFrame )
	{
		sharedminimapPos = Player::Minimap_t::sharedMinimapPos;
	}

	{
		Uint8 r, g, b, a;
		getColor(dimmer->color, &r, &g, &b, &a);
		a = m.animFade * 64;
		dimmer->color = makeColor(r, g, b, a);

		if ( m.state >= 8 || m.initialWarningCompleted )
		{
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			real_t setpointDiff = fpsScale * std::max(.01, (m.animFade)) / 5.0;
			m.animFade -= setpointDiff;
			m.animFade = std::max(0.0, m.animFade);
		}
		else
		{
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			real_t setpointDiff = fpsScale * std::max(.01, (1.0 - m.animFade)) / 5.0;
			m.animFade += setpointDiff;
			m.animFade = std::min(1.0, m.animFade);
		}
	}

	static ConsoleVariable<float> cvar_minoanimspeed("/minoanimspeed", 1.0);
	static ConsoleVariable<int> cvar_minoanimvolume("/minoanimvolume", 128);
	real_t animspeed = 5.0 * (*cvar_minoanimspeed);//5.0 / 4.0;
	const int movementAmount = 0;
	real_t scalingAmount = 2.0;
	real_t midScalingAmount = 1.5;

	if ( m.state == 0 )
	{
		if ( m.stateInit == 0 )
		{
			m.pos = SDL_Rect{ midX - imgSizeX / 2, midY - imgSizeY / 2, imgSizeX, imgSizeY };
			m.stateInit = 1;
			m.setAnimatePosition(
				midX - imgSizeX / 2 - movementAmount,
				midY - imgSizeY / 2 - movementAmount,
				imgSizeX, imgSizeY);
		}
		minotaurImgFg->color = makeColor(255, 255, 255, 255 * m.animateX);
		minotaurImgFg->disabled = false;
		if ( m.animateX >= 1.0 )
		{
			m.animTicks = 0;
			m.state = 1;
		}
		animspeed *= 2;
	}
	else if ( m.state == 1 )
	{
		if ( m.stateInit == 1 )
		{
			m.stateInit = 2;
			m.setAnimatePosition(
				midX - imgSizeX / 2 - movementAmount - (scalingAmount - 1.0) * imgSizeX / 2,
				midY - imgSizeY / 2 - movementAmount - (scalingAmount - 1.0) * imgSizeY / 2,
				imgSizeX * scalingAmount,
				imgSizeY * scalingAmount);
		}
		minotaurImgFg->color = 0xFFFFFFFF;
		minotaurImgFg->disabled = false;
		if ( m.animateX >= 1.0 )
		{
			m.animTicks = 0;
			m.state = 2;
		}
		animspeed /= 2;
	}
	else if ( m.state == 2 )
	{
		if ( m.stateInit == 2 )
		{
			m.stateInit = 3;
			m.setAnimatePosition(
				midX - imgSizeX / 2 - movementAmount - (midScalingAmount - 1.0) * imgSizeX / 2,
				midY - imgSizeY / 2 - movementAmount - (midScalingAmount - 1.0) * imgSizeY / 2,
				imgSizeX * midScalingAmount,
				imgSizeY * midScalingAmount);
			m.animBg = 1.0;
			if ( !splitscreen || (splitscreen && player.playernum == 0) )
			{
				playSound(514, *cvar_minoanimvolume);
			}
		}
		minotaurImgFg->disabled = false;

		minotaurImgBg->pos = SDL_Rect{ midX - imgSizeX,
			midY - imgSizeY, imgSizeX * 2, imgSizeY * 2 };
		if ( m.animateX >= 1.0 )
		{
			m.animTicks = 0;
			m.state = 3;
		}
	}
	else if ( m.state == 3 )
	{
		if ( m.stateInit == 3 )
		{
			m.stateInit = 4;
			m.setAnimatePosition(
				midX - imgSizeX / 2 - movementAmount - (midScalingAmount - 1.0) * imgSizeX / 2,
				midY - imgSizeY / 2 - movementAmount - (midScalingAmount - 1.0) * imgSizeY / 2,
				imgSizeX * midScalingAmount,
				imgSizeY * midScalingAmount);
		}
		minotaurImgFg->disabled = false;

		if ( m.animateX >= 1.0 )
		{
			m.animTicks = 0;
			m.state = 4;
		}
	}
	else if ( m.state == 4 )
	{
		if ( m.stateInit == 4 )
		{
			m.stateInit = 5;
			m.setAnimatePosition(
				midX - imgSizeX / 2 - movementAmount,
				midY - imgSizeY / 2 - movementAmount,
				imgSizeX, imgSizeY);
		}
		minotaurImgFg->disabled = false;

		if ( m.animateX >= 1.0 )
		{
			m.animTicks = 0;
			m.state = 5;
		}
		animspeed /= 2;
	}
	else if ( m.state == 5 )
	{
		if ( m.stateInit == 5 )
		{
			m.stateInit = 6;
			m.setAnimatePosition(
				midX - imgSizeX / 2 - movementAmount - (scalingAmount - 1.0) * imgSizeX / 2,
				midY - imgSizeY / 2 - movementAmount - (scalingAmount - 1.0) * imgSizeY / 2,
				imgSizeX * scalingAmount,
				imgSizeY * scalingAmount);
		}
		minotaurImgFg->color = 0xFFFFFFFF;
		minotaurImgFg->disabled = false;
		if ( m.animateX >= 1.0 )
		{
			m.animTicks = 0;
			m.state = 6;
		}
		animspeed /= 2;
	}
	else if ( m.state == 6 )
	{
		if ( m.stateInit == 6 )
		{
			m.stateInit = 7;
			m.setAnimatePosition(
				midX - imgSizeX / 2 - movementAmount - (midScalingAmount - 1.0) * imgSizeX / 2,
				midY - imgSizeY / 2 - movementAmount - (midScalingAmount - 1.0) * imgSizeY / 2,
				imgSizeX * midScalingAmount,
				imgSizeY * midScalingAmount);
			m.animBg = 1.0;
			if ( !splitscreen || (splitscreen && player.playernum == 0) )
			{
				playSound(515, *cvar_minoanimvolume);
			}
		}
		minotaurImgFg->disabled = false;

		if ( m.animateX >= 1.0 )
		{
			m.animTicks = 0;
			m.state = 7;
		}
	}
	else if ( m.state == 7 )
	{
		if ( m.stateInit == 7 )
		{
			m.stateInit = 8;
			m.setAnimatePosition(
				midX - imgSizeX / 2 - movementAmount - (midScalingAmount - 1.0) * imgSizeX / 2,
				midY - imgSizeY / 2 - movementAmount - (midScalingAmount - 1.0) * imgSizeY / 2,
				imgSizeX * midScalingAmount,
				imgSizeY * midScalingAmount);
		}
		minotaurImgFg->disabled = false;

		if ( m.animateX >= 1.0 )
		{
			m.animTicks = 0;
			m.state = 8;
		}
	}
	else if ( m.state == 8 )
	{
		if ( m.stateInit == 8 )
		{
			m.stateInit = 9;
			m.setAnimatePosition(
				midX - imgSizeX / 2 - movementAmount,
				midY - imgSizeY / 2 - movementAmount,
				imgSizeX, imgSizeY);
		}
		minotaurImgFg->color = makeColor(255, 255, 255, 255);
		minotaurImgFg->disabled = false;

		if ( m.animateX >= 1.0 )
		{
			m.animTicks = 0;
			m.state = 9;
		}
		animspeed /= 2;
	}
	else if ( m.state == 9 )
	{
		if ( m.stateInit == 9 )
		{
			m.stateInit = 10;
			if ( ::minimapFrame && !::minimapFrame->isInvisible() && sharedminimapPos.x > 0 )
			{
				if ( minotaurSharedDisplay )
				{
					/*m.setAnimatePosition(
						sharedminimapPos.x + sharedminimapPos.w / 2 - imgSizeX / 2 - movementAmount,
						sharedminimapPos.y - imgSizeY - 16 - movementAmount,
						imgSizeX, imgSizeY);*/
				}
				m.setAnimatePosition(
					midX - imgSizeX / 2 - movementAmount,
					midY - imgSizeY / 2 - movementAmount,
					imgSizeX, imgSizeY);
			}
			else if ( minotaurDisplay && minimap && !minimap->isInvisible() && minimapPos.x > 0 )
			{
				if ( leftAlignToMap )
				{
					m.setAnimatePosition(
						minimapPos.x - imgSizeX - 16 + leftAlignXOffset - movementAmount,
						minimapPos.y + minimapPos.h - imgSizeY - leftAlignYOffset - movementAmount,
						imgSizeX, imgSizeY);
				}
				else
				{
					m.setAnimatePosition(
						minimapPos.x + minimapPos.w - imgSizeX - 16 - movementAmount,
						minimapPos.y - imgSizeY - 16 - topAlignYOffset - movementAmount,
						imgSizeX, imgSizeY);
				}
			}
			else
			{
				m.setAnimatePosition(
					minotaurFrame->getSize().w - imgSizeX - 16 - movementAmount,
					minotaurFrame->getSize().h - imgSizeY - 16 - movementAmount,
					imgSizeX, imgSizeY);
			}
		}

		minotaurImgFg->color = makeColor(255, 255, 255, 255);
		if ( ::minimapFrame && !::minimapFrame->isInvisible() )
		{
			/*if ( !minotaurSharedDisplay )*/
			{
				// fade out icon for local splitscreen
				minotaurImgFg->color = makeColor(255, 255, 255, 255 * (1.0 - m.animateX));
			}
		}

		minotaurImgFg->disabled = false;

		if ( m.animateX >= 1.0 )
		{
			m.animTicks = 0;
			m.state = 10;
			m.animFlash = *cvar_minoflashmax * 2;
			m.animFlashIncrease = false;
			/*if ( !splitscreen || (splitscreen && player.playernum == 0) )
			{
				playSound(517, 64);
			}*/
		}
	}
	else if ( m.state == 10 )
	{
		m.initialWarningCompleted = true;
	}

	if ( m.initialWarningCompleted )
	{
		if ( !m.minotaurDied && ticks % 5 == 0 && (!splitscreen || splitscreen && player.playernum == 0) )
		{
			if ( !m.minotaurSpawned )
			{
				for ( node_t* mapNode = map.creatures->first; mapNode != nullptr; mapNode = mapNode->next )
				{
					Entity* monster = (Entity*)mapNode->element;
					if ( monster && monster->getMonsterTypeFromSprite() == MINOTAUR )
					{
						m.minotaurSpawned = true;
						m.minotaurUid = monster->getUID();
					}
				}
			}
			else if ( !uidToEntity(m.minotaurUid) )
			{
				m.minotaurDied = true;
			}
		}

		if ( splitscreen && player.playernum != 0 )
		{
			m.minotaurDied = minotaurWarning[0].minotaurDied;
			m.minotaurSpawned = minotaurWarning[0].minotaurSpawned;
		}

		bool flash = false;
		if ( m.minotaurSpawned && !m.minotaurDied )
		{
			m.animFlash = 1.0;
			flash = !((ticks % 50) - (ticks % 25));
		}
		else if ( m.animFlashIncrease )
		{
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			real_t setpointDiff = fpsScale * (*cvar_minoflashrate) / 5.0;
			m.animFlash += setpointDiff;
			if ( m.animFlash >= *cvar_minoflashmax )
			{
				m.animFlashIncrease = false;
			}
			m.animFlash = std::min(*cvar_minoflashmax, (float)m.animFlash);
		}
		else	
		{
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			real_t setpointDiff = fpsScale * (*cvar_minoflashrate) / 5.0;
			m.animFlash -= setpointDiff;
			if ( m.animFlash <= *cvar_minoflashmin )
			{
				m.animFlashIncrease = true;
			}
			m.animFlash = std::max(*cvar_minoflashmin, (float)m.animFlash);
		}

		if ( m.minotaurDied )
		{
			// don't show icon.
		}
		else if ( ::minimapFrame && !::minimapFrame->isInvisible() && sharedminimapPos.x > 0 )
		{
			if ( minotaurSharedDisplay )
			{
				minotaurSharedDisplay->setDisabled(flash);
				minotaurSharedDisplay->setOpacity(100.0 * std::max(0.25, std::min(1.0, m.animFlash)));
				minotaurSharedDisplay->setSize(SDL_Rect{ sharedminimapPos.x + sharedminimapPos.w / 2 - imgSizeX / 2 - movementAmount,
					sharedminimapPos.y - imgSizeY - 16 - movementAmount,
					imgSizeX, imgSizeY });
				/*if ( (minotaurSharedDisplay->getSize().x + minotaurSharedDisplay->getSize().w) > 
					(players[0]->camera_virtualx1() + players[0]->camera_virtualWidth()) )*/
				{
					// keep on player 1's camera for now.
					SDL_Rect pos = minotaurSharedDisplay->getSize();
					//int diff = (players[0]->camera_virtualx1() + players[0]->camera_virtualWidth()) -
					//	(minotaurSharedDisplay->getSize().x + minotaurSharedDisplay->getSize().w);
					//pos.x -= abs(diff) + 4;
					pos.x = players[0]->camera_virtualx1() + players[0]->camera_virtualWidth() - pos.w - 4;
					pos.y = players[0]->camera_virtualy1() + players[0]->camera_virtualHeight() - pos.h - 4;
					if ( players[0]->hud.mapPromptFrame && !players[0]->hud.mapPromptFrame->isDisabled() )
					{
						pos.y -= players[0]->hud.mapPromptFrame->getSize().h;
					}
					minotaurSharedDisplay->setSize(pos);
				}
			}
		}
		else if ( minotaurDisplay && minimap && !minimap->isInvisible() && minimapPos.x > 0 )
		{
			minotaurDisplay->setDisabled(flash);
			minotaurDisplay->setOpacity(100.0 * std::max(0.25, std::min(1.0, m.animFlash)));

			if ( leftAlignToMap )
			{
				minotaurDisplay->setSize(SDL_Rect{
					minimapPos.x - imgSizeX - 16 + leftAlignXOffset - movementAmount,
					minimapPos.y + minimapPos.h - imgSizeY - leftAlignYOffset - movementAmount,
					imgSizeX, imgSizeY });
			}
			else
			{
				minotaurDisplay->setSize(SDL_Rect{ minimapPos.x + minimapPos.w - imgSizeX - 16 - movementAmount,
					minimapPos.y - imgSizeY - 16 - topAlignYOffset - movementAmount,
					imgSizeX, imgSizeY });
			}
		}
		else
		{
			minotaurDisplay->setDisabled(flash);
			minotaurDisplay->setOpacity(100.0 * std::max(0.25, std::min(1.0, m.animFlash)));
			minotaurDisplay->setSize(SDL_Rect{ minotaurFrame->getSize().w - imgSizeX - 16 - movementAmount,
				minotaurFrame->getSize().h - imgSizeY - 16 - movementAmount,
				imgSizeX, imgSizeY });
		}
	}

	if ( m.animBg > 0.0 )
	{
		minotaurImgBg->color = makeColor(255, 255, 255, 255 * (std::min(1.0, m.animBg)));
		minotaurImgBg->disabled = false;
	}

	const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
	real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - m.animateX)) / (animspeed);
	real_t setpointDiffY = fpsScale * std::max(.1, (1.0 - m.animateY)) / (animspeed);
	real_t setpointDiffW = fpsScale * std::max(.1, (1.0 - m.animateW)) / (animspeed);
	real_t setpointDiffH = fpsScale * std::max(.1, (1.0 - m.animateH)) / (animspeed);
	m.animateX += setpointDiffX;
	m.animateY += setpointDiffY;
	m.animateX = std::min(1.0, m.animateX);
	m.animateY = std::min(1.0, m.animateY);
	m.animateW += setpointDiffW;
	m.animateH += setpointDiffH;
	m.animateW = std::min(1.0, m.animateW);
	m.animateH = std::min(1.0, m.animateH);

	int destX = m.animateSetpointX - m.animateStartX;
	int destY = m.animateSetpointY - m.animateStartY;
	int destW = m.animateSetpointW - m.animateStartW;
	int destH = m.animateSetpointH - m.animateStartH;

	m.pos.x = m.animateStartX + destX * m.animateX;
	m.pos.y = m.animateStartY + destY * m.animateY;
	m.pos.w = m.animateStartW + destW * m.animateW;
	m.pos.h = m.animateStartH + destH * m.animateH;
	minotaurImgFg->pos = m.pos;

	m.animBg -= fpsScale * 0.2 / animspeed;
	m.animBg = std::max(0.0, m.animBg);
}

bool Player::WorldUI_t::WorldTooltipItem_t::isItemSameAsCurrent(Item* item)
{
	if ( !item ) 
	{
		return false;
	}
	if ( item->type == type
		&& item->status == status
		&& item->beatitude == beatitude
		&& item->count == count
		&& item->appearance == appearance
		&& item->identified == identified )
	{
		return true;
	}
	return false;
}


SDL_Surface* Player::WorldUI_t::WorldTooltipItem_t::blitItemWorldTooltip(Item* item)
{
	if ( !item )
	{
		return nullptr;
	}

	if ( itemWorldTooltipSurface && isItemSameAsCurrent(item) )
	{
		return itemWorldTooltipSurface;
	}

	type = item->type;
	status = item->status;
	beatitude = item->beatitude;
	count = item->count;
	appearance = item->appearance;
	identified = item->identified;

	SDL_Rect tooltip;
	char buf[1024] = "";
	char buf2[1024] = "";
	int numHeaderLines = 1;
	int numDescLines = 3;
	Font* font = Font::get("fonts/pixel_maz.ttf#32#2");
	int headerSize = 16;

	if ( !itemFrame )
	{
		itemFrame = new Frame("world tooltip frame");
		itemFrame->setSize(SDL_Rect{ 0, 0, player.hotbar.getSlotSize() - 4, player.hotbar.getSlotSize() - 4 });
		itemFrame->setUserData(&GAMEUI_FRAMEDATA_WORLDTOOLTIP_ITEM);
		createPlayerInventorySlotFrameElements(itemFrame);
		itemFrame->setSize(SDL_Rect{ 0, 0, player.hotbar.getSlotSize(), player.hotbar.getSlotSize() });
	}

	updateSlotFrameFromItem(itemFrame, item);

	// get tooltip name and background
	{
		if ( !item->identified )
		{
			if ( itemCategory(item) == BOOK )
			{
				snprintf(buf, sizeof(buf), "%s %s", ItemTooltips.getItemStatusAdjective(item->type, item->status).c_str(),
					Language::get(4214)); // brand new copy of
				snprintf(buf2, sizeof(buf), "%s (?)", getBookLocalizedNameFromIndex(item->appearance % numbooks).c_str());
			}
			else if ( itemCategory(item) == SCROLL )
			{
				snprintf(buf, sizeof(buf), "%s %s", ItemTooltips.getItemStatusAdjective(item->type, item->status).c_str(),
					items[item->type].getUnidentifiedName());
				snprintf(buf2, sizeof(buf), "%s %s (?)", Language::get(4215), item->getScrollLabel());
			}
			else
			{
				snprintf(buf, sizeof(buf), "%s %s (?)", ItemTooltips.getItemStatusAdjective(item->type, item->status).c_str(), item->getName());
			}
		}
		else
		{
			if ( (item->type == TOOL_SENTRYBOT || item->type == TOOL_DUMMYBOT || item->type == TOOL_SPELLBOT
				|| item->type == TOOL_GYROBOT) )
			{
				int health = 100;
				if ( !item->tinkeringBotIsMaxHealth() )
				{
					health = 25 * (item->appearance % 10);
					if ( health == 0 && item->status != BROKEN )
					{
						health = 5;
					}
				}
				snprintf(buf, sizeof(buf), "%s %s (%d%%)", ItemTooltips.getItemStatusAdjective(item->type, item->status).c_str(), item->getName(), health);
			}
			else if ( item->type == ENCHANTED_FEATHER && item->identified )
			{
				snprintf(buf, sizeof(buf), "%s %s (%d%%) (%+d)", ItemTooltips.getItemStatusAdjective(item->type, item->status).c_str(),
					item->getName(), item->appearance % ENCHANTED_FEATHER_MAX_DURABILITY, item->beatitude);
			}
			else if ( itemCategory(item) == BOOK )
			{
				snprintf(buf, sizeof(buf), "%s %s", ItemTooltips.getItemStatusAdjective(item->type, item->status).c_str(),
					Language::get(4214)); // brand new copy of
				snprintf(buf2, sizeof(buf), "%s (%+d)", getBookLocalizedNameFromIndex(item->appearance % numbooks).c_str(), item->beatitude);
			}
			else
			{
				snprintf(buf, sizeof(buf), "%s %s (%+d)", ItemTooltips.getItemStatusAdjective(item->type, item->status).c_str(), item->getName(), item->beatitude);
			}
		}

		if ( strcmp(buf2, "") )
		{
			numHeaderLines += 1;
		}

		size_t longestLine = 200;
		if ( auto textGet = Text::get(buf, font->getName(), 0xFFFFFFFF, 0) )
		{
			if ( numHeaderLines == 1 && textGet->getWidth() > 300 )
			{
				Field* f = new Field(1024);
				f->setText(buf);
				f->setSize(SDL_Rect{ 0, 0, 300, 0 });
				f->reflowTextToFit(0);
				strcpy(buf, f->getText());
				delete f;
				f = nullptr;
				for ( size_t c = 0; c < strlen(buf); ++c )
				{
					if ( buf[c] == '\n' )
					{
						buf[c] = '\0';
						strcpy(buf2, buf + c + 1);
						std::string buf2Str = buf2;
						replace(buf2Str.begin(), buf2Str.end(), '\n', ' ');
						strcpy(buf2, buf2Str.c_str());
						break;
					}
				}
				textGet = Text::get(buf, font->getName(), 0xFFFFFFFF, 0);
				numHeaderLines++;
			}
			longestLine = std::max(longestLine, (size_t)textGet->getWidth());
		}
		if ( numHeaderLines > 1 )
		{
			if ( auto textGet = Text::get(buf2, font->getName(), 0xFFFFFFFF, 0) )
			{
				longestLine = std::max(longestLine, (size_t)textGet->getWidth());
			}
		}
		tooltip.w = 16 + 16 + 8 + longestLine;

		if ( numHeaderLines > 1 )
		{
			headerSize = 42;
		}
		else
		{
			headerSize = 28;
		}
		itemFrame->setSize(SDL_Rect{
			tooltip.w - itemFrame->getSize().w - 16,
			headerSize + 4,
			itemFrame->getSize().w,
			itemFrame->getSize().h });
		tooltip.h = itemFrame->getSize().h + 8 + headerSize;

		if ( itemWorldTooltipSurface )
		{
			SDL_FreeSurface(itemWorldTooltipSurface);
			itemWorldTooltipSurface = nullptr;
		}
		itemWorldTooltipSurface = SDL_CreateRGBSurface(0, tooltip.w, tooltip.h, 32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000);

		SDL_Rect imgPos{ 0, 0, 0, 0 };
		if ( numHeaderLines == 1 )
		{
			if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_TL00.png") )
			{
				imgPos.w = img->getWidth();
				imgPos.h = img->getHeight();
				SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
				SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
			}
			imgPos.x += imgPos.w;
			if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_T00.png") )
			{
				imgPos.w = tooltip.w - imgPos.w * 2;
				imgPos.h = img->getHeight();
				SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
				SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
			}
			imgPos.x += imgPos.w;
			if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_TR00.png") )
			{
				imgPos.w = img->getWidth();
				imgPos.h = img->getHeight();
				SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
				SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
			}
		}
		else
		{
			if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_TL00_2x.png") )
			{
				imgPos.w = img->getWidth();
				imgPos.h = img->getHeight();
				SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
				SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
			}
			imgPos.x += imgPos.w;
			if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_T00_2x.png") )
			{
				imgPos.w = tooltip.w - imgPos.w * 2;
				imgPos.h = img->getHeight();
				SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
				SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
			}
			imgPos.x += imgPos.w;
			if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_TR00_2x.png") )
			{
				imgPos.w = img->getWidth();
				imgPos.h = img->getHeight();
				SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
				SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
			}
		}

		imgPos.x = 0;
		imgPos.y += imgPos.h;
		if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_L00.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = tooltip.h - imgPos.h - 26;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_C00.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_R00.png") )
		{
			imgPos.w = img->getWidth();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
		}

		imgPos.x = 0;
		imgPos.y += imgPos.h;
		if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_BL01_NoPrompt.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_B00_NoPrompt.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/Inventory/tooltips/Hover_BR01_NoPrompt.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
		}
	}

	{
		SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get("images/ui/HUD/hotbar/HUD_Quickbar_Slot_Box_02.png")->getSurf());
		SDL_Rect pos = SDL_Rect{ itemFrame->getSize().x, itemFrame->getSize().y, 
			player.hotbar.getSlotSize(), player.hotbar.getSlotSize()};
		SDL_BlitSurface(srcSurf, nullptr, itemWorldTooltipSurface, &pos);
	}

	for ( auto& f : itemFrame->getFrames() )
	{
		SDL_Rect pos = itemFrame->getSize();
		pos.x += f->getSize().x;
		pos.y += f->getSize().y;

		if ( f->isDisabled() ) { continue; }
		for ( auto& img : f->getImages() )
		{
			if ( img->disabled ) { continue; }
			if ( img->path == "" ) { continue; }
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(Image::get(img->path.c_str())->getSurf());
			Uint8 r, g, b, a;
			getColor(img->color, &r, &g, &b, &a);
			SDL_SetSurfaceAlphaMod(srcSurf, a);
			SDL_Rect imgPos = pos;
			imgPos.x += img->pos.x;
			imgPos.y += img->pos.y;
			imgPos.w = img->pos.w;
			imgPos.h = img->pos.h;
			SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &imgPos);
		}
		for ( auto& field : f->getFields() )
		{
			if ( field->isDisabled() ) { continue; }
			SDL_Rect txtPos = pos;
			auto textGet = field->getTextObject();
			int x = field->getSize().x;
			int y = field->getSize().y;
			if ( field->getHJustify() == Field::justify_t::RIGHT
				|| field->getHJustify() == Field::justify_t::BOTTOM )
			{
				x = field->getSize().x + field->getSize().w - textGet->getWidth();
			}
			if ( field->getVJustify() == Field::justify_t::BOTTOM
				|| field->getVJustify() == Field::justify_t::RIGHT )
			{
				y = field->getSize().y + field->getSize().h - font->height();
			}
			txtPos.x += x;
			txtPos.y += y;
			txtPos.w = field->getSize().w;
			txtPos.h = field->getSize().h;
			SDL_BlitSurface(const_cast<SDL_Surface*>(textGet->getSurf()), nullptr, itemWorldTooltipSurface, &txtPos);
		}
	}

	GLuint itemTexid = 0;
	SDL_Rect pos;
	if ( SDL_Surface* textSurf = const_cast<SDL_Surface*>(Text::get(buf, font->getName(),
		makeColor(67, 195, 157, 255), 0)->getSurf()) )
	{
		pos.x = 16 + 4;
		pos.y = 2;
		if ( numHeaderLines > 1 )
		{
			pos.y = -2;
		}
		SDL_BlitSurface(textSurf, nullptr, itemWorldTooltipSurface, &pos);
	}
	if ( numHeaderLines > 1 )
	{
		if ( SDL_Surface* textSurf = const_cast<SDL_Surface*>(Text::get(buf2, font->getName(),
			hudColors.characterSheetHeadingText, 0)->getSurf()) )
		{
			pos.x = 16 + 4;
			pos.y = (font->height() - 8);
			SDL_BlitSurface(textSurf, nullptr, itemWorldTooltipSurface, &pos);
		}
	}

	{
		SDL_Rect identifyPos = pos;
		std::string identifyStr = ItemTooltips.adjectives["item_identified_status"]["unidentified"];
		if ( item->identified )
		{
			if ( item->beatitude > 0 )
			{
				identifyStr = ItemTooltips.adjectives["item_identified_status"]["blessed"];
			}
			else if ( item->beatitude < 0 )
			{
				identifyStr = ItemTooltips.adjectives["item_identified_status"]["cursed"];
			}
			else
			{
				identifyStr = ItemTooltips.adjectives["item_identified_status"]["uncursed"];
			}
		}
		identifyPos.y = headerSize;
		if ( auto textGet = Text::get(identifyStr.c_str(), font->getName(),
			hudColors.characterSheetNeutral, 0) )
		{
			if ( SDL_Surface* textSurf = const_cast<SDL_Surface*>(textGet->getSurf()) )
			{
				SDL_BlitSurface(textSurf, nullptr, itemWorldTooltipSurface, &identifyPos);
			}
			identifyPos.w = textGet->getWidth();
			identifyPos.h = textGet->getHeight();
		}

		SDL_Rect wgtPos = pos;
		wgtPos.y = identifyPos.y + identifyPos.h + 2;
		wgtPos.x = identifyPos.x;
		const char* wgtImg = "images/ui/Inventory/tooltips/HUD_Tooltip_Icon_WGT_00.png";
		if ( auto imgGet = Image::get(wgtImg) )
		{
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(imgGet->getSurf());
			wgtPos.w = imgGet->getWidth();
			wgtPos.h = imgGet->getHeight();
			SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &wgtPos);

			char wgtBuf[32];
			snprintf(wgtBuf, sizeof(wgtBuf), "%d", item->getWeight());
			if ( auto textGet = Text::get(wgtBuf, font->getName(),
				hudColors.characterSheetNeutral, 0) )
			{
				SDL_Surface* textSurf = const_cast<SDL_Surface*>(textGet->getSurf());
				wgtPos.x += wgtPos.w + 4;
				wgtPos.y = wgtPos.y + wgtPos.h / 2 - font->height() / 2;
				if ( wgtPos.y % 2 == 1 )
				{
					++wgtPos.y;
				}
				SDL_BlitSurface(textSurf, nullptr, itemWorldTooltipSurface, &wgtPos);
				wgtPos.x += textGet->getWidth() + 8;
			}
		}

		SDL_Rect goldPos = wgtPos;
		goldPos.y = identifyPos.y + identifyPos.h;
		const char* goldImg = "images/ui/Inventory/tooltips/HUD_Tooltip_Icon_Money_00.png";
		if ( auto imgGet = Image::get(goldImg) )
		{
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(imgGet->getSurf());
			goldPos.w = imgGet->getWidth();
			goldPos.h = imgGet->getHeight();
			SDL_BlitScaled(srcSurf, nullptr, itemWorldTooltipSurface, &goldPos);

			char goldBuf[32];
			if ( !item->identified && itemCategory(item) == GEM )
			{
				snprintf(goldBuf, sizeof(goldBuf), "%d", items[GEM_GLASS].value);
			}
			else
			{
				snprintf(goldBuf, sizeof(goldBuf), "%d", items[item->type].value);
			}
			if ( SDL_Surface* textSurf = const_cast<SDL_Surface*>(Text::get(goldBuf, font->getName(),
				hudColors.characterSheetNeutral, 0)->getSurf()) )
			{
				goldPos.x += goldPos.w + 4;
				goldPos.y = goldPos.y + goldPos.h / 2 - font->height() / 2;
				if ( goldPos.y % 2 == 1 )
				{
					++goldPos.y;
				}
				SDL_BlitSurface(textSurf, nullptr, itemWorldTooltipSurface, &goldPos);
			}
		}
	}
	return itemWorldTooltipSurface;
}

void Player::WorldUI_t::WorldTooltipDialogue_t::Dialogue_t::deactivate()
{
	parent = 0;
	x = 0.0;
	y = 0.0;
	z = 0.0;
	active = false;
	init = false;
	draw = false;
	alpha = 0.0;
	spawnTick = 0;
	updatedThisTick = 0;
	expiryTicks = 0;
	dialogueStringLength = 0;
	dialogueStrFull = "";
	dialogueStrCurrent = "";
	int langEntry = 0;
	DialogueType_t dialogueType = DIALOGUE_NONE;
	if ( dialogueTooltipSurface )
	{
		SDL_FreeSurface(dialogueTooltipSurface);
		dialogueTooltipSurface = nullptr;
	}
}

void Player::WorldUI_t::WorldTooltipDialogue_t::update()
{
	playerDialogue.update();
	for ( auto& d : sharedDialogues )
	{
		d.second.update();
	}
	for ( auto it = sharedDialogues.cbegin(); it != sharedDialogues.cend(); )
	{
		if ( !it->second.active && it->second.alpha <= 0.0
			&& (ticks - it->second.spawnTick >= it->second.expiryTicks) )
		{
			it = sharedDialogues.erase(it);
		}
		else
		{
			++it;
		}
	}
}

void Player::WorldUI_t::WorldTooltipDialogue_t::Dialogue_t::update()
{
	if ( !init )
	{
		return;
	}
	if ( player == -1 )
	{
		deactivate();
		return;
	}
	bool singleDisplayDialogue = (this == &players[player]->worldUI.worldTooltipDialogue.playerDialogue);
	if ( client_disconnected[player] )
	{
		active = false;
	}

	Entity* parentEnt = uidToEntity(parent);
	bool expired = false;
	if ( !parentEnt )
	{
		active = false;
		expired = true;
	}
	else if ( ticks - spawnTick >= expiryTicks )
	{
		active = false;
		expired = true;
	}


	auto& setting = WorldDialogueSettings_t::settings[dialogueType];
	if ( parentEnt && setting.followEntity )
	{
		/*if ( parentEnt->bUseRenderInterpolation )
		{
			x = parentEnt->lerpRenderState.x.position * 16.0;
			y = parentEnt->lerpRenderState.y.position * 16.0;
			z = parentEnt->lerpRenderState.z.position + setting.offsetZ;
		}
		else*/
		{
			x = parentEnt->x;
			y = parentEnt->y;
			z = parentEnt->z + setting.offsetZ;
		}
	}

	real_t dx, dy;
	auto& camera = cameras[player];
	dx = x - camera.x * 16.0;
	dy = y - camera.y * 16.0;
	if ( dx * dx + dy * dy > setting.fadeDist * setting.fadeDist )
	{
		active = false;
	}
	else if ( !singleDisplayDialogue && !expired )
	{
		active = true;
	}

	if ( ticks != updatedThisTick )
	{
		if ( active )
		{
			alpha = std::min(1.0, alpha + .15);
			animZ -= animZ * 0.25;
			animZ = std::max(0.1, animZ);
		}
		else
		{
			alpha = std::max(0.0, alpha - .12);
			animZ += 0.05;
			animZ = std::min(1.5, animZ);
			if ( alpha <= 0.0 )
			{
				if ( expired || singleDisplayDialogue )
				{
					deactivate();
				}
				return;
			}
		}
	}

	if ( setting.textDelay <= 0 )
	{
		dialogueStrCurrent = dialogueStrFull;
		dialogueStringLength = dialogueStrFull.size();
	}
	else if ( ticks - updatedThisTick > (Uint32)(setting.textDelay - 1) )
	{
		size_t fullLen = dialogueStrFull.size();
		if ( dialogueStringLength < fullLen )
		{
			if ( dialogueStringLength + 1 == fullLen )
			{
				dialogueStrCurrent = dialogueStrFull;
			}
			else
			{
				dialogueStrCurrent = dialogueStrFull.substr(0U, dialogueStringLength + 1);
				++dialogueStringLength;
			}
		}
		else if ( dialogueStringLength > fullLen )
		{
			dialogueStringLength = fullLen;
		}
	}
	draw = true;

	if ( ticks != updatedThisTick )
	{
		blitDialogueTooltip();
	}
	updatedThisTick = ticks;
}

void Player::WorldUI_t::WorldTooltipDialogue_t::createDialogueTooltip(Uint32 uid, 
	Player::WorldUI_t::WorldTooltipDialogue_t::DialogueType_t type, char const * const message, ...)
{
	if ( multiplayer == SERVER )
	{
		if ( player.playernum != clientnum )
		{
			if ( client_disconnected[player.playernum] )
			{
				return;
			}
			char buf[1024] = { 0 };

			va_list argptr;
			va_start(argptr, message);
			vsnprintf(buf, sizeof(buf), message, argptr);
			va_end(argptr);

			strcpy((char*)net_packet->data, "BUBL");
			SDLNet_Write32(uid, &net_packet->data[4]);
			net_packet->data[8] = Uint8(type);
			strcpy((char*)(&net_packet->data[9]), buf);
			net_packet->address.host = net_clients[player.playernum - 1].host;
			net_packet->address.port = net_clients[player.playernum - 1].port;
			net_packet->len = 9 + strlen(buf) + 1;
			sendPacketSafe(net_sock, -1, net_packet, player.playernum - 1);
			return;
		}
	}

	Dialogue_t* d = &playerDialogue;
	if ( !(type == DIALOGUE_GRAVE || type == DIALOGUE_SIGNPOST
		|| type == DIALOGUE_NPC) )
	{
		if ( type == DIALOGUE_ATTACK && (sharedDialogues.find(uid) != sharedDialogues.end()) )
		{
			if ( sharedDialogues[uid].dialogueType == DIALOGUE_ATTACK )
			{
				return; // don't process combat taunts unless previous finished
			}
		}
		d = &sharedDialogues[uid];
	}
	d->player = player.playernum;
	Uint32 oldUid = d->parent;
	real_t oldAlpha = d->alpha;
	real_t oldAnimZ = d->animZ;
	d->deactivate();
	Entity* parentEnt = uidToEntity(uid);
	if ( !parentEnt )
	{
		return;
	}
	d->parent = uid;

	char buf[1024] = { 0 };

	va_list argptr;
	va_start(argptr, message);
	vsnprintf(buf, sizeof(buf), message, argptr);
	va_end(argptr);

	if (player.playernum == clientnum)
	{
		messagePlayer(player.playernum, MESSAGE_CHATTER, buf);
	}

	d->dialogueStrFull = buf;
	d->spawnTick = ticks;
	d->updatedThisTick = 0;
	d->dialogueType = type;

	auto& setting = WorldDialogueSettings_t::settings[d->dialogueType];

	/*if ( parentEnt->bUseRenderInterpolation )
	{
		d->x = parentEnt->lerpRenderState.x.position * 16.0;
		d->y = parentEnt->lerpRenderState.y.position * 16.0;
		d->z = parentEnt->lerpRenderState.z.position + setting.offsetZ;
	}
	else*/
	{
		d->x = parentEnt->x;
		d->y = parentEnt->y;
		d->z = parentEnt->z + setting.offsetZ;
	}
	d->animZ = 1.5;
	d->drawScale = 0.1 + setting.scaleMod;

	d->active = true;
	d->init = true;
	d->alpha = 0.0;

	if ( d->parent == oldUid )
	{
		d->alpha = oldAlpha;
		d->animZ = oldAnimZ;
	}

	if ( !d->dialogueField )
	{
		d->dialogueField = new Field(1024);
		d->dialogueField->setFont("fonts/pixel_maz_multiline.ttf#16");
	}
	d->dialogueField->setText(d->dialogueStrFull.c_str());
	int maxWidth = setting.maxWidth;
	d->dialogueField->setSize(SDL_Rect{ 0, 0, maxWidth, 0 });
	d->dialogueField->reflowTextToFit(0);
	int numLines = d->dialogueField->getNumTextLines();
	if ( Font* actualFont = Font::get(d->dialogueField->getFont()) )
	{
		auto textHeight = numLines * actualFont->height(true) + 16;
		if ( auto textGet = Text::get(d->dialogueField->getLongestLine().c_str(),
			d->dialogueField->getFont(), d->dialogueField->getTextColor(),
			d->dialogueField->getOutlineColor()) )
		{
			d->dialogueField->setSize(SDL_Rect{ 0, 0, (int)textGet->getWidth() + 16, textHeight });
		}
		else
		{
			d->dialogueField->setSize(SDL_Rect{ 0, 0, maxWidth, textHeight });
		}
	}
	d->expiryTicks = setting.baseTicksToDisplay;
	if ( numLines > 1 )
	{
		d->expiryTicks += (numLines - 1) * setting.extraTicksPerLine;
	}
	d->dialogueStrFull = d->dialogueField->getText();

	if ( d->dialogueType == DIALOGUE_NPC )
	{
		// insta-show the first line (e.g The NPC:)
		size_t found = d->dialogueStrFull.find('\n');
		if ( found != std::string::npos )
		{
			size_t foundColon = d->dialogueStrFull.find(':');
			if ( foundColon != std::string::npos
				&& foundColon < found )
			{
				d->dialogueStringLength = found;

				while ( found != std::string::npos )
				{
					if ( found + 1 < d->dialogueStrFull.length() )
					{
						if ( d->dialogueStrFull[found + 1] != ' ' )
						{
							d->dialogueStrFull.insert(found + 1, 1, ' ');
							++found;
						}
					}
					found = d->dialogueStrFull.find('\n', found + 1);
				}
			}
		}
		d->dialogueField->setText(d->dialogueStrFull.c_str());
	}
}

SDL_Surface* Player::WorldUI_t::WorldTooltipDialogue_t::Dialogue_t::blitDialogueTooltip()
{
	auto& setting = WorldDialogueSettings_t::settings[dialogueType];
	const int pointerExtraHeight = 16;
	SDL_Rect tooltip{ 0, 0, dialogueField->getSize().w, dialogueField->getSize().h };
	tooltip.h += 16 + setting.padx * 2 + pointerExtraHeight;
	tooltip.w += 16 + setting.pady * 2;
	const int numLines = dialogueField->getNumTextLines();
	if ( numLines > 1 )
	{
		tooltip.h += setting.padAfterFirstLine;
	}

	if ( dialogueTooltipSurface )
	{
		SDL_FreeSurface(dialogueTooltipSurface);
		dialogueTooltipSurface = nullptr;
	}

	dialogueTooltipSurface = SDL_CreateRGBSurface(0, tooltip.w, tooltip.h, 32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000);

	SDL_Rect imgPos{ 0, 0, 0, 0 };
	if ( dialogueType == DIALOGUE_GRAVE )
	{
		dialogueField->setTextColor(makeColor(51, 45, 59, 255));
		dialogueField->setOutlineColor(makeColor(115, 127, 134, 255));

		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Grave_TL.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Grave_T.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Grave_TR.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}

		imgPos.x = 0;
		imgPos.y += imgPos.h;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Grave_L.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = tooltip.h - imgPos.h - 26 - pointerExtraHeight;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Grave_Color.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Grave_R.png") )
		{
			imgPos.w = img->getWidth();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}

		imgPos.x = 0;
		imgPos.y += imgPos.h;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Grave_BL.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Grave_B.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Grave_BR.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}

		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Grave_Pointer.png") )
		{
			imgPos.x = tooltip.w / 2;
			if ( imgPos.x % 2 == 1 )
			{
				++imgPos.x;
			}
			imgPos.y += imgPos.h - 6;
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
	}
	else if ( dialogueType == DIALOGUE_SIGNPOST )
	{
		dialogueField->setTextColor(makeColor(29, 16, 11, 255));
		dialogueField->setOutlineColor(makeColor(82, 66, 60, 255));

		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Sign_TL.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Sign_T.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Sign_TR.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}

		imgPos.x = 0;
		imgPos.y += imgPos.h;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Sign_L.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = tooltip.h - imgPos.h - 26 - pointerExtraHeight;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Sign_Color.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Sign_R.png") )
		{
			imgPos.w = img->getWidth();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}

		imgPos.x = 0;
		imgPos.y += imgPos.h;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Sign_BL.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Sign_B.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Sign_BR.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}

		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_Sign_Pointer.png") )
		{
			imgPos.x = tooltip.w / 2;
			if ( imgPos.x % 2 == 1 )
			{
				++imgPos.x;
			}
			imgPos.y += imgPos.h - 6;
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
	}
	else if ( dialogueType == DIALOGUE_NPC
		|| dialogueType == DIALOGUE_FOLLOWER_CMD
		|| dialogueType == DIALOGUE_BROADCAST
		|| dialogueType == DIALOGUE_ATTACK )
	{
		dialogueField->setTextColor(makeColor(29, 16, 11, 255));
		dialogueField->setOutlineColor(makeColor(186, 169, 128, 255));

		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_NPC_TL.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_NPC_T.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_NPC_TR.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}

		imgPos.x = 0;
		imgPos.y += imgPos.h;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_NPC_L.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = tooltip.h - imgPos.h - 26 - pointerExtraHeight;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_NPC_Color.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_NPC_R.png") )
		{
			imgPos.w = img->getWidth();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}

		imgPos.x = 0;
		imgPos.y += imgPos.h;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_NPC_BL.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_NPC_B.png") )
		{
			imgPos.w = tooltip.w - imgPos.w * 2;
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
		imgPos.x += imgPos.w;
		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_NPC_BR.png") )
		{
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}

		if ( auto img = Image::get("*#images/ui/TextBubbles/Textbox_NPC_Pointer.png") )
		{
			imgPos.x = tooltip.w / 2;
			if ( imgPos.x % 2 == 1 )
			{
				++imgPos.x;
			}
			imgPos.y += imgPos.h - 6;
			imgPos.w = img->getWidth();
			imgPos.h = img->getHeight();
			SDL_Surface* srcSurf = const_cast<SDL_Surface*>(img->getSurf());
			SDL_BlitScaled(srcSurf, nullptr, dialogueTooltipSurface, &imgPos);
		}
	}

	SDL_Rect txtPos{ 16 + setting.padx, 9 + setting.pady, 0, 0 };
	int fontHeight = Font::get(dialogueField->getFont())->height(true);
	std::string buf;
	int linesDone = 0;
	for ( size_t i = 0; i < dialogueStrCurrent.length(); ++i )
	{
		if ( dialogueStrCurrent[i] == '\n' || i == dialogueStrCurrent.length() - 1 )
		{
			if ( i == dialogueStrCurrent.length() - 1 
				&& dialogueStrCurrent[i] != '\r'
				&& dialogueStrCurrent[i] != '\n' )
			{
				buf += dialogueStrCurrent[i];
			}
			if ( auto textGet = Text::get(buf.c_str(), dialogueField->getFont(),
				dialogueField->getTextColor(), dialogueField->getOutlineColor()) )
			{
				bool quoteOffsetY = 0;
				size_t foundEOL = dialogueStrCurrent.find('\0', i + 1);
				size_t foundNewLine = dialogueStrCurrent.find('\n', i + 1);
				size_t foundQuote = dialogueStrCurrent.find('\"', i + 1);
				if ( foundNewLine != std::string::npos && foundEOL != std::string::npos
					&& foundNewLine < foundEOL )
				{
					if ( foundQuote < foundNewLine )
					{
						// this line has a quote after first char
						// adjust line spacing to account for offset quote introduces
						quoteOffsetY = -2; 
					}
				}
				else if ( foundEOL != std::string::npos )
				{
					if ( foundQuote < foundEOL )
					{
						// this line has a quote after first char
						// adjust line spacing to account for offset quote introduces
						quoteOffsetY = -2;
					}
				}
				txtPos.y += quoteOffsetY;
				SDL_BlitSurface(const_cast<SDL_Surface*>(textGet->getSurf()), nullptr, dialogueTooltipSurface, &txtPos);
				txtPos.y -= quoteOffsetY;
				txtPos.y += fontHeight;
				if ( linesDone == 0 )
				{
					txtPos.y += setting.padAfterFirstLine;
				}
			}
			buf = "";
			++linesDone;
			continue;
		}
		else if ( dialogueStrCurrent[i] != '\r' )
		{
			buf += dialogueStrCurrent[i];
		}
	}
	return dialogueTooltipSurface;
}

void handleDamageIndicatorTicks()
{
	for ( int i = 0; i < MAXPLAYERS; ++i )
	{
		for ( auto& ind : DamageIndicatorHandler.indicators[i] )
		{
			if ( ind.ticks > 0 )
			{
				--ind.ticks;
			}
		}
	}
}

void DamageIndicatorHandler_t::update()
{
	for ( int i = 0; i < MAXPLAYERS; ++i )
	{
		for ( auto it = indicators[i].begin(); it != indicators[i].end(); )
		{
			it->process();
			if ( it->expired )
			{
				it = indicators[i].erase(it);
			}
			else
			{
				++it;
			}
		}
	}
}
void DamageIndicatorHandler_t::insert(const int player, const real_t _x, const real_t _y, const bool damaged)
{
	for ( auto it = indicators[player].begin(); it != indicators[player].end(); ++it )
	{
		if ( !it->expired && it->x == _x && it->y == _y && it->hitDealtDamage == damaged )
		{
			// matching, delete this one
			indicators[player].erase(it);
			break;
		}
	}
	indicators[player].push_back(DamageIndicator_t(player));
	auto& i = indicators[player].at(indicators[player].size() - 1);
	i.alpha = 255.0;
	i.ticks = damageIndicatorSettings.deleteAfterTicks;
	i.x = _x;
	i.y = _y;
	i.flashTicks = ::ticks;
	i.flashAnimState = -1;
	i.hitDealtDamage = damaged;
}

static ConsoleVariable<int> cvar_indicatoranimdebug("/indicatoranimdebug", 1);

void DamageIndicatorHandler_t::DamageIndicator_t::process()
{
	if ( expired )
	{
		return;
	}
	double tangent = atan2(y / 16 - cameras[player].y, x / 16 - cameras[player].x);
	double angle = tangent - cameras[player].ang;
	angle += 3 * PI / 2;
	while ( angle >= PI )
	{
		angle -= PI * 2;
	}
	while ( angle < -PI )
	{
		angle += PI * 2;
	}

	const int framesPerAnimation = 1 * *cvar_indicatoranimdebug;
	const int numAnimationFrames = damageIndicatorSettings.deleteAfterTicks * *cvar_indicatoranimdebug;
	auto layout = DamageIndicatorSettings_t::LAYOUT_DEFAULT;
	if ( players[player]->bUseCompactGUIHeight() && players[player]->bUseCompactGUIWidth() )
	{
		layout = DamageIndicatorSettings_t::LAYOUT_4P;
	}
	else if ( !players[player]->bUseCompactGUIHeight() && players[player]->bUseCompactGUIWidth() )
	{
		layout = DamageIndicatorSettings_t::LAYOUT_2P_TALL;
	}
	else if ( players[player]->bUseCompactGUIHeight() && !players[player]->bUseCompactGUIWidth() )
	{
		layout = DamageIndicatorSettings_t::LAYOUT_2P_WIDE;
	}
	size = damageIndicatorSettings.settings[layout].image_size;
	auto& indicatorDamagePaths = damageIndicatorSettings.indicatorDamageFramePaths;
	auto& indicatorBlockPaths = damageIndicatorSettings.indicatorBlockedFramePaths;
	std::string imagePath = hitDealtDamage ? indicatorDamagePaths[0] : indicatorBlockPaths[0];
	if ( flashTicks > 0 )
	{
		if ( flashAnimState > numAnimationFrames )
		{
			flashTicks = 0;
			flashAnimState = -1;
			alpha = 0.0;
		}
		else
		{
			if ( ::ticks == flashTicks )
			{
				flashAnimState = 1;
				flashProcessedOnTick = ::ticks;
			}
			else if ( (flashProcessedOnTick != ::ticks)
				&& (::ticks > flashTicks)
				&& (::ticks - flashTicks) % framesPerAnimation == 0 )
			{
				++flashAnimState;
				flashProcessedOnTick = ::ticks;
			}

			if ( flashAnimState <= 6 )
			{
				alpha = 255.0;
			}

			if ( flashAnimState == 0 )
			{
				imagePath = hitDealtDamage ? indicatorDamagePaths[0] : indicatorBlockPaths[0];
			}
			else if ( flashAnimState >= 1 && flashAnimState <= 2 )
			{
				imagePath = hitDealtDamage ? indicatorDamagePaths[0] : indicatorBlockPaths[0];
			}
			else if ( flashAnimState == 3 )
			{
				imagePath = hitDealtDamage ? indicatorDamagePaths[2] : indicatorBlockPaths[2];
			}
			else if ( flashAnimState >= 4 && flashAnimState <= 5 )
			{
				imagePath = hitDealtDamage ? indicatorDamagePaths[1] : indicatorBlockPaths[1];
			}
			else if ( flashAnimState == 6 )
			{
				imagePath = hitDealtDamage ? indicatorDamagePaths[3] : indicatorBlockPaths[3];
			}
			else if ( flashAnimState >= damageIndicatorSettings.fadeAfterTicks )
			{
				imagePath = hitDealtDamage ? indicatorDamagePaths[0] : indicatorBlockPaths[0];
				int decrement = 20;
				real_t fpsScale = (getFPSScale(60.0)) / damageIndicatorSettings.fadeSpeed;
				decrement *= fpsScale;
				alpha = std::max(0, (int)alpha - decrement);
			}
		}
	}

	switch ( size )
	{
		case 3:
			imagePath += "_3x.png";
			break;
		case 2:
			imagePath += "_2x.png";
			break;
		case 1:
		default:
			imagePath += "_1x.png";
			break;
	}

	if ( auto imgGet = Image::get(imagePath.c_str()) )
	{
		SDL_Rect pos;
		pos.x = players[player]->camera_midx();
		pos.y = players[player]->camera_midy();
		const float factorX = (float)xres / Frame::virtualScreenX;
		const float factorY = (float)yres / Frame::virtualScreenY;
		pos.x += damageIndicatorSettings.settings[layout].radius_x * cos(angle) * factorX;
		pos.y += damageIndicatorSettings.settings[layout].radius_y * sin(angle) * factorY;
		pos.w = imgGet->getWidth() * factorX;
		pos.h = imgGet->getHeight() * factorY;
		if ( stats[player]->HP > 0 )
		{
			const SDL_Rect viewport{ 0, 0, xres, yres };
			imgGet->drawRotated(nullptr, pos, viewport, makeColor(255, 255, 255, (Uint8)alpha), angle);
		}
	}

	if ( alpha <= 0 || ticks == 0 )
	{
		expired = true;
	}
}

void createLevelUpFrame(const int player)
{
	auto& hud_t = players[player]->hud;
	hud_t.levelupFrame = gameUIFrame[player]->addFrame("levelup");
	hud_t.levelupFrame->setHollow(true);
	hud_t.levelupFrame->setInheritParentFrameOpacity(false);
	hud_t.levelupFrame->setOpacity(100.0);
	hud_t.levelupFrame->setDisabled(true);
	hud_t.levelupFrame->setOwner(player);

	auto lvlupImg = hud_t.levelupFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "images/ui/HUD/lvluptext.png", "lvl up img");
	lvlupImg->disabled = true;

	auto statsFrame = hud_t.levelupFrame->addFrame("stats");
	statsFrame->setDisabled(true);
	statsFrame->setHollow(true);
	char name[32];
	std::string font = "fonts/pixelmix.ttf#16#2";
	for ( int i = 0; i < 6; ++i )
	{
		snprintf(name, sizeof(name), "stat %d", i);
		auto statFrame = statsFrame->addFrame(name);
		statFrame->setDisabled(true);
		statFrame->setHollow(true);
		statFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "stat img");

		auto statCurrentTxt = statFrame->addField("stat current", 32);
		statCurrentTxt->setFont(font.c_str());
		statCurrentTxt->setHJustify(Field::justify_t::RIGHT);
		statCurrentTxt->setVJustify(Field::justify_t::TOP);
		statCurrentTxt->setText("0");

		auto statIncreaseTxt = statFrame->addField("stat increase", 32);
		statIncreaseTxt->setFont(font.c_str());
		statIncreaseTxt->setHJustify(Field::justify_t::LEFT);
		statIncreaseTxt->setVJustify(Field::justify_t::TOP);
		statIncreaseTxt->setText("0");
	}
}

static ConsoleVariable<int> cvar_lvlup_sfx("/lvlup_sfx", 526);
Uint32 levelupSoundDelay = 0;
void LevelUpAnimation_t::addLevelUp(const int currentLvl, const int increaseLvl, std::vector<LevelUp_t::StatUp_t>& statInfo)
{
	if ( lvlUps.size() > 2 )
	{
		// stack everything onto the back
		auto& lvlUp = lvlUps.back();
		for ( auto& info : statInfo )
		{
			for ( auto& currentInfo : lvlUp.statUps )
			{
				if ( currentInfo.whichStat == info.whichStat )
				{
					if ( info.increaseStat > 0 ) // ignore negatives
					{
						currentInfo.increaseStat += info.increaseStat;
					}
				}
			}
		}
	}
	else
	{
		bool inProgress = !lvlUps.empty();
		lvlUps.push_back(LevelUp_t(currentLvl, increaseLvl));
		auto& lvlUp = lvlUps.back();
		if ( inProgress )
		{
			// skip some animation
			lvlUp.titleFinishAnim = true;
			lvlUp.animTitleFade = 1.0;
			lvlUp.ticksToLive = 3 * TICKS_PER_SECOND;
		}
		else
		{
			for ( int i = 0; i < MAXPLAYERS; ++i )
			{
				if ( &levelUpAnimation[i] == this )
				{
					if ( levelupSoundDelay == 0 || ((ticks - levelupSoundDelay) > (TICKS_PER_SECOND / 10)) )
					{
						playSoundNotificationPlayer(i, *cvar_lvlup_sfx, 255);
						levelupSoundDelay = TICKS_PER_SECOND / 10;
					}
					break;
				}
			}
			levelupSoundDelay = ticks;
		}

		for ( int i = 0; i < NUMSTATS; ++i )
		{
			for ( auto& statUp : statInfo )
			{
				if ( statUp.whichStat == i )
				{
					lvlUp.statUps.push_back(statUp);
				}
			}
		}
	}
}

void LevelUpAnimation_t::LevelUp_t::StatUp_t::setAnimatePosition(int destx, int desty, int destw, int desth)
{
	animateStartX = pos.x;
	animateStartY = pos.y;
	animateStartW = pos.w;
	animateStartH = pos.h;
	animateSetpointX = destx;
	animateSetpointY = desty;
	animateSetpointW = destw;
	animateSetpointH = desth;
	animateX = 0.0;
	animateY = 0.0;
	animateW = 0.0;
	animateH = 0.0;
}

void LevelUpAnimation_t::LevelUp_t::StatUp_t::setAnimatePosition(int destx, int desty)
{
	animateStartX = pos.x;
	animateStartY = pos.y;
	animateStartW = pos.w;
	animateStartH = pos.h;
	animateSetpointX = destx;
	animateSetpointY = desty;
	animateSetpointW = 0;
	animateSetpointH = 0;
	animateX = 0.0;
	animateY = 0.0;
	animateW = 0.0;
	animateH = 0.0;
}

static ConsoleVariable<int> cvar_skill_ding_sfx("/skill_sfx_ding", 554);
static ConsoleVariable<int> cvar_lvl_ding_sfx("/lvl_sfx_ding", 555);
static ConsoleVariable<int> cvar_skill_sfx_volume("/skill_sfx_volume", 128);
static ConsoleVariable<int> cvar_skill_newspell_sfx("/skill_sfx_newspell", 560);

bool SkillUpAnimation_t::soundIndexUsedForNotification(const int index)
{
	if ( index == 0 ) { return false; }
	if ( index >= *cvar_skill_ding_sfx && index <= *cvar_skill_ding_sfx + 3 )
	{
		return true;
	}
	else if ( index == CalloutRadialMenu::CALLOUT_SFX_NEGATIVE
		|| index == CalloutRadialMenu::CALLOUT_SFX_NEUTRAL
		|| index == CalloutRadialMenu::CALLOUT_SFX_POSITIVE )
	{
		return true;
	}
	else if ( index == Message::CHAT_MESSAGE_SFX )
	{
		return true;
	}
	else if ( index == *cvar_lvl_ding_sfx )
	{
		return true;
	}
	else if ( index == *cvar_skill_newspell_sfx )
	{
		return true;
	}
	else
	{
		for ( auto skill : Player::SkillSheet_t::skillSheetData.skillEntries )
		{
			if ( index == skill.skillSfx )
			{
				return true;
			}
		}
	}
	return false;
}

void LevelUpAnimation_t::LevelUp_t::StatUp_t::animateNotification(const int player)
{
	real_t animspeed = 5.0 / (4.0);
	static ConsoleVariable<float> cvar_lvlup_speed("/lvlup_speed", .5);
	static ConsoleVariable<float> cvar_lvlup_bounce("/lvlup_bounce", 1.0 /*2.5*/);
	static ConsoleVariable<float> cvar_lvlup_animfall("/lvlup_animfall", 0.5/*2.0*/);
	static ConsoleVariable<int> cvar_lvlup_ding_volume("/lvlup_ding_volume", 64);
	animspeed *= *cvar_lvlup_speed;
	int movementAmount = 0;
	if ( players[player]->bUseCompactGUIHeight() )
	{
		movementAmount = 0;
	}

	if ( ticks != processedOnTick )
	{
		processedOnTick = ticks;
		++ticksActive;
	}

	const real_t largestScaling = 2.0;
	real_t midScaling = 2.0;
	const int normalSize = 36;
	const int baseEffectPosX = baseX;
	const int baseEffectPosY = baseY;

	switch ( notificationState )
	{
		case STATE_1:
			if ( notificationStateInit == STATE_1 )
			{
				notificationStateInit = STATE_2;
				setAnimatePosition(
					baseEffectPosX - movementAmount,
					baseEffectPosY - movementAmount,
					normalSize, normalSize);
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_2;
			}
			animspeed *= .01;
			break;
		case STATE_2:
			if ( notificationStateInit == STATE_2 )
			{
				notificationStateInit = STATE_3;
				setAnimatePosition(
					baseEffectPosX - movementAmount - (largestScaling - 1.0) * normalSize / 2,
					baseEffectPosY - movementAmount - (largestScaling - 1.0) * normalSize / 2,
					normalSize * largestScaling,
					normalSize * largestScaling);
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_3;
			}
			animspeed *= 4.0;
			break;
		case STATE_3:
			if ( notificationStateInit == STATE_3 )
			{
				midScaling = 1.0;
				notificationStateInit = STATE_4;
				setAnimatePosition(
					baseEffectPosX - movementAmount - (midScaling - 1.0) * normalSize / 2,
					baseEffectPosY - movementAmount - (midScaling - 1.0) * normalSize / 2,
					normalSize * midScaling,
					normalSize * midScaling);
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_4;
			}
			animspeed *= 4.0;
			break;
		case STATE_4:
			if ( notificationStateInit == STATE_4 )
			{
				notificationStateInit = STATE_END;
				setAnimatePosition(notificationTargetPosition.x,
					notificationTargetPosition.y,
					notificationTargetPosition.w,
					notificationTargetPosition.h);
			}
			if ( notificationTargetPosition.x != animateSetpointX
				|| notificationTargetPosition.y != animateSetpointY
				|| notificationTargetPosition.w != animateSetpointW
				|| notificationTargetPosition.h != animateSetpointH )
			{
				// re update this as our target moved.
				setAnimatePosition(notificationTargetPosition.x,
					notificationTargetPosition.y,
					notificationTargetPosition.w,
					notificationTargetPosition.h);
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_END;
			}
			animspeed *= 2.0;
			break;
		case STATE_END:
		{
			const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
			if ( ticksActive >= TICKS_PER_SECOND )
			{
				real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - animCurrentStat)) / (2.5 * *cvar_lvlup_animfall);
				animCurrentStat += setpointDiffX;
				animCurrentStat = std::min(1.0, animCurrentStat);

				if ( animCurrentStat >= 1.0 )
				{
					const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
					real_t setpointDiffX = fpsScale * 1.0 / (10.0 * *cvar_lvlup_bounce);
					animIncreaseStat += setpointDiffX;
					animIncreaseStat = std::min(1.0, animIncreaseStat);
				}
			}
			return;
		}
		default:
			break;
	}

	real_t oldAngle = animAngle;
	const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
	animAngle += fpsScale * std::max(.1, (1.0 - animAngle)) / (5.0);
	animAngle = std::min(1.0, animAngle);
	if ( animAngle > 0.0 && oldAngle <= 0.001 )
	{
		playSound(*cvar_lvl_ding_sfx, *cvar_lvlup_ding_volume);
	}
	real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - animateX)) / (animspeed);
	real_t setpointDiffY = fpsScale * std::max(.1, (1.0 - animateY)) / (animspeed);
	real_t setpointDiffW = fpsScale * std::max(.1, (1.0 - animateW)) / (animspeed);
	real_t setpointDiffH = fpsScale * std::max(.1, (1.0 - animateH)) / (animspeed);
	animateX += setpointDiffX;
	animateY += setpointDiffY;
	animateX = std::min(1.0, animateX);
	animateY = std::min(1.0, animateY);
	animateW += setpointDiffW;
	animateH += setpointDiffH;
	animateW = std::min(1.0, animateW);
	animateH = std::min(1.0, animateH);

	int destX = animateSetpointX - animateStartX;
	int destY = animateSetpointY - animateStartY;
	int destW = animateSetpointW - animateStartW;
	int destH = animateSetpointH - animateStartH;

	pos.x = animateStartX + destX * animateX;
	pos.y = animateStartY + destY * animateY;
	pos.w = animateStartW + destW * animateW;
	pos.h = animateStartH + destH * animateH;
}

void LevelUpAnimation_t::LevelUp_t::animateTitle(SDL_Rect basePos)
{
	if ( ticksActive == 0 )
	{
		titleAnimatePos = basePos;
	}

	static ConsoleVariable<int> cvar_lvlup_title_ticks("/lvlup_title_ticks", 15);
	static ConsoleVariable<int> cvar_lvlup_title_fade_ticks("/lvlup_title_fade_ticks", TICKS_PER_SECOND);
	real_t anim = std::min(1.0, ticksActive / (real_t)*cvar_lvlup_title_ticks);
	real_t grow = 1.0;

	real_t curvePosition = (LevelUpAnimBreakpoints[anim * (LevelUpAnimBreakpoints.size() - 1)]) / 100.0;

	//titleAnimatePos.x = basePos.x - anim * (grow) * basePos.w / 2;
	//titleAnimatePos.y = basePos.y - anim * (grow) * basePos.h / 2;
	//titleAnimatePos.w = basePos.w + anim * grow * basePos.w;
	//titleAnimatePos.h = basePos.h + anim * grow * basePos.h;
	titleAnimatePos.x = basePos.x - curvePosition * basePos.w / 2;
	titleAnimatePos.y = basePos.y - curvePosition * basePos.h / 2;
	titleAnimatePos.w = basePos.w + curvePosition * basePos.w;
	titleAnimatePos.h = basePos.h + curvePosition * basePos.h;

	if ( ticksActive >= *cvar_lvlup_title_fade_ticks )
	{
		titleFinishAnim = true;
		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
		animTitleFade += fpsScale * std::max(.1, (1.0 - animTitleFade)) / (5.0);
		animTitleFade = std::min(1.0, animTitleFade);

		titleAnimatePos.y += animTitleFade * titleAnimatePos.h;
	}
}

void updateLevelUpFrame(const int player)
{
	auto& hud_t = players[player]->hud;
	if ( !hud_t.levelupFrame )
	{
		createLevelUpFrame(player);
	}

	if ( !hud_t.levelupFrame || !hud_t.hudFrame )
	{
		return;
	}

	if ( !players[player]->isLocalPlayer() || hud_t.hudFrame->isDisabled() )
	{
		hud_t.levelupFrame->setDisabled(true);
		return;
	}

	if ( gamePaused && multiplayer == SINGLE )
	{
		return;
	}

	auto frame = hud_t.levelupFrame;
	auto& lvlUpAnimation = levelUpAnimation[player];

	static ConsoleVariable<int> cvar_lvlup_debug("/lvlup_debug", 0);
	if ( *cvar_lvlup_debug > 0 )
	{
		std::vector<int> statPicks;
		std::vector<unsigned int> statWeight = { 1, 1, 1, 1, 1, 1 };
		if ( *cvar_lvlup_debug != 1 )
		{
			for ( int i = 0; i < std::min(*cvar_lvlup_debug, NUMSTATS); ++i )
			{
				int stat = local_rng.discrete(statWeight.data(), statWeight.size());
				statWeight[stat] = 0;
				statPicks.push_back(stat);
			}
		}
		else
		{
			for ( int i = 0; i < 3; ++i )
			{
				int stat = local_rng.discrete(statWeight.data(), statWeight.size());
				statWeight[stat] = 0;
				statPicks.push_back(stat);
			}
		}
		int currentStat = 0;
		int increaseStat = 1;
		std::vector<LevelUpAnimation_t::LevelUp_t::StatUp_t> StatUps;
		for ( int i = 0; i < statPicks.size(); ++i )
		{
			if ( *cvar_lvlup_debug != 1 )
			{
				increaseStat = local_rng.rand() % 2;
			}
			switch ( statPicks[i] )
			{
				case STAT_STR:
					currentStat = stats[player]->STR;
					break;
				case STAT_DEX:
					currentStat = stats[player]->DEX;
					break;
				case STAT_CON:
					currentStat = stats[player]->CON;
					break;
				case STAT_INT:
					currentStat = stats[player]->INT;
					break;
				case STAT_PER:
					currentStat = stats[player]->PER;
					break;
				case STAT_CHR:
					currentStat = stats[player]->CHR;
					break;
				default:
					break;
			}

			StatUps.push_back(LevelUpAnimation_t::LevelUp_t::StatUp_t(statPicks[i], currentStat, increaseStat));
		}

		/*lvlUpAnimation.lvlUps.clear();*/
		lvlUpAnimation.addLevelUp(stats[player]->LVL, 1, StatUps);

		for ( auto& lvlUp : lvlUpAnimation.lvlUps )
		{
			messagePlayer(player, MESSAGE_DEBUG, "Lvl: [%d %d]", lvlUp.currentLvl, lvlUp.increaseLvl);
			for ( auto& statUp : lvlUp.statUps )
			{
				messagePlayer(player, MESSAGE_DEBUG, "Stat: %d: [%d %d]", statUp.whichStat, statUp.currentStat, statUp.increaseStat);
			}
		}
		*cvar_lvlup_debug = 0;
	}

	if ( lvlUpAnimation.lvlUps.empty() )
	{
		hud_t.levelupFrame->setDisabled(true);
		return;
	}

	if ( lvlUpAnimation.lvlUps.front().expired )
	{
		const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
		lvlUpAnimation.lvlUps.front().fadeout += fpsScale * std::max(.1, (1.0 - lvlUpAnimation.lvlUps.front().fadeout)) / (5.0);
		lvlUpAnimation.lvlUps.front().fadeout = std::min(1.0, lvlUpAnimation.lvlUps.front().fadeout);
		hud_t.levelupFrame->setOpacity(hud_t.hudFrame->getOpacity() 
			* (1.0 - lvlUpAnimation.lvlUps.front().fadeout));
		if ( lvlUpAnimation.lvlUps.front().fadeout >= 1.0 )
		{
			lvlUpAnimation.lvlUps.pop_front();
		}
	}

	if ( lvlUpAnimation.lvlUps.empty() )
	{
		hud_t.levelupFrame->setDisabled(true);
		return;
	}

	auto& lvlUp = lvlUpAnimation.lvlUps.front();

	static ConsoleVariable<int> cvar_lvlup_angle("/lvlup_angle", 16);
	static ConsoleVariable<int> cvar_lvlup_falldist("/lvlup_falldist", 64);
	static ConsoleVariable<int> cvar_lvlup_currentstatY("/lvlup_currentstatY", -10);
	static ConsoleVariable<int> cvar_lvlup_increasestatY("/lvlup_increasestatY", 0);

	if ( !lvlUp.expired )
	{
		hud_t.levelupFrame->setOpacity(hud_t.hudFrame->getOpacity());
	}
	hud_t.levelupFrame->setDisabled(false);
	const int frameWidth = 600;


	auto lvlupImg = hud_t.levelupFrame->findImage("lvl up img");
	lvlupImg->disabled = false;
	if ( auto imgGet = Image::get(lvlupImg->path.c_str()) )
	{
		lvlupImg->pos.w = imgGet->getWidth();
		lvlupImg->pos.h = imgGet->getHeight();
		lvlupImg->pos.x = frameWidth / 2 - lvlupImg->pos.w / 2;
		lvlupImg->pos.y = 0;
	}

	SDL_Rect statsFramePos{ frameWidth / 2, 0, 0, 200 };
	auto statsFrame = hud_t.levelupFrame->findFrame("stats");
	statsFrame->setDisabled(true);

	lvlUp.animateTitle(lvlupImg->pos);
	lvlupImg->pos = lvlUp.titleAnimatePos;
	lvlupImg->color = makeColor(255, 255, 255, 255 * (1.0 - lvlUp.animTitleFade));
	if ( lvlUp.titleFinishAnim )
	{
		statsFrame->setDisabled(false);
	}

	int index = 0;
	SDL_Rect statFramePos{ 0, 0, 0, 200 };
	const int statSpacing = 64;
	int statStartX = 100;
	std::vector<int> statPosX;
	auto prevNotificationState = LevelUpAnimation_t::LevelUp_t::StatUp_t::NotificationStates_t::STATE_END;
	for ( auto statFrame : statsFrame->getFrames() )
	{
		if ( statsFrame->isDisabled() )
		{
			statFrame->setDisabled(true);
			continue;
		}
		int currentIndex = index;
		++index;
		if ( currentIndex >= lvlUp.statUps.size() )
		{
			statFrame->setDisabled(true);
			continue;
		}
		auto& statUp = lvlUp.statUps[currentIndex];
		auto statImg = statFrame->findImage("stat img");
		statImg->path = "";
		statImg->disabled = true;
		switch ( statUp.whichStat )
		{
			case STAT_STR:
				//statImg->path = Player::CharacterSheet_t::getHoverTextString("icon_str_path");
				statImg->path = "images/ui/HUD/HUD_StatUp_STR_00.png";
				break;
			case STAT_DEX:
				statImg->path = "images/ui/HUD/HUD_StatUp_DEX_00.png";
				break;
			case STAT_CON:
				statImg->path = "images/ui/HUD/HUD_StatUp_CON_00.png";
				break;
			case STAT_INT:
				statImg->path = "images/ui/HUD/HUD_StatUp_INT_00.png";
				break;
			case STAT_PER:
				statImg->path = "images/ui/HUD/HUD_StatUp_PER_00.png";
				break;
			case STAT_CHR:
				statImg->path = "images/ui/HUD/HUD_StatUp_CHA_00.png";
				break;
			default:
				break;
		}

		char buf[32] = "";

		if ( statImg->path == "" ) { continue; }

		if ( auto imgGet = Image::get(statImg->path.c_str()) )
		{
			statImg->pos.w = imgGet->getWidth();
			statImg->pos.h = imgGet->getHeight();
			statImg->disabled = false;
		}
		statImg->pos.x = 32;
		int baseImgY = 48;
		if ( players[player]->bUseCompactGUIHeight() )
		{
			baseImgY = 40;
		}
		statImg->pos.y = baseImgY - statImg->pos.h / 2;

		snprintf(buf, sizeof(buf), "%+d", statUp.increaseStat);
		auto statIncreaseTxt = statFrame->findField("stat increase");
		statIncreaseTxt->setDisabled(statUp.increaseStat == 0);
		statIncreaseTxt->setText(buf);
		if ( auto textGet = statIncreaseTxt->getTextObject() )
		{
			SDL_Rect pos;
			pos.x = statImg->pos.x + statImg->pos.w + 8;
			pos.y = baseImgY - 8;
			pos.w = std::max(40, (int)textGet->getWidth());
			pos.h = std::max(24, (int)textGet->getHeight());

			statIncreaseTxt->setColor(makeColor(255, 255, 255, (1.0 - statUp.animCurrentStat) * statUp.animAngle * 255));
			pos.x += -*cvar_lvlup_angle * cos(PI / 2 + (3 * statUp.animAngle * (PI / 2)));
			pos.y += (*cvar_lvlup_angle) - (*cvar_lvlup_angle * sin(PI / 2 + (3 * statUp.animAngle * (PI / 2))));
			pos.y += *cvar_lvlup_increasestatY;
			statIncreaseTxt->setSize(pos);
		}

		snprintf(buf, sizeof(buf), "%d", statUp.currentStat + statUp.increaseStat);
		auto statCurrentTxt = statFrame->findField("stat current");
		statCurrentTxt->setDisabled(!(statUp.ticksActive >= TICKS_PER_SECOND * 1));
		statCurrentTxt->setText(buf);
		if ( auto textGet = statCurrentTxt->getTextObject() )
		{
			SDL_Rect pos;
			pos.w = textGet->getWidth();
			pos.h = textGet->getHeight();
			pos.x = statImg->pos.x + statImg->pos.w / 2 - pos.w / 2;
			pos.y = statImg->pos.y + statImg->pos.h + 4;
			pos.y += *cvar_lvlup_currentstatY;
			if ( statUp.increaseStat != 0 )
			{
				pos.y += -((1.0 - statUp.animCurrentStat) * *cvar_lvlup_falldist);
				pos.y += -4 + 4 * (cos(statUp.animIncreaseStat * 2 * PI));
			}
			statCurrentTxt->setSize(pos);

			Uint8 r, g, b, a;
			getColor(0xFFFFFFFF, &r, &g, &b, &a);
			statCurrentTxt->setColor(makeColor(r, g, b, statUp.animCurrentStat * a));
		}

		statFramePos.w = 120;
		statFrame->setSize(statFramePos);

		statPosX.push_back(statFramePos.x + statImg->pos.x + statImg->pos.w / 2);
		statFramePos.x += statSpacing;

		if ( !statUp.init && (prevNotificationState == LevelUpAnimation_t::LevelUp_t::StatUp_t::NotificationStates_t::STATE_END
			|| prevNotificationState >= LevelUpAnimation_t::LevelUp_t::StatUp_t::NotificationStates_t::STATE_3) )
		{
			statUp.notificationTargetPosition.x = statImg->pos.x;
			statUp.notificationTargetPosition.y = statImg->pos.y;
			statUp.notificationTargetPosition.w = statImg->pos.w;
			statUp.notificationTargetPosition.h = statImg->pos.h;
			statUp.baseX = statImg->pos.x;
			statUp.baseY = statImg->pos.y;
			statUp.pos.x = statUp.baseX;
			statUp.pos.y = statUp.baseY;
			statUp.pos.w = statImg->pos.w;
			statUp.pos.h = statImg->pos.h;
			statUp.init = true;
		}

		if ( statUp.init )
		{
			statUp.animateNotification(player);
			statFrame->setDisabled(false);
		}
		else
		{
			statFrame->setDisabled(true);
		}
		statImg->pos = statUp.pos;
		statsFramePos.w = statFramePos.x + statFramePos.w;
		statStartX += statSpacing;

		prevNotificationState = statUp.notificationState;
	}

	int midpoint = 0;
	if ( statPosX.size() > 1 )
	{
		if ( statPosX.size() % 2 == 1 )
		{
			midpoint = statPosX[size_t(statPosX.size() / 2)];
		}
		else
		{
			size_t midIndex1 = std::max((size_t)0, (statPosX.size() / 2) - 1);
			size_t midIndex2 = (statPosX.size() / 2);
			midpoint = statPosX[midIndex1] + (statPosX[midIndex2] - statPosX[midIndex1]) / 2;
		}
		statsFramePos.x -= midpoint;
	}
	else if ( statPosX.size() == 1 )
	{
		statsFramePos.x -= statPosX[0];
	}
	else
	{
		statsFramePos.x -= statsFramePos.w / 2;
	}
	if ( statsFramePos.x % 2 == 1 )
	{
		++statsFramePos.x;
	}
	statsFrame->setSize(statsFramePos);
	if ( ticks != lvlUp.processedOnTick )
	{
		lvlUp.processedOnTick = ticks;
		++lvlUp.ticksActive;
	}

	static ConsoleVariable<int> cvar_lvlup_framey("/lvlup_framey", 16);
	SDL_Rect levelUpFramePos{ hud_t.hudFrame->getSize().w / 2 - frameWidth / 2, *cvar_lvlup_framey,
		frameWidth, std::max(lvlupImg->pos.y + lvlupImg->pos.h, statsFramePos.y + statsFramePos.h)};
	levelUpFramePos.x += players[player]->camera_virtualx1();
	levelUpFramePos.y += players[player]->camera_virtualy1();
	levelUpFramePos.y += lvlUp.fadeout * *cvar_lvlup_falldist;
	hud_t.levelupFrame->setSize(levelUpFramePos);

	if ( lvlUp.ticksActive >= lvlUp.ticksToLive )
	{
		lvlUp.expired = true;
	}
}

SkillUpAnimation_t skillUpAnimation[MAXPLAYERS];

void createSkillUpFrame(const int player)
{
	auto& hud_t = players[player]->hud;
	hud_t.skillupFrame = gameUIFrame[player]->addFrame("skillup");
	hud_t.skillupFrame->setHollow(true);
	hud_t.skillupFrame->setInheritParentFrameOpacity(false);
	hud_t.skillupFrame->setOpacity(100.0);
	hud_t.skillupFrame->setDisabled(true);
	hud_t.skillupFrame->setOwner(player);

	auto skillsFrame = hud_t.skillupFrame->addFrame("skills");
	skillsFrame->setDisabled(true);
	skillsFrame->setHollow(true);
	char name[32];
	std::string font = "fonts/pixelmix.ttf#16#2";

	auto skillFrame = skillsFrame->addFrame("skill");
	skillFrame->setDisabled(true);
	skillFrame->setHollow(true);

	skillFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "skill bg img");
	skillFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "skill bg cap img");
	skillFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "skill border img");
	skillFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "skill img");
	skillFrame->addImage(SDL_Rect{ 0, 0, 0, 0 }, 0xFFFFFFFF, "", "skill gleam");

	auto skillCurrentTxt = skillFrame->addField("skill current", 32);
	skillCurrentTxt->setFont(font.c_str());
	skillCurrentTxt->setHJustify(Field::justify_t::RIGHT);
	skillCurrentTxt->setVJustify(Field::justify_t::TOP);
	skillCurrentTxt->setText("0");

	auto skillCurrentOldTxt = skillFrame->addField("skill current old", 32);
	skillCurrentOldTxt->setFont(font.c_str());
	skillCurrentOldTxt->setHJustify(Field::justify_t::RIGHT);
	skillCurrentOldTxt->setVJustify(Field::justify_t::TOP);
	skillCurrentOldTxt->setText("0");

	auto skillIncreaseTxt = skillFrame->addField("skill increase", 32);
	skillIncreaseTxt->setFont(font.c_str());
	skillIncreaseTxt->setHJustify(Field::justify_t::LEFT);
	skillIncreaseTxt->setVJustify(Field::justify_t::TOP);
	skillIncreaseTxt->setText("0");

	std::string font2 = "fonts/pixel_maz.ttf#32#2";
	auto skillNameTxt = skillFrame->addField("skill name txt", 64);
	skillNameTxt->setFont(font2.c_str());
	skillNameTxt->setHJustify(Field::justify_t::RIGHT);
	skillNameTxt->setVJustify(Field::justify_t::TOP);
	skillNameTxt->setText("");
}

void SkillUpAnimation_t::SkillUp_t::setAnimatePosition(int destx, int desty, int destw, int desth)
{
	animateStartX = pos.x;
	animateStartY = pos.y;
	animateStartW = pos.w;
	animateStartH = pos.h;
	animateSetpointX = destx;
	animateSetpointY = desty;
	animateSetpointW = destw;
	animateSetpointH = desth;
	animateX = 0.0;
	animateY = 0.0;
	animateW = 0.0;
	animateH = 0.0;
}

void SkillUpAnimation_t::SkillUp_t::setAnimatePosition(int destx, int desty)
{
	animateStartX = pos.x;
	animateStartY = pos.y;
	animateStartW = pos.w;
	animateStartH = pos.h;
	animateSetpointX = destx;
	animateSetpointY = desty;
	animateSetpointW = 0;
	animateSetpointH = 0;
	animateX = 0.0;
	animateY = 0.0;
	animateW = 0.0;
	animateH = 0.0;
}

int SkillUpAnimation_t::SkillUp_t::getIconNominalSize()
{
	return isSpell ? 32 : 24;
}

void SkillUpAnimation_t::SkillUp_t::animateNotification(const int player)
{
	real_t animspeed = 5.0 / (4.0);
	static ConsoleVariable<float> cvar_skillup_speed("/skillup_speed", .5);
	static ConsoleVariable<float> cvar_skillup_bounce("/skillup_bounce", 1.0 /*2.5*/);
	static ConsoleVariable<float> cvar_skillup_animfall("/skillup_animfall", 0.5/*2.0*/);
	static ConsoleVariable<int> cvar_skillup_increase_delay("/skillup_increase_delay", 50);
	static ConsoleVariable<int> cvar_skillup_ding_volume("/skillup_ding_volume", 32);
	animspeed *= *cvar_skillup_speed;
	int movementAmount = 0;
	if ( players[player]->bUseCompactGUIHeight() )
	{
		movementAmount = 0;
	}

	bool newtick = ticks != processedOnTick;
	if ( newtick )
	{
		processedOnTick = ticks;
		++ticksActive;
	}

	const real_t largestScaling = 2.0;
	real_t midScaling = 2.0;
	const int normalSize = getIconNominalSize();
	const int baseEffectPosX = baseX;
	const int baseEffectPosY = baseY;

	const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
	if ( notificationState >= STATE_4 )
	{
		real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - animBackground)) / (2.5);
		animBackground += setpointDiffX;
		animBackground = std::min(1.0, animBackground);
	}

	real_t oldAngle = animAngle;
	animAngle += fpsScale * std::max(.1, (1.0 - animAngle)) / (5.0);
	animAngle = std::min(1.0, animAngle);
	if ( newtick && ticksActive == *cvar_skillup_increase_delay )
	{
		if ( !isSpell )
		{
			playSound(*cvar_skill_ding_sfx + local_rng.rand() % 4, *cvar_skillup_ding_volume);
		}
	}

	switch ( notificationState )
	{
		case STATE_1:
			if ( notificationStateInit == STATE_1 )
			{
				notificationStateInit = STATE_2;
				setAnimatePosition(
					baseEffectPosX - movementAmount,
					baseEffectPosY - movementAmount,
					normalSize, normalSize);
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_2;
			}
			animspeed *= .01;
			break;
		case STATE_2:
			if ( notificationStateInit == STATE_2 )
			{
				notificationStateInit = STATE_3;
				setAnimatePosition(
					baseEffectPosX - movementAmount - (largestScaling - 1.0) * normalSize / 2,
					baseEffectPosY - movementAmount - (largestScaling - 1.0) * normalSize / 2,
					normalSize * largestScaling,
					normalSize * largestScaling);
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_3;
			}
			animspeed *= 4.0;
			break;
		case STATE_3:
			if ( notificationStateInit == STATE_3 )
			{
				midScaling = 1.0;
				notificationStateInit = STATE_4;
				setAnimatePosition(
					baseEffectPosX - movementAmount - (midScaling - 1.0) * normalSize / 2,
					baseEffectPosY - movementAmount - (midScaling - 1.0) * normalSize / 2,
					normalSize * midScaling,
					normalSize * midScaling);
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_4;
			}
			animspeed *= 4.0;
			break;
		case STATE_4:
			if ( notificationStateInit == STATE_4 )
			{
				notificationStateInit = STATE_END;
				setAnimatePosition(notificationTargetPosition.x,
					notificationTargetPosition.y,
					notificationTargetPosition.w,
					notificationTargetPosition.h);
			}
			if ( notificationTargetPosition.x != animateSetpointX
				|| notificationTargetPosition.y != animateSetpointY
				|| notificationTargetPosition.w != animateSetpointW
				|| notificationTargetPosition.h != animateSetpointH )
			{
				// re update this as our target moved.
				setAnimatePosition(notificationTargetPosition.x,
					notificationTargetPosition.y,
					notificationTargetPosition.w,
					notificationTargetPosition.h);
			}
			if ( animateX >= 1.0 )
			{
				notificationState = STATE_END;
			}
			animspeed *= 2.0;
			break;
		case STATE_END:
		{
			if ( ticksActive >= TICKS_PER_SECOND )
			{
				real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - animCurrentStat)) / (2.5 * *cvar_skillup_animfall);
				animCurrentStat += setpointDiffX;
				animCurrentStat = std::min(1.0, animCurrentStat);

				if ( animCurrentStat >= 1.0 )
				{
					real_t setpointDiffX = fpsScale * 1.0 / (10.0 * *cvar_skillup_bounce);
					animIncreaseStat += setpointDiffX;
					animIncreaseStat = std::min(1.0, animIncreaseStat);
				}
			}
			return;
		}
		default:
			break;
	}

	real_t setpointDiffX = fpsScale * std::max(.1, (1.0 - animateX)) / (animspeed);
	real_t setpointDiffY = fpsScale * std::max(.1, (1.0 - animateY)) / (animspeed);
	real_t setpointDiffW = fpsScale * std::max(.1, (1.0 - animateW)) / (animspeed);
	real_t setpointDiffH = fpsScale * std::max(.1, (1.0 - animateH)) / (animspeed);
	animateX += setpointDiffX;
	animateY += setpointDiffY;
	animateX = std::min(1.0, animateX);
	animateY = std::min(1.0, animateY);
	animateW += setpointDiffW;
	animateH += setpointDiffH;
	animateW = std::min(1.0, animateW);
	animateH = std::min(1.0, animateH);

	int destX = animateSetpointX - animateStartX;
	int destY = animateSetpointY - animateStartY;
	int destW = animateSetpointW - animateStartW;
	int destH = animateSetpointH - animateStartH;

	pos.x = animateStartX + destX * animateX;
	pos.y = animateStartY + destY * animateY;
	pos.w = animateStartW + destW * animateW;
	pos.h = animateStartH + destH * animateH;
}

SkillUpAnimation_t::SkillUp_t& SkillUpAnimation_t::getSkillUpToDisplay()
{
	return skillUps.at(getSkillUpIndexToDisplay());
}

size_t SkillUpAnimation_t::getSkillUpIndexToDisplay()
{
	size_t index = 0;
	std::priority_queue<std::pair<int, size_t>> priority;
	for ( auto& skillUp : skillUps )
	{
		if ( skillUp.init )
		{
			return index;
		}
		if ( skillUp.isSpell )
		{
			priority.push(std::make_pair(15, index));
		}
		else
		{
			switch ( skillUp.whichSkill )
			{
				case PRO_RANGED:
				case PRO_SWORD:
				case PRO_MACE:
				case PRO_AXE:
				case PRO_POLEARM:
				case PRO_SHIELD:
				case PRO_UNARMED:
					priority.push(std::make_pair(10, index));
					break;
				case PRO_MAGIC:
				case PRO_SPELLCASTING:
					priority.push(std::make_pair(5, index));
					break;
				case PRO_STEALTH:
					priority.push(std::make_pair(4, index));
					break;
				case PRO_LOCKPICKING:
				case PRO_TRADING:
				case PRO_LEADERSHIP:
				case PRO_ALCHEMY:
					priority.push(std::make_pair(2, index));
					break;
				case PRO_SWIMMING:
					priority.push(std::make_pair(1, index));
					break;
				case PRO_APPRAISAL:
				default:
					priority.push(std::make_pair(0, index));
					break;
			}
		}
		++index;
	}
	return priority.top().second;
}

void SkillUpAnimation_t::addSpellLearned(const int _spellID)
{
	skillUps.push_back(SkillUp_t(_spellID));
	skillUps.at(skillUps.size() - 1).ticksToLive = 5 * TICKS_PER_SECOND;
}

void SkillUpAnimation_t::addSkillUp(const int _numSkill, const int _currentSkill, const int _increaseSkill)
{
	if ( _increaseSkill <= 0 )
	{
		return;
	}

	for ( auto& s : skillUps )
	{
		if ( s.whichSkill != _numSkill )
		{
			continue;
		}
		if ( s.expired )
		{
			continue;
		}
		int diff = std::max(0, (_currentSkill + _increaseSkill) - (s.currentSkill + s.increaseSkill));
		if ( diff > 0 )
		{
			if ( s.ticksActive >= TICKS_PER_SECOND )
			{
				// update current value
				s.currentSkill = _currentSkill;
				s.increaseSkill = _increaseSkill;
			}
			else
			{
				s.increaseSkill += diff;
			}
			s.ticksActive = 0;
			s.animAngle = 0.0;
			s.animCurrentStat = 0.0;
			s.animIncreaseStat = 0.0;
			return;
		}
		else
		{
			return;
		}
	}

	skillUps.push_back(SkillUp_t(_numSkill, _currentSkill, _increaseSkill));
	Uint32 ticksToLive = 3 * TICKS_PER_SECOND;
	switch ( _numSkill )
	{
		case PRO_RANGED:
		case PRO_SWORD:
		case PRO_MACE:
		case PRO_AXE:
		case PRO_POLEARM:
		case PRO_SHIELD:
		case PRO_UNARMED:
			ticksToLive = 4 * TICKS_PER_SECOND;
			break;
		case PRO_STEALTH:
			ticksToLive = 4 * TICKS_PER_SECOND;
			break;
		case PRO_MAGIC:
		case PRO_SPELLCASTING:
			ticksToLive = 2 * TICKS_PER_SECOND;
			break;
		case PRO_LOCKPICKING:
		case PRO_TRADING:
		case PRO_LEADERSHIP:
		case PRO_ALCHEMY:
			ticksToLive = 3 * TICKS_PER_SECOND;
			break;
		case PRO_SWIMMING:
			ticksToLive = 2 * TICKS_PER_SECOND;
			break;
		case PRO_APPRAISAL:
		default:
			ticksToLive = 2 * TICKS_PER_SECOND;
			break;
	}
	skillUps.at(skillUps.size() - 1).ticksToLive = ticksToLive;
}

void updateSkillUpFrame(const int player)
{
	auto& hud_t = players[player]->hud;
	if ( !hud_t.skillupFrame )
	{
		createSkillUpFrame(player);
	}

	if ( !hud_t.skillupFrame || !hud_t.hudFrame )
	{
		return;
	}

	if ( !players[player]->isLocalPlayer() || hud_t.hudFrame->isDisabled() )
	{
		hud_t.skillupFrame->setDisabled(true);
		return;
	}

	if ( gamePaused && multiplayer == SINGLE )
	{
		return;
	}

	auto frame = hud_t.skillupFrame;
	auto& skillUpAnim = skillUpAnimation[player];

	//if ( enableDebugKeys && keystatus[SDLK_g] )
	//{
	//	keystatus[SDLK_g] = 0;

	//	int skill = PRO_APPRAISAL; local_rng.rand() % NUMPROFICIENCIES;
	//	int currentSkill = stats[player]->PROFICIENCIES[skill];
	//	int increaseSkill = 1;
	//	skillUpAnim.addSkillUp(skill, currentSkill, increaseSkill);
	//	//skillUpAnim.skillUps.push_back(SkillUpAnimation_t::SkillUp_t(skill, currentSkill, increaseSkill));
	//	++stats[player]->PROFICIENCIES[skill];
	//}

	//if ( enableDebugKeys && keystatus[SDLK_h] )
	//{
	//	keystatus[SDLK_h] = 0;

	//	skillUpAnim.addSpellLearned(SPELL_FORCEBOLT + local_rng.rand() % (NUM_SPELLS - 1));
	//}

	if ( skillUpAnim.skillUps.empty() || levelUpAnimation[player].lvlUps.size() > 0 )
	{
		if ( levelUpAnimation[player].lvlUps.size() > 0 )
		{
			skillUpAnim.animFrameFadeIn = 0.0;
		}
		hud_t.skillupFrame->setDisabled(true);
		return;
	}

	if ( players[player]->bUseCompactGUIWidth() && players[player]->gui_mode != GUI_MODE_NONE )
	{
		hud_t.skillupFrame->setDisabled(true);
		return;
	}
	
	auto& skillUpCheck = skillUpAnim.getSkillUpToDisplay();
	const real_t fpsScale = getFPSScale(50.0); // ported from 50Hz
	if ( skillUpCheck.expired )
	{
		skillUpCheck.fadeout += fpsScale * std::max(.1, (1.0 - skillUpCheck.fadeout)) / (5.0);
		skillUpCheck.fadeout = std::min(1.0, skillUpCheck.fadeout);
		hud_t.skillupFrame->setOpacity(hud_t.hudFrame->getOpacity()
			* (1.0 - skillUpCheck.fadeout) * skillUpAnim.animFrameFadeIn);
		if ( skillUpCheck.fadeout >= 1.0 )
		{
			skillUpAnim.skillUps.erase(skillUpAnim.skillUps.begin() + skillUpAnim.getSkillUpIndexToDisplay());
		}
	}

	if ( skillUpAnim.skillUps.empty() )
	{
		hud_t.skillupFrame->setDisabled(true);
		return;
	}

	auto& skillUp = skillUpAnim.getSkillUpToDisplay();

	static ConsoleVariable<int> cvar_skillup_angle("/skillup_angle", 16);
	static ConsoleVariable<int> cvar_skillup_falldist("/skillup_falldist", 64);
	static ConsoleVariable<int> cvar_skillup_currentstatY("/skillup_currentstatY", -10);
	static ConsoleVariable<int> cvar_skillup_increasestatY("/skillup_increasestatY", 0);

	if ( !skillUp.expired )
	{
		skillUpAnim.animFrameFadeIn += fpsScale * std::max(.1, (1.0 - skillUpAnim.animFrameFadeIn)) / (5.0);
		skillUpAnim.animFrameFadeIn = std::min(1.0, skillUpAnim.animFrameFadeIn);
		hud_t.skillupFrame->setOpacity(hud_t.hudFrame->getOpacity() * skillUpAnim.animFrameFadeIn);
	}
	hud_t.skillupFrame->setDisabled(false);
	const int frameWidth = 600;

	SDL_Rect skillsFramePos{ frameWidth / 2, 0, 0, 200 };
	auto skillsFrame = hud_t.skillupFrame->findFrame("skills");
	skillsFrame->setDisabled(false);

	int index = 0;
	SDL_Rect skillFramePos{ 0, 0, 0, 400 };
	const int skillSpacing = 64;
	int skillStartX = 100;
	std::vector<int> skillPosX;
	auto prevNotificationState = SkillUpAnimation_t::SkillUp_t::NotificationStates_t::STATE_END;
	for ( auto skillFrame : skillsFrame->getFrames() )
	{
		if ( skillsFrame->isDisabled() )
		{
			skillFrame->setDisabled(true);
			continue;
		}
		if ( skillUp.preDelayTicks > 0 )
		{
			continue;
		}
		auto skillImg = skillFrame->findImage("skill img");
		auto skillBorderImg = skillFrame->findImage("skill border img");
		auto skillBgImg = skillFrame->findImage("skill bg img");
		auto skillBgCapImg = skillFrame->findImage("skill bg cap img");
		skillBgCapImg->disabled = true;
		skillImg->path = "";
		skillImg->disabled = true;
		skillBorderImg->disabled = true;
		skillBgImg->disabled = true;
		int skillsheetIndex = -1;
		auto skillCurrentTxt = skillFrame->findField("skill current");
		auto skillCurrentOldTxt = skillFrame->findField("skill current old");

		if ( skillUp.isSpell )
		{
			skillCurrentTxt->setDisabled(true);
		}
		else
		{
			char buf[32] = "";
			snprintf(buf, sizeof(buf), "%d", skillUp.currentSkill + skillUp.increaseSkill);
			skillCurrentTxt->setDisabled(!(skillUp.ticksActive >= TICKS_PER_SECOND * 1));
			skillCurrentTxt->setText(buf);
		}

		if ( skillUp.isSpell )
		{
			node_t* spellImageNode = ItemTooltips.getSpellNodeFromSpellID(skillUp.spellID);
			if ( spellImageNode )
			{
				if ( string_t* string = (string_t*)spellImageNode->element )
				{
					skillImg->path = string->data;
				}
				skillCurrentTxt->setColor(Player::SkillSheet_t::skillSheetData.defaultTextColor);
				skillCurrentOldTxt->setColor(hudColors.itemContextMenuHeadingText);
				skillBorderImg->path = "#*images/ui/HUD/HUD_NewSpell_Border_00.png";
				skillBgImg->path = "*images/ui/HUD/HUD_NewSpell_BG_00.png";
			}
		}
		else
		{
			for ( auto& skill : Player::SkillSheet_t::skillSheetData.skillEntries )
			{
				++skillsheetIndex;
				if ( skill.skillId == skillUp.whichSkill )
				{
					skillImg->path = skill.skillIconPath;
					int currentskill = skillCurrentTxt->isDisabled() ? skillUp.currentSkill : skillUp.currentSkill + skillUp.increaseSkill;
					if ( currentskill >= SKILL_LEVEL_LEGENDARY )
					{
						skillImg->path = skill.skillIconPathLegend;
						skillCurrentTxt->setColor(Player::SkillSheet_t::skillSheetData.legendTextColor);
						skillCurrentOldTxt->setColor(Player::SkillSheet_t::skillSheetData.legendTextColor);
						skillBorderImg->path = Player::SkillSheet_t::skillSheetData.iconBgPathLegend;
						skillBgImg->path = "*images/ui/HUD/HUD_SkillUp_BG100_00.png";
					}
					else if ( currentskill >= SKILL_LEVEL_EXPERT )
					{
						skillCurrentTxt->setColor(Player::SkillSheet_t::skillSheetData.expertTextColor);
						skillCurrentOldTxt->setColor(Player::SkillSheet_t::skillSheetData.expertTextColor);
						skillBorderImg->path = Player::SkillSheet_t::skillSheetData.iconBgPathExpert;
						skillBgImg->path = "*images/ui/HUD/HUD_SkillUp_BG60_00.png";
					}
					else if ( currentskill >= SKILL_LEVEL_BASIC )
					{
						skillCurrentTxt->setColor(Player::SkillSheet_t::skillSheetData.noviceTextColor);
						skillCurrentOldTxt->setColor(Player::SkillSheet_t::skillSheetData.noviceTextColor);
						skillBorderImg->path = Player::SkillSheet_t::skillSheetData.iconBgPathNovice;
						skillBgImg->path = "*images/ui/HUD/HUD_SkillUp_BG20_00.png";
					}
					else
					{
						skillCurrentTxt->setColor(Player::SkillSheet_t::skillSheetData.defaultTextColor);
						skillCurrentOldTxt->setColor(Player::SkillSheet_t::skillSheetData.defaultTextColor);
						skillBorderImg->path = Player::SkillSheet_t::skillSheetData.iconBgPathDefault;
						skillBgImg->path = "*images/ui/HUD/HUD_SkillUp_BG_00.png";
					}
					break;
				}
			}
		}

		if ( skillImg->path == "" ) { continue; }

		if ( auto imgGet = Image::get(skillImg->path.c_str()) )
		{
			skillImg->pos.w = imgGet->getWidth();
			skillImg->pos.h = imgGet->getHeight();
			skillImg->disabled = false;
		}
		skillImg->pos.x = 140;
		if ( !skillUp.isSpell )
		{
			skillImg->pos.y = 40 - skillImg->pos.h / 2;
		}
		else
		{
			skillImg->pos.y = 44 - skillImg->pos.h / 2;
		}

		if ( auto imgGet = Image::get(skillBorderImg->path.c_str()) )
		{
			skillBorderImg->pos.w = imgGet->getWidth();
			skillBorderImg->pos.h = imgGet->getHeight();
			skillBorderImg->disabled = false;
			skillBorderImg->pos.x = skillImg->pos.x + skillImg->pos.w / 2 - skillBorderImg->pos.w / 2;
			skillBorderImg->pos.y = skillImg->pos.y + skillImg->pos.h / 2 - skillBorderImg->pos.h / 2;
		}

		auto skillIncreaseTxt = skillFrame->findField("skill increase");
		skillIncreaseTxt->setDisabled(skillUp.increaseSkill == 0 || skillUp.isSpell);
		if ( !skillIncreaseTxt->isDisabled() )
		{
			char buf[32] = "";
			snprintf(buf, sizeof(buf), "%+d", skillUp.increaseSkill);
			skillIncreaseTxt->setText(buf);
			if ( auto textGet = skillIncreaseTxt->getTextObject() )
			{
				SDL_Rect pos;
				pos.x = skillImg->pos.x + skillImg->pos.w + 8;
				pos.y = 32;
				pos.w = std::max(40, (int)textGet->getWidth());
				pos.h = std::max(24, (int)textGet->getHeight());

				skillIncreaseTxt->setColor(makeColor(255, 255, 255, (1.0 - skillUp.animCurrentStat) * skillUp.animAngle * 255));
				pos.x += -*cvar_skillup_angle * cos(PI / 2 + (3 * skillUp.animAngle * (PI / 2)));
				pos.x += (skillBgImg->pos.w - skillBorderImg->pos.w) * skillUp.animBackground;
				pos.y += (*cvar_skillup_angle) - (*cvar_skillup_angle * sin(PI / 2 + (3 * skillUp.animAngle * (PI / 2))));
				pos.y += *cvar_skillup_increasestatY;
				skillIncreaseTxt->setSize(pos);
			}
		}

		if ( skillUp.isSpell )
		{
			if ( auto spell = getSpellFromID(skillUp.spellID) )
			{
				std::string spellname = spell->getSpellName();
				camelCaseString(spellname);
				skillCurrentOldTxt->setText(spellname.c_str());
			}
		}

		if ( auto imgGet = Image::get(skillBgImg->path.c_str()) )
		{
			skillBgImg->color = makeColor(255, 255, 255, skillUp.animBackground * 255);
			skillBgImg->pos.w = imgGet->getWidth();
			skillBgImg->pos.h = imgGet->getHeight();
			skillBgImg->disabled = false;
			skillBgImg->pos.y = skillBorderImg->pos.y;
			if ( skillUp.isSpell )
			{
				skillBgCapImg->path = "#*images/ui/HUD/HUD_NewSpell_BG_Cap_00.png";
				if ( auto imgGet2 = Image::get(skillBgCapImg->path.c_str()) )
				{
					skillBgCapImg->disabled = false;
					skillBgCapImg->pos.w = imgGet2->getWidth();
					skillBgCapImg->pos.h = imgGet2->getHeight();
					skillBgCapImg->pos.y = skillBgImg->pos.y;
					skillBgCapImg->color = skillBgImg->color;
				}
				if ( auto textGet = skillCurrentOldTxt->getTextObject() )
				{
					skillBgImg->pos.w = (textGet->getWidth() + 8 + skillBgCapImg->pos.w) * skillUp.animBackground;
					if ( skillBgImg->pos.w == 0 )
					{
						skillBgImg->disabled = true;
					}
					int bgStartX = skillBorderImg->pos.x + skillBorderImg->pos.w - skillBgCapImg->pos.w;
					skillBgImg->pos.x = bgStartX;
					skillBgCapImg->pos.x = skillBgImg->pos.x + skillBgImg->pos.w;
				}
			}
			else
			{
				skillBgImg->pos.x = skillBorderImg->pos.x - skillBorderImg->pos.w + skillBorderImg->pos.w * skillUp.animBackground;
			}
		}

		auto skillGleam = skillFrame->findImage("skill gleam");
		skillGleam->disabled = !skillUp.isSpell;

		skillCurrentOldTxt->setDisabled(true);
		if ( skillCurrentTxt->isDisabled() )
		{
			skillCurrentOldTxt->setDisabled(false);
			
			if ( !skillUp.isSpell )
			{
				char buf[32] = "";
				snprintf(buf, sizeof(buf), "%d", skillUp.currentSkill);
				skillCurrentOldTxt->setText(buf);
			}
			if ( auto textGet = skillCurrentOldTxt->getTextObject() )
			{
				SDL_Rect pos;
				pos.w = textGet->getWidth();
				pos.h = std::max(24, (int)textGet->getHeight());
				if ( skillUp.isSpell )
				{
					pos.w = std::min(pos.w, skillBgImg->pos.w);
					pos.y = skillBgImg->pos.y + 12;
					skillCurrentOldTxt->setFont("fonts/pixel_maz_multiline.ttf#16#2");
					pos.x = skillBgCapImg->pos.x - pos.w;
				}
				else
				{
					pos.x = skillBgImg->pos.x + skillBgImg->pos.w - pos.w - 12;
					pos.y = skillBgImg->pos.y + 8;
					skillCurrentOldTxt->setFont("fonts/pixelmix.ttf#16#2");
				}
				skillCurrentOldTxt->setSize(pos);

				Uint8 r, g, b, a;
				getColor(skillCurrentOldTxt->getColor(), &r, &g, &b, &a);
				skillCurrentOldTxt->setColor(makeColor(r, g, b, skillUp.animBackground * a));
			}
		}
		else if ( auto textGet = skillCurrentTxt->getTextObject() )
		{
			SDL_Rect pos;
			pos.w = textGet->getWidth();
			pos.h = textGet->getHeight();
			pos.x = skillBgImg->pos.x + skillBgImg->pos.w - pos.w - 12;
			pos.y = skillBgImg->pos.y + 8;

			if ( skillUp.increaseSkill != 0 )
			{
				pos.y += -((1.0 - skillUp.animCurrentStat) * *cvar_skillup_falldist);
				pos.y += -4 + 4 * (cos(skillUp.animIncreaseStat * 2 * PI));
			}
			skillCurrentTxt->setSize(pos);

			Uint8 r, g, b, a;
			getColor(skillCurrentTxt->getColor(), &r, &g, &b, &a);
			skillCurrentTxt->setColor(makeColor(r, g, b, skillUp.animCurrentStat * a));
		}

		skillFramePos.w = std::max(120, (int)(skillBgImg->pos.x + skillBgImg->pos.w + 64));
		if ( skillUp.isSpell )
		{
			skillFramePos.w = std::max(skillFramePos.w, (skillBgCapImg->pos.x + skillBgCapImg->pos.w));
		}
		skillFrame->setSize(skillFramePos);

		if ( skillUp.isSpell )
		{
			skillPosX.push_back(skillFramePos.x + skillImg->pos.x + skillImg->pos.w / 2 + ((skillBgImg->pos.w) /** skillUp.animBackground*/ / 2));
		}
		else
		{
			skillPosX.push_back(skillFramePos.x + skillImg->pos.x + skillImg->pos.w / 2 + ((skillBgImg->pos.w - skillBorderImg->pos.w) * skillUp.animBackground / 2));
		}

		auto skillNameTxt = skillFrame->findField("skill name txt");
		skillNameTxt->setDisabled(true);
		{
			if ( skillUp.isSpell )
			{
				skillNameTxt->setText(Language::get(4328));
			}
			else
			{
				char buf[128];
				snprintf(buf, sizeof(buf), Language::get(4327), Player::SkillSheet_t::skillSheetData.skillEntries[skillsheetIndex].name.c_str());
				skillNameTxt->setText(buf);
			}
			if ( auto textGet = skillNameTxt->getTextObject() )
			{
				skillNameTxt->setDisabled(false);
				SDL_Rect pos = skillNameTxt->getSize();
				pos.w = textGet->getWidth();
				pos.h = std::max(24, (int)textGet->getHeight());
				pos.y = 0;
				pos.x = skillPosX[skillPosX.size() - 1] - pos.w / 2;
				skillNameTxt->setSize(pos);

				Uint8 r, g, b, a;
				getColor(0xFFFFFFFF, &r, &g, &b, &a);
				skillNameTxt->setColor(makeColor(r, g, b, skillUp.animBackground * a));

				skillFramePos.w = std::max(skillFramePos.w, (int)(pos.x + pos.w));
				skillFrame->setSize(skillFramePos);
			}
		}

		skillFramePos.x += skillSpacing;

		if ( !skillUp.init )
		{
			skillUp.notificationTargetPosition.x = skillImg->pos.x;
			skillUp.notificationTargetPosition.y = skillImg->pos.y;
			skillUp.notificationTargetPosition.w = skillImg->pos.w;
			skillUp.notificationTargetPosition.h = skillImg->pos.h;
			skillUp.baseX = skillImg->pos.x;
			skillUp.baseY = skillImg->pos.y;
			skillUp.pos.x = skillUp.baseX;
			skillUp.pos.y = skillUp.baseY;
			skillUp.pos.w = skillImg->pos.w;
			skillUp.pos.h = skillImg->pos.h;
			skillUp.init = true;

			if ( skillUp.isSpell )
			{
				playSound(*cvar_skill_newspell_sfx, *cvar_skill_sfx_volume);
			}
			else
			{
				for ( auto skill : Player::SkillSheet_t::skillSheetData.skillEntries )
				{
					if ( skill.skillId == skillUp.whichSkill )
					{
						playSound(skill.skillSfx, *cvar_skill_sfx_volume);
						break;
					}
				}
			}
		}

		if ( skillUp.init )
		{
			skillUp.animateNotification(player);
			skillFrame->setDisabled(false);
		}
		else
		{
			skillFrame->setDisabled(true);
		}
		skillImg->pos = skillUp.pos;
		{
			int newWidth = skillBorderImg->pos.w * (skillImg->pos.w / (float)skillUp.getIconNominalSize());
			int newHeight = skillBorderImg->pos.h * (skillImg->pos.h / (float)skillUp.getIconNominalSize());
			skillBorderImg->pos.x -= (newWidth - skillBorderImg->pos.w) / 2;
			skillBorderImg->pos.y -= (newHeight - skillBorderImg->pos.h) / 2;
			skillBorderImg->pos.w = newWidth;
			skillBorderImg->pos.h = newHeight;

			if ( skillUp.isSpell )
			{
				skillGleam->path = "*#images/ui/HUD/HUD_NewSpell_Gleam_00.png";
				skillGleam->pos = skillBorderImg->pos;
				const int gleam = ((ticks % TICKS_PER_SECOND) / 5) % 5;
				switch ( gleam )
				{
					case 0:
						skillGleam->path = "*#images/ui/HUD/HUD_NewSpell_Gleam_00.png";
						break;
					case 1:
						skillGleam->path = "*#images/ui/HUD/HUD_NewSpell_Gleam_01.png";
						break;
					case 2:
						skillGleam->path = "*#images/ui/HUD/HUD_NewSpell_Gleam_02.png";
						break;
					case 3:
						skillGleam->path = "*#images/ui/HUD/HUD_NewSpell_Gleam_03.png";
						break;
					case 4:
						skillGleam->path = "*#images/ui/HUD/HUD_NewSpell_Gleam_04.png";
						break;
					default:
						break;
				}
			}
		}
		skillsFramePos.w = skillFramePos.x + skillFramePos.w;
		if ( skillUp.isSpell )
		{
			skillsFramePos.w = std::max(skillsFramePos.w, skillBgCapImg->pos.x + skillBgCapImg->pos.w);
		}
		else
		{
			skillsFramePos.w = std::max(skillsFramePos.w, skillBgImg->pos.x + skillBgImg->pos.w);
		}
		skillStartX += skillSpacing;
	}

	int midpoint = 0;
	if ( skillPosX.size() > 1 )
	{
		if ( skillPosX.size() % 2 == 1 )
		{
			midpoint = skillPosX[size_t(skillPosX.size() / 2)];
		}
		else
		{
			size_t midIndex1 = std::max((size_t)0, (skillPosX.size() / 2) - 1);
			size_t midIndex2 = (skillPosX.size() / 2);
			midpoint = skillPosX[midIndex1] + (skillPosX[midIndex2] - skillPosX[midIndex1]) / 2;
		}
		skillsFramePos.x -= midpoint;
	}
	else if ( skillPosX.size() == 1 )
	{
		skillsFramePos.x -= skillPosX[0];
	}
	else
	{
		skillsFramePos.x -= skillsFramePos.w / 2;
	}
	/*if ( skillsFramePos.x % 2 == 1 )
	{
		++skillsFramePos.x;
	}*/
	skillsFrame->setSize(skillsFramePos);
	if ( ticks != skillUp.processedOnTick )
	{
		skillUp.processedOnTick = ticks;
		if ( skillUp.preDelayTicks > 0 )
		{
			--skillUp.preDelayTicks;
		}
		else
		{
			++skillUp.ticksActive;
		}
	}

	static ConsoleVariable<int> cvar_skillup_framey("/skillup_framey", 48);
	int framey = *cvar_skillup_framey;
	if ( players[player]->bUseCompactGUIHeight() && players[player]->shootmode )
	{
		framey -= 28;
		framey = std::max(4, framey);
	}
	SDL_Rect levelUpFramePos{ hud_t.hudFrame->getSize().w / 2 - frameWidth / 2, framey,
		frameWidth, skillsFramePos.y + skillsFramePos.h };
	levelUpFramePos.x += players[player]->camera_virtualx1();
	levelUpFramePos.y += players[player]->camera_virtualy1();
	levelUpFramePos.y += skillUp.fadeout * *cvar_skillup_falldist;
	if ( players[player]->bUseCompactGUIWidth() || players[player]->bUseCompactGUIHeight() )
	{
		levelUpFramePos.y += -16;
	}
	hud_t.skillupFrame->setSize(levelUpFramePos);

	if ( skillUp.ticksActive >= skillUp.ticksToLive )
	{
		skillUp.expired = true;
	}
}
